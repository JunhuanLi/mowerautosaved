; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_can.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_can.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_can.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c]
                          THUMB

                          AREA ||i.CAN_CancelTransmit||, CODE, READONLY, ALIGN=2

                  CAN_CancelTransmit PROC
;;;697      */
;;;698    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
000000  b570              PUSH     {r4-r6,lr}
;;;699    {
000002  4604              MOV      r4,r0
;;;700      /* Check the parameters */
;;;701      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  4812              LDR      r0,|L1.80|
000006  460d              MOV      r5,r1                 ;699
000008  4284              CMP      r4,r0
00000a  d007              BEQ      |L1.28|
00000c  4811              LDR      r0,|L1.84|
00000e  4284              CMP      r4,r0
000010  d004              BEQ      |L1.28|
000012  f24021bd          MOV      r1,#0x2bd
000016  4810              LDR      r0,|L1.88|
000018  f7fffffe          BL       assert_failed
                  |L1.28|
;;;702      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
00001c  2d02              CMP      r5,#2
00001e  d904              BLS      |L1.42|
000020  f24021be          MOV      r1,#0x2be
000024  480c              LDR      r0,|L1.88|
000026  f7fffffe          BL       assert_failed
                  |L1.42|
;;;703      /* abort transmission */
;;;704      switch (Mailbox)
00002a  b145              CBZ      r5,|L1.62|
00002c  2d01              CMP      r5,#1
00002e  d00a              BEQ      |L1.70|
000030  2d02              CMP      r5,#2
000032  d103              BNE      |L1.60|
;;;705      {
;;;706        case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
;;;707          break;
;;;708        case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
;;;709          break;
;;;710        case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
000034  68a0              LDR      r0,[r4,#8]
000036  f4400000          ORR      r0,r0,#0x800000
                  |L1.58|
00003a  60a0              STR      r0,[r4,#8]
                  |L1.60|
;;;711          break;
;;;712        default:
;;;713          break;
;;;714      }
;;;715    }
00003c  bd70              POP      {r4-r6,pc}
                  |L1.62|
00003e  68a0              LDR      r0,[r4,#8]            ;706
000040  f0400080          ORR      r0,r0,#0x80           ;706
000044  e7f9              B        |L1.58|
                  |L1.70|
000046  68a0              LDR      r0,[r4,#8]            ;708
000048  f4404000          ORR      r0,r0,#0x8000         ;708
00004c  e7f5              B        |L1.58|
;;;716    /**
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      0x40006400
                  |L1.84|
                          DCD      0x40006800
                  |L1.88|
                          DCD      ||.conststring||

                          AREA ||i.CAN_ClearFlag||, CODE, READONLY, ALIGN=2

                  CAN_ClearFlag PROC
;;;1426     */
;;;1427   void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1428   {
000002  4605              MOV      r5,r0
;;;1429     uint32_t flagtmp=0;
;;;1430     /* Check the parameters */
;;;1431     assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  4822              LDR      r0,|L2.144|
000006  460c              MOV      r4,r1                 ;1428
000008  4285              CMP      r5,r0
00000a  d007              BEQ      |L2.28|
00000c  4821              LDR      r0,|L2.148|
00000e  4285              CMP      r5,r0
000010  d004              BEQ      |L2.28|
000012  f2405197          MOV      r1,#0x597
000016  4820              LDR      r0,|L2.152|
000018  f7fffffe          BL       assert_failed
                  |L2.28|
;;;1432     assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
00001c  4e1f              LDR      r6,|L2.156|
00001e  42b4              CMP      r4,r6
000020  d020              BEQ      |L2.100|
000022  481f              LDR      r0,|L2.160|
000024  4284              CMP      r4,r0
000026  d01d              BEQ      |L2.100|
000028  481e              LDR      r0,|L2.164|
00002a  4284              CMP      r4,r0
00002c  d01a              BEQ      |L2.100|
00002e  f06f5060          MVN      r0,#0x38000000
000032  42c4              CMN      r4,r0
000034  d016              BEQ      |L2.100|
000036  f1a45048          SUB      r0,r4,#0x32000000
00003a  3808              SUBS     r0,r0,#8
00003c  d012              BEQ      |L2.100|
00003e  3808              SUBS     r0,r0,#8
000040  d010              BEQ      |L2.100|
000042  f1a45050          SUB      r0,r4,#0x34000000
000046  3808              SUBS     r0,r0,#8
000048  d00c              BEQ      |L2.100|
00004a  3808              SUBS     r0,r0,#8
00004c  d00a              BEQ      |L2.100|
00004e  f1a45044          SUB      r0,r4,#0x31000000
000052  3808              SUBS     r0,r0,#8
000054  d006              BEQ      |L2.100|
000056  380a              SUBS     r0,r0,#0xa
000058  d004              BEQ      |L2.100|
00005a  f44f61b3          MOV      r1,#0x598
00005e  480e              LDR      r0,|L2.152|
000060  f7fffffe          BL       assert_failed
                  |L2.100|
;;;1433     
;;;1434     if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
000064  42b4              CMP      r4,r6
000066  d102              BNE      |L2.110|
;;;1435     {
;;;1436       /* Clear the selected CAN flags */
;;;1437       CANx->ESR = (uint32_t)RESET;
000068  2000              MOVS     r0,#0
00006a  61a8              STR      r0,[r5,#0x18]
;;;1438     }
;;;1439     else /* MSR or TSR or RF0R or RF1R */
;;;1440     {
;;;1441       flagtmp = CAN_FLAG & 0x000FFFFF;
;;;1442   
;;;1443       if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
;;;1444       {
;;;1445         /* Receive Flags */
;;;1446         CANx->RF0R = (uint32_t)(flagtmp);
;;;1447       }
;;;1448       else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
;;;1449       {
;;;1450         /* Receive Flags */
;;;1451         CANx->RF1R = (uint32_t)(flagtmp);
;;;1452       }
;;;1453       else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
;;;1454       {
;;;1455         /* Transmit Flags */
;;;1456         CANx->TSR = (uint32_t)(flagtmp);
;;;1457       }
;;;1458       else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
;;;1459       {
;;;1460         /* Operating mode Flags */
;;;1461         CANx->MSR = (uint32_t)(flagtmp);
;;;1462       }
;;;1463     }
;;;1464   }
00006c  bd70              POP      {r4-r6,pc}
                  |L2.110|
00006e  f3c40013          UBFX     r0,r4,#0,#20          ;1441
000072  01a1              LSLS     r1,r4,#6              ;1443
000074  d501              BPL      |L2.122|
000076  60e8              STR      r0,[r5,#0xc]          ;1446
000078  bd70              POP      {r4-r6,pc}
                  |L2.122|
00007a  0161              LSLS     r1,r4,#5              ;1448
00007c  d501              BPL      |L2.130|
00007e  6128              STR      r0,[r5,#0x10]         ;1451
000080  bd70              POP      {r4-r6,pc}
                  |L2.130|
000082  0121              LSLS     r1,r4,#4              ;1453
000084  d501              BPL      |L2.138|
000086  60a8              STR      r0,[r5,#8]            ;1456
000088  bd70              POP      {r4-r6,pc}
                  |L2.138|
00008a  6068              STR      r0,[r5,#4]            ;1461
00008c  bd70              POP      {r4-r6,pc}
;;;1465   
                          ENDP

00008e  0000              DCW      0x0000
                  |L2.144|
                          DCD      0x40006400
                  |L2.148|
                          DCD      0x40006800
                  |L2.152|
                          DCD      ||.conststring||
                  |L2.156|
                          DCD      0x30f00070
                  |L2.160|
                          DCD      0x38010000
                  |L2.164|
                          DCD      0x38000100

                          AREA ||i.CAN_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CAN_ClearITPendingBit PROC
;;;1590     */
;;;1591   void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1592   {
000004  4604              MOV      r4,r0
;;;1593     /* Check the parameters */
;;;1594     assert_param(IS_CAN_ALL_PERIPH(CANx));
000006  4834              LDR      r0,|L3.216|
000008  460d              MOV      r5,r1                 ;1592
00000a  4284              CMP      r4,r0
00000c  d007              BEQ      |L3.30|
00000e  4833              LDR      r0,|L3.220|
000010  4284              CMP      r4,r0
000012  d004              BEQ      |L3.30|
000014  f240613a          MOV      r1,#0x63a
000018  4831              LDR      r0,|L3.224|
00001a  f7fffffe          BL       assert_failed
                  |L3.30|
;;;1595     assert_param(IS_CAN_CLEAR_IT(CAN_IT));
00001e  f44f7680          MOV      r6,#0x100
000022  0077              LSLS     r7,r6,#1
000024  f44f6880          MOV      r8,#0x400
000028  f44f6900          MOV      r9,#0x800
00002c  f44f4a00          MOV      r10,#0x8000
000030  f44f3b80          MOV      r11,#0x10000
000034  2d01              CMP      r5,#1
000036  d01b              BEQ      |L3.112|
000038  2d04              CMP      r5,#4
00003a  d019              BEQ      |L3.112|
00003c  2d08              CMP      r5,#8
00003e  d017              BEQ      |L3.112|
000040  2d20              CMP      r5,#0x20
000042  d015              BEQ      |L3.112|
000044  2d40              CMP      r5,#0x40
000046  d013              BEQ      |L3.112|
000048  42b5              CMP      r5,r6
00004a  d011              BEQ      |L3.112|
00004c  42bd              CMP      r5,r7
00004e  d00f              BEQ      |L3.112|
000050  4545              CMP      r5,r8
000052  d00d              BEQ      |L3.112|
000054  454d              CMP      r5,r9
000056  d00b              BEQ      |L3.112|
000058  4555              CMP      r5,r10
00005a  d009              BEQ      |L3.112|
00005c  455d              CMP      r5,r11
00005e  d007              BEQ      |L3.112|
000060  f5b53f00          CMP      r5,#0x20000
000064  d004              BEQ      |L3.112|
000066  f240613b          MOV      r1,#0x63b
00006a  481d              LDR      r0,|L3.224|
00006c  f7fffffe          BL       assert_failed
                  |L3.112|
000070  2004              MOVS     r0,#4                 ;1592
000072  2108              MOVS     r1,#8                 ;1592
;;;1596   
;;;1597     switch (CAN_IT)
;;;1598     {
;;;1599       case CAN_IT_TME:
;;;1600         /* Clear CAN_TSR_RQCPx (rc_w1)*/
;;;1601         CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
;;;1602         break;
;;;1603       case CAN_IT_FF0:
;;;1604         /* Clear CAN_RF0R_FULL0 (rc_w1)*/
;;;1605         CANx->RF0R = CAN_RF0R_FULL0; 
;;;1606         break;
;;;1607       case CAN_IT_FOV0:
;;;1608         /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
;;;1609         CANx->RF0R = CAN_RF0R_FOVR0; 
000074  2210              MOVS     r2,#0x10
000076  42bd              CMP      r5,r7                 ;1597
000078  d01a              BEQ      |L3.176|
00007a  dc10              BGT      |L3.158|
00007c  2d20              CMP      r5,#0x20              ;1597
00007e  d025              BEQ      |L3.204|
000080  dc08              BGT      |L3.148|
000082  2d01              CMP      r5,#1                 ;1597
000084  d01d              BEQ      |L3.194|
000086  2d04              CMP      r5,#4                 ;1597
000088  d01e              BEQ      |L3.200|
00008a  2d08              CMP      r5,#8                 ;1597
00008c  d100              BNE      |L3.144|
00008e  60e2              STR      r2,[r4,#0xc]
                  |L3.144|
;;;1610         break;
;;;1611       case CAN_IT_FF1:
;;;1612         /* Clear CAN_RF1R_FULL1 (rc_w1)*/
;;;1613         CANx->RF1R = CAN_RF1R_FULL1;  
;;;1614         break;
;;;1615       case CAN_IT_FOV1:
;;;1616         /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
;;;1617         CANx->RF1R = CAN_RF1R_FOVR1; 
;;;1618         break;
;;;1619       case CAN_IT_WKU:
;;;1620         /* Clear CAN_MSR_WKUI (rc_w1)*/
;;;1621         CANx->MSR = CAN_MSR_WKUI;  
;;;1622         break;
;;;1623       case CAN_IT_SLK:
;;;1624         /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
;;;1625         CANx->MSR = CAN_MSR_SLAKI;   
;;;1626         break;
;;;1627       case CAN_IT_EWG:
;;;1628         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1629         CANx->MSR = CAN_MSR_ERRI;
;;;1630          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
;;;1631         break;
;;;1632       case CAN_IT_EPV:
;;;1633         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1634         CANx->MSR = CAN_MSR_ERRI; 
;;;1635          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1636         break;
;;;1637       case CAN_IT_BOF:
;;;1638         /* Clear CAN_MSR_ERRI (rc_w1) */ 
;;;1639         CANx->MSR = CAN_MSR_ERRI; 
;;;1640          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1641          break;
;;;1642       case CAN_IT_LEC:
;;;1643         /*  Clear LEC bits */
;;;1644         CANx->ESR = RESET; 
;;;1645         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1646         CANx->MSR = CAN_MSR_ERRI; 
;;;1647         break;
;;;1648       case CAN_IT_ERR:
;;;1649         /*Clear LEC bits */
;;;1650         CANx->ESR = RESET; 
;;;1651         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1652         CANx->MSR = CAN_MSR_ERRI; 
;;;1653          /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
;;;1654          break;
;;;1655       default:
;;;1656          break;
;;;1657      }
;;;1658   }
000090  e8bd9ff0          POP      {r4-r12,pc}
                  |L3.148|
000094  2d40              CMP      r5,#0x40              ;1597
000096  d01b              BEQ      |L3.208|
000098  42b5              CMP      r5,r6                 ;1597
00009a  d1f9              BNE      |L3.144|
00009c  e008              B        |L3.176|
                  |L3.158|
00009e  2300              MOVS     r3,#0                 ;1597
0000a0  4555              CMP      r5,r10                ;1597
0000a2  d004              BEQ      |L3.174|
0000a4  dc06              BGT      |L3.180|
0000a6  4545              CMP      r5,r8                 ;1597
0000a8  d002              BEQ      |L3.176|
0000aa  454d              CMP      r5,r9                 ;1597
0000ac  d1f0              BNE      |L3.144|
                  |L3.174|
0000ae  61a3              STR      r3,[r4,#0x18]         ;1650
                  |L3.176|
0000b0  6060              STR      r0,[r4,#4]            ;1639
0000b2  e7ed              B        |L3.144|
                  |L3.180|
0000b4  455d              CMP      r5,r11                ;1597
0000b6  d00d              BEQ      |L3.212|
0000b8  f5b53f00          CMP      r5,#0x20000           ;1597
0000bc  d1e8              BNE      |L3.144|
0000be  6062              STR      r2,[r4,#4]            ;1625
0000c0  e7e6              B        |L3.144|
                  |L3.194|
0000c2  4808              LDR      r0,|L3.228|
0000c4  60a0              STR      r0,[r4,#8]            ;1601
0000c6  e7e3              B        |L3.144|
                  |L3.200|
0000c8  60e1              STR      r1,[r4,#0xc]          ;1605
0000ca  e7e1              B        |L3.144|
                  |L3.204|
0000cc  6121              STR      r1,[r4,#0x10]         ;1613
0000ce  e7df              B        |L3.144|
                  |L3.208|
0000d0  6122              STR      r2,[r4,#0x10]         ;1617
0000d2  e7dd              B        |L3.144|
                  |L3.212|
0000d4  6061              STR      r1,[r4,#4]            ;1621
0000d6  e7db              B        |L3.144|
;;;1659    /**
                          ENDP

                  |L3.216|
                          DCD      0x40006400
                  |L3.220|
                          DCD      0x40006800
                  |L3.224|
                          DCD      ||.conststring||
                  |L3.228|
                          DCD      0x00010101

                          AREA ||i.CAN_DBGFreeze||, CODE, READONLY, ALIGN=2

                  CAN_DBGFreeze PROC
;;;487      */
;;;488    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;489    {
000002  4604              MOV      r4,r0
;;;490      /* Check the parameters */
;;;491      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  480e              LDR      r0,|L4.64|
000006  460d              MOV      r5,r1                 ;489
000008  4284              CMP      r4,r0
00000a  d007              BEQ      |L4.28|
00000c  480d              LDR      r0,|L4.68|
00000e  4284              CMP      r4,r0
000010  d004              BEQ      |L4.28|
000012  f24011eb          MOV      r1,#0x1eb
000016  480c              LDR      r0,|L4.72|
000018  f7fffffe          BL       assert_failed
                  |L4.28|
;;;492      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001c  b155              CBZ      r5,|L4.52|
00001e  2d01              CMP      r5,#1
000020  d004              BEQ      |L4.44|
000022  f44f71f6          MOV      r1,#0x1ec
000026  4808              LDR      r0,|L4.72|
000028  f7fffffe          BL       assert_failed
                  |L4.44|
;;;493      
;;;494      if (NewState != DISABLE)
;;;495      {
;;;496        /* Enable Debug Freeze  */
;;;497        CANx->MCR |= MCR_DBF;
00002c  6820              LDR      r0,[r4,#0]
00002e  f4403080          ORR      r0,r0,#0x10000
000032  e002              B        |L4.58|
                  |L4.52|
;;;498      }
;;;499      else
;;;500      {
;;;501        /* Disable Debug Freeze */
;;;502        CANx->MCR &= ~MCR_DBF;
000034  6820              LDR      r0,[r4,#0]
000036  f4203080          BIC      r0,r0,#0x10000
                  |L4.58|
00003a  6020              STR      r0,[r4,#0]            ;497
;;;503      }
;;;504    }
00003c  bd70              POP      {r4-r6,pc}
;;;505    
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      0x40006400
                  |L4.68|
                          DCD      0x40006800
                  |L4.72|
                          DCD      ||.conststring||

                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;161      */
;;;162    void CAN_DeInit(CAN_TypeDef* CANx)
000000  b570              PUSH     {r4-r6,lr}
;;;163    {
;;;164      /* Check the parameters */
;;;165      assert_param(IS_CAN_ALL_PERIPH(CANx));
000002  4d0e              LDR      r5,|L5.60|
000004  4604              MOV      r4,r0                 ;163
000006  42a8              CMP      r0,r5
000008  d006              BEQ      |L5.24|
00000a  480d              LDR      r0,|L5.64|
00000c  4284              CMP      r4,r0
00000e  d003              BEQ      |L5.24|
000010  21a5              MOVS     r1,#0xa5
000012  480c              LDR      r0,|L5.68|
000014  f7fffffe          BL       assert_failed
                  |L5.24|
;;;166     
;;;167      if (CANx == CAN1)
000018  42ac              CMP      r4,r5
;;;168      {
;;;169        /* Enable CAN1 reset state */
;;;170        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
;;;171        /* Release CAN1 from reset state */
;;;172        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
;;;173      }
;;;174      else
;;;175      {  
;;;176        /* Enable CAN2 reset state */
;;;177        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
00001a  f04f0101          MOV      r1,#1
00001e  d101              BNE      |L5.36|
000020  064c              LSLS     r4,r1,#25             ;170
000022  e001              B        |L5.40|
                  |L5.36|
000024  f04f6480          MOV      r4,#0x4000000
                  |L5.40|
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;178        /* Release CAN2 from reset state */
;;;179        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
00002e  4620              MOV      r0,r4
000030  e8bd4070          POP      {r4-r6,lr}
000034  2100              MOVS     r1,#0
000036  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;180      }
;;;181    }
;;;182    
                          ENDP

00003a  0000              DCW      0x0000
                  |L5.60|
                          DCD      0x40006400
                  |L5.64|
                          DCD      0x40006800
                  |L5.68|
                          DCD      ||.conststring||

                          AREA ||i.CAN_FIFORelease||, CODE, READONLY, ALIGN=2

                  CAN_FIFORelease PROC
;;;793      */
;;;794    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b570              PUSH     {r4-r6,lr}
;;;795    {
000002  4604              MOV      r4,r0
;;;796      /* Check the parameters */
;;;797      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  480e              LDR      r0,|L6.64|
000006  460d              MOV      r5,r1                 ;795
000008  4284              CMP      r4,r0
00000a  d007              BEQ      |L6.28|
00000c  480d              LDR      r0,|L6.68|
00000e  4284              CMP      r4,r0
000010  d004              BEQ      |L6.28|
000012  f240311d          MOV      r1,#0x31d
000016  480c              LDR      r0,|L6.72|
000018  f7fffffe          BL       assert_failed
                  |L6.28|
;;;798      assert_param(IS_CAN_FIFO(FIFONumber));
00001c  b15d              CBZ      r5,|L6.54|
00001e  2d01              CMP      r5,#1
000020  d004              BEQ      |L6.44|
000022  f240311e          MOV      r1,#0x31e
000026  4808              LDR      r0,|L6.72|
000028  f7fffffe          BL       assert_failed
                  |L6.44|
;;;799      /* Release FIFO0 */
;;;800      if (FIFONumber == CAN_FIFO0)
;;;801      {
;;;802        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;803      }
;;;804      /* Release FIFO1 */
;;;805      else /* FIFONumber == CAN_FIFO1 */
;;;806      {
;;;807        CANx->RF1R |= CAN_RF1R_RFOM1;
00002c  6920              LDR      r0,[r4,#0x10]
00002e  f0400020          ORR      r0,r0,#0x20
000032  6120              STR      r0,[r4,#0x10]
;;;808      }
;;;809    }
000034  bd70              POP      {r4-r6,pc}
                  |L6.54|
000036  68e0              LDR      r0,[r4,#0xc]          ;802
000038  f0400020          ORR      r0,r0,#0x20           ;802
00003c  60e0              STR      r0,[r4,#0xc]          ;802
00003e  bd70              POP      {r4-r6,pc}
;;;810    
                          ENDP

                  |L6.64|
                          DCD      0x40006400
                  |L6.68|
                          DCD      0x40006800
                  |L6.72|
                          DCD      ||.conststring||

                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=2

                  CAN_FilterInit PROC
;;;328      */
;;;329    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;330    {
000004  4604              MOV      r4,r0
;;;331      uint32_t filter_number_bit_pos = 0;
;;;332      /* Check the parameters */
;;;333      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
000006  7a80              LDRB     r0,[r0,#0xa]
000008  281b              CMP      r0,#0x1b
00000a  d904              BLS      |L7.22|
00000c  f240114d          MOV      r1,#0x14d
000010  4843              LDR      r0,|L7.288|
000012  f7fffffe          BL       assert_failed
                  |L7.22|
;;;334      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
000016  7ae0              LDRB     r0,[r4,#0xb]
000018  b130              CBZ      r0,|L7.40|
00001a  2801              CMP      r0,#1
00001c  d004              BEQ      |L7.40|
00001e  f44f71a7          MOV      r1,#0x14e
000022  483f              LDR      r0,|L7.288|
000024  f7fffffe          BL       assert_failed
                  |L7.40|
;;;335      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
000028  7b20              LDRB     r0,[r4,#0xc]
00002a  b130              CBZ      r0,|L7.58|
00002c  2801              CMP      r0,#1
00002e  d004              BEQ      |L7.58|
000030  f240114f          MOV      r1,#0x14f
000034  483a              LDR      r0,|L7.288|
000036  f7fffffe          BL       assert_failed
                  |L7.58|
;;;336      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
00003a  8920              LDRH     r0,[r4,#8]
00003c  b130              CBZ      r0,|L7.76|
00003e  2801              CMP      r0,#1
000040  d004              BEQ      |L7.76|
000042  f44f71a8          MOV      r1,#0x150
000046  4836              LDR      r0,|L7.288|
000048  f7fffffe          BL       assert_failed
                  |L7.76|
;;;337      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
00004c  7b60              LDRB     r0,[r4,#0xd]
00004e  b130              CBZ      r0,|L7.94|
000050  2801              CMP      r0,#1
000052  d004              BEQ      |L7.94|
000054  f2401151          MOV      r1,#0x151
000058  4831              LDR      r0,|L7.288|
00005a  f7fffffe          BL       assert_failed
                  |L7.94|
;;;338    
;;;339      filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
00005e  7aa1              LDRB     r1,[r4,#0xa]
;;;340    
;;;341      /* Initialisation mode for the filter */
;;;342      CAN1->FMR |= FMR_FINIT;
000060  4b30              LDR      r3,|L7.292|
000062  2001              MOVS     r0,#1                 ;339
000064  4088              LSLS     r0,r0,r1              ;339
000066  6819              LDR      r1,[r3,#0]
000068  f0410101          ORR      r1,r1,#1
00006c  6019              STR      r1,[r3,#0]
;;;343    
;;;344      /* Filter Deactivation */
;;;345      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
00006e  4d2d              LDR      r5,|L7.292|
000070  351c              ADDS     r5,r5,#0x1c
000072  6829              LDR      r1,[r5,#0]
000074  4381              BICS     r1,r1,r0
000076  6029              STR      r1,[r5,#0]
;;;346    
;;;347      /* Filter Scale */
;;;348      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
;;;349      {
;;;350        /* 16-bit scale for the filter */
;;;351        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
000078  492a              LDR      r1,|L7.292|
00007a  7b26              LDRB     r6,[r4,#0xc]          ;348
;;;352    
;;;353        /* First 16-bit identifier and First 16-bit mask */
;;;354        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;355        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
00007c  4a2a              LDR      r2,|L7.296|
00007e  310c              ADDS     r1,r1,#0xc            ;351
000080  b9a6              CBNZ     r6,|L7.172|
000082  680e              LDR      r6,[r1,#0]            ;351
000084  4386              BICS     r6,r6,r0              ;351
000086  600e              STR      r6,[r1,#0]            ;351
000088  8866              LDRH     r6,[r4,#2]
00008a  88e7              LDRH     r7,[r4,#6]
00008c  ea464607          ORR      r6,r6,r7,LSL #16
000090  7aa7              LDRB     r7,[r4,#0xa]
000092  eb0207c7          ADD      r7,r2,r7,LSL #3
000096  f8c76640          STR      r6,[r7,#0x640]
;;;356           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;357            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;358    
;;;359        /* Second 16-bit identifier and Second 16-bit mask */
;;;360        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;361        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
00009a  8826              LDRH     r6,[r4,#0]
00009c  88a7              LDRH     r7,[r4,#4]
00009e  ea464607          ORR      r6,r6,r7,LSL #16
0000a2  7aa7              LDRB     r7,[r4,#0xa]
0000a4  eb0207c7          ADD      r7,r2,r7,LSL #3
0000a8  f8c76644          STR      r6,[r7,#0x644]
                  |L7.172|
;;;362           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;363            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;364      }
;;;365    
;;;366      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
0000ac  7b26              LDRB     r6,[r4,#0xc]
0000ae  2e01              CMP      r6,#1
0000b0  d112              BNE      |L7.216|
;;;367      {
;;;368        /* 32-bit scale for the filter */
;;;369        CAN1->FS1R |= filter_number_bit_pos;
0000b2  680e              LDR      r6,[r1,#0]
0000b4  4306              ORRS     r6,r6,r0
0000b6  600e              STR      r6,[r1,#0]
;;;370        /* 32-bit identifier or First 32-bit identifier */
;;;371        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
0000b8  7aa6              LDRB     r6,[r4,#0xa]
0000ba  6821              LDR      r1,[r4,#0]
0000bc  eb0206c6          ADD      r6,r2,r6,LSL #3
0000c0  ea4f4131          ROR      r1,r1,#16
0000c4  f8c61640          STR      r1,[r6,#0x640]
;;;372           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;373            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;374        /* 32-bit mask or Second 32-bit identifier */
;;;375        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
0000c8  7aa6              LDRB     r6,[r4,#0xa]
0000ca  6861              LDR      r1,[r4,#4]
0000cc  eb0202c6          ADD      r2,r2,r6,LSL #3
0000d0  ea4f4131          ROR      r1,r1,#16
0000d4  f8c21644          STR      r1,[r2,#0x644]
                  |L7.216|
;;;376           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;377            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;378      }
;;;379    
;;;380      /* Filter Mode */
;;;381      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
;;;382      {
;;;383        /*Id/Mask mode for the filter*/
;;;384        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
0000d8  4912              LDR      r1,|L7.292|
0000da  7ae2              LDRB     r2,[r4,#0xb]          ;381
0000dc  1d09              ADDS     r1,r1,#4
0000de  2a00              CMP      r2,#0                 ;381
;;;385      }
;;;386      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;387      {
;;;388        /*Identifier list mode for the filter*/
;;;389        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
0000e0  680a              LDR      r2,[r1,#0]
0000e2  d006              BEQ      |L7.242|
0000e4  4302              ORRS     r2,r2,r0
                  |L7.230|
0000e6  600a              STR      r2,[r1,#0]
;;;390      }
;;;391    
;;;392      /* Filter FIFO assignment */
;;;393      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
;;;394      {
;;;395        /* FIFO 0 assignation for the filter */
;;;396        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
0000e8  490e              LDR      r1,|L7.292|
0000ea  8922              LDRH     r2,[r4,#8]            ;393
0000ec  3114              ADDS     r1,r1,#0x14
0000ee  b112              CBZ      r2,|L7.246|
0000f0  e004              B        |L7.252|
                  |L7.242|
0000f2  4382              BICS     r2,r2,r0              ;384
0000f4  e7f7              B        |L7.230|
                  |L7.246|
0000f6  680a              LDR      r2,[r1,#0]
0000f8  4382              BICS     r2,r2,r0
0000fa  600a              STR      r2,[r1,#0]
                  |L7.252|
;;;397      }
;;;398    
;;;399      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
0000fc  8922              LDRH     r2,[r4,#8]
0000fe  2a01              CMP      r2,#1
000100  d102              BNE      |L7.264|
;;;400      {
;;;401        /* FIFO 1 assignation for the filter */
;;;402        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
000102  680a              LDR      r2,[r1,#0]
000104  4302              ORRS     r2,r2,r0
000106  600a              STR      r2,[r1,#0]
                  |L7.264|
;;;403      }
;;;404      
;;;405      /* Filter activation */
;;;406      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
000108  7b61              LDRB     r1,[r4,#0xd]
00010a  2901              CMP      r1,#1
00010c  d102              BNE      |L7.276|
;;;407      {
;;;408        CAN1->FA1R |= filter_number_bit_pos;
00010e  6829              LDR      r1,[r5,#0]
000110  4301              ORRS     r1,r1,r0
000112  6029              STR      r1,[r5,#0]
                  |L7.276|
;;;409      }
;;;410    
;;;411      /* Leave the initialisation mode for the filter */
;;;412      CAN1->FMR &= ~FMR_FINIT;
000114  6818              LDR      r0,[r3,#0]
000116  f0200001          BIC      r0,r0,#1
00011a  6018              STR      r0,[r3,#0]
;;;413    }
00011c  e8bd81f0          POP      {r4-r8,pc}
;;;414    
                          ENDP

                  |L7.288|
                          DCD      ||.conststring||
                  |L7.292|
                          DCD      0x40006600
                  |L7.296|
                          DCD      0x40006000

                          AREA ||i.CAN_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  CAN_GetFlagStatus PROC
;;;1326     */
;;;1327   FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1328   {
000002  4605              MOV      r5,r0
;;;1329     FlagStatus bitstatus = RESET;
;;;1330     
;;;1331     /* Check the parameters */
;;;1332     assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  482d              LDR      r0,|L8.188|
000006  2600              MOVS     r6,#0                 ;1329
000008  460c              MOV      r4,r1                 ;1328
00000a  4285              CMP      r5,r0
00000c  d007              BEQ      |L8.30|
00000e  482c              LDR      r0,|L8.192|
000010  4285              CMP      r5,r0
000012  d004              BEQ      |L8.30|
000014  f2405134          MOV      r1,#0x534
000018  482a              LDR      r0,|L8.196|
00001a  f7fffffe          BL       assert_failed
                  |L8.30|
;;;1333     assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
00001e  482a              LDR      r0,|L8.200|
000020  4284              CMP      r4,r0
000022  d033              BEQ      |L8.140|
000024  4829              LDR      r0,|L8.204|
000026  4284              CMP      r4,r0
000028  d030              BEQ      |L8.140|
00002a  1e80              SUBS     r0,r0,#2
00002c  4284              CMP      r4,r0
00002e  d02d              BEQ      |L8.140|
000030  1e40              SUBS     r0,r0,#1
000032  4284              CMP      r4,r0
000034  d02a              BEQ      |L8.140|
000036  f1a45044          SUB      r0,r4,#0x31000000
00003a  3808              SUBS     r0,r0,#8
00003c  d026              BEQ      |L8.140|
00003e  f1a45048          SUB      r0,r4,#0x32000000
000042  3810              SUBS     r0,r0,#0x10
000044  d022              BEQ      |L8.140|
000046  3008              ADDS     r0,r0,#8
000048  d020              BEQ      |L8.140|
00004a  f1a45090          SUB      r0,r4,#0x12000000
00004e  1ec0              SUBS     r0,r0,#3
000050  d01c              BEQ      |L8.140|
000052  f1a45050          SUB      r0,r4,#0x34000000
000056  3810              SUBS     r0,r0,#0x10
000058  d018              BEQ      |L8.140|
00005a  3008              ADDS     r0,r0,#8
00005c  d016              BEQ      |L8.140|
00005e  f1a450a0          SUB      r0,r4,#0x14000000
000062  1ec0              SUBS     r0,r0,#3
000064  d012              BEQ      |L8.140|
000066  481a              LDR      r0,|L8.208|
000068  4284              CMP      r4,r0
00006a  d00f              BEQ      |L8.140|
00006c  4819              LDR      r0,|L8.212|
00006e  4284              CMP      r4,r0
000070  d00c              BEQ      |L8.140|
000072  f06f5060          MVN      r0,#0x38000000
000076  42c4              CMN      r4,r0
000078  d008              BEQ      |L8.140|
00007a  f1a45044          SUB      r0,r4,#0x31000000
00007e  3812              SUBS     r0,r0,#0x12
000080  d004              BEQ      |L8.140|
000082  f2405135          MOV      r1,#0x535
000086  480f              LDR      r0,|L8.196|
000088  f7fffffe          BL       assert_failed
                  |L8.140|
;;;1334     
;;;1335   
;;;1336     if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
00008c  f4140f70          TST      r4,#0xf00000
000090  d001              BEQ      |L8.150|
;;;1337     { 
;;;1338       /* Check the status of the specified CAN flag */
;;;1339       if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000092  69a8              LDR      r0,[r5,#0x18]
000094  e00c              B        |L8.176|
                  |L8.150|
;;;1340       { 
;;;1341         /* CAN_FLAG is set */
;;;1342         bitstatus = SET;
;;;1343       }
;;;1344       else
;;;1345       { 
;;;1346         /* CAN_FLAG is reset */
;;;1347         bitstatus = RESET;
;;;1348       }
;;;1349     }
;;;1350     else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
000096  01e0              LSLS     r0,r4,#7
000098  d501              BPL      |L8.158|
;;;1351     { 
;;;1352       /* Check the status of the specified CAN flag */
;;;1353       if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
00009a  6868              LDR      r0,[r5,#4]
00009c  e008              B        |L8.176|
                  |L8.158|
;;;1354       { 
;;;1355         /* CAN_FLAG is set */
;;;1356         bitstatus = SET;
;;;1357       }
;;;1358       else
;;;1359       { 
;;;1360         /* CAN_FLAG is reset */
;;;1361         bitstatus = RESET;
;;;1362       }
;;;1363     }
;;;1364     else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
00009e  0120              LSLS     r0,r4,#4
0000a0  d501              BPL      |L8.166|
;;;1365     { 
;;;1366       /* Check the status of the specified CAN flag */
;;;1367       if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
0000a2  68a8              LDR      r0,[r5,#8]
0000a4  e004              B        |L8.176|
                  |L8.166|
;;;1368       { 
;;;1369         /* CAN_FLAG is set */
;;;1370         bitstatus = SET;
;;;1371       }
;;;1372       else
;;;1373       { 
;;;1374         /* CAN_FLAG is reset */
;;;1375         bitstatus = RESET;
;;;1376       }
;;;1377     }
;;;1378     else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
0000a6  01a0              LSLS     r0,r4,#6
0000a8  d501              BPL      |L8.174|
;;;1379     { 
;;;1380       /* Check the status of the specified CAN flag */
;;;1381       if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
0000aa  68e8              LDR      r0,[r5,#0xc]
0000ac  e000              B        |L8.176|
                  |L8.174|
;;;1382       { 
;;;1383         /* CAN_FLAG is set */
;;;1384         bitstatus = SET;
;;;1385       }
;;;1386       else
;;;1387       { 
;;;1388         /* CAN_FLAG is reset */
;;;1389         bitstatus = RESET;
;;;1390       }
;;;1391     }
;;;1392     else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
;;;1393     { 
;;;1394       /* Check the status of the specified CAN flag */
;;;1395       if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
0000ae  6928              LDR      r0,[r5,#0x10]
                  |L8.176|
0000b0  4020              ANDS     r0,r0,r4
0000b2  0300              LSLS     r0,r0,#12
0000b4  d000              BEQ      |L8.184|
;;;1396       { 
;;;1397         /* CAN_FLAG is set */
;;;1398         bitstatus = SET;
0000b6  2601              MOVS     r6,#1
                  |L8.184|
;;;1399       }
;;;1400       else
;;;1401       { 
;;;1402         /* CAN_FLAG is reset */
;;;1403         bitstatus = RESET;
;;;1404       }
;;;1405     }
;;;1406     /* Return the CAN_FLAG status */
;;;1407     return  bitstatus;
0000b8  4630              MOV      r0,r6
;;;1408   }
0000ba  bd70              POP      {r4-r6,pc}
;;;1409   
                          ENDP

                  |L8.188|
                          DCD      0x40006400
                  |L8.192|
                          DCD      0x40006800
                  |L8.196|
                          DCD      ||.conststring||
                  |L8.200|
                          DCD      0x30f00070
                  |L8.204|
                          DCD      0x10f00004
                  |L8.208|
                          DCD      0x38010000
                  |L8.212|
                          DCD      0x38000100

                          AREA ||i.CAN_GetITStatus||, CODE, READONLY, ALIGN=2

                  CAN_GetITStatus PROC
;;;1486     */
;;;1487   ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1488   {
000004  4604              MOV      r4,r0
;;;1489     ITStatus itstatus = RESET;
000006  2000              MOVS     r0,#0
;;;1490     /* Check the parameters */
;;;1491     assert_param(IS_CAN_ALL_PERIPH(CANx));
000008  9000              STR      r0,[sp,#0]
00000a  4844              LDR      r0,|L9.284|
00000c  460d              MOV      r5,r1                 ;1488
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L9.34|
000012  4843              LDR      r0,|L9.288|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L9.34|
000018  f24051d3          MOV      r1,#0x5d3
00001c  4841              LDR      r0,|L9.292|
00001e  f7fffffe          BL       assert_failed
                  |L9.34|
;;;1492     assert_param(IS_CAN_IT(CAN_IT));
000022  f44f7680          MOV      r6,#0x100
000026  0077              LSLS     r7,r6,#1
000028  f44f6880          MOV      r8,#0x400
00002c  f44f6900          MOV      r9,#0x800
000030  f44f4a00          MOV      r10,#0x8000
000034  f44f3b80          MOV      r11,#0x10000
000038  2d01              CMP      r5,#1
00003a  d01f              BEQ      |L9.124|
00003c  2d02              CMP      r5,#2
00003e  d01d              BEQ      |L9.124|
000040  2d04              CMP      r5,#4
000042  d01b              BEQ      |L9.124|
000044  2d08              CMP      r5,#8
000046  d019              BEQ      |L9.124|
000048  2d10              CMP      r5,#0x10
00004a  d017              BEQ      |L9.124|
00004c  2d20              CMP      r5,#0x20
00004e  d015              BEQ      |L9.124|
000050  2d40              CMP      r5,#0x40
000052  d013              BEQ      |L9.124|
000054  42b5              CMP      r5,r6
000056  d011              BEQ      |L9.124|
000058  42bd              CMP      r5,r7
00005a  d00f              BEQ      |L9.124|
00005c  4545              CMP      r5,r8
00005e  d00d              BEQ      |L9.124|
000060  454d              CMP      r5,r9
000062  d00b              BEQ      |L9.124|
000064  4555              CMP      r5,r10
000066  d009              BEQ      |L9.124|
000068  455d              CMP      r5,r11
00006a  d007              BEQ      |L9.124|
00006c  f5b53f00          CMP      r5,#0x20000
000070  d004              BEQ      |L9.124|
000072  f24051d4          MOV      r1,#0x5d4
000076  482b              LDR      r0,|L9.292|
000078  f7fffffe          BL       assert_failed
                  |L9.124|
;;;1493     
;;;1494     /* check the interrupt enable bit */
;;;1495    if((CANx->IER & CAN_IT) != RESET)
00007c  6960              LDR      r0,[r4,#0x14]
00007e  4228              TST      r0,r5
000080  d048              BEQ      |L9.276|
;;;1496    {
;;;1497      /* in case the Interrupt is enabled, .... */
;;;1498       switch (CAN_IT)
000082  42b5              CMP      r5,r6
000084  d039              BEQ      |L9.250|
000086  dc10              BGT      |L9.170|
000088  2d08              CMP      r5,#8
00008a  d027              BEQ      |L9.220|
00008c  dc06              BGT      |L9.156|
00008e  2d01              CMP      r5,#1
000090  d01d              BEQ      |L9.206|
000092  2d02              CMP      r5,#2
000094  d01e              BEQ      |L9.212|
000096  2d04              CMP      r5,#4
000098  d13c              BNE      |L9.276|
00009a  e01d              B        |L9.216|
                  |L9.156|
00009c  2d10              CMP      r5,#0x10
00009e  d01f              BEQ      |L9.224|
0000a0  2d20              CMP      r5,#0x20
0000a2  d020              BEQ      |L9.230|
0000a4  2d40              CMP      r5,#0x40
0000a6  d135              BNE      |L9.276|
0000a8  e020              B        |L9.236|
                  |L9.170|
0000aa  4555              CMP      r5,r10
0000ac  d02d              BEQ      |L9.266|
0000ae  dc08              BGT      |L9.194|
0000b0  42bd              CMP      r5,r7
0000b2  d025              BEQ      |L9.256|
0000b4  4545              CMP      r5,r8
0000b6  d026              BEQ      |L9.262|
0000b8  454d              CMP      r5,r9
0000ba  d12b              BNE      |L9.276|
;;;1499       {
;;;1500         case CAN_IT_TME:
;;;1501           /* Check CAN_TSR_RQCPx bits */
;;;1502           itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
;;;1503           break;
;;;1504         case CAN_IT_FMP0:
;;;1505           /* Check CAN_RF0R_FMP0 bit */
;;;1506           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
;;;1507           break;
;;;1508         case CAN_IT_FF0:
;;;1509           /* Check CAN_RF0R_FULL0 bit */
;;;1510           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
;;;1511           break;
;;;1512         case CAN_IT_FOV0:
;;;1513           /* Check CAN_RF0R_FOVR0 bit */
;;;1514           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
;;;1515           break;
;;;1516         case CAN_IT_FMP1:
;;;1517           /* Check CAN_RF1R_FMP1 bit */
;;;1518           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
;;;1519           break;
;;;1520         case CAN_IT_FF1:
;;;1521           /* Check CAN_RF1R_FULL1 bit */
;;;1522           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
;;;1523           break;
;;;1524         case CAN_IT_FOV1:
;;;1525           /* Check CAN_RF1R_FOVR1 bit */
;;;1526           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
;;;1527           break;
;;;1528         case CAN_IT_WKU:
;;;1529           /* Check CAN_MSR_WKUI bit */
;;;1530           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
;;;1531           break;
;;;1532         case CAN_IT_SLK:
;;;1533           /* Check CAN_MSR_SLAKI bit */
;;;1534           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
;;;1535           break;
;;;1536         case CAN_IT_EWG:
;;;1537           /* Check CAN_ESR_EWGF bit */
;;;1538           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
;;;1539           break;
;;;1540         case CAN_IT_EPV:
;;;1541           /* Check CAN_ESR_EPVF bit */
;;;1542           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
;;;1543           break;
;;;1544         case CAN_IT_BOF:
;;;1545           /* Check CAN_ESR_BOFF bit */
;;;1546           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
;;;1547           break;
;;;1548         case CAN_IT_LEC:
;;;1549           /* Check CAN_ESR_LEC bit */
;;;1550           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
0000bc  69a0              LDR      r0,[r4,#0x18]
0000be  2170              MOVS     r1,#0x70
;;;1551           break;
0000c0  e025              B        |L9.270|
                  |L9.194|
0000c2  455d              CMP      r5,r11                ;1498
0000c4  d015              BEQ      |L9.242|
0000c6  f5b53f00          CMP      r5,#0x20000           ;1498
0000ca  d123              BNE      |L9.276|
0000cc  e013              B        |L9.246|
                  |L9.206|
0000ce  68a0              LDR      r0,[r4,#8]            ;1502
0000d0  4915              LDR      r1,|L9.296|
0000d2  e01c              B        |L9.270|
                  |L9.212|
0000d4  68e0              LDR      r0,[r4,#0xc]          ;1506
0000d6  e004              B        |L9.226|
                  |L9.216|
0000d8  68e0              LDR      r0,[r4,#0xc]          ;1510
0000da  e005              B        |L9.232|
                  |L9.220|
0000dc  68e0              LDR      r0,[r4,#0xc]          ;1514
0000de  e006              B        |L9.238|
                  |L9.224|
0000e0  6920              LDR      r0,[r4,#0x10]         ;1518
                  |L9.226|
0000e2  2103              MOVS     r1,#3                 ;1506
0000e4  e013              B        |L9.270|
                  |L9.230|
0000e6  6920              LDR      r0,[r4,#0x10]         ;1522
                  |L9.232|
0000e8  2108              MOVS     r1,#8                 ;1510
0000ea  e010              B        |L9.270|
                  |L9.236|
0000ec  6920              LDR      r0,[r4,#0x10]         ;1526
                  |L9.238|
0000ee  2110              MOVS     r1,#0x10              ;1514
0000f0  e00d              B        |L9.270|
                  |L9.242|
0000f2  6860              LDR      r0,[r4,#4]            ;1530
0000f4  e7f8              B        |L9.232|
                  |L9.246|
0000f6  6860              LDR      r0,[r4,#4]            ;1534
0000f8  e7f9              B        |L9.238|
                  |L9.250|
0000fa  69a0              LDR      r0,[r4,#0x18]         ;1538
0000fc  2101              MOVS     r1,#1                 ;1538
0000fe  e006              B        |L9.270|
                  |L9.256|
000100  69a0              LDR      r0,[r4,#0x18]         ;1542
000102  2102              MOVS     r1,#2                 ;1542
000104  e003              B        |L9.270|
                  |L9.262|
000106  69a0              LDR      r0,[r4,#0x18]         ;1546
000108  e000              B        |L9.268|
                  |L9.266|
;;;1552         case CAN_IT_ERR:
;;;1553           /* Check CAN_MSR_ERRI bit */ 
;;;1554           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
00010a  6860              LDR      r0,[r4,#4]
                  |L9.268|
00010c  2104              MOVS     r1,#4                 ;1546
                  |L9.270|
00010e  f7fffffe          BL       CheckITStatus
000112  9000              STR      r0,[sp,#0]
                  |L9.276|
;;;1555           break;
;;;1556         default:
;;;1557           /* in case of error, return RESET */
;;;1558           itstatus = RESET;
;;;1559           break;
;;;1560       }
;;;1561     }
;;;1562     else
;;;1563     {
;;;1564      /* in case the Interrupt is not enabled, return RESET */
;;;1565       itstatus  = RESET;
;;;1566     }
;;;1567     
;;;1568     /* Return the CAN_IT status */
;;;1569     return  itstatus;
000114  9800              LDR      r0,[sp,#0]
;;;1570   }
000116  e8bd8ff8          POP      {r3-r11,pc}
;;;1571   
                          ENDP

00011a  0000              DCW      0x0000
                  |L9.284|
                          DCD      0x40006400
                  |L9.288|
                          DCD      0x40006800
                  |L9.292|
                          DCD      ||.conststring||
                  |L9.296|
                          DCD      0x00010101

                          AREA ||i.CAN_GetLSBTransmitErrorCounter||, CODE, READONLY, ALIGN=2

                  CAN_GetLSBTransmitErrorCounter PROC
;;;1079     */
;;;1080   uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;1081   {
000002  4604              MOV      r4,r0
;;;1082     uint8_t counter=0;
;;;1083     
;;;1084     /* Check the parameters */
;;;1085     assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  4807              LDR      r0,|L10.36|
000006  4284              CMP      r4,r0
000008  d007              BEQ      |L10.26|
00000a  4807              LDR      r0,|L10.40|
00000c  4284              CMP      r4,r0
00000e  d004              BEQ      |L10.26|
000010  f240413d          MOV      r1,#0x43d
000014  4805              LDR      r0,|L10.44|
000016  f7fffffe          BL       assert_failed
                  |L10.26|
;;;1086     
;;;1087     /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1088     counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  f3c04007          UBFX     r0,r0,#16,#8
;;;1089     
;;;1090     /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1091     return counter;
;;;1092   }
000020  bd10              POP      {r4,pc}
;;;1093   /**
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      0x40006400
                  |L10.40|
                          DCD      0x40006800
                  |L10.44|
                          DCD      ||.conststring||

                          AREA ||i.CAN_GetLastErrorCode||, CODE, READONLY, ALIGN=2

                  CAN_GetLastErrorCode PROC
;;;1034     */
;;;1035   uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;1036   {
000002  4604              MOV      r4,r0
;;;1037     uint8_t errorcode=0;
;;;1038     
;;;1039     /* Check the parameters */
;;;1040     assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  4807              LDR      r0,|L11.36|
000006  4284              CMP      r4,r0
000008  d007              BEQ      |L11.26|
00000a  4807              LDR      r0,|L11.40|
00000c  4284              CMP      r4,r0
00000e  d004              BEQ      |L11.26|
000010  f44f6182          MOV      r1,#0x410
000014  4805              LDR      r0,|L11.44|
000016  f7fffffe          BL       assert_failed
                  |L11.26|
;;;1041     
;;;1042     /* Get the error code*/
;;;1043     errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  f3c01002          UBFX     r0,r0,#4,#3
000020  0100              LSLS     r0,r0,#4
;;;1044     
;;;1045     /* Return the error code*/
;;;1046     return errorcode;
;;;1047   }
000022  bd10              POP      {r4,pc}
;;;1048   
                          ENDP

                  |L11.36|
                          DCD      0x40006400
                  |L11.40|
                          DCD      0x40006800
                  |L11.44|
                          DCD      ||.conststring||

                          AREA ||i.CAN_GetReceiveErrorCounter||, CODE, READONLY, ALIGN=2

                  CAN_GetReceiveErrorCounter PROC
;;;1059     */
;;;1060   uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;1061   {
000002  4604              MOV      r4,r0
;;;1062     uint8_t counter=0;
;;;1063     
;;;1064     /* Check the parameters */
;;;1065     assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  4806              LDR      r0,|L12.32|
000006  4284              CMP      r4,r0
000008  d007              BEQ      |L12.26|
00000a  4806              LDR      r0,|L12.36|
00000c  4284              CMP      r4,r0
00000e  d004              BEQ      |L12.26|
000010  f2404129          MOV      r1,#0x429
000014  4804              LDR      r0,|L12.40|
000016  f7fffffe          BL       assert_failed
                  |L12.26|
;;;1066     
;;;1067     /* Get the Receive Error Counter*/
;;;1068     counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  0e00              LSRS     r0,r0,#24
;;;1069     
;;;1070     /* Return the Receive Error Counter*/
;;;1071     return counter;
;;;1072   }
00001e  bd10              POP      {r4,pc}
;;;1073   
                          ENDP

                  |L12.32|
                          DCD      0x40006400
                  |L12.36|
                          DCD      0x40006800
                  |L12.40|
                          DCD      ||.conststring||

                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=2

                  CAN_ITConfig PROC
;;;1286     */
;;;1287   void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1288   {
000002  4605              MOV      r5,r0
;;;1289     /* Check the parameters */
;;;1290     assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  4821              LDR      r0,|L13.140|
000006  4616              MOV      r6,r2                 ;1288
000008  460c              MOV      r4,r1                 ;1288
00000a  4285              CMP      r5,r0
00000c  d007              BEQ      |L13.30|
00000e  4820              LDR      r0,|L13.144|
000010  4285              CMP      r5,r0
000012  d004              BEQ      |L13.30|
000014  f240510a          MOV      r1,#0x50a
000018  481e              LDR      r0,|L13.148|
00001a  f7fffffe          BL       assert_failed
                  |L13.30|
;;;1291     assert_param(IS_CAN_IT(CAN_IT));
00001e  2c01              CMP      r4,#1
000020  d025              BEQ      |L13.110|
000022  2c02              CMP      r4,#2
000024  d023              BEQ      |L13.110|
000026  2c04              CMP      r4,#4
000028  d021              BEQ      |L13.110|
00002a  2c08              CMP      r4,#8
00002c  d01f              BEQ      |L13.110|
00002e  2c10              CMP      r4,#0x10
000030  d01d              BEQ      |L13.110|
000032  2c20              CMP      r4,#0x20
000034  d01b              BEQ      |L13.110|
000036  2c40              CMP      r4,#0x40
000038  d019              BEQ      |L13.110|
00003a  f5b47f80          CMP      r4,#0x100
00003e  d016              BEQ      |L13.110|
000040  f5b47f00          CMP      r4,#0x200
000044  d013              BEQ      |L13.110|
000046  f5b46f80          CMP      r4,#0x400
00004a  d010              BEQ      |L13.110|
00004c  f5b46f00          CMP      r4,#0x800
000050  d00d              BEQ      |L13.110|
000052  f5b44f00          CMP      r4,#0x8000
000056  d00a              BEQ      |L13.110|
000058  f5b43f80          CMP      r4,#0x10000
00005c  d007              BEQ      |L13.110|
00005e  f5b43f00          CMP      r4,#0x20000
000062  d004              BEQ      |L13.110|
000064  f240510b          MOV      r1,#0x50b
000068  480a              LDR      r0,|L13.148|
00006a  f7fffffe          BL       assert_failed
                  |L13.110|
;;;1292     assert_param(IS_FUNCTIONAL_STATE(NewState));
00006e  b14e              CBZ      r6,|L13.132|
000070  2e01              CMP      r6,#1
000072  d004              BEQ      |L13.126|
000074  f240510c          MOV      r1,#0x50c
000078  4806              LDR      r0,|L13.148|
00007a  f7fffffe          BL       assert_failed
                  |L13.126|
;;;1293   
;;;1294     if (NewState != DISABLE)
;;;1295     {
;;;1296       /* Enable the selected CANx interrupt */
;;;1297       CANx->IER |= CAN_IT;
00007e  6968              LDR      r0,[r5,#0x14]
000080  4320              ORRS     r0,r0,r4
000082  e001              B        |L13.136|
                  |L13.132|
;;;1298     }
;;;1299     else
;;;1300     {
;;;1301       /* Disable the selected CANx interrupt */
;;;1302       CANx->IER &= ~CAN_IT;
000084  6968              LDR      r0,[r5,#0x14]
000086  43a0              BICS     r0,r0,r4
                  |L13.136|
000088  6168              STR      r0,[r5,#0x14]         ;1297
;;;1303     }
;;;1304   }
00008a  bd70              POP      {r4-r6,pc}
;;;1305   /**
                          ENDP

                  |L13.140|
                          DCD      0x40006400
                  |L13.144|
                          DCD      0x40006800
                  |L13.148|
                          DCD      ||.conststring||

                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=2

                  CAN_Init PROC
;;;191      */
;;;192    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;193    {
000002  4604              MOV      r4,r0
;;;194      uint8_t InitStatus = CAN_InitStatus_Failed;
;;;195      uint32_t wait_ack = 0x00000000;
;;;196      /* Check the parameters */
;;;197      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  486e              LDR      r0,|L14.448|
000006  2600              MOVS     r6,#0                 ;195
000008  460d              MOV      r5,r1                 ;193
00000a  4284              CMP      r4,r0
00000c  d006              BEQ      |L14.28|
00000e  486d              LDR      r0,|L14.452|
000010  4284              CMP      r4,r0
000012  d003              BEQ      |L14.28|
000014  21c5              MOVS     r1,#0xc5
000016  486c              LDR      r0,|L14.456|
000018  f7fffffe          BL       assert_failed
                  |L14.28|
;;;198      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
00001c  79a8              LDRB     r0,[r5,#6]
00001e  b128              CBZ      r0,|L14.44|
000020  2801              CMP      r0,#1
000022  d003              BEQ      |L14.44|
000024  21c6              MOVS     r1,#0xc6
000026  4868              LDR      r0,|L14.456|
000028  f7fffffe          BL       assert_failed
                  |L14.44|
;;;199      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
00002c  79e8              LDRB     r0,[r5,#7]
00002e  b128              CBZ      r0,|L14.60|
000030  2801              CMP      r0,#1
000032  d003              BEQ      |L14.60|
000034  21c7              MOVS     r1,#0xc7
000036  4864              LDR      r0,|L14.456|
000038  f7fffffe          BL       assert_failed
                  |L14.60|
;;;200      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
00003c  7a28              LDRB     r0,[r5,#8]
00003e  b128              CBZ      r0,|L14.76|
000040  2801              CMP      r0,#1
000042  d003              BEQ      |L14.76|
000044  21c8              MOVS     r1,#0xc8
000046  4860              LDR      r0,|L14.456|
000048  f7fffffe          BL       assert_failed
                  |L14.76|
;;;201      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
00004c  7a68              LDRB     r0,[r5,#9]
00004e  b128              CBZ      r0,|L14.92|
000050  2801              CMP      r0,#1
000052  d003              BEQ      |L14.92|
000054  21c9              MOVS     r1,#0xc9
000056  485c              LDR      r0,|L14.456|
000058  f7fffffe          BL       assert_failed
                  |L14.92|
;;;202      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
00005c  7aa8              LDRB     r0,[r5,#0xa]
00005e  b128              CBZ      r0,|L14.108|
000060  2801              CMP      r0,#1
000062  d003              BEQ      |L14.108|
000064  21ca              MOVS     r1,#0xca
000066  4858              LDR      r0,|L14.456|
000068  f7fffffe          BL       assert_failed
                  |L14.108|
;;;203      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
00006c  7ae8              LDRB     r0,[r5,#0xb]
00006e  b128              CBZ      r0,|L14.124|
000070  2801              CMP      r0,#1
000072  d003              BEQ      |L14.124|
000074  21cb              MOVS     r1,#0xcb
000076  4854              LDR      r0,|L14.456|
000078  f7fffffe          BL       assert_failed
                  |L14.124|
;;;204      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
00007c  78a8              LDRB     r0,[r5,#2]
00007e  b148              CBZ      r0,|L14.148|
000080  2801              CMP      r0,#1
000082  d007              BEQ      |L14.148|
000084  2802              CMP      r0,#2
000086  d005              BEQ      |L14.148|
000088  2803              CMP      r0,#3
00008a  d003              BEQ      |L14.148|
00008c  21cc              MOVS     r1,#0xcc
00008e  484e              LDR      r0,|L14.456|
000090  f7fffffe          BL       assert_failed
                  |L14.148|
;;;205      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
000094  78e8              LDRB     r0,[r5,#3]
000096  b148              CBZ      r0,|L14.172|
000098  2801              CMP      r0,#1
00009a  d007              BEQ      |L14.172|
00009c  2802              CMP      r0,#2
00009e  d005              BEQ      |L14.172|
0000a0  2803              CMP      r0,#3
0000a2  d003              BEQ      |L14.172|
0000a4  21cd              MOVS     r1,#0xcd
0000a6  4848              LDR      r0,|L14.456|
0000a8  f7fffffe          BL       assert_failed
                  |L14.172|
;;;206      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
0000ac  7928              LDRB     r0,[r5,#4]
0000ae  280f              CMP      r0,#0xf
0000b0  d903              BLS      |L14.186|
0000b2  21ce              MOVS     r1,#0xce
0000b4  4844              LDR      r0,|L14.456|
0000b6  f7fffffe          BL       assert_failed
                  |L14.186|
;;;207      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
0000ba  7968              LDRB     r0,[r5,#5]
0000bc  2807              CMP      r0,#7
0000be  d903              BLS      |L14.200|
0000c0  21cf              MOVS     r1,#0xcf
0000c2  4841              LDR      r0,|L14.456|
0000c4  f7fffffe          BL       assert_failed
                  |L14.200|
;;;208      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
0000c8  8828              LDRH     r0,[r5,#0]
0000ca  1e40              SUBS     r0,r0,#1
0000cc  f5b06f80          CMP      r0,#0x400
0000d0  d303              BCC      |L14.218|
0000d2  21d0              MOVS     r1,#0xd0
0000d4  483c              LDR      r0,|L14.456|
0000d6  f7fffffe          BL       assert_failed
                  |L14.218|
;;;209    
;;;210      /* Exit from sleep mode */
;;;211      CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
0000da  6820              LDR      r0,[r4,#0]
0000dc  f0200002          BIC      r0,r0,#2
0000e0  6020              STR      r0,[r4,#0]
;;;212    
;;;213      /* Request initialisation */
;;;214      CANx->MCR |= CAN_MCR_INRQ ;
0000e2  6820              LDR      r0,[r4,#0]
0000e4  f0400001          ORR      r0,r0,#1
0000e8  6020              STR      r0,[r4,#0]
;;;215    
;;;216      /* Wait the acknowledge */
;;;217      while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
0000ea  f64f71ff          MOV      r1,#0xffff
0000ee  e000              B        |L14.242|
                  |L14.240|
0000f0  1c76              ADDS     r6,r6,#1
                  |L14.242|
0000f2  6860              LDR      r0,[r4,#4]
0000f4  07c0              LSLS     r0,r0,#31
0000f6  d101              BNE      |L14.252|
0000f8  428e              CMP      r6,r1
0000fa  d1f9              BNE      |L14.240|
                  |L14.252|
;;;218      {
;;;219        wait_ack++;
;;;220      }
;;;221    
;;;222      /* Check acknowledge */
;;;223      if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
0000fc  6860              LDR      r0,[r4,#4]
0000fe  07c0              LSLS     r0,r0,#31
000100  d05a              BEQ      |L14.440|
;;;224      {
;;;225        InitStatus = CAN_InitStatus_Failed;
;;;226      }
;;;227      else 
;;;228      {
;;;229        /* Set the time triggered communication mode */
;;;230        if (CAN_InitStruct->CAN_TTCM == ENABLE)
000102  79a8              LDRB     r0,[r5,#6]
000104  2801              CMP      r0,#1
;;;231        {
;;;232          CANx->MCR |= CAN_MCR_TTCM;
;;;233        }
;;;234        else
;;;235        {
;;;236          CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
000106  6820              LDR      r0,[r4,#0]
000108  d03a              BEQ      |L14.384|
00010a  f0200080          BIC      r0,r0,#0x80
                  |L14.270|
00010e  6020              STR      r0,[r4,#0]
;;;237        }
;;;238    
;;;239        /* Set the automatic bus-off management */
;;;240        if (CAN_InitStruct->CAN_ABOM == ENABLE)
000110  79e8              LDRB     r0,[r5,#7]
000112  2801              CMP      r0,#1
;;;241        {
;;;242          CANx->MCR |= CAN_MCR_ABOM;
;;;243        }
;;;244        else
;;;245        {
;;;246          CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
000114  6820              LDR      r0,[r4,#0]
000116  d036              BEQ      |L14.390|
000118  f0200040          BIC      r0,r0,#0x40
                  |L14.284|
00011c  6020              STR      r0,[r4,#0]
;;;247        }
;;;248    
;;;249        /* Set the automatic wake-up mode */
;;;250        if (CAN_InitStruct->CAN_AWUM == ENABLE)
00011e  7a28              LDRB     r0,[r5,#8]
000120  2801              CMP      r0,#1
;;;251        {
;;;252          CANx->MCR |= CAN_MCR_AWUM;
;;;253        }
;;;254        else
;;;255        {
;;;256          CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
000122  6820              LDR      r0,[r4,#0]
000124  d032              BEQ      |L14.396|
000126  f0200020          BIC      r0,r0,#0x20
                  |L14.298|
00012a  6020              STR      r0,[r4,#0]
;;;257        }
;;;258    
;;;259        /* Set the no automatic retransmission */
;;;260        if (CAN_InitStruct->CAN_NART == ENABLE)
00012c  7a68              LDRB     r0,[r5,#9]
00012e  2801              CMP      r0,#1
;;;261        {
;;;262          CANx->MCR |= CAN_MCR_NART;
;;;263        }
;;;264        else
;;;265        {
;;;266          CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
000130  6820              LDR      r0,[r4,#0]
000132  d02e              BEQ      |L14.402|
000134  f0200010          BIC      r0,r0,#0x10
                  |L14.312|
000138  6020              STR      r0,[r4,#0]
;;;267        }
;;;268    
;;;269        /* Set the receive FIFO locked mode */
;;;270        if (CAN_InitStruct->CAN_RFLM == ENABLE)
00013a  7aa8              LDRB     r0,[r5,#0xa]
00013c  2801              CMP      r0,#1
;;;271        {
;;;272          CANx->MCR |= CAN_MCR_RFLM;
;;;273        }
;;;274        else
;;;275        {
;;;276          CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
00013e  6820              LDR      r0,[r4,#0]
000140  d02a              BEQ      |L14.408|
000142  f0200008          BIC      r0,r0,#8
                  |L14.326|
000146  6020              STR      r0,[r4,#0]
;;;277        }
;;;278    
;;;279        /* Set the transmit FIFO priority */
;;;280        if (CAN_InitStruct->CAN_TXFP == ENABLE)
000148  7ae8              LDRB     r0,[r5,#0xb]
00014a  2801              CMP      r0,#1
;;;281        {
;;;282          CANx->MCR |= CAN_MCR_TXFP;
;;;283        }
;;;284        else
;;;285        {
;;;286          CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
00014c  6820              LDR      r0,[r4,#0]
00014e  d026              BEQ      |L14.414|
000150  f0200004          BIC      r0,r0,#4
                  |L14.340|
000154  6020              STR      r0,[r4,#0]
;;;287        }
;;;288    
;;;289        /* Set the bit timing register */
;;;290        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
000156  78a8              LDRB     r0,[r5,#2]
000158  78ea              LDRB     r2,[r5,#3]
00015a  0780              LSLS     r0,r0,#30
00015c  ea406002          ORR      r0,r0,r2,LSL #24
000160  792a              LDRB     r2,[r5,#4]
000162  ea404002          ORR      r0,r0,r2,LSL #16
000166  796a              LDRB     r2,[r5,#5]
000168  ea405002          ORR      r0,r0,r2,LSL #20
00016c  882a              LDRH     r2,[r5,#0]
00016e  1e52              SUBS     r2,r2,#1
000170  4310              ORRS     r0,r0,r2
000172  61e0              STR      r0,[r4,#0x1c]
;;;291                    ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
;;;292                    ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
;;;293                    ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
;;;294                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;295    
;;;296        /* Request leave initialisation */
;;;297        CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
000174  6820              LDR      r0,[r4,#0]
000176  f0200001          BIC      r0,r0,#1
00017a  6020              STR      r0,[r4,#0]
;;;298    
;;;299       /* Wait the acknowledge */
;;;300       wait_ack = 0;
00017c  2000              MOVS     r0,#0
00017e  e012              B        |L14.422|
                  |L14.384|
000180  f0400080          ORR      r0,r0,#0x80           ;232
000184  e7c3              B        |L14.270|
                  |L14.390|
000186  f0400040          ORR      r0,r0,#0x40           ;242
00018a  e7c7              B        |L14.284|
                  |L14.396|
00018c  f0400020          ORR      r0,r0,#0x20           ;252
000190  e7cb              B        |L14.298|
                  |L14.402|
000192  f0400010          ORR      r0,r0,#0x10           ;262
000196  e7cf              B        |L14.312|
                  |L14.408|
000198  f0400008          ORR      r0,r0,#8              ;272
00019c  e7d3              B        |L14.326|
                  |L14.414|
00019e  f0400004          ORR      r0,r0,#4              ;282
0001a2  e7d7              B        |L14.340|
                  |L14.420|
0001a4  1c40              ADDS     r0,r0,#1              ;282
                  |L14.422|
;;;301    
;;;302       while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
0001a6  6862              LDR      r2,[r4,#4]
0001a8  07d2              LSLS     r2,r2,#31
0001aa  d001              BEQ      |L14.432|
0001ac  4288              CMP      r0,r1
0001ae  d1f9              BNE      |L14.420|
                  |L14.432|
;;;303       {
;;;304         wait_ack++;
;;;305       }
;;;306    
;;;307        /* ...and check acknowledged */
;;;308        if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
0001b0  6860              LDR      r0,[r4,#4]
0001b2  07c0              LSLS     r0,r0,#31
0001b4  d001              BEQ      |L14.442|
;;;309        {
;;;310          InitStatus = CAN_InitStatus_Failed;
0001b6  2000              MOVS     r0,#0
                  |L14.440|
;;;311        }
;;;312        else
;;;313        {
;;;314          InitStatus = CAN_InitStatus_Success ;
;;;315        }
;;;316      }
;;;317    
;;;318      /* At this step, return the status of initialization */
;;;319      return InitStatus;
;;;320    }
0001b8  bd70              POP      {r4-r6,pc}
                  |L14.442|
0001ba  2001              MOVS     r0,#1                 ;314
0001bc  bd70              POP      {r4-r6,pc}
;;;321    
                          ENDP

0001be  0000              DCW      0x0000
                  |L14.448|
                          DCD      0x40006400
                  |L14.452|
                          DCD      0x40006800
                  |L14.456|
                          DCD      ||.conststring||

                          AREA ||i.CAN_MessagePending||, CODE, READONLY, ALIGN=2

                  CAN_MessagePending PROC
;;;816      */
;;;817    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b570              PUSH     {r4-r6,lr}
;;;818    {
000002  4604              MOV      r4,r0
;;;819      uint8_t message_pending=0;
;;;820      /* Check the parameters */
;;;821      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  480e              LDR      r0,|L15.64|
000006  2500              MOVS     r5,#0                 ;819
000008  460e              MOV      r6,r1                 ;818
00000a  4284              CMP      r4,r0
00000c  d007              BEQ      |L15.30|
00000e  480d              LDR      r0,|L15.68|
000010  4284              CMP      r4,r0
000012  d004              BEQ      |L15.30|
000014  f2403135          MOV      r1,#0x335
000018  480b              LDR      r0,|L15.72|
00001a  f7fffffe          BL       assert_failed
                  |L15.30|
;;;822      assert_param(IS_CAN_FIFO(FIFONumber));
00001e  b13e              CBZ      r6,|L15.48|
000020  2e01              CMP      r6,#1
000022  d007              BEQ      |L15.52|
000024  f2403136          MOV      r1,#0x336
000028  4807              LDR      r0,|L15.72|
00002a  f7fffffe          BL       assert_failed
00002e  e004              B        |L15.58|
                  |L15.48|
;;;823      if (FIFONumber == CAN_FIFO0)
;;;824      {
;;;825        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
000030  68e0              LDR      r0,[r4,#0xc]
000032  e000              B        |L15.54|
                  |L15.52|
;;;826      }
;;;827      else if (FIFONumber == CAN_FIFO1)
;;;828      {
;;;829        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
000034  6920              LDR      r0,[r4,#0x10]
                  |L15.54|
000036  f0000503          AND      r5,r0,#3
                  |L15.58|
;;;830      }
;;;831      else
;;;832      {
;;;833        message_pending = 0;
;;;834      }
;;;835      return message_pending;
00003a  4628              MOV      r0,r5
;;;836    }
00003c  bd70              POP      {r4-r6,pc}
;;;837    /**
                          ENDP

00003e  0000              DCW      0x0000
                  |L15.64|
                          DCD      0x40006400
                  |L15.68|
                          DCD      0x40006800
                  |L15.72|
                          DCD      ||.conststring||

                          AREA ||i.CAN_OperatingModeRequest||, CODE, READONLY, ALIGN=2

                  CAN_OperatingModeRequest PROC
;;;866      */
;;;867    uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;868    {
000004  4605              MOV      r5,r0
;;;869      uint8_t status = CAN_ModeStatus_Failed;
;;;870      
;;;871      /* Timeout for INAK or also for SLAK bits*/
;;;872      uint32_t timeout = INAK_TIMEOUT; 
;;;873    
;;;874      /* Check the parameters */
;;;875      assert_param(IS_CAN_ALL_PERIPH(CANx));
000006  482c              LDR      r0,|L16.184|
000008  2600              MOVS     r6,#0                 ;869
00000a  460f              MOV      r7,r1                 ;868
00000c  f64f74ff          MOV      r4,#0xffff            ;872
000010  4285              CMP      r5,r0
000012  d007              BEQ      |L16.36|
000014  4829              LDR      r0,|L16.188|
000016  4285              CMP      r5,r0
000018  d004              BEQ      |L16.36|
00001a  f240316b          MOV      r1,#0x36b
00001e  4828              LDR      r0,|L16.192|
000020  f7fffffe          BL       assert_failed
                  |L16.36|
;;;876      assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
000024  b14f              CBZ      r7,|L16.58|
000026  2f01              CMP      r7,#1
000028  d01c              BEQ      |L16.100|
00002a  2f02              CMP      r7,#2
00002c  d029              BEQ      |L16.130|
00002e  f44f715b          MOV      r1,#0x36c
000032  4823              LDR      r0,|L16.192|
000034  f7fffffe          BL       assert_failed
000038  e03a              B        |L16.176|
                  |L16.58|
;;;877    
;;;878      if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
;;;879      {
;;;880        /* Request initialisation */
;;;881        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
00003a  6828              LDR      r0,[r5,#0]
00003c  f0200002          BIC      r0,r0,#2
000040  f0400001          ORR      r0,r0,#1
000044  6028              STR      r0,[r5,#0]
;;;882    
;;;883        /* Wait the acknowledge */
;;;884        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
000046  e000              B        |L16.74|
                  |L16.72|
000048  1e64              SUBS     r4,r4,#1
                  |L16.74|
00004a  6868              LDR      r0,[r5,#4]
00004c  f0000003          AND      r0,r0,#3
000050  2801              CMP      r0,#1
000052  d001              BEQ      |L16.88|
000054  2c00              CMP      r4,#0
000056  d1f7              BNE      |L16.72|
                  |L16.88|
;;;885        {
;;;886          timeout--;
;;;887        }
;;;888        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
000058  6868              LDR      r0,[r5,#4]
00005a  f0000003          AND      r0,r0,#3
00005e  2801              CMP      r0,#1
000060  d123              BNE      |L16.170|
000062  e024              B        |L16.174|
                  |L16.100|
;;;889        {
;;;890          status = CAN_ModeStatus_Failed;
;;;891        }
;;;892        else
;;;893        {
;;;894          status = CAN_ModeStatus_Success;
;;;895        }
;;;896      }
;;;897      else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
;;;898      {
;;;899        /* Request leave initialisation and sleep mode  and enter Normal mode */
;;;900        CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
000064  6828              LDR      r0,[r5,#0]
000066  f0200003          BIC      r0,r0,#3
00006a  6028              STR      r0,[r5,#0]
;;;901    
;;;902        /* Wait the acknowledge */
;;;903        while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
00006c  e000              B        |L16.112|
                  |L16.110|
00006e  1e64              SUBS     r4,r4,#1
                  |L16.112|
000070  6868              LDR      r0,[r5,#4]
000072  0780              LSLS     r0,r0,#30
000074  d001              BEQ      |L16.122|
000076  2c00              CMP      r4,#0
000078  d1f9              BNE      |L16.110|
                  |L16.122|
;;;904        {
;;;905          timeout--;
;;;906        }
;;;907        if ((CANx->MSR & CAN_MODE_MASK) != 0)
00007a  6868              LDR      r0,[r5,#4]
00007c  0780              LSLS     r0,r0,#30
00007e  d114              BNE      |L16.170|
000080  e015              B        |L16.174|
                  |L16.130|
;;;908        {
;;;909          status = CAN_ModeStatus_Failed;
;;;910        }
;;;911        else
;;;912        {
;;;913          status = CAN_ModeStatus_Success;
;;;914        }
;;;915      }
;;;916      else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
;;;917      {
;;;918        /* Request Sleep mode */
;;;919        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
000082  6828              LDR      r0,[r5,#0]
000084  f0200001          BIC      r0,r0,#1
000088  f0400002          ORR      r0,r0,#2
00008c  6028              STR      r0,[r5,#0]
;;;920    
;;;921        /* Wait the acknowledge */
;;;922        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
00008e  e000              B        |L16.146|
                  |L16.144|
000090  1e64              SUBS     r4,r4,#1
                  |L16.146|
000092  6868              LDR      r0,[r5,#4]
000094  f0000003          AND      r0,r0,#3
000098  2802              CMP      r0,#2
00009a  d001              BEQ      |L16.160|
00009c  2c00              CMP      r4,#0
00009e  d1f7              BNE      |L16.144|
                  |L16.160|
;;;923        {
;;;924          timeout--;
;;;925        }
;;;926        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
0000a0  6868              LDR      r0,[r5,#4]
0000a2  f0000003          AND      r0,r0,#3
0000a6  2802              CMP      r0,#2
0000a8  d001              BEQ      |L16.174|
                  |L16.170|
;;;927        {
;;;928          status = CAN_ModeStatus_Failed;
0000aa  2600              MOVS     r6,#0
0000ac  e000              B        |L16.176|
                  |L16.174|
;;;929        }
;;;930        else
;;;931        {
;;;932          status = CAN_ModeStatus_Success;
0000ae  2601              MOVS     r6,#1
                  |L16.176|
;;;933        }
;;;934      }
;;;935      else
;;;936      {
;;;937        status = CAN_ModeStatus_Failed;
;;;938      }
;;;939    
;;;940      return  (uint8_t) status;
0000b0  4630              MOV      r0,r6
;;;941    }
0000b2  e8bd81f0          POP      {r4-r8,pc}
;;;942    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L16.184|
                          DCD      0x40006400
                  |L16.188|
                          DCD      0x40006800
                  |L16.192|
                          DCD      ||.conststring||

                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=2

                  CAN_Receive PROC
;;;744      */
;;;745    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000000  b570              PUSH     {r4-r6,lr}
;;;746    {
000002  4605              MOV      r5,r0
;;;747      /* Check the parameters */
;;;748      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  482d              LDR      r0,|L17.188|
000006  4614              MOV      r4,r2                 ;746
000008  460e              MOV      r6,r1                 ;746
00000a  4285              CMP      r5,r0
00000c  d007              BEQ      |L17.30|
00000e  482c              LDR      r0,|L17.192|
000010  4285              CMP      r5,r0
000012  d004              BEQ      |L17.30|
000014  f44f713b          MOV      r1,#0x2ec
000018  482a              LDR      r0,|L17.196|
00001a  f7fffffe          BL       assert_failed
                  |L17.30|
;;;749      assert_param(IS_CAN_FIFO(FIFONumber));
00001e  b136              CBZ      r6,|L17.46|
000020  2e01              CMP      r6,#1
000022  d004              BEQ      |L17.46|
000024  f24021ed          MOV      r1,#0x2ed
000028  4826              LDR      r0,|L17.196|
00002a  f7fffffe          BL       assert_failed
                  |L17.46|
;;;750      /* Get the Id */
;;;751      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
00002e  eb051206          ADD      r2,r5,r6,LSL #4
000032  f8d201b0          LDR      r0,[r2,#0x1b0]
000036  f0100004          ANDS     r0,r0,#4
00003a  7220              STRB     r0,[r4,#8]
;;;752      if (RxMessage->IDE == CAN_Id_Standard)
;;;753      {
;;;754        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
;;;755      }
;;;756      else
;;;757      {
;;;758        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
00003c  f8d201b0          LDR      r0,[r2,#0x1b0]
000040  d033              BEQ      |L17.170|
000042  08c0              LSRS     r0,r0,#3
000044  6060              STR      r0,[r4,#4]
                  |L17.70|
;;;759      }
;;;760      
;;;761      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
000046  f8d201b0          LDR      r0,[r2,#0x1b0]
00004a  f0000002          AND      r0,r0,#2
00004e  7260              STRB     r0,[r4,#9]
;;;762      /* Get the DLC */
;;;763      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
000050  f8d201b4          LDR      r0,[r2,#0x1b4]
000054  f000000f          AND      r0,r0,#0xf
000058  72a0              STRB     r0,[r4,#0xa]
;;;764      /* Get the FMI */
;;;765      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
00005a  f8d201b4          LDR      r0,[r2,#0x1b4]
00005e  0a00              LSRS     r0,r0,#8
000060  74e0              STRB     r0,[r4,#0x13]
;;;766      /* Get the data field */
;;;767      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
000062  f8d201b8          LDR      r0,[r2,#0x1b8]
000066  72e0              STRB     r0,[r4,#0xb]
;;;768      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
000068  f8d201b8          LDR      r0,[r2,#0x1b8]
00006c  0a00              LSRS     r0,r0,#8
00006e  7320              STRB     r0,[r4,#0xc]
;;;769      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
000070  f8d201b8          LDR      r0,[r2,#0x1b8]
000074  0c00              LSRS     r0,r0,#16
000076  7360              STRB     r0,[r4,#0xd]
;;;770      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
000078  f8d201b8          LDR      r0,[r2,#0x1b8]
00007c  0e00              LSRS     r0,r0,#24
00007e  73a0              STRB     r0,[r4,#0xe]
;;;771      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
000080  f8d201bc          LDR      r0,[r2,#0x1bc]
000084  73e0              STRB     r0,[r4,#0xf]
;;;772      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
000086  f8d201bc          LDR      r0,[r2,#0x1bc]
00008a  0a00              LSRS     r0,r0,#8
00008c  7420              STRB     r0,[r4,#0x10]
;;;773      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
00008e  f8d201bc          LDR      r0,[r2,#0x1bc]
000092  0c00              LSRS     r0,r0,#16
000094  7460              STRB     r0,[r4,#0x11]
;;;774      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
000096  f8d201bc          LDR      r0,[r2,#0x1bc]
00009a  0e00              LSRS     r0,r0,#24
00009c  74a0              STRB     r0,[r4,#0x12]
;;;775      /* Release the FIFO */
;;;776      /* Release FIFO0 */
;;;777      if (FIFONumber == CAN_FIFO0)
00009e  b13e              CBZ      r6,|L17.176|
;;;778      {
;;;779        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;780      }
;;;781      /* Release FIFO1 */
;;;782      else /* FIFONumber == CAN_FIFO1 */
;;;783      {
;;;784        CANx->RF1R |= CAN_RF1R_RFOM1;
0000a0  6928              LDR      r0,[r5,#0x10]
0000a2  f0400020          ORR      r0,r0,#0x20
0000a6  6128              STR      r0,[r5,#0x10]
;;;785      }
;;;786    }
0000a8  bd70              POP      {r4-r6,pc}
                  |L17.170|
0000aa  0d40              LSRS     r0,r0,#21             ;754
0000ac  6020              STR      r0,[r4,#0]            ;754
0000ae  e7ca              B        |L17.70|
                  |L17.176|
0000b0  68e8              LDR      r0,[r5,#0xc]          ;779
0000b2  f0400020          ORR      r0,r0,#0x20           ;779
0000b6  60e8              STR      r0,[r5,#0xc]          ;779
0000b8  bd70              POP      {r4-r6,pc}
;;;787    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L17.188|
                          DCD      0x40006400
                  |L17.192|
                          DCD      0x40006800
                  |L17.196|
                          DCD      ||.conststring||

                          AREA ||i.CAN_SlaveStartBank||, CODE, READONLY, ALIGN=2

                  CAN_SlaveStartBank PROC
;;;462      */
;;;463    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
000000  b510              PUSH     {r4,lr}
;;;464    {
000002  4604              MOV      r4,r0
;;;465      /* Check the parameters */
;;;466      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
000004  1e40              SUBS     r0,r0,#1
000006  281a              CMP      r0,#0x1a
000008  d904              BLS      |L18.20|
00000a  f44f71e9          MOV      r1,#0x1d2
00000e  480b              LDR      r0,|L18.60|
000010  f7fffffe          BL       assert_failed
                  |L18.20|
;;;467      
;;;468      /* Enter Initialisation mode for the filter */
;;;469      CAN1->FMR |= FMR_FINIT;
000014  490a              LDR      r1,|L18.64|
000016  6808              LDR      r0,[r1,#0]
000018  f0400001          ORR      r0,r0,#1
00001c  6008              STR      r0,[r1,#0]
;;;470      
;;;471      /* Select the start slave bank */
;;;472      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
00001e  6808              LDR      r0,[r1,#0]
000020  f643720e          MOV      r2,#0x3f0e
000024  4390              BICS     r0,r0,r2
000026  6008              STR      r0,[r1,#0]
;;;473      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
000028  6808              LDR      r0,[r1,#0]
00002a  ea402004          ORR      r0,r0,r4,LSL #8
00002e  6008              STR      r0,[r1,#0]
;;;474      
;;;475      /* Leave Initialisation mode for the filter */
;;;476      CAN1->FMR &= ~FMR_FINIT;
000030  6808              LDR      r0,[r1,#0]
000032  f0200001          BIC      r0,r0,#1
000036  6008              STR      r0,[r1,#0]
;;;477    }
000038  bd10              POP      {r4,pc}
;;;478    
                          ENDP

00003a  0000              DCW      0x0000
                  |L18.60|
                          DCD      ||.conststring||
                  |L18.64|
                          DCD      0x40006600

                          AREA ||i.CAN_Sleep||, CODE, READONLY, ALIGN=2

                  CAN_Sleep PROC
;;;947      */
;;;948    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000000  b570              PUSH     {r4-r6,lr}
;;;949    {
000002  4604              MOV      r4,r0
;;;950      uint8_t sleepstatus = CAN_Sleep_Failed;
;;;951      
;;;952      /* Check the parameters */
;;;953      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  480c              LDR      r0,|L19.56|
000006  2500              MOVS     r5,#0                 ;950
000008  4284              CMP      r4,r0
00000a  d007              BEQ      |L19.28|
00000c  480b              LDR      r0,|L19.60|
00000e  4284              CMP      r4,r0
000010  d004              BEQ      |L19.28|
000012  f24031b9          MOV      r1,#0x3b9
000016  480a              LDR      r0,|L19.64|
000018  f7fffffe          BL       assert_failed
                  |L19.28|
;;;954        
;;;955      /* Request Sleep mode */
;;;956       CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
00001c  6820              LDR      r0,[r4,#0]
00001e  f0200001          BIC      r0,r0,#1
000022  f0400002          ORR      r0,r0,#2
000026  6020              STR      r0,[r4,#0]
;;;957       
;;;958      /* Sleep mode status */
;;;959      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
000028  6860              LDR      r0,[r4,#4]
00002a  f0000003          AND      r0,r0,#3
00002e  2802              CMP      r0,#2
000030  d100              BNE      |L19.52|
;;;960      {
;;;961        /* Sleep mode not entered */
;;;962        sleepstatus =  CAN_Sleep_Ok;
000032  2501              MOVS     r5,#1
                  |L19.52|
;;;963      }
;;;964      /* return sleep mode status */
;;;965       return (uint8_t)sleepstatus;
000034  4628              MOV      r0,r5
;;;966    }
000036  bd70              POP      {r4-r6,pc}
;;;967    
                          ENDP

                  |L19.56|
                          DCD      0x40006400
                  |L19.60|
                          DCD      0x40006800
                  |L19.64|
                          DCD      ||.conststring||

                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;419      */
;;;420    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;421    {
;;;422      /* Reset CAN init structure parameters values */
;;;423      
;;;424      /* Initialize the time triggered communication mode */
;;;425      CAN_InitStruct->CAN_TTCM = DISABLE;
000002  7181              STRB     r1,[r0,#6]
;;;426      
;;;427      /* Initialize the automatic bus-off management */
;;;428      CAN_InitStruct->CAN_ABOM = DISABLE;
000004  71c1              STRB     r1,[r0,#7]
;;;429      
;;;430      /* Initialize the automatic wake-up mode */
;;;431      CAN_InitStruct->CAN_AWUM = DISABLE;
000006  7201              STRB     r1,[r0,#8]
;;;432      
;;;433      /* Initialize the no automatic retransmission */
;;;434      CAN_InitStruct->CAN_NART = DISABLE;
000008  7241              STRB     r1,[r0,#9]
;;;435      
;;;436      /* Initialize the receive FIFO locked mode */
;;;437      CAN_InitStruct->CAN_RFLM = DISABLE;
00000a  7281              STRB     r1,[r0,#0xa]
;;;438      
;;;439      /* Initialize the transmit FIFO priority */
;;;440      CAN_InitStruct->CAN_TXFP = DISABLE;
00000c  72c1              STRB     r1,[r0,#0xb]
;;;441      
;;;442      /* Initialize the CAN_Mode member */
;;;443      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
00000e  7081              STRB     r1,[r0,#2]
;;;444      
;;;445      /* Initialize the CAN_SJW member */
;;;446      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000010  70c1              STRB     r1,[r0,#3]
;;;447      
;;;448      /* Initialize the CAN_BS1 member */
;;;449      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
000012  2103              MOVS     r1,#3
000014  7101              STRB     r1,[r0,#4]
;;;450      
;;;451      /* Initialize the CAN_BS2 member */
;;;452      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
000016  2102              MOVS     r1,#2
000018  7141              STRB     r1,[r0,#5]
;;;453      
;;;454      /* Initialize the CAN_Prescaler member */
;;;455      CAN_InitStruct->CAN_Prescaler = 1;
00001a  2101              MOVS     r1,#1
00001c  8001              STRH     r1,[r0,#0]
;;;456    }
00001e  4770              BX       lr
;;;457    
                          ENDP


                          AREA ||i.CAN_TTComModeCmd||, CODE, READONLY, ALIGN=2

                  CAN_TTComModeCmd PROC
;;;517      */
;;;518    void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;519    {
000002  4604              MOV      r4,r0
;;;520      /* Check the parameters */
;;;521      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  481f              LDR      r0,|L21.132|
000006  460d              MOV      r5,r1                 ;519
000008  4284              CMP      r4,r0
00000a  d007              BEQ      |L21.28|
00000c  481e              LDR      r0,|L21.136|
00000e  4284              CMP      r4,r0
000010  d004              BEQ      |L21.28|
000012  f2402109          MOV      r1,#0x209
000016  481d              LDR      r0,|L21.140|
000018  f7fffffe          BL       assert_failed
                  |L21.28|
;;;522      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001c  b1dd              CBZ      r5,|L21.86|
00001e  2d01              CMP      r5,#1
000020  d004              BEQ      |L21.44|
000022  f240210a          MOV      r1,#0x20a
000026  4819              LDR      r0,|L21.140|
000028  f7fffffe          BL       assert_failed
                  |L21.44|
;;;523      if (NewState != DISABLE)
;;;524      {
;;;525        /* Enable the TTCM mode */
;;;526        CANx->MCR |= CAN_MCR_TTCM;
00002c  6820              LDR      r0,[r4,#0]
00002e  f0400080          ORR      r0,r0,#0x80
000032  6020              STR      r0,[r4,#0]
;;;527    
;;;528        /* Set TGT bits */
;;;529        CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
000034  f8d40184          LDR      r0,[r4,#0x184]
000038  f4407080          ORR      r0,r0,#0x100
00003c  f8c40184          STR      r0,[r4,#0x184]
;;;530        CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
000040  f8d40194          LDR      r0,[r4,#0x194]
000044  f4407080          ORR      r0,r0,#0x100
000048  f8c40194          STR      r0,[r4,#0x194]
;;;531        CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
00004c  f8d401a4          LDR      r0,[r4,#0x1a4]
000050  f4407080          ORR      r0,r0,#0x100
000054  e013              B        |L21.126|
                  |L21.86|
;;;532      }
;;;533      else
;;;534      {
;;;535        /* Disable the TTCM mode */
;;;536        CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
000056  6820              LDR      r0,[r4,#0]
000058  f0200080          BIC      r0,r0,#0x80
00005c  6020              STR      r0,[r4,#0]
;;;537    
;;;538        /* Reset TGT bits */
;;;539        CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
00005e  f8d40184          LDR      r0,[r4,#0x184]
000062  f4207080          BIC      r0,r0,#0x100
000066  f8c40184          STR      r0,[r4,#0x184]
;;;540        CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
00006a  f8d40194          LDR      r0,[r4,#0x194]
00006e  f4207080          BIC      r0,r0,#0x100
000072  f8c40194          STR      r0,[r4,#0x194]
;;;541        CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
000076  f8d401a4          LDR      r0,[r4,#0x1a4]
00007a  f4207080          BIC      r0,r0,#0x100
                  |L21.126|
00007e  f8c401a4          STR      r0,[r4,#0x1a4]        ;531
;;;542      }
;;;543    }
000082  bd70              POP      {r4-r6,pc}
;;;544    /**
                          ENDP

                  |L21.132|
                          DCD      0x40006400
                  |L21.136|
                          DCD      0x40006800
                  |L21.140|
                          DCD      ||.conststring||

                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=2

                  CAN_Transmit PROC
;;;571      */
;;;572    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000000  b570              PUSH     {r4-r6,lr}
;;;573    {
000002  4605              MOV      r5,r0
;;;574      uint8_t transmit_mailbox = 0;
;;;575      /* Check the parameters */
;;;576      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  4844              LDR      r0,|L22.280|
000006  2600              MOVS     r6,#0                 ;574
000008  460c              MOV      r4,r1                 ;573
00000a  4285              CMP      r5,r0
00000c  d007              BEQ      |L22.30|
00000e  4843              LDR      r0,|L22.284|
000010  4285              CMP      r5,r0
000012  d004              BEQ      |L22.30|
000014  f44f7110          MOV      r1,#0x240
000018  4841              LDR      r0,|L22.288|
00001a  f7fffffe          BL       assert_failed
                  |L22.30|
;;;577      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
00001e  7a20              LDRB     r0,[r4,#8]
000020  b130              CBZ      r0,|L22.48|
000022  2804              CMP      r0,#4
000024  d004              BEQ      |L22.48|
000026  f2402141          MOV      r1,#0x241
00002a  483d              LDR      r0,|L22.288|
00002c  f7fffffe          BL       assert_failed
                  |L22.48|
;;;578      assert_param(IS_CAN_RTR(TxMessage->RTR));
000030  7a60              LDRB     r0,[r4,#9]
000032  b130              CBZ      r0,|L22.66|
000034  2802              CMP      r0,#2
000036  d004              BEQ      |L22.66|
000038  f2402142          MOV      r1,#0x242
00003c  4838              LDR      r0,|L22.288|
00003e  f7fffffe          BL       assert_failed
                  |L22.66|
;;;579      assert_param(IS_CAN_DLC(TxMessage->DLC));
000042  7aa0              LDRB     r0,[r4,#0xa]
000044  2808              CMP      r0,#8
000046  d904              BLS      |L22.82|
000048  f2402143          MOV      r1,#0x243
00004c  4834              LDR      r0,|L22.288|
00004e  f7fffffe          BL       assert_failed
                  |L22.82|
;;;580    
;;;581      /* Select one empty transmit mailbox */
;;;582      if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
000052  68a8              LDR      r0,[r5,#8]
000054  0140              LSLS     r0,r0,#5
000056  d408              BMI      |L22.106|
;;;583      {
;;;584        transmit_mailbox = 0;
;;;585      }
;;;586      else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
000058  68a8              LDR      r0,[r5,#8]
00005a  0100              LSLS     r0,r0,#4
00005c  d501              BPL      |L22.98|
;;;587      {
;;;588        transmit_mailbox = 1;
00005e  2601              MOVS     r6,#1
000060  e003              B        |L22.106|
                  |L22.98|
;;;589      }
;;;590      else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
000062  68a8              LDR      r0,[r5,#8]
000064  00c0              LSLS     r0,r0,#3
000066  d543              BPL      |L22.240|
;;;591      {
;;;592        transmit_mailbox = 2;
000068  2602              MOVS     r6,#2
                  |L22.106|
;;;593      }
;;;594      else
;;;595      {
;;;596        transmit_mailbox = CAN_TxStatus_NoMailBox;
;;;597      }
;;;598    
;;;599      if (transmit_mailbox != CAN_TxStatus_NoMailBox)
;;;600      {
;;;601        /* Set up the Id */
;;;602        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
00006a  eb051506          ADD      r5,r5,r6,LSL #4
00006e  f8d50180          LDR      r0,[r5,#0x180]
000072  f0000001          AND      r0,r0,#1
000076  f8c50180          STR      r0,[r5,#0x180]
;;;603        if (TxMessage->IDE == CAN_Id_Standard)
00007a  7a20              LDRB     r0,[r4,#8]
00007c  b3b8              CBZ      r0,|L22.238|
;;;604        {
;;;605          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;606          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
;;;607                                                      TxMessage->RTR);
;;;608        }
;;;609        else
;;;610        {
;;;611          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
00007e  6860              LDR      r0,[r4,#4]
000080  f1b05f00          CMP      r0,#0x20000000
000084  d304              BCC      |L22.144|
000086  f2402163          MOV      r1,#0x263
00008a  4825              LDR      r0,|L22.288|
00008c  f7fffffe          BL       assert_failed
                  |L22.144|
;;;612          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
000090  f8d50180          LDR      r0,[r5,#0x180]
000094  7a21              LDRB     r1,[r4,#8]
000096  6862              LDR      r2,[r4,#4]
000098  4308              ORRS     r0,r0,r1
00009a  7a61              LDRB     r1,[r4,#9]
00009c  ea4101c2          ORR      r1,r1,r2,LSL #3
0000a0  4308              ORRS     r0,r0,r1
                  |L22.162|
0000a2  f8c50180          STR      r0,[r5,#0x180]
;;;613                                                      TxMessage->IDE | \
;;;614                                                      TxMessage->RTR);
;;;615        }
;;;616        
;;;617        /* Set up the DLC */
;;;618        TxMessage->DLC &= (uint8_t)0x0000000F;
0000a6  7aa0              LDRB     r0,[r4,#0xa]
0000a8  f000000f          AND      r0,r0,#0xf
0000ac  72a0              STRB     r0,[r4,#0xa]
;;;619        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
0000ae  f8d50184          LDR      r0,[r5,#0x184]
0000b2  f020000f          BIC      r0,r0,#0xf
0000b6  f8c50184          STR      r0,[r5,#0x184]
;;;620        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
0000ba  f8d50184          LDR      r0,[r5,#0x184]
0000be  7aa1              LDRB     r1,[r4,#0xa]
0000c0  4308              ORRS     r0,r0,r1
0000c2  f8c50184          STR      r0,[r5,#0x184]
;;;621    
;;;622        /* Set up the data field */
;;;623        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
0000c6  7ae0              LDRB     r0,[r4,#0xb]
0000c8  68e1              LDR      r1,[r4,#0xc]
0000ca  ea402001          ORR      r0,r0,r1,LSL #8
0000ce  f8c50188          STR      r0,[r5,#0x188]
;;;624                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;625                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;626                                                 ((uint32_t)TxMessage->Data[0]));
;;;627        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
0000d2  7be0              LDRB     r0,[r4,#0xf]
0000d4  6921              LDR      r1,[r4,#0x10]
0000d6  ea402001          ORR      r0,r0,r1,LSL #8
0000da  f8c5018c          STR      r0,[r5,#0x18c]
;;;628                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;629                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;630                                                 ((uint32_t)TxMessage->Data[4]));
;;;631        /* Request transmission */
;;;632        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
0000de  f8d50180          LDR      r0,[r5,#0x180]
0000e2  f0400001          ORR      r0,r0,#1
0000e6  f8c50180          STR      r0,[r5,#0x180]
                  |L22.234|
;;;633      }
;;;634      return transmit_mailbox;
0000ea  4630              MOV      r0,r6
;;;635    }
0000ec  bd70              POP      {r4-r6,pc}
                  |L22.238|
0000ee  e001              B        |L22.244|
                  |L22.240|
0000f0  2604              MOVS     r6,#4                 ;596
0000f2  e7fa              B        |L22.234|
                  |L22.244|
0000f4  6820              LDR      r0,[r4,#0]            ;605
0000f6  f5b06f00          CMP      r0,#0x800             ;605
0000fa  d304              BCC      |L22.262|
0000fc  f240215d          MOV      r1,#0x25d             ;605
000100  4807              LDR      r0,|L22.288|
000102  f7fffffe          BL       assert_failed
                  |L22.262|
000106  f8d50180          LDR      r0,[r5,#0x180]        ;606
00010a  7a61              LDRB     r1,[r4,#9]            ;606
00010c  4308              ORRS     r0,r0,r1              ;606
00010e  8821              LDRH     r1,[r4,#0]            ;606
000110  ea405041          ORR      r0,r0,r1,LSL #21      ;606
000114  e7c5              B        |L22.162|
;;;636    
                          ENDP

000116  0000              DCW      0x0000
                  |L22.280|
                          DCD      0x40006400
                  |L22.284|
                          DCD      0x40006800
                  |L22.288|
                          DCD      ||.conststring||

                          AREA ||i.CAN_TransmitStatus||, CODE, READONLY, ALIGN=2

                  CAN_TransmitStatus PROC
;;;643      */
;;;644    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000000  b570              PUSH     {r4-r6,lr}
;;;645    {
000002  4605              MOV      r5,r0
;;;646      uint32_t state = 0;
;;;647    
;;;648      /* Check the parameters */
;;;649      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  481f              LDR      r0,|L23.132|
000006  2400              MOVS     r4,#0                 ;646
000008  460e              MOV      r6,r1                 ;645
00000a  4285              CMP      r5,r0
00000c  d007              BEQ      |L23.30|
00000e  481e              LDR      r0,|L23.136|
000010  4285              CMP      r5,r0
000012  d004              BEQ      |L23.30|
000014  f2402189          MOV      r1,#0x289
000018  481c              LDR      r0,|L23.140|
00001a  f7fffffe          BL       assert_failed
                  |L23.30|
;;;650      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
00001e  2e02              CMP      r6,#2
000020  d904              BLS      |L23.44|
000022  f240218a          MOV      r1,#0x28a
000026  4819              LDR      r0,|L23.140|
000028  f7fffffe          BL       assert_failed
                  |L23.44|
;;;651     
;;;652      switch (TransmitMailbox)
00002c  b126              CBZ      r6,|L23.56|
00002e  2e01              CMP      r6,#1
000030  d005              BEQ      |L23.62|
000032  2e02              CMP      r6,#2
000034  d106              BNE      |L23.68|
000036  e012              B        |L23.94|
                  |L23.56|
;;;653      {
;;;654        case (CAN_TXMAILBOX_0): 
;;;655          state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
000038  68ac              LDR      r4,[r5,#8]
00003a  4815              LDR      r0,|L23.144|
;;;656          break;
00003c  e001              B        |L23.66|
                  |L23.62|
;;;657        case (CAN_TXMAILBOX_1): 
;;;658          state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
00003e  68ac              LDR      r4,[r5,#8]
000040  4814              LDR      r0,|L23.148|
                  |L23.66|
000042  4004              ANDS     r4,r4,r0              ;655
                  |L23.68|
;;;659          break;
;;;660        case (CAN_TXMAILBOX_2): 
;;;661          state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
;;;662          break;
;;;663        default:
;;;664          state = CAN_TxStatus_Failed;
;;;665          break;
;;;666      }
;;;667      switch (state)
000044  4914              LDR      r1,|L23.152|
000046  1a60              SUBS     r0,r4,r1
000048  428c              CMP      r4,r1
00004a  d014              BEQ      |L23.118|
00004c  dc0a              BGT      |L23.100|
00004e  b1a4              CBZ      r4,|L23.122|
000050  f06f6080          MVN      r0,#0x4000000
000054  1820              ADDS     r0,r4,r0
000056  d00f              BEQ      |L23.120|
000058  2802              CMP      r0,#2
00005a  d10c              BNE      |L23.118|
00005c  e00f              B        |L23.126|
                  |L23.94|
00005e  68ac              LDR      r4,[r5,#8]            ;661
000060  480e              LDR      r0,|L23.156|
000062  e7ee              B        |L23.66|
                  |L23.100|
000064  f5b07f00          CMP      r0,#0x200
000068  d009              BEQ      |L23.126|
00006a  490d              LDR      r1,|L23.160|
00006c  1840              ADDS     r0,r0,r1
00006e  d003              BEQ      |L23.120|
000070  f5b03f00          CMP      r0,#0x20000
000074  d003              BEQ      |L23.126|
                  |L23.118|
;;;668      {
;;;669          /* transmit pending  */
;;;670        case (0x0): state = CAN_TxStatus_Pending;
;;;671          break;
;;;672          /* transmit failed  */
;;;673         case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
;;;674          break;
;;;675         case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
;;;676          break;
;;;677         case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
;;;678          break;
;;;679          /* transmit succeeded  */
;;;680        case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
;;;681          break;
;;;682        case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
;;;683          break;
;;;684        case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
;;;685          break;
;;;686        default: state = CAN_TxStatus_Failed;
000076  2000              MOVS     r0,#0
                  |L23.120|
;;;687          break;
;;;688      }
;;;689      return (uint8_t) state;
;;;690    }
000078  bd70              POP      {r4-r6,pc}
                  |L23.122|
00007a  2002              MOVS     r0,#2                 ;670
00007c  bd70              POP      {r4-r6,pc}
                  |L23.126|
00007e  2001              MOVS     r0,#1                 ;684
000080  bd70              POP      {r4-r6,pc}
;;;691    
                          ENDP

000082  0000              DCW      0x0000
                  |L23.132|
                          DCD      0x40006400
                  |L23.136|
                          DCD      0x40006800
                  |L23.140|
                          DCD      ||.conststring||
                  |L23.144|
                          DCD      0x04000003
                  |L23.148|
                          DCD      0x08000300
                  |L23.152|
                          DCD      0x08000100
                  |L23.156|
                          DCD      0x10030000
                  |L23.160|
                          DCD      0xf7ff0100

                          AREA ||i.CAN_WakeUp||, CODE, READONLY, ALIGN=2

                  CAN_WakeUp PROC
;;;972      */
;;;973    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
000000  b570              PUSH     {r4-r6,lr}
;;;974    {
000002  4604              MOV      r4,r0
;;;975      uint32_t wait_slak = SLAK_TIMEOUT;
;;;976      uint8_t wakeupstatus = CAN_WakeUp_Failed;
;;;977      
;;;978      /* Check the parameters */
;;;979      assert_param(IS_CAN_ALL_PERIPH(CANx));
000004  480f              LDR      r0,|L24.68|
000006  2600              MOVS     r6,#0                 ;976
000008  f64f75ff          MOV      r5,#0xffff            ;975
00000c  4284              CMP      r4,r0
00000e  d007              BEQ      |L24.32|
000010  480d              LDR      r0,|L24.72|
000012  4284              CMP      r4,r0
000014  d004              BEQ      |L24.32|
000016  f24031d3          MOV      r1,#0x3d3
00001a  480c              LDR      r0,|L24.76|
00001c  f7fffffe          BL       assert_failed
                  |L24.32|
;;;980        
;;;981      /* Wake up request */
;;;982      CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
000020  6820              LDR      r0,[r4,#0]
000022  f0200002          BIC      r0,r0,#2
000026  6020              STR      r0,[r4,#0]
;;;983        
;;;984      /* Sleep mode status */
;;;985      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
000028  e000              B        |L24.44|
                  |L24.42|
00002a  1e6d              SUBS     r5,r5,#1
                  |L24.44|
00002c  6860              LDR      r0,[r4,#4]
00002e  0780              LSLS     r0,r0,#30
000030  d501              BPL      |L24.54|
000032  2d00              CMP      r5,#0
000034  d1f9              BNE      |L24.42|
                  |L24.54|
;;;986      {
;;;987       wait_slak--;
;;;988      }
;;;989      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
000036  6860              LDR      r0,[r4,#4]
000038  0780              LSLS     r0,r0,#30
00003a  d400              BMI      |L24.62|
;;;990      {
;;;991       /* wake up done : Sleep mode exited */
;;;992        wakeupstatus = CAN_WakeUp_Ok;
00003c  2601              MOVS     r6,#1
                  |L24.62|
;;;993      }
;;;994      /* return wakeup status */
;;;995      return (uint8_t)wakeupstatus;
00003e  4630              MOV      r0,r6
;;;996    }
000040  bd70              POP      {r4-r6,pc}
;;;997    /**
                          ENDP

000042  0000              DCW      0x0000
                  |L24.68|
                          DCD      0x40006400
                  |L24.72|
                          DCD      0x40006800
                  |L24.76|
                          DCD      ||.conststring||

                          AREA ||i.CheckITStatus||, CODE, READONLY, ALIGN=1

                  CheckITStatus PROC
;;;1668     */
;;;1669   static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
000000  4602              MOV      r2,r0
;;;1670   {
;;;1671     ITStatus pendingbitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1672     
;;;1673     if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
000004  420a              TST      r2,r1
000006  d000              BEQ      |L25.10|
;;;1674     {
;;;1675       /* CAN_IT is set */
;;;1676       pendingbitstatus = SET;
000008  2001              MOVS     r0,#1
                  |L25.10|
;;;1677     }
;;;1678     else
;;;1679     {
;;;1680       /* CAN_IT is reset */
;;;1681       pendingbitstatus = RESET;
;;;1682     }
;;;1683     return pendingbitstatus;
;;;1684   }
00000a  4770              BX       lr
;;;1685   
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_can.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f63616e
00004a  2e6300  

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_can.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_can_c_347dae01____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_can_c_347dae01____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_can_c_347dae01____REVSH|
#line 128
|__asm___15_stm32f4xx_can_c_347dae01____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
