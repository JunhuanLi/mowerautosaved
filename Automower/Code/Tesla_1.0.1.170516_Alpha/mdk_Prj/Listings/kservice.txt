; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\kservice.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\kservice.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\kservice.crf ..\OS\src\kservice.c]
                          THUMB

                          AREA ||i.__rt_ffs||, CODE, READONLY, ALIGN=2

                  __rt_ffs PROC
;;;1234    */
;;;1235   int __rt_ffs(int value)
000000  2800              CMP      r0,#0
;;;1236   {
000002  d007              BEQ      |L1.20|
;;;1237       if (value == 0) return 0;
;;;1238   
;;;1239       if (value & 0xff)
;;;1240           return __lowest_bit_bitmap[value & 0xff] + 1;
000004  490e              LDR      r1,|L1.64|
000006  f0100fff          TST      r0,#0xff              ;1239
00000a  d004              BEQ      |L1.22|
00000c  fa51f080          UXTAB    r0,r1,r0
000010  7800              LDRB     r0,[r0,#0]
000012  1c40              ADDS     r0,r0,#1
                  |L1.20|
;;;1241   
;;;1242       if (value & 0xff00)
;;;1243           return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
;;;1244   
;;;1245       if (value & 0xff0000)
;;;1246           return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
;;;1247   
;;;1248       return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
;;;1249   }
000014  4770              BX       lr
                  |L1.22|
000016  f4104f7f          TST      r0,#0xff00            ;1242
00001a  d004              BEQ      |L1.38|
00001c  f3c02007          UBFX     r0,r0,#8,#8           ;1243
000020  5c08              LDRB     r0,[r1,r0]            ;1243
000022  3009              ADDS     r0,r0,#9              ;1243
000024  4770              BX       lr
                  |L1.38|
000026  f4100f7f          TST      r0,#0xff0000          ;1245
00002a  d004              BEQ      |L1.54|
00002c  f3c04007          UBFX     r0,r0,#16,#8          ;1246
000030  5c08              LDRB     r0,[r1,r0]            ;1246
000032  3011              ADDS     r0,r0,#0x11           ;1246
000034  4770              BX       lr
                  |L1.54|
000036  eb016010          ADD      r0,r1,r0,LSR #24      ;1248
00003a  7800              LDRB     r0,[r0,#0]            ;1248
00003c  3019              ADDS     r0,r0,#0x19           ;1248
00003e  4770              BX       lr
;;;1250   #endif
                          ENDP

                  |L1.64|
                          DCD      ||.constdata||

                          AREA ||i._rt_errno||, CODE, READONLY, ALIGN=2

                  _rt_errno PROC
;;;110     */
;;;111    int *_rt_errno(void)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113        rt_thread_t tid;
;;;114    
;;;115        if (rt_interrupt_get_nest() != 0)
000002  f7fffffe          BL       rt_interrupt_get_nest
000006  b920              CBNZ     r0,|L2.18|
;;;116            return (int *)&_errno;
;;;117    
;;;118        tid = rt_thread_self();
000008  f7fffffe          BL       rt_thread_self
;;;119        if (tid != RT_NULL)
00000c  b108              CBZ      r0,|L2.18|
00000e  3030              ADDS     r0,r0,#0x30
;;;120            return (int *)&(tid->error);
;;;121    
;;;122        return (int *)&_errno;
;;;123    }
000010  bd10              POP      {r4,pc}
                  |L2.18|
000012  4801              LDR      r0,|L2.24|
000014  bd10              POP      {r4,pc}
;;;124    RTM_EXPORT(_rt_errno);
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      ||.data||+0x4

                          AREA ||i.print_number||, CODE, READONLY, ALIGN=2

                  print_number PROC
;;;559    #ifdef RT_PRINTF_PRECISION
;;;560    static char *print_number(char *buf,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;561                              char *end,
;;;562                              long  num,
;;;563                              int   base,
;;;564                              int   s,
;;;565                              int   precision,
;;;566                              int   type)
;;;567    #else
;;;568    static char *print_number(char *buf,
;;;569                              char *end,
;;;570                              long  num,
;;;571                              int   base,
;;;572                              int   s,
;;;573                              int   type)
;;;574    #endif
;;;575    {
000004  469a              MOV      r10,r3
000006  e9ddb50d          LDRD     r11,r5,[sp,#0x34]
;;;576        char c, sign;
;;;577    #ifdef RT_PRINTF_LONGLONG
;;;578        char tmp[32];
;;;579    #else
;;;580        char tmp[16];
;;;581    #endif
;;;582        const char *digits;
;;;583        static const char small_digits[] = "0123456789abcdef";
;;;584        static const char large_digits[] = "0123456789ABCDEF";
;;;585        register int i;
;;;586        register int size;
;;;587    
;;;588        size = s;
;;;589    
;;;590        digits = (type & LARGE) ? large_digits : small_digits;
00000a  9c0f              LDR      r4,[sp,#0x3c]
00000c  0663              LSLS     r3,r4,#25
00000e  d502              BPL      |L3.22|
000010  f8df8110          LDR      r8,|L3.292|
000014  e003              B        |L3.30|
                  |L3.22|
000016  f8df810c          LDR      r8,|L3.292|
00001a  f1a80811          SUB      r8,r8,#0x11
                  |L3.30|
;;;591        if (type & LEFT)
00001e  06e3              LSLS     r3,r4,#27
000020  d501              BPL      |L3.38|
;;;592            type &= ~ZEROPAD;
000022  f0240401          BIC      r4,r4,#1
                  |L3.38|
;;;593    
;;;594        c = (type & ZEROPAD) ? '0' : ' ';
000026  07e3              LSLS     r3,r4,#31
000028  d001              BEQ      |L3.46|
00002a  2330              MOVS     r3,#0x30
00002c  e000              B        |L3.48|
                  |L3.46|
00002e  2320              MOVS     r3,#0x20
                  |L3.48|
000030  4699              MOV      r9,r3
;;;595    
;;;596        /* get sign */
;;;597        sign = 0;
000032  2600              MOVS     r6,#0
;;;598        if (type & SIGN)
000034  07a3              LSLS     r3,r4,#30
000036  d50b              BPL      |L3.80|
;;;599        {
;;;600            if (num < 0)
000038  2a00              CMP      r2,#0
00003a  da02              BGE      |L3.66|
;;;601            {
;;;602                sign = '-';
00003c  262d              MOVS     r6,#0x2d
;;;603                num = -num;
00003e  4252              RSBS     r2,r2,#0
000040  e006              B        |L3.80|
                  |L3.66|
;;;604            }
;;;605            else if (type & PLUS)
000042  0763              LSLS     r3,r4,#29
000044  d501              BPL      |L3.74|
;;;606                sign = '+';
000046  262b              MOVS     r6,#0x2b
000048  e002              B        |L3.80|
                  |L3.74|
;;;607            else if (type & SPACE)
00004a  0723              LSLS     r3,r4,#28
00004c  d500              BPL      |L3.80|
;;;608                sign = ' ';
00004e  2620              MOVS     r6,#0x20
                  |L3.80|
;;;609        }
;;;610    
;;;611    #ifdef RT_PRINTF_SPECIAL
;;;612        if (type & SPECIAL)
;;;613        {
;;;614            if (base == 16)
;;;615                size -= 2;
;;;616            else if (base == 8)
;;;617                size--;
;;;618        }
;;;619    #endif
;;;620    
;;;621        i = 0;
000050  2300              MOVS     r3,#0
000052  46ee              MOV      lr,sp                 ;580
;;;622        if (num == 0)
000054  b922              CBNZ     r2,|L3.96|
;;;623            tmp[i++]='0';
000056  2230              MOVS     r2,#0x30
000058  f88d2000          STRB     r2,[sp,#0]
00005c  2301              MOVS     r3,#1
00005e  e00c              B        |L3.122|
                  |L3.96|
000060  f1ba0f0a          CMP      r10,#0xa
000064  d014              BEQ      |L3.144|
000066  f0020c0f          AND      r12,r2,#0xf
00006a  0912              LSRS     r2,r2,#4
                  |L3.108|
;;;624        else
;;;625        {
;;;626            while (num != 0)
;;;627                tmp[i++] = digits[divide(&num, base)];
00006c  f818c00c          LDRB     r12,[r8,r12]
000070  f80ec003          STRB     r12,[lr,r3]
000074  1c5b              ADDS     r3,r3,#1
000076  2a00              CMP      r2,#0
000078  d1f2              BNE      |L3.96|
                  |L3.122|
;;;628        }
;;;629    
;;;630    #ifdef RT_PRINTF_PRECISION
;;;631        if (i > precision)
00007a  42ab              CMP      r3,r5
00007c  dd00              BLE      |L3.128|
;;;632            precision = i;
00007e  461d              MOV      r5,r3
                  |L3.128|
;;;633        size -= precision;
000080  ebab0205          SUB      r2,r11,r5
;;;634    #else
;;;635        size -= i;
;;;636    #endif
;;;637    
;;;638        if (!(type&(ZEROPAD | LEFT)))
000084  f0140f11          TST      r4,#0x11
000088  f04f0720          MOV      r7,#0x20              ;594
00008c  d008              BEQ      |L3.160|
00008e  e015              B        |L3.188|
                  |L3.144|
000090  270a              MOVS     r7,#0xa
000092  fbb2fcf7          UDIV     r12,r2,r7
000096  fb072c1c          MLS      r12,r7,r12,r2
00009a  fbb2f2f7          UDIV     r2,r2,r7
00009e  e7e5              B        |L3.108|
                  |L3.160|
;;;639        {
;;;640            if ((sign)&&(size>0))
0000a0  b13e              CBZ      r6,|L3.178|
0000a2  2a00              CMP      r2,#0
0000a4  dd05              BLE      |L3.178|
0000a6  1e52              SUBS     r2,r2,#1
;;;641                size--;
0000a8  e003              B        |L3.178|
                  |L3.170|
;;;642    
;;;643            while (size-->0)
;;;644            {
;;;645                if (buf <= end)
0000aa  4288              CMP      r0,r1
0000ac  d800              BHI      |L3.176|
;;;646                    *buf = ' ';
0000ae  7007              STRB     r7,[r0,#0]
                  |L3.176|
0000b0  1c40              ADDS     r0,r0,#1
                  |L3.178|
0000b2  f1b20c00          SUBS     r12,r2,#0             ;643
0000b6  f1a20201          SUB      r2,r2,#1              ;643
0000ba  dcf6              BGT      |L3.170|
                  |L3.188|
;;;647                ++ buf;
;;;648            }
;;;649        }
;;;650    
;;;651        if (sign)
0000bc  b126              CBZ      r6,|L3.200|
;;;652        {
;;;653            if (buf <= end)
0000be  4288              CMP      r0,r1
0000c0  d801              BHI      |L3.198|
;;;654            {
;;;655                *buf = sign;
0000c2  7006              STRB     r6,[r0,#0]
0000c4  1e52              SUBS     r2,r2,#1
                  |L3.198|
0000c6  1c40              ADDS     r0,r0,#1
                  |L3.200|
;;;656                -- size;
;;;657            }
;;;658            ++ buf;
;;;659        }
;;;660    
;;;661    #ifdef RT_PRINTF_SPECIAL
;;;662        if (type & SPECIAL)
;;;663        {
;;;664            if (base==8)
;;;665            {
;;;666                if (buf <= end)
;;;667                    *buf = '0';
;;;668                ++ buf;
;;;669            }
;;;670            else if (base == 16)
;;;671            {
;;;672                if (buf <= end)
;;;673                    *buf = '0';
;;;674                ++ buf;
;;;675                if (buf <= end)
;;;676                {
;;;677                    *buf = type & LARGE? 'X' : 'x';
;;;678                }
;;;679                ++ buf;
;;;680            }
;;;681        }
;;;682    #endif
;;;683    
;;;684        /* no align to the left */
;;;685        if (!(type & LEFT))
0000c8  06e4              LSLS     r4,r4,#27
0000ca  d505              BPL      |L3.216|
0000cc  e008              B        |L3.224|
                  |L3.206|
;;;686        {
;;;687            while (size-- > 0)
;;;688            {
;;;689                if (buf <= end)
0000ce  4288              CMP      r0,r1
0000d0  d801              BHI      |L3.214|
;;;690                    *buf = c;
0000d2  f8809000          STRB     r9,[r0,#0]
                  |L3.214|
0000d6  1c40              ADDS     r0,r0,#1
                  |L3.216|
0000d8  1e14              SUBS     r4,r2,#0              ;687
0000da  f1a20201          SUB      r2,r2,#1              ;687
0000de  dcf6              BGT      |L3.206|
                  |L3.224|
0000e0  2430              MOVS     r4,#0x30              ;594
                  |L3.226|
;;;691                ++ buf;
;;;692            }
;;;693        }
;;;694    
;;;695    #ifdef RT_PRINTF_PRECISION
;;;696        while (i < precision--)
0000e2  462e              MOV      r6,r5
0000e4  1e6d              SUBS     r5,r5,#1
0000e6  429e              CMP      r6,r3
0000e8  dd0a              BLE      |L3.256|
;;;697        {
;;;698            if (buf <= end)
0000ea  4288              CMP      r0,r1
0000ec  d800              BHI      |L3.240|
;;;699                *buf = '0';
0000ee  7004              STRB     r4,[r0,#0]
                  |L3.240|
0000f0  1c40              ADDS     r0,r0,#1
;;;700            ++ buf;
0000f2  e7f6              B        |L3.226|
                  |L3.244|
;;;701        }
;;;702    #endif
;;;703    
;;;704        /* put number in the temporary buffer */
;;;705        while (i-- > 0)
;;;706        {
;;;707            if (buf <= end)
0000f4  4288              CMP      r0,r1
0000f6  d801              BHI      |L3.252|
;;;708                *buf = tmp[i];
0000f8  5ce5              LDRB     r5,[r4,r3]
0000fa  7005              STRB     r5,[r0,#0]
                  |L3.252|
0000fc  1c40              ADDS     r0,r0,#1
;;;709            ++ buf;
0000fe  e000              B        |L3.258|
                  |L3.256|
000100  4674              MOV      r4,lr                 ;580
                  |L3.258|
000102  1e1d              SUBS     r5,r3,#0              ;705
000104  f1a30301          SUB      r3,r3,#1              ;705
000108  dcf4              BGT      |L3.244|
00010a  e003              B        |L3.276|
                  |L3.268|
;;;710        }
;;;711    
;;;712        while (size-- > 0)
;;;713        {
;;;714            if (buf <= end)
00010c  4288              CMP      r0,r1
00010e  d800              BHI      |L3.274|
;;;715                *buf = ' ';
000110  7007              STRB     r7,[r0,#0]
                  |L3.274|
000112  1c40              ADDS     r0,r0,#1
                  |L3.276|
000114  1e13              SUBS     r3,r2,#0              ;712
000116  f1a20201          SUB      r2,r2,#1              ;712
00011a  dcf7              BGT      |L3.268|
;;;716            ++ buf;
;;;717        }
;;;718    
;;;719        return buf;
;;;720    }
00011c  b004              ADD      sp,sp,#0x10
00011e  e8bd8ff0          POP      {r4-r11,pc}
;;;721    
                          ENDP

000122  0000              DCW      0x0000
                  |L3.292|
                          DCD      ||.constdata||+0x111

                          AREA ||i.rt_console_get_device||, CODE, READONLY, ALIGN=2

                  rt_console_get_device PROC
;;;1041    */
;;;1042   rt_device_t rt_console_get_device(void)
000000  4801              LDR      r0,|L4.8|
;;;1043   {
;;;1044       return _console_device;
000002  6800              LDR      r0,[r0,#0]  ; _console_device
;;;1045   }
000004  4770              BX       lr
;;;1046   RTM_EXPORT(rt_console_get_device);
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||.data||

                          AREA ||i.rt_console_set_device||, CODE, READONLY, ALIGN=2

                  rt_console_set_device PROC
;;;1056    */
;;;1057   rt_device_t rt_console_set_device(const char *name)
000000  b570              PUSH     {r4-r6,lr}
;;;1058   {
;;;1059       rt_device_t new, old;
;;;1060   
;;;1061       /* save old device */
;;;1062       old = _console_device;
000002  4d08              LDR      r5,|L5.36|
;;;1063   
;;;1064       /* find new console device */
;;;1065       new = rt_device_find(name);
000004  682e              LDR      r6,[r5,#0]  ; _console_device
000006  f7fffffe          BL       rt_device_find
00000a  0004              MOVS     r4,r0
;;;1066       if (new != RT_NULL)
00000c  d008              BEQ      |L5.32|
;;;1067       {
;;;1068           if (_console_device != RT_NULL)
00000e  6828              LDR      r0,[r5,#0]  ; _console_device
000010  b108              CBZ      r0,|L5.22|
;;;1069           {
;;;1070               /* close old console device */
;;;1071               rt_device_close(_console_device);
000012  f7fffffe          BL       rt_device_close
                  |L5.22|
;;;1072           }
;;;1073   
;;;1074           /* set new console device */
;;;1075           rt_device_open(new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);
000016  2143              MOVS     r1,#0x43
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_device_open
;;;1076           _console_device = new;
00001e  602c              STR      r4,[r5,#0]  ; _console_device
                  |L5.32|
;;;1077       }
;;;1078   
;;;1079       return old;
000020  4630              MOV      r0,r6
;;;1080   }
000022  bd70              POP      {r4-r6,pc}
;;;1081   RTM_EXPORT(rt_console_set_device);
                          ENDP

                  |L5.36|
                          DCD      ||.data||

                          AREA ||i.rt_free_align||, CODE, READONLY, ALIGN=1

                  rt_free_align PROC
;;;1193    */
;;;1194   void rt_free_align(void *ptr)
000000  f8500c04          LDR      r0,[r0,#-4]
;;;1195   {
;;;1196       void *real_ptr;
;;;1197   
;;;1198       real_ptr = (void *)*(rt_uint32_t *)((rt_uint32_t)ptr - sizeof(void *));
;;;1199       rt_free(real_ptr);
000004  f7ffbffe          B.W      rt_free
;;;1200   }
;;;1201   RTM_EXPORT(rt_free_align);
                          ENDP


                          AREA ||i.rt_get_errno||, CODE, READONLY, ALIGN=2

                  rt_get_errno PROC
;;;58      */
;;;59     rt_err_t rt_get_errno(void)
000000  b510              PUSH     {r4,lr}
;;;60     {
;;;61         rt_thread_t tid;
;;;62     
;;;63         if (rt_interrupt_get_nest() != 0)
000002  f7fffffe          BL       rt_interrupt_get_nest
;;;64         {
;;;65             /* it's in interrupt context */
;;;66             return _errno;
000006  4c04              LDR      r4,|L7.24|
000008  b920              CBNZ     r0,|L7.20|
;;;67         }
;;;68     
;;;69         tid = rt_thread_self();
00000a  f7fffffe          BL       rt_thread_self
;;;70         if (tid == RT_NULL)
00000e  b108              CBZ      r0,|L7.20|
;;;71             return _errno;
;;;72     
;;;73         return tid->error;
000010  6b00              LDR      r0,[r0,#0x30]
;;;74     }
000012  bd10              POP      {r4,pc}
                  |L7.20|
000014  6860              LDR      r0,[r4,#4]            ;71  ; _errno
000016  bd10              POP      {r4,pc}
;;;75     RTM_EXPORT(rt_get_errno);
                          ENDP

                  |L7.24|
                          DCD      ||.data||

                          AREA ||i.rt_hw_console_output||, CODE, READONLY, ALIGN=1

                  rt_hw_console_output PROC
;;;1087   #elif defined(__CC_ARM)
;;;1088   __weak void rt_hw_console_output(const char *str)
000000  4770              BX       lr
;;;1089   #elif defined(__IAR_SYSTEMS_ICC__)
;;;1090       #if __VER__ > 540
;;;1091       __weak
;;;1092       #endif
;;;1093   void rt_hw_console_output(const char *str)
;;;1094   #else
;;;1095   void rt_hw_console_output(const char *str)
;;;1096   #endif
;;;1097   {
;;;1098       /* empty console output */
;;;1099   }
;;;1100   RTM_EXPORT(rt_hw_console_output);
                          ENDP


                          AREA ||i.rt_kprintf||, CODE, READONLY, ALIGN=2

                  rt_kprintf PROC
;;;1106    */
;;;1107   void rt_kprintf(const char *fmt, ...)
000000  b40f              PUSH     {r0-r3}
;;;1108   {
;;;1109       va_list args;
;;;1110       rt_size_t length;
;;;1111       static char rt_log_buf[RT_CONSOLEBUF_SIZE];
;;;1112   
;;;1113       va_start(args, fmt);
;;;1114       /* the return value of vsnprintf is the number of bytes that would be
;;;1115        * written to buffer had if the size of the buffer been sufficiently
;;;1116        * large excluding the terminating null byte. If the output string
;;;1117        * would be larger than the rt_log_buf, we have to adjust the output
;;;1118        * length. */
;;;1119       length = rt_vsnprintf(rt_log_buf, sizeof(rt_log_buf) - 1, fmt, args);
000002  217f              MOVS     r1,#0x7f
000004  b570              PUSH     {r4-r6,lr}            ;1108
000006  ab05              ADD      r3,sp,#0x14           ;1113
000008  480d              LDR      r0,|L9.64|
00000a  9a04              LDR      r2,[sp,#0x10]
00000c  f7fffffe          BL       rt_vsnprintf
000010  4603              MOV      r3,r0
;;;1120       if (length > RT_CONSOLEBUF_SIZE - 1)
000012  287f              CMP      r0,#0x7f
000014  d900              BLS      |L9.24|
;;;1121           length = RT_CONSOLEBUF_SIZE - 1;
000016  237f              MOVS     r3,#0x7f
                  |L9.24|
;;;1122   #ifdef RT_USING_DEVICE
;;;1123       if (_console_device == RT_NULL)
000018  4d0a              LDR      r5,|L9.68|
00001a  6828              LDR      r0,[r5,#0]  ; _console_device
00001c  b160              CBZ      r0,|L9.56|
;;;1124       {
;;;1125           rt_hw_console_output(rt_log_buf);
;;;1126       }
;;;1127       else
;;;1128       {
;;;1129           rt_uint16_t old_flag = _console_device->flag;
00001e  8ac4              LDRH     r4,[r0,#0x16]
;;;1130   
;;;1131           _console_device->flag |= RT_DEVICE_FLAG_STREAM;
;;;1132           rt_device_write(_console_device, 0, rt_log_buf, length);
000020  4a07              LDR      r2,|L9.64|
000022  f0440140          ORR      r1,r4,#0x40           ;1131
000026  82c1              STRH     r1,[r0,#0x16]         ;1131
000028  2100              MOVS     r1,#0
00002a  f7fffffe          BL       rt_device_write
;;;1133           _console_device->flag = old_flag;
00002e  6828              LDR      r0,[r5,#0]  ; _console_device
000030  82c4              STRH     r4,[r0,#0x16]
                  |L9.50|
;;;1134       }
;;;1135   #else
;;;1136       rt_hw_console_output(rt_log_buf);
;;;1137   #endif
;;;1138       va_end(args);
;;;1139   }
000032  bc70              POP      {r4-r6}
000034  f85dfb14          LDR      pc,[sp],#0x14
                  |L9.56|
000038  4801              LDR      r0,|L9.64|
00003a  f7fffffe          BL       rt_hw_console_output
00003e  e7f8              B        |L9.50|
;;;1140   RTM_EXPORT(rt_kprintf);
                          ENDP

                  |L9.64|
                          DCD      ||.bss||
                  |L9.68|
                          DCD      ||.data||

                          AREA ||i.rt_malloc_align||, CODE, READONLY, ALIGN=1

                  rt_malloc_align PROC
;;;1152    */
;;;1153   void* rt_malloc_align(rt_size_t size, rt_size_t align)
000000  b510              PUSH     {r4,lr}
;;;1154   {
000002  1cc9              ADDS     r1,r1,#3
;;;1155       void *align_ptr;
;;;1156       void *ptr;
;;;1157       rt_size_t align_size;
;;;1158   
;;;1159       /* align the alignment size to 4 byte */
;;;1160       align = ((align + 0x03) & ~0x03);
000004  1cc0              ADDS     r0,r0,#3
000006  f0210403          BIC      r4,r1,#3
;;;1161   
;;;1162       /* get total aligned size */
;;;1163       align_size = ((size + 0x03) & ~0x03) + align;
00000a  f0200003          BIC      r0,r0,#3
00000e  4420              ADD      r0,r0,r4
;;;1164       /* allocate memory block from heap */
;;;1165       ptr = rt_malloc(align_size);
000010  f7fffffe          BL       rt_malloc
;;;1166       if (ptr != RT_NULL)
000014  2800              CMP      r0,#0
000016  d00b              BEQ      |L10.48|
;;;1167       {
;;;1168            /* the allocated memory block is aligned */
;;;1169           if (((rt_uint32_t)ptr & (align - 1)) == 0)
000018  1e61              SUBS     r1,r4,#1
00001a  4208              TST      r0,r1
00001c  d101              BNE      |L10.34|
;;;1170           {
;;;1171               align_ptr = (void *)((rt_uint32_t)ptr + align);
00001e  1901              ADDS     r1,r0,r4
000020  e003              B        |L10.42|
                  |L10.34|
;;;1172           }
;;;1173           else
;;;1174           {
;;;1175               align_ptr = (void *)(((rt_uint32_t)ptr + (align - 1)) & ~(align - 1));
000022  1902              ADDS     r2,r0,r4
000024  1e52              SUBS     r2,r2,#1
000026  ea220101          BIC      r1,r2,r1
                  |L10.42|
;;;1176           }
;;;1177   
;;;1178           /* set the pointer before alignment pointer to the real pointer */
;;;1179           *((rt_uint32_t *)((rt_uint32_t)align_ptr - sizeof(void *))) = (rt_uint32_t)ptr;
00002a  f8410c04          STR      r0,[r1,#-4]
;;;1180   
;;;1181           ptr = align_ptr;
00002e  4608              MOV      r0,r1
                  |L10.48|
;;;1182       }
;;;1183   
;;;1184       return ptr;
;;;1185   }
000030  bd10              POP      {r4,pc}
;;;1186   RTM_EXPORT(rt_malloc_align);
                          ENDP


                          AREA ||i.rt_memcmp||, CODE, READONLY, ALIGN=1

                  rt_memcmp PROC
;;;323     */
;;;324    rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
000000  b510              PUSH     {r4,lr}
;;;325    {
;;;326        const unsigned char *su1, *su2;
;;;327        int res = 0;
000002  2300              MOVS     r3,#0
000004  e006              B        |L11.20|
                  |L11.6|
;;;328    
;;;329        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
;;;330            if ((res = *su1 - *su2) != 0)
000006  7803              LDRB     r3,[r0,#0]
000008  780c              LDRB     r4,[r1,#0]
00000a  1b1b              SUBS     r3,r3,r4
00000c  d104              BNE      |L11.24|
00000e  1c40              ADDS     r0,r0,#1
000010  1c49              ADDS     r1,r1,#1
000012  1e52              SUBS     r2,r2,#1
                  |L11.20|
000014  2a00              CMP      r2,#0                 ;329
000016  d1f6              BNE      |L11.6|
                  |L11.24|
;;;331                break;
;;;332    
;;;333        return res;
000018  4618              MOV      r0,r3
;;;334    }
00001a  bd10              POP      {r4,pc}
;;;335    RTM_EXPORT(rt_memcmp);
                          ENDP


                          AREA ||i.rt_memcpy||, CODE, READONLY, ALIGN=1

                  rt_memcpy PROC
;;;217     */
;;;218    void *rt_memcpy(void *dst, const void *src, rt_ubase_t count)
000000  b510              PUSH     {r4,lr}
;;;219    {
;;;220    #ifdef RT_TINY_SIZE
;;;221        char *tmp = (char *)dst, *s = (char *)src;
;;;222    
;;;223        while (count--)
;;;224            *tmp++ = *s++;
;;;225    
;;;226        return dst;
;;;227    #else
;;;228    
;;;229    #define UNALIGNED(X, Y)                                               \
;;;230                            (((rt_int32_t)X & (sizeof(rt_int32_t) - 1)) | \
;;;231                             ((rt_int32_t)Y & (sizeof(rt_int32_t) - 1)))
;;;232    #define BIGBLOCKSIZE    (sizeof(rt_int32_t) << 2)
;;;233    #define LITTLEBLOCKSIZE (sizeof(rt_int32_t))
;;;234    #define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)
;;;235    
;;;236        char *dst_ptr = (char *)dst;
000002  4603              MOV      r3,r0
;;;237        char *src_ptr = (char *)src;
;;;238        rt_int32_t *aligned_dst;
;;;239        rt_int32_t *aligned_src;
;;;240        int len = count;
;;;241    
;;;242        /* If the size is small, or either SRC or DST is unaligned,
;;;243        then punt into the byte copy loop.  This should be rare. */
;;;244        if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
000004  2a10              CMP      r2,#0x10
000006  d31d              BCC      |L12.68|
000008  ea410403          ORR      r4,r1,r3
00000c  07a4              LSLS     r4,r4,#30
00000e  d119              BNE      |L12.68|
                  |L12.16|
;;;245        {
;;;246            aligned_dst = (rt_int32_t *)dst_ptr;
;;;247            aligned_src = (rt_int32_t *)src_ptr;
;;;248    
;;;249            /* Copy 4X long words at a time if possible. */
;;;250            while (len >= BIGBLOCKSIZE)
;;;251            {
;;;252                *aligned_dst++ = *aligned_src++;
000010  c910              LDM      r1!,{r4}
;;;253                *aligned_dst++ = *aligned_src++;
;;;254                *aligned_dst++ = *aligned_src++;
;;;255                *aligned_dst++ = *aligned_src++;
000012  3a10              SUBS     r2,r2,#0x10
000014  c310              STM      r3!,{r4}              ;252
000016  c910              LDM      r1!,{r4}              ;253
000018  2a10              CMP      r2,#0x10              ;250
00001a  c310              STM      r3!,{r4}              ;253
00001c  f8514b08          LDR      r4,[r1],#8            ;254
000020  f8434b08          STR      r4,[r3],#8            ;254
000024  f8514c04          LDR      r4,[r1,#-4]
000028  f8434c04          STR      r4,[r3,#-4]
;;;256                len -= BIGBLOCKSIZE;
00002c  d2f0              BCS      |L12.16|
00002e  e002              B        |L12.54|
                  |L12.48|
;;;257            }
;;;258    
;;;259            /* Copy one long word at a time if possible. */
;;;260            while (len >= LITTLEBLOCKSIZE)
;;;261            {
;;;262                *aligned_dst++ = *aligned_src++;
000030  c910              LDM      r1!,{r4}
000032  1f12              SUBS     r2,r2,#4
000034  c310              STM      r3!,{r4}
                  |L12.54|
000036  2a04              CMP      r2,#4                 ;260
000038  d2fa              BCS      |L12.48|
00003a  e003              B        |L12.68|
                  |L12.60|
;;;263                len -= LITTLEBLOCKSIZE;
;;;264            }
;;;265    
;;;266            /* Pick up any residual with a byte copier. */
;;;267            dst_ptr = (char *)aligned_dst;
;;;268            src_ptr = (char *)aligned_src;
;;;269        }
;;;270    
;;;271        while (len--)
;;;272            *dst_ptr++ = *src_ptr++;
00003c  f8114b01          LDRB     r4,[r1],#1
000040  f8034b01          STRB     r4,[r3],#1
                  |L12.68|
000044  1e52              SUBS     r2,r2,#1
000046  d2f9              BCS      |L12.60|
;;;273    
;;;274        return dst;
;;;275    #undef UNALIGNED
;;;276    #undef BIGBLOCKSIZE
;;;277    #undef LITTLEBLOCKSIZE
;;;278    #undef TOO_SMALL
;;;279    #endif
;;;280    }
000048  bd10              POP      {r4,pc}
;;;281    RTM_EXPORT(rt_memcpy);
                          ENDP


                          AREA ||i.rt_memmove||, CODE, READONLY, ALIGN=1

                  rt_memmove PROC
;;;292     */
;;;293    void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
000000  b510              PUSH     {r4,lr}
;;;294    {
;;;295        char *tmp = (char *)dest, *s = (char *)src;
000002  4603              MOV      r3,r0
;;;296    
;;;297        if (s < tmp && tmp < s + n)
000004  4281              CMP      r1,r0
000006  d20f              BCS      |L13.40|
000008  188c              ADDS     r4,r1,r2
00000a  429c              CMP      r4,r3
00000c  d90c              BLS      |L13.40|
;;;298        {
;;;299            tmp += n;
00000e  1881              ADDS     r1,r0,r2
;;;300            s += n;
;;;301    
;;;302            while (n--)
000010  e003              B        |L13.26|
                  |L13.18|
;;;303                *(--tmp) = *(--s);
000012  f8143d01          LDRB     r3,[r4,#-1]!
000016  f8013d01          STRB     r3,[r1,#-1]!
                  |L13.26|
00001a  1e52              SUBS     r2,r2,#1
00001c  d2f9              BCS      |L13.18|
;;;304        }
;;;305        else
;;;306        {
;;;307            while (n--)
;;;308                *tmp++ = *s++;
;;;309        }
;;;310    
;;;311        return dest;
;;;312    }
00001e  bd10              POP      {r4,pc}
                  |L13.32|
000020  f8114b01          LDRB     r4,[r1],#1            ;308
000024  f8034b01          STRB     r4,[r3],#1            ;308
                  |L13.40|
000028  1e52              SUBS     r2,r2,#1              ;308
00002a  d2f9              BCS      |L13.32|
00002c  bd10              POP      {r4,pc}
;;;313    RTM_EXPORT(rt_memmove);
                          ENDP


                          AREA ||i.rt_memset||, CODE, READONLY, ALIGN=1

                  rt_memset PROC
;;;134     */
;;;135    void *rt_memset(void *s, int c, rt_ubase_t count)
000000  b510              PUSH     {r4,lr}
;;;136    {
;;;137    #ifdef RT_TINY_SIZE
;;;138        char *xs = (char *)s;
;;;139    
;;;140        while (count--)
;;;141            *xs++ = c;
;;;142    
;;;143        return s;
;;;144    #else
;;;145    #define LBLOCKSIZE      (sizeof(rt_int32_t))
;;;146    #define UNALIGNED(X)    ((rt_int32_t)X & (LBLOCKSIZE - 1))
;;;147    #define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)
;;;148    
;;;149        int i;
;;;150        char *m = (char *)s;
000002  4603              MOV      r3,r0
;;;151        rt_uint32_t buffer;
;;;152        rt_uint32_t *aligned_addr;
;;;153        rt_uint32_t d = c & 0xff;
000004  b2cc              UXTB     r4,r1
;;;154    
;;;155        if (!TOO_SMALL(count) && !UNALIGNED(s))
000006  2a04              CMP      r2,#4
000008  d319              BCC      |L14.62|
00000a  0781              LSLS     r1,r0,#30
00000c  d117              BNE      |L14.62|
;;;156        {
;;;157            /* If we get this far, we know that n is large and m is word-aligned. */
;;;158            aligned_addr = (rt_uint32_t *)s;
00000e  4619              MOV      r1,r3
;;;159    
;;;160            /* Store D into each char sized location in BUFFER so that
;;;161             * we can set large blocks quickly.
;;;162             */
;;;163            if (LBLOCKSIZE == 4)
;;;164            {
;;;165                buffer = (d << 8) | d;
000010  ea442304          ORR      r3,r4,r4,LSL #8
;;;166                buffer |= (buffer << 16);
000014  ea434303          ORR      r3,r3,r3,LSL #16
;;;167            }
;;;168            else
;;;169            {
;;;170                buffer = 0;
;;;171                for (i = 0; i < LBLOCKSIZE; i ++)
;;;172                    buffer = (buffer << 8) | d;
;;;173            }
;;;174    
;;;175            while (count >= LBLOCKSIZE * 4)
000018  e006              B        |L14.40|
                  |L14.26|
;;;176            {
;;;177                *aligned_addr++ = buffer;
00001a  c108              STM      r1!,{r3}
;;;178                *aligned_addr++ = buffer;
;;;179                *aligned_addr++ = buffer;
;;;180                *aligned_addr++ = buffer;
00001c  3a10              SUBS     r2,r2,#0x10
00001e  c108              STM      r1!,{r3}              ;178
000020  f8413b08          STR      r3,[r1],#8            ;179
000024  f8413c04          STR      r3,[r1,#-4]
                  |L14.40|
000028  2a10              CMP      r2,#0x10              ;175
00002a  d2f6              BCS      |L14.26|
00002c  e001              B        |L14.50|
                  |L14.46|
;;;181                count -= 4 * LBLOCKSIZE;
;;;182            }
;;;183    
;;;184            while (count >= LBLOCKSIZE)
;;;185            {
;;;186                *aligned_addr++ = buffer;
00002e  c108              STM      r1!,{r3}
000030  1f12              SUBS     r2,r2,#4
                  |L14.50|
000032  2a04              CMP      r2,#4                 ;184
000034  d2fb              BCS      |L14.46|
;;;187                count -= LBLOCKSIZE;
;;;188            }
;;;189    
;;;190            /* Pick up the remainder with a bytewise loop. */
;;;191            m = (char *)aligned_addr;
000036  460b              MOV      r3,r1
000038  e001              B        |L14.62|
                  |L14.58|
;;;192        }
;;;193    
;;;194        while (count--)
;;;195        {
;;;196            *m++ = (char)d;
00003a  f8034b01          STRB     r4,[r3],#1
                  |L14.62|
00003e  1e52              SUBS     r2,r2,#1
000040  d2fb              BCS      |L14.58|
;;;197        }
;;;198    
;;;199        return s;
;;;200    
;;;201    #undef LBLOCKSIZE
;;;202    #undef UNALIGNED
;;;203    #undef TOO_SMALL
;;;204    #endif
;;;205    }
000042  bd10              POP      {r4,pc}
;;;206    RTM_EXPORT(rt_memset);
                          ENDP


                          AREA ||i.rt_set_errno||, CODE, READONLY, ALIGN=2

                  rt_set_errno PROC
;;;81      */
;;;82     void rt_set_errno(rt_err_t error)
000000  b570              PUSH     {r4-r6,lr}
;;;83     {
000002  4604              MOV      r4,r0
;;;84         rt_thread_t tid;
;;;85     
;;;86         if (rt_interrupt_get_nest() != 0)
000004  f7fffffe          BL       rt_interrupt_get_nest
;;;87         {
;;;88             /* it's in interrupt context */
;;;89             _errno = error;
000008  4d04              LDR      r5,|L15.28|
00000a  b920              CBNZ     r0,|L15.22|
;;;90     
;;;91             return;
;;;92         }
;;;93     
;;;94         tid = rt_thread_self();
00000c  f7fffffe          BL       rt_thread_self
;;;95         if (tid == RT_NULL)
000010  b108              CBZ      r0,|L15.22|
;;;96         {
;;;97             _errno = error;
;;;98     
;;;99             return;
;;;100        }
;;;101    
;;;102        tid->error = error;
;;;103    }
000012  6304              STR      r4,[r0,#0x30]
000014  bd70              POP      {r4-r6,pc}
                  |L15.22|
000016  606c              STR      r4,[r5,#4]            ;97  ; _errno
000018  bd70              POP      {r4-r6,pc}
;;;104    RTM_EXPORT(rt_set_errno);
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      ||.data||

                          AREA ||i.rt_show_version||, CODE, READONLY, ALIGN=2

                  rt_show_version PROC
;;;509     */
;;;510    void rt_show_version(void)
000000  b508              PUSH     {r3,lr}
;;;511    {
;;;512        rt_kprintf("\n \\ | /\n");
000002  a009              ADR      r0,|L16.40|
000004  f7fffffe          BL       rt_kprintf
;;;513        rt_kprintf("- RT -     Thread Operating System\n");
000008  a00a              ADR      r0,|L16.52|
00000a  f7fffffe          BL       rt_kprintf
;;;514        rt_kprintf(" / | \\     %d.%d.%d build %s\n",
00000e  a012              ADR      r0,|L16.88|
000010  9000              STR      r0,[sp,#0]
000012  2305              MOVS     r3,#5
000014  2202              MOVS     r2,#2
000016  2101              MOVS     r1,#1
000018  a012              ADR      r0,|L16.100|
00001a  f7fffffe          BL       rt_kprintf
;;;515                   RT_VERSION, RT_SUBVERSION, RT_REVISION, __DATE__);
;;;516        rt_kprintf(" 2006 - 2013 Copyright by rt-thread team\n");
00001e  e8bd4008          POP      {r3,lr}
000022  a018              ADR      r0,|L16.132|
000024  f7ffbffe          B.W      rt_kprintf
;;;517    }
;;;518    RTM_EXPORT(rt_show_version);
                          ENDP

                  |L16.40|
000028  0a205c20          DCB      "\n \\ | /\n",0
00002c  7c202f0a
000030  00      
000031  00                DCB      0
000032  00                DCB      0
000033  00                DCB      0
                  |L16.52|
000034  2d205254          DCB      "- RT -     Thread Operating System\n",0
000038  202d2020
00003c  20202054
000040  68726561
000044  64204f70
000048  65726174
00004c  696e6720
000050  53797374
000054  656d0a00
                  |L16.88|
000058  41707220          DCB      "Apr 20 2017",0
00005c  32302032
000060  30313700
                  |L16.100|
000064  202f207c          DCB      " / | \\     %d.%d.%d build %s\n",0
000068  205c2020
00006c  20202025
000070  642e2564
000074  2e256420
000078  6275696c
00007c  64202573
000080  0a00    
000082  00                DCB      0
000083  00                DCB      0
                  |L16.132|
000084  20323030          DCB      " 2006 - 2013 Copyright by rt-thread team\n",0
000088  36202d20
00008c  32303133
000090  20436f70
000094  79726967
000098  68742062
00009c  79207274
0000a0  2d746872
0000a4  65616420
0000a8  7465616d
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.rt_snprintf||, CODE, READONLY, ALIGN=1

                  rt_snprintf PROC
;;;988     */
;;;989    rt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *fmt, ...)
000000  b40f              PUSH     {r0-r3}
;;;990    {
000002  b510              PUSH     {r4,lr}
;;;991        rt_int32_t n;
;;;992        va_list args;
;;;993    
;;;994        va_start(args, fmt);
000004  ab05              ADD      r3,sp,#0x14
;;;995        n = rt_vsnprintf(buf, size, fmt, args);
000006  9a04              LDR      r2,[sp,#0x10]
000008  f7fffffe          BL       rt_vsnprintf
;;;996        va_end(args);
;;;997    
;;;998        return n;
;;;999    }
00000c  bc10              POP      {r4}
00000e  f85dfb14          LDR      pc,[sp],#0x14
;;;1000   RTM_EXPORT(rt_snprintf);
                          ENDP


                          AREA ||i.rt_sprintf||, CODE, READONLY, ALIGN=1

                  rt_sprintf PROC
;;;1020    */
;;;1021   rt_int32_t rt_sprintf(char *buf, const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;1022   {
000002  b510              PUSH     {r4,lr}
;;;1023       rt_int32_t n;
;;;1024       va_list arg_ptr;
;;;1025   
;;;1026       va_start(arg_ptr, format);
000004  aa04              ADD      r2,sp,#0x10
;;;1027       n = rt_vsprintf(buf ,format, arg_ptr);
000006  9903              LDR      r1,[sp,#0xc]
000008  f7fffffe          BL       rt_vsprintf
;;;1028       va_end(arg_ptr);
;;;1029   
;;;1030       return n;
;;;1031   }
00000c  bc10              POP      {r4}
00000e  f85dfb14          LDR      pc,[sp],#0x14
;;;1032   RTM_EXPORT(rt_sprintf);
                          ENDP


                          AREA ||i.rt_strcasecmp||, CODE, READONLY, ALIGN=1

                  rt_strcasecmp PROC
;;;372     */
;;;373    rt_uint32_t rt_strcasecmp(const char *a, const char *b)
000000  b510              PUSH     {r4,lr}
                  |L19.2|
;;;374    {
;;;375        int ca, cb;
;;;376    
;;;377        do
;;;378        {
;;;379            ca = *a++ & 0xff;
000002  f8102b01          LDRB     r2,[r0],#1
;;;380            cb = *b++ & 0xff;
000006  f8113b01          LDRB     r3,[r1],#1
;;;381            if (ca >= 'A' && ca <= 'Z')
00000a  f1a20441          SUB      r4,r2,#0x41
00000e  2c19              CMP      r4,#0x19
000010  d800              BHI      |L19.20|
000012  3220              ADDS     r2,r2,#0x20
                  |L19.20|
;;;382                ca += 'a' - 'A';
;;;383            if (cb >= 'A' && cb <= 'Z')
000014  f1a30441          SUB      r4,r3,#0x41
000018  2c19              CMP      r4,#0x19
00001a  d800              BHI      |L19.30|
00001c  3320              ADDS     r3,r3,#0x20
                  |L19.30|
;;;384                cb += 'a' - 'A';
;;;385        }
;;;386        while (ca == cb && ca != '\0');
00001e  429a              CMP      r2,r3
000020  d101              BNE      |L19.38|
000022  2a00              CMP      r2,#0
000024  d1ed              BNE      |L19.2|
                  |L19.38|
;;;387    
;;;388        return ca - cb;
000026  1ad0              SUBS     r0,r2,r3
;;;389    }
000028  bd10              POP      {r4,pc}
;;;390    RTM_EXPORT(rt_strcasecmp);
                          ENDP


                          AREA ||i.rt_strcmp||, CODE, READONLY, ALIGN=1

                  rt_strcmp PROC
;;;455     */
;;;456    rt_ubase_t rt_strcmp(const char *cs, const char *ct)
000000  e001              B        |L20.6|
                  |L20.2|
;;;457    {
;;;458        while (*cs && *cs == *ct)
;;;459            cs++, ct++;
000002  1c40              ADDS     r0,r0,#1
000004  1c49              ADDS     r1,r1,#1
                  |L20.6|
000006  7802              LDRB     r2,[r0,#0]            ;458
000008  b112              CBZ      r2,|L20.16|
00000a  780b              LDRB     r3,[r1,#0]            ;458
00000c  429a              CMP      r2,r3                 ;458
00000e  d0f8              BEQ      |L20.2|
                  |L20.16|
;;;460    
;;;461        return (*cs - *ct);
000010  7809              LDRB     r1,[r1,#0]
000012  b2d0              UXTB     r0,r2
000014  1a40              SUBS     r0,r0,r1
;;;462    }
000016  4770              BX       lr
;;;463    RTM_EXPORT(rt_strcmp);
                          ENDP


                          AREA ||i.rt_strdup||, CODE, READONLY, ALIGN=1

                  rt_strdup PROC
;;;491     */
;;;492    char *rt_strdup(const char *s)
000000  b570              PUSH     {r4-r6,lr}
;;;493    {
000002  4606              MOV      r6,r0
;;;494        rt_size_t len = rt_strlen(s) + 1;
000004  f7fffffe          BL       rt_strlen
000008  1c40              ADDS     r0,r0,#1
00000a  4605              MOV      r5,r0
;;;495        char *tmp = (char *)rt_malloc(len);
00000c  f7fffffe          BL       rt_malloc
000010  0004              MOVS     r4,r0
;;;496    
;;;497        if (!tmp)
000012  d005              BEQ      |L21.32|
;;;498            return RT_NULL;
;;;499    
;;;500        rt_memcpy(tmp, s, len);
000014  462a              MOV      r2,r5
000016  4631              MOV      r1,r6
000018  f7fffffe          BL       rt_memcpy
;;;501    
;;;502        return tmp;
00001c  4620              MOV      r0,r4
;;;503    }
00001e  bd70              POP      {r4-r6,pc}
                  |L21.32|
000020  2000              MOVS     r0,#0                 ;498
000022  bd70              POP      {r4-r6,pc}
;;;504    RTM_EXPORT(rt_strdup);
                          ENDP


                          AREA ||i.rt_strlen||, CODE, READONLY, ALIGN=1

                  rt_strlen PROC
;;;472     */
;;;473    rt_ubase_t rt_strlen(const char *s)
000000  4601              MOV      r1,r0
;;;474    {
000002  e000              B        |L22.6|
                  |L22.4|
000004  1c49              ADDS     r1,r1,#1
                  |L22.6|
;;;475        const char *sc;
;;;476    
;;;477        for (sc = s; *sc != '\0'; ++sc) /* nothing */
000006  780a              LDRB     r2,[r1,#0]
000008  2a00              CMP      r2,#0
00000a  d1fb              BNE      |L22.4|
;;;478            ;
;;;479    
;;;480        return sc - s;
00000c  1a08              SUBS     r0,r1,r0
;;;481    }
00000e  4770              BX       lr
;;;482    RTM_EXPORT(rt_strlen);
                          ENDP


                          AREA ||i.rt_strncmp||, CODE, READONLY, ALIGN=1

                  rt_strncmp PROC
;;;432     */
;;;433    rt_ubase_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
000000  b510              PUSH     {r4,lr}
;;;434    {
;;;435        register signed char __res = 0;
000002  2400              MOVS     r4,#0
000004  e008              B        |L23.24|
                  |L23.6|
;;;436    
;;;437        while (count)
;;;438        {
;;;439            if ((__res = *cs - *ct++) != 0 || !*cs++)
000006  7803              LDRB     r3,[r0,#0]
000008  f8114b01          LDRB     r4,[r1],#1
00000c  1b1c              SUBS     r4,r3,r4
00000e  b264              SXTB     r4,r4
000010  b924              CBNZ     r4,|L23.28|
000012  1c40              ADDS     r0,r0,#1
000014  b113              CBZ      r3,|L23.28|
000016  1e52              SUBS     r2,r2,#1
                  |L23.24|
000018  2a00              CMP      r2,#0                 ;437
00001a  d1f4              BNE      |L23.6|
                  |L23.28|
;;;440                break;
;;;441            count --;
;;;442        }
;;;443    
;;;444        return __res;
00001c  4620              MOV      r0,r4
;;;445    }
00001e  bd10              POP      {r4,pc}
;;;446    RTM_EXPORT(rt_strncmp);
                          ENDP


                          AREA ||i.rt_strncpy||, CODE, READONLY, ALIGN=1

                  rt_strncpy PROC
;;;400     */
;;;401    char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
000000  b510              PUSH     {r4,lr}
;;;402    {
000002  2a00              CMP      r2,#0
000004  d007              BEQ      |L24.22|
;;;403        if (n != 0)
;;;404        {
;;;405            char *d = dst;
000006  4603              MOV      r3,r0
                  |L24.8|
;;;406            const char *s = src;
;;;407    
;;;408            do
;;;409            {
;;;410                if ((*d++ = *s++) == 0)
000008  f8114b01          LDRB     r4,[r1],#1
00000c  f8034b01          STRB     r4,[r3],#1
000010  b12c              CBZ      r4,|L24.30|
000012  1e52              SUBS     r2,r2,#1
;;;411                {
;;;412                    /* NUL pad the remaining n-1 bytes */
;;;413                    while (--n != 0)
;;;414                        *d++ = 0;
;;;415                    break;
;;;416                }
;;;417            } while (--n != 0);
000014  d1f8              BNE      |L24.8|
                  |L24.22|
;;;418        }
;;;419    
;;;420        return (dst);
;;;421    }
000016  bd10              POP      {r4,pc}
                  |L24.24|
000018  f8031b01          STRB     r1,[r3],#1            ;414
00001c  e000              B        |L24.32|
                  |L24.30|
00001e  2100              MOVS     r1,#0                 ;414
                  |L24.32|
000020  1e52              SUBS     r2,r2,#1              ;414
000022  d1f9              BNE      |L24.24|
000024  bd10              POP      {r4,pc}
;;;422    RTM_EXPORT(rt_strncpy);
                          ENDP


                          AREA ||i.rt_strstr||, CODE, READONLY, ALIGN=1

                  rt_strstr PROC
;;;344     */
;;;345    char *rt_strstr(const char *s1, const char *s2)
000000  b5f0              PUSH     {r4-r7,lr}
;;;346    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;347        int l1, l2;
;;;348    
;;;349        l2 = rt_strlen(s2);
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       rt_strlen
00000c  0005              MOVS     r5,r0
;;;350        if (!l2)
00000e  d010              BEQ      |L25.50|
;;;351            return (char *)s1;
;;;352        l1 = rt_strlen(s1);
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       rt_strlen
000016  4604              MOV      r4,r0
;;;353        while (l1 >= l2)
000018  e007              B        |L25.42|
                  |L25.26|
;;;354        {
;;;355            l1 --;
;;;356            if (!rt_memcmp(s1, s2, l2))
00001a  462a              MOV      r2,r5
00001c  4639              MOV      r1,r7
00001e  4630              MOV      r0,r6
000020  1e64              SUBS     r4,r4,#1
000022  f7fffffe          BL       rt_memcmp
000026  b120              CBZ      r0,|L25.50|
000028  1c76              ADDS     r6,r6,#1
                  |L25.42|
00002a  42ac              CMP      r4,r5                 ;353
00002c  daf5              BGE      |L25.26|
;;;357                return (char *)s1;
;;;358            s1 ++;
;;;359        }
;;;360    
;;;361        return RT_NULL;
00002e  2000              MOVS     r0,#0
;;;362    }
000030  bdf0              POP      {r4-r7,pc}
                  |L25.50|
000032  4630              MOV      r0,r6                 ;357
000034  bdf0              POP      {r4-r7,pc}
;;;363    RTM_EXPORT(rt_strstr);
                          ENDP


                          AREA ||i.rt_vsnprintf||, CODE, READONLY, ALIGN=2

                  rt_vsnprintf PROC
;;;721    
;;;722    rt_int32_t rt_vsnprintf(char       *buf,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;723                            rt_size_t   size,
;;;724                            const char *fmt,
;;;725                            va_list     args)
;;;726    {
000004  4683              MOV      r11,r0
;;;727    #ifdef RT_PRINTF_LONGLONG
;;;728        unsigned long long num;
;;;729    #else
;;;730        rt_uint32_t num;
;;;731    #endif
;;;732        int i, len;
;;;733        char *str, *end, c;
;;;734        const char *s;
;;;735    
;;;736        rt_uint8_t base;            /* the base of number */
;;;737        rt_uint8_t flags;           /* flags to print number */
;;;738        rt_uint8_t qualifier;       /* 'h', 'l', or 'L' for integer fields */
;;;739        rt_int32_t field_width;     /* width of output field */
;;;740    
;;;741    #ifdef RT_PRINTF_PRECISION
;;;742        int precision;      /* min. # of digits for integers and max for a string */
;;;743    #endif
;;;744    
;;;745        str = buf;
;;;746        end = buf + size - 1;
000006  4604              MOV      r4,r0
000008  4408              ADD      r0,r0,r1
00000a  f1a00801          SUB      r8,r0,#1
00000e  b083              SUB      sp,sp,#0xc            ;726
000010  461f              MOV      r7,r3                 ;726
;;;747    
;;;748        /* Make sure end is always >= buf */
;;;749        if (end < buf)
;;;750        {
;;;751            end  = ((char *)-1);
;;;752            size = end - buf;
;;;753        }
;;;754    
;;;755        for (; *fmt ; ++fmt)
;;;756        {
;;;757            if (*fmt != '%')
000012  f04f0a20          MOV      r10,#0x20
000016  45a0              CMP      r8,r4                 ;749
000018  d201              BCS      |L26.30|
00001a  f04f38ff          MOV      r8,#0xffffffff        ;751
                  |L26.30|
00001e  e0fa              B        |L26.534|
                  |L26.32|
000020  2825              CMP      r0,#0x25
000022  d003              BEQ      |L26.44|
                  |L26.36|
;;;758            {
;;;759                if (str <= end)
000024  4544              CMP      r4,r8
000026  d800              BHI      |L26.42|
                  |L26.40|
;;;760                    *str = *fmt;
000028  7020              STRB     r0,[r4,#0]
                  |L26.42|
00002a  e0fd              B        |L26.552|
                  |L26.44|
;;;761                ++ str;
;;;762                continue;
;;;763            }
;;;764    
;;;765            /* process flags */
;;;766            flags = 0;
00002c  2500              MOVS     r5,#0
                  |L26.46|
;;;767    
;;;768            while (1)
;;;769            {
;;;770                /* skips the first '%' also */
;;;771                ++ fmt;
00002e  9905              LDR      r1,[sp,#0x14]
000030  1c49              ADDS     r1,r1,#1
;;;772                if (*fmt == '-') flags |= LEFT;
000032  9105              STR      r1,[sp,#0x14]
000034  7808              LDRB     r0,[r1,#0]
000036  282d              CMP      r0,#0x2d
000038  d013              BEQ      |L26.98|
;;;773                else if (*fmt == '+') flags |= PLUS;
00003a  282b              CMP      r0,#0x2b
00003c  d014              BEQ      |L26.104|
;;;774                else if (*fmt == ' ') flags |= SPACE;
00003e  2820              CMP      r0,#0x20
000040  d015              BEQ      |L26.110|
;;;775                else if (*fmt == '#') flags |= SPECIAL;
000042  2823              CMP      r0,#0x23
000044  d016              BEQ      |L26.116|
;;;776                else if (*fmt == '0') flags |= ZEROPAD;
000046  2830              CMP      r0,#0x30
000048  d017              BEQ      |L26.122|
;;;777                else break;
;;;778            }
;;;779    
;;;780            /* get field width */
;;;781            field_width = -1;
;;;782            if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
00004a  780a              LDRB     r2,[r1,#0]
00004c  f04f39ff          MOV      r9,#0xffffffff        ;781
000050  3a30              SUBS     r2,r2,#0x30
000052  464e              MOV      r6,r9                 ;781
000054  2a0a              CMP      r2,#0xa
000056  d213              BCS      |L26.128|
000058  a805              ADD      r0,sp,#0x14
00005a  f7fffffe          BL       skip_atoi
00005e  4606              MOV      r6,r0
000060  e018              B        |L26.148|
                  |L26.98|
000062  f0450510          ORR      r5,r5,#0x10           ;772
000066  e7e2              B        |L26.46|
                  |L26.104|
000068  f0450504          ORR      r5,r5,#4              ;773
00006c  e7df              B        |L26.46|
                  |L26.110|
00006e  f0450508          ORR      r5,r5,#8              ;774
000072  e7dc              B        |L26.46|
                  |L26.116|
000074  f0450520          ORR      r5,r5,#0x20           ;775
000078  e7d9              B        |L26.46|
                  |L26.122|
00007a  f0450501          ORR      r5,r5,#1              ;776
00007e  e7d6              B        |L26.46|
                  |L26.128|
;;;783            else if (*fmt == '*')
000080  282a              CMP      r0,#0x2a
000082  d107              BNE      |L26.148|
000084  1c49              ADDS     r1,r1,#1
;;;784            {
;;;785                ++ fmt;
;;;786                /* it's the next argument */
;;;787                field_width = va_arg(args, int);
000086  9105              STR      r1,[sp,#0x14]
000088  cf40              LDM      r7!,{r6}
;;;788                if (field_width < 0)
00008a  2e00              CMP      r6,#0
00008c  da02              BGE      |L26.148|
;;;789                {
;;;790                    field_width = -field_width;
00008e  4276              RSBS     r6,r6,#0
;;;791                    flags |= LEFT;
000090  f0450510          ORR      r5,r5,#0x10
                  |L26.148|
;;;792                }
;;;793            }
;;;794    
;;;795    #ifdef RT_PRINTF_PRECISION
;;;796            /* get the precision */
;;;797            precision = -1;
;;;798            if (*fmt == '.')
000094  9805              LDR      r0,[sp,#0x14]
000096  464b              MOV      r3,r9                 ;797
000098  7801              LDRB     r1,[r0,#0]
00009a  292e              CMP      r1,#0x2e
00009c  d113              BNE      |L26.198|
00009e  1c40              ADDS     r0,r0,#1
;;;799            {
;;;800                ++ fmt;
;;;801                if (isdigit(*fmt)) precision = skip_atoi(&fmt);
0000a0  9005              STR      r0,[sp,#0x14]
0000a2  7801              LDRB     r1,[r0,#0]
0000a4  f1a10230          SUB      r2,r1,#0x30
0000a8  2a0a              CMP      r2,#0xa
0000aa  d204              BCS      |L26.182|
0000ac  a805              ADD      r0,sp,#0x14
0000ae  f7fffffe          BL       skip_atoi
0000b2  4603              MOV      r3,r0
0000b4  e004              B        |L26.192|
                  |L26.182|
;;;802                else if (*fmt == '*')
0000b6  292a              CMP      r1,#0x2a
0000b8  d104              BNE      |L26.196|
0000ba  1c40              ADDS     r0,r0,#1
;;;803                {
;;;804                    ++ fmt;
;;;805                    /* it's the next argument */
;;;806                    precision = va_arg(args, int);
0000bc  9005              STR      r0,[sp,#0x14]
0000be  cf08              LDM      r7!,{r3}
                  |L26.192|
;;;807                }
;;;808                if (precision < 0) precision = 0;
0000c0  2b00              CMP      r3,#0
0000c2  da00              BGE      |L26.198|
                  |L26.196|
0000c4  2300              MOVS     r3,#0
                  |L26.198|
;;;809            }
;;;810    #endif
;;;811            /* get the conversion qualifier */
;;;812            qualifier = 0;
;;;813    #ifdef RT_PRINTF_LONGLONG
;;;814            if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
;;;815    #else
;;;816            if (*fmt == 'h' || *fmt == 'l')
0000c6  9a05              LDR      r2,[sp,#0x14]
0000c8  2100              MOVS     r1,#0                 ;812
0000ca  7810              LDRB     r0,[r2,#0]
0000cc  2868              CMP      r0,#0x68
0000ce  d001              BEQ      |L26.212|
0000d0  286c              CMP      r0,#0x6c
0000d2  d102              BNE      |L26.218|
                  |L26.212|
;;;817    #endif
;;;818            {
;;;819                qualifier = *fmt;
0000d4  1c52              ADDS     r2,r2,#1
0000d6  4601              MOV      r1,r0
;;;820                ++ fmt;
0000d8  9205              STR      r2,[sp,#0x14]
                  |L26.218|
;;;821    #ifdef RT_PRINTF_LONGLONG
;;;822                if (qualifier == 'l' && *fmt == 'l')
;;;823                {
;;;824                    qualifier = 'L';
;;;825                    ++ fmt;
;;;826                }
;;;827    #endif
;;;828            }
;;;829    
;;;830            /* the default base */
;;;831            base = 10;
;;;832    
;;;833            switch (*fmt)
0000da  7810              LDRB     r0,[r2,#0]
0000dc  f04f0c0a          MOV      r12,#0xa              ;831
0000e0  286f              CMP      r0,#0x6f
0000e2  d07d              BEQ      |L26.480|
0000e4  dc0c              BGT      |L26.256|
0000e6  2863              CMP      r0,#0x63
0000e8  d01e              BEQ      |L26.296|
0000ea  dc04              BGT      |L26.246|
0000ec  2825              CMP      r0,#0x25
0000ee  d073              BEQ      |L26.472|
0000f0  2858              CMP      r0,#0x58
0000f2  d10d              BNE      |L26.272|
0000f4  e077              B        |L26.486|
                  |L26.246|
0000f6  2864              CMP      r0,#0x64
0000f8  d07a              BEQ      |L26.496|
0000fa  2869              CMP      r0,#0x69
0000fc  d108              BNE      |L26.272|
0000fe  e077              B        |L26.496|
                  |L26.256|
000100  2870              CMP      r0,#0x70
000102  d05c              BEQ      |L26.446|
000104  2873              CMP      r0,#0x73
000106  d029              BEQ      |L26.348|
000108  2875              CMP      r0,#0x75
00010a  d073              BEQ      |L26.500|
00010c  2878              CMP      r0,#0x78
00010e  d06c              BEQ      |L26.490|
                  |L26.272|
;;;834            {
;;;835            case 'c':
;;;836                if (!(flags & LEFT))
;;;837                {
;;;838                    while (--field_width > 0)
;;;839                    {
;;;840                        if (str <= end) *str = ' ';
;;;841                        ++ str;
;;;842                    }
;;;843                }
;;;844    
;;;845                /* get character */
;;;846                c = (rt_uint8_t)va_arg(args, int);
;;;847                if (str <= end) *str = c;
;;;848                ++ str;
;;;849    
;;;850                /* put width */
;;;851                while (--field_width > 0)
;;;852                {
;;;853                    if (str <= end) *str = ' ';
;;;854                    ++ str;
;;;855                }
;;;856                continue;
;;;857    
;;;858            case 's':
;;;859                s = va_arg(args, char *);
;;;860                if (!s) s = "(NULL)";
;;;861    
;;;862                len = rt_strlen(s);
;;;863    #ifdef RT_PRINTF_PRECISION
;;;864                if (precision > 0 && len > precision) len = precision;
;;;865    #endif
;;;866    
;;;867                if (!(flags & LEFT))
;;;868                {
;;;869                    while (len < field_width--)
;;;870                    {
;;;871                        if (str <= end) *str = ' ';
;;;872                        ++ str;
;;;873                    }
;;;874                }
;;;875    
;;;876                for (i = 0; i < len; ++i)
;;;877                {
;;;878                    if (str <= end) *str = *s;
;;;879                    ++ str;
;;;880                    ++ s;
;;;881                }
;;;882    
;;;883                while (len < field_width--)
;;;884                {
;;;885                    if (str <= end) *str = ' ';
;;;886                    ++ str;
;;;887                }
;;;888                continue;
;;;889    
;;;890            case 'p':
;;;891                if (field_width == -1)
;;;892                {
;;;893                    field_width = sizeof(void *) << 1;
;;;894                    flags |= ZEROPAD;
;;;895                }
;;;896    #ifdef RT_PRINTF_PRECISION
;;;897                str = print_number(str, end,
;;;898                                   (long)va_arg(args, void *),
;;;899                                   16, field_width, precision, flags);
;;;900    #else
;;;901                str = print_number(str, end,
;;;902                                   (long)va_arg(args, void *),
;;;903                                   16, field_width, flags);
;;;904    #endif
;;;905                continue;
;;;906    
;;;907            case '%':
;;;908                if (str <= end) *str = '%';
;;;909                ++ str;
;;;910                continue;
;;;911    
;;;912                /* integer number formats - set up the flags and "break" */
;;;913            case 'o':
;;;914                base = 8;
;;;915                break;
;;;916    
;;;917            case 'X':
;;;918                flags |= LARGE;
;;;919            case 'x':
;;;920                base = 16;
;;;921                break;
;;;922    
;;;923            case 'd':
;;;924            case 'i':
;;;925                flags |= SIGN;
;;;926            case 'u':
;;;927                break;
;;;928    
;;;929            default:
;;;930                if (str <= end) *str = '%';
000110  4544              CMP      r4,r8
000112  d801              BHI      |L26.280|
000114  2025              MOVS     r0,#0x25
000116  7020              STRB     r0,[r4,#0]
                  |L26.280|
;;;931                ++ str;
;;;932    
;;;933                if (*fmt)
000118  9905              LDR      r1,[sp,#0x14]
00011a  1c64              ADDS     r4,r4,#1
00011c  7808              LDRB     r0,[r1,#0]
00011e  2800              CMP      r0,#0
000120  d180              BNE      |L26.36|
000122  1e49              SUBS     r1,r1,#1
;;;934                {
;;;935                    if (str <= end) *str = *fmt;
;;;936                    ++ str;
;;;937                }
;;;938                else
;;;939                {
;;;940                    -- fmt;
000124  9105              STR      r1,[sp,#0x14]
000126  e073              B        |L26.528|
                  |L26.296|
000128  06e8              LSLS     r0,r5,#27             ;836
00012a  d408              BMI      |L26.318|
00012c  4650              MOV      r0,r10                ;757
                  |L26.302|
00012e  1e76              SUBS     r6,r6,#1              ;757
000130  2e00              CMP      r6,#0                 ;838
000132  dd04              BLE      |L26.318|
000134  4544              CMP      r4,r8                 ;840
000136  d800              BHI      |L26.314|
000138  7020              STRB     r0,[r4,#0]            ;840
                  |L26.314|
00013a  1c64              ADDS     r4,r4,#1              ;840
00013c  e7f7              B        |L26.302|
                  |L26.318|
00013e  f8170b04          LDRB     r0,[r7],#4            ;846
000142  4544              CMP      r4,r8                 ;847
000144  d800              BHI      |L26.328|
000146  7020              STRB     r0,[r4,#0]            ;847
                  |L26.328|
000148  4651              MOV      r1,r10                ;757
00014a  e002              B        |L26.338|
                  |L26.332|
00014c  4544              CMP      r4,r8                 ;853
00014e  d800              BHI      |L26.338|
000150  7021              STRB     r1,[r4,#0]            ;853
                  |L26.338|
000152  1c64              ADDS     r4,r4,#1              ;853
000154  1e76              SUBS     r6,r6,#1              ;853
000156  2e00              CMP      r6,#0                 ;851
000158  dcf8              BGT      |L26.332|
00015a  e059              B        |L26.528|
                  |L26.348|
00015c  cf01              LDM      r7!,{r0}              ;859
00015e  ea5f0900          MOVS     r9,r0                 ;859
000162  4648              MOV      r0,r9                 ;860
000164  d101              BNE      |L26.362|
000166  a038              ADR      r0,|L26.584|
000168  4681              MOV      r9,r0                 ;860
                  |L26.362|
00016a  f7fffffe          BL       rt_strlen
00016e  2b00              CMP      r3,#0                 ;864
000170  dd02              BLE      |L26.376|
000172  4298              CMP      r0,r3                 ;864
000174  dd00              BLE      |L26.376|
000176  4618              MOV      r0,r3                 ;864
                  |L26.376|
000178  06e9              LSLS     r1,r5,#27             ;867
00017a  d409              BMI      |L26.400|
00017c  4652              MOV      r2,r10                ;757
                  |L26.382|
00017e  4631              MOV      r1,r6                 ;869
000180  1e76              SUBS     r6,r6,#1              ;869
000182  4281              CMP      r1,r0                 ;869
000184  dd04              BLE      |L26.400|
000186  4544              CMP      r4,r8                 ;871
000188  d800              BHI      |L26.396|
00018a  7022              STRB     r2,[r4,#0]            ;871
                  |L26.396|
00018c  1c64              ADDS     r4,r4,#1              ;871
00018e  e7f6              B        |L26.382|
                  |L26.400|
000190  2100              MOVS     r1,#0                 ;876
000192  e008              B        |L26.422|
                  |L26.404|
000194  4544              CMP      r4,r8                 ;878
000196  d802              BHI      |L26.414|
000198  f8992000          LDRB     r2,[r9,#0]            ;878
00019c  7022              STRB     r2,[r4,#0]            ;878
                  |L26.414|
00019e  1c49              ADDS     r1,r1,#1              ;880
0001a0  f1090901          ADD      r9,r9,#1              ;880
0001a4  1c64              ADDS     r4,r4,#1              ;880
                  |L26.422|
0001a6  4281              CMP      r1,r0                 ;876
0001a8  dbf4              BLT      |L26.404|
0001aa  4652              MOV      r2,r10                ;757
                  |L26.428|
0001ac  4631              MOV      r1,r6                 ;883
0001ae  1e76              SUBS     r6,r6,#1              ;883
0001b0  4281              CMP      r1,r0                 ;883
0001b2  dd2d              BLE      |L26.528|
0001b4  4544              CMP      r4,r8                 ;885
0001b6  d800              BHI      |L26.442|
0001b8  7022              STRB     r2,[r4,#0]            ;885
                  |L26.442|
0001ba  1c64              ADDS     r4,r4,#1              ;885
0001bc  e7f6              B        |L26.428|
                  |L26.446|
0001be  1c70              ADDS     r0,r6,#1              ;891
0001c0  d102              BNE      |L26.456|
0001c2  2608              MOVS     r6,#8                 ;893
0001c4  f0450501          ORR      r5,r5,#1              ;894
                  |L26.456|
0001c8  9600              STR      r6,[sp,#0]            ;897
0001ca  e9cd3501          STRD     r3,r5,[sp,#4]         ;897
0001ce  cf04              LDM      r7!,{r2}              ;897
0001d0  2310              MOVS     r3,#0x10              ;897
0001d2  e018              B        |L26.518|
0001d4  e004              B        |L26.480|
0001d6  e7ff              B        |L26.472|
                  |L26.472|
0001d8  4544              CMP      r4,r8                 ;908
0001da  d825              BHI      |L26.552|
0001dc  2025              MOVS     r0,#0x25              ;908
0001de  e723              B        |L26.40|
                  |L26.480|
0001e0  f04f0c08          MOV      r12,#8                ;914
0001e4  e006              B        |L26.500|
                  |L26.486|
0001e6  f0450540          ORR      r5,r5,#0x40           ;918
                  |L26.490|
0001ea  f04f0c10          MOV      r12,#0x10             ;920
0001ee  e001              B        |L26.500|
                  |L26.496|
0001f0  f0450502          ORR      r5,r5,#2              ;925
                  |L26.500|
;;;941                }
;;;942                continue;
;;;943            }
;;;944    
;;;945    #ifdef RT_PRINTF_LONGLONG
;;;946            if (qualifier == 'L') num = va_arg(args, long long);
;;;947            else if (qualifier == 'l')
;;;948    #else
;;;949            if (qualifier == 'l')
0001f4  296c              CMP      r1,#0x6c
0001f6  d001              BEQ      |L26.508|
;;;950    #endif
;;;951            {
;;;952                num = va_arg(args, rt_uint32_t);
;;;953                if (flags & SIGN) num = (rt_int32_t)num;
;;;954            }
;;;955            else if (qualifier == 'h')
0001f8  2968              CMP      r1,#0x68
0001fa  d017              BEQ      |L26.556|
                  |L26.508|
;;;956            {
;;;957                num = (rt_uint16_t)va_arg(args, rt_int32_t);
;;;958                if (flags & SIGN) num = (rt_int16_t)num;
;;;959            }
;;;960            else
;;;961            {
;;;962                num = va_arg(args, rt_uint32_t);
0001fc  cf04              LDM      r7!,{r2}
                  |L26.510|
;;;963                if (flags & SIGN) num = (rt_int32_t)num;
;;;964            }
;;;965    #ifdef RT_PRINTF_PRECISION
;;;966            str = print_number(str, end, num, base, field_width, precision, flags);
0001fe  9600              STR      r6,[sp,#0]
000200  e9cd3501          STRD     r3,r5,[sp,#4]
000204  4663              MOV      r3,r12
                  |L26.518|
000206  4641              MOV      r1,r8
000208  4620              MOV      r0,r4
00020a  f7fffffe          BL       print_number
00020e  4604              MOV      r4,r0
                  |L26.528|
000210  9805              LDR      r0,[sp,#0x14]         ;755
000212  1c40              ADDS     r0,r0,#1              ;755
000214  9005              STR      r0,[sp,#0x14]         ;755
                  |L26.534|
000216  9805              LDR      r0,[sp,#0x14]         ;755
000218  7800              LDRB     r0,[r0,#0]            ;755
00021a  2800              CMP      r0,#0                 ;755
00021c  f47faf00          BNE      |L26.32|
;;;967    #else
;;;968            str = print_number(str, end, num, base, field_width, flags);
;;;969    #endif
;;;970        }
;;;971    
;;;972        if (str <= end) *str = '\0';
000220  4544              CMP      r4,r8
000222  d80a              BHI      |L26.570|
000224  7020              STRB     r0,[r4,#0]
000226  e00a              B        |L26.574|
                  |L26.552|
000228  1c64              ADDS     r4,r4,#1
00022a  e7f1              B        |L26.528|
                  |L26.556|
00022c  f8370b04          LDRH     r0,[r7],#4            ;957
000230  b282              UXTH     r2,r0                 ;957
000232  07a8              LSLS     r0,r5,#30             ;958
000234  d5e3              BPL      |L26.510|
000236  b212              SXTH     r2,r2                 ;958
000238  e7e1              B        |L26.510|
                  |L26.570|
;;;973        else *end = '\0';
00023a  f8880000          STRB     r0,[r8,#0]
                  |L26.574|
;;;974    
;;;975        /* the trailing null byte doesn't count towards the total
;;;976        * ++str;
;;;977        */
;;;978        return str - buf;
;;;979    }
00023e  b007              ADD      sp,sp,#0x1c
000240  eba4000b          SUB      r0,r4,r11             ;978
000244  e8bd8ff0          POP      {r4-r11,pc}
;;;980    RTM_EXPORT(rt_vsnprintf);
                          ENDP

                  |L26.584|
000248  284e554c          DCB      "(NULL)",0
00024c  4c2900  
00024f  00                DCB      0

                          AREA ||i.rt_vsprintf||, CODE, READONLY, ALIGN=1

                  rt_vsprintf PROC
;;;1008    */
;;;1009   rt_int32_t rt_vsprintf(char *buf, const char *format, va_list arg_ptr)
000000  4613              MOV      r3,r2
;;;1010   {
;;;1011       return rt_vsnprintf(buf, (rt_size_t) -1, format, arg_ptr);
000002  460a              MOV      r2,r1
000004  f04f31ff          MOV      r1,#0xffffffff
000008  f7ffbffe          B.W      rt_vsnprintf
;;;1012   }
;;;1013   RTM_EXPORT(rt_vsprintf);
                          ENDP


                          AREA ||i.skip_atoi||, CODE, READONLY, ALIGN=1

                  skip_atoi PROC
;;;541    
;;;542    rt_inline int skip_atoi(const char **s)
000000  b510              PUSH     {r4,lr}
;;;543    {
000002  4602              MOV      r2,r0
;;;544        register int i=0;
000004  2000              MOVS     r0,#0
;;;545        while (isdigit(**s))
;;;546            i = i * 10 + *((*s)++) - '0';
000006  f06f042f          MVN      r4,#0x2f
00000a  e007              B        |L28.28|
                  |L28.12|
00000c  1c4b              ADDS     r3,r1,#1
00000e  6013              STR      r3,[r2,#0]
000010  7809              LDRB     r1,[r1,#0]
000012  eb000080          ADD      r0,r0,r0,LSL #2
000016  eb040040          ADD      r0,r4,r0,LSL #1
00001a  4408              ADD      r0,r0,r1
                  |L28.28|
00001c  6811              LDR      r1,[r2,#0]            ;545
00001e  780b              LDRB     r3,[r1,#0]            ;545
000020  3b30              SUBS     r3,r3,#0x30           ;545
000022  2b0a              CMP      r3,#0xa               ;545
000024  d3f2              BCC      |L28.12|
;;;547    
;;;548        return i;
;;;549    }
000026  bd10              POP      {r4,pc}
;;;550    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  rt_log_buf
                          %        128

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __lowest_bit_bitmap
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00
                  small_digits
000100  30313233          DCB      0x30,0x31,0x32,0x33
000104  34353637          DCB      0x34,0x35,0x36,0x37
000108  38396162          DCB      0x38,0x39,0x61,0x62
00010c  63646566          DCB      0x63,0x64,0x65,0x66
000110  00                DCB      0x00
                  large_digits
000111  303132            DCB      0x30,0x31,0x32
000114  33343536          DCB      0x33,0x34,0x35,0x36
000118  37383941          DCB      0x37,0x38,0x39,0x41
00011c  42434445          DCB      0x42,0x43,0x44,0x45
000120  4600              DCB      0x46,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  _console_device
                          DCD      0x00000000
                  _errno
                          DCD      0x00000000
