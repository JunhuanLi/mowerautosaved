; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_hash_sha1.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_hash_sha1.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_hash_sha1.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_hash_sha1.c]
                          THUMB

                          AREA ||i.HASH_SHA1||, CODE, READONLY, ALIGN=1

                  HASH_SHA1 PROC
;;;86       */
;;;87     ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;88     {
000004  b08b              SUB      sp,sp,#0x2c
;;;89       HASH_InitTypeDef SHA1_HASH_InitStructure;
;;;90       HASH_MsgDigest SHA1_MessageDigest;
;;;91       __IO uint16_t nbvalidbitsdata = 0;
000006  f04f0800          MOV      r8,#0
00000a  4616              MOV      r6,r2                 ;88
00000c  460f              MOV      r7,r1                 ;88
00000e  4604              MOV      r4,r0                 ;88
000010  f8ad8028          STRH     r8,[sp,#0x28]
;;;92       uint32_t i = 0;
;;;93       __IO uint32_t counter = 0;
;;;94       uint32_t busystatus = 0;
;;;95       ErrorStatus status = SUCCESS;
;;;96       uint32_t inputaddr  = (uint32_t)Input;
;;;97       uint32_t outputaddr = (uint32_t)Output;
;;;98     
;;;99       /* Number of valid bits in last word of the Input data */
;;;100      nbvalidbitsdata = 8 * (Ilen % 4);
000014  0788              LSLS     r0,r1,#30
000016  0ec0              LSRS     r0,r0,#27
000018  4645              MOV      r5,r8                 ;92
00001a  f04f0901          MOV      r9,#1                 ;95
00001e  f8cd8024          STR      r8,[sp,#0x24]
000022  f8ad0028          STRH     r0,[sp,#0x28]
;;;101    
;;;102      /* HASH peripheral initialization */
;;;103      HASH_DeInit();
000026  f7fffffe          BL       HASH_DeInit
;;;104    
;;;105      /* HASH Configuration */
;;;106      SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
;;;107      SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
;;;108      SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
00002a  2020              MOVS     r0,#0x20
;;;109      HASH_Init(&SHA1_HASH_InitStructure);
00002c  e9cd8006          STRD     r8,r0,[sp,#0x18]
000030  f8cd8014          STR      r8,[sp,#0x14]         ;107
000034  a805              ADD      r0,sp,#0x14
000036  f7fffffe          BL       HASH_Init
;;;110    
;;;111      /* Configure the number of valid bits in last word of the data */
;;;112      HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
00003a  f8bd0028          LDRH     r0,[sp,#0x28]
00003e  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;113    
;;;114      /* Write the Input block in the IN FIFO */
;;;115      for(i=0; i<Ilen; i+=4)
000042  e004              B        |L1.78|
                  |L1.68|
;;;116      {
;;;117        HASH_DataIn(*(uint32_t*)inputaddr);
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       HASH_DataIn
00004a  1d24              ADDS     r4,r4,#4
00004c  1d2d              ADDS     r5,r5,#4
                  |L1.78|
00004e  42bd              CMP      r5,r7                 ;115
000050  d3f8              BCC      |L1.68|
;;;118        inputaddr+=4;
;;;119      }
;;;120    
;;;121      /* Start the HASH processor */
;;;122      HASH_StartDigest();
000052  f7fffffe          BL       HASH_StartDigest
;;;123    
;;;124      /* wait until the Busy flag is RESET */
;;;125      do
;;;126      {
;;;127        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
;;;128        counter++;
;;;129      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
000056  f44f3480          MOV      r4,#0x10000
                  |L1.90|
00005a  2008              MOVS     r0,#8                 ;127
00005c  f7fffffe          BL       HASH_GetFlagStatus
000060  9909              LDR      r1,[sp,#0x24]         ;128
000062  1c49              ADDS     r1,r1,#1              ;128
000064  9109              STR      r1,[sp,#0x24]
000066  42a1              CMP      r1,r4
000068  d002              BEQ      |L1.112|
00006a  2800              CMP      r0,#0
00006c  d1f5              BNE      |L1.90|
00006e  e003              B        |L1.120|
                  |L1.112|
;;;130    
;;;131      if (busystatus != RESET)
000070  b110              CBZ      r0,|L1.120|
;;;132      {
;;;133         status = ERROR;
000072  f04f0900          MOV      r9,#0
000076  e011              B        |L1.156|
                  |L1.120|
;;;134      }
;;;135      else
;;;136      {
;;;137        /* Read the message digest */
;;;138        HASH_GetDigest(&SHA1_MessageDigest);
000078  4668              MOV      r0,sp
00007a  f7fffffe          BL       HASH_GetDigest
;;;139        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
00007e  9800              LDR      r0,[sp,#0]
000080  ba00              REV      r0,r0
;;;140        outputaddr+=4;
;;;141        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
000082  6030              STR      r0,[r6,#0]
000084  9801              LDR      r0,[sp,#4]
000086  ba00              REV      r0,r0
;;;142        outputaddr+=4;
;;;143        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
000088  6070              STR      r0,[r6,#4]
00008a  9802              LDR      r0,[sp,#8]
00008c  ba00              REV      r0,r0
;;;144        outputaddr+=4;
;;;145        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
00008e  60b0              STR      r0,[r6,#8]
000090  9803              LDR      r0,[sp,#0xc]
000092  ba00              REV      r0,r0
;;;146        outputaddr+=4;
;;;147        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
000094  60f0              STR      r0,[r6,#0xc]
000096  9804              LDR      r0,[sp,#0x10]
000098  ba00              REV      r0,r0
00009a  6130              STR      r0,[r6,#0x10]
                  |L1.156|
;;;148      }
;;;149      return status;
;;;150    }
00009c  b00b              ADD      sp,sp,#0x2c
00009e  4648              MOV      r0,r9                 ;149
0000a0  e8bd83f0          POP      {r4-r9,pc}
;;;151    
                          ENDP


                          AREA ||i.HMAC_SHA1||, CODE, READONLY, ALIGN=1

                  HMAC_SHA1 PROC
;;;162      */
;;;163    ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;164                          uint32_t Ilen, uint8_t Output[20])
;;;165    {
000004  b08d              SUB      sp,sp,#0x34
;;;166      HASH_InitTypeDef SHA1_HASH_InitStructure;
;;;167      HASH_MsgDigest SHA1_MessageDigest;
;;;168      __IO uint16_t nbvalidbitsdata = 0;
000006  f04f0b00          MOV      r11,#0
00000a  f8dd9068          LDR      r9,[sp,#0x68]
00000e  469a              MOV      r10,r3                ;165
000010  4614              MOV      r4,r2                 ;165
000012  460e              MOV      r6,r1                 ;165
000014  f8adb02c          STRH     r11,[sp,#0x2c]
;;;169      __IO uint16_t nbvalidbitskey = 0;
000018  f8adb028          STRH     r11,[sp,#0x28]
;;;170      uint32_t i = 0;
;;;171      __IO uint32_t counter = 0;
;;;172      uint32_t busystatus = 0;
;;;173      ErrorStatus status = SUCCESS;
;;;174      uint32_t keyaddr    = (uint32_t)Key;
;;;175      uint32_t inputaddr  = (uint32_t)Input;
;;;176      uint32_t outputaddr = (uint32_t)Output;
;;;177    
;;;178      /* Number of valid bits in last word of the Input data */
;;;179      nbvalidbitsdata = 8 * (Ilen % 4);
00001c  0798              LSLS     r0,r3,#30
00001e  0ec0              LSRS     r0,r0,#27
000020  9d0d              LDR      r5,[sp,#0x34]
000022  465f              MOV      r7,r11                ;170
000024  f04f0801          MOV      r8,#1                 ;173
000028  f8cdb000          STR      r11,[sp,#0]           ;174
00002c  f8ad002c          STRH     r0,[sp,#0x2c]
;;;180    
;;;181      /* Number of valid bits in last word of the Key */
;;;182      nbvalidbitskey = 8 * (Keylen % 4);
000030  0788              LSLS     r0,r1,#30
000032  0ec0              LSRS     r0,r0,#27
000034  f8ad0028          STRH     r0,[sp,#0x28]
;;;183    
;;;184      /* HASH peripheral initialization */
;;;185      HASH_DeInit();
000038  f7fffffe          BL       HASH_DeInit
;;;186    
;;;187      /* HASH Configuration */
;;;188      SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
;;;189      SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
00003c  2040              MOVS     r0,#0x40
00003e  e9cdb006          STRD     r11,r0,[sp,#0x18]
;;;190      SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
000042  2020              MOVS     r0,#0x20
;;;191      if(Keylen > 64)
000044  9008              STR      r0,[sp,#0x20]
000046  2e40              CMP      r6,#0x40
000048  d901              BLS      |L2.78|
;;;192      {
;;;193        /* HMAC long Key */
;;;194        SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
00004a  02c0              LSLS     r0,r0,#11
00004c  e000              B        |L2.80|
                  |L2.78|
;;;195      }
;;;196      else
;;;197      {
;;;198        /* HMAC short Key */
;;;199        SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
00004e  4658              MOV      r0,r11
                  |L2.80|
;;;200      }
;;;201      HASH_Init(&SHA1_HASH_InitStructure);
000050  9009              STR      r0,[sp,#0x24]
000052  a806              ADD      r0,sp,#0x18
000054  f7fffffe          BL       HASH_Init
;;;202    
;;;203      /* Configure the number of valid bits in last word of the Key */
;;;204      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
000058  f8bd0028          LDRH     r0,[sp,#0x28]
00005c  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;205    
;;;206      /* Write the Key */
;;;207      for(i=0; i<Keylen; i+=4)
000060  e004              B        |L2.108|
                  |L2.98|
;;;208      {
;;;209        HASH_DataIn(*(uint32_t*)keyaddr);
000062  6828              LDR      r0,[r5,#0]
000064  f7fffffe          BL       HASH_DataIn
000068  1d2d              ADDS     r5,r5,#4
00006a  1d3f              ADDS     r7,r7,#4
                  |L2.108|
00006c  42b7              CMP      r7,r6                 ;207
00006e  d3f8              BCC      |L2.98|
;;;210        keyaddr+=4;
;;;211      }
;;;212    
;;;213      /* Start the HASH processor */
;;;214      HASH_StartDigest();
000070  f7fffffe          BL       HASH_StartDigest
000074  f44f3580          MOV      r5,#0x10000           ;194
                  |L2.120|
;;;215    
;;;216      /* wait until the Busy flag is RESET */
;;;217      do
;;;218      {
;;;219        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
000078  2008              MOVS     r0,#8
00007a  f7fffffe          BL       HASH_GetFlagStatus
;;;220        counter++;
00007e  9900              LDR      r1,[sp,#0]
000080  1c49              ADDS     r1,r1,#1
;;;221      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
000082  9100              STR      r1,[sp,#0]
000084  42a9              CMP      r1,r5
000086  d002              BEQ      |L2.142|
000088  2800              CMP      r0,#0
00008a  d1f5              BNE      |L2.120|
00008c  e000              B        |L2.144|
                  |L2.142|
;;;222    
;;;223      if (busystatus != RESET)
00008e  bbc8              CBNZ     r0,|L2.260|
                  |L2.144|
;;;224      {
;;;225         status = ERROR;
;;;226      }
;;;227      else
;;;228      {
;;;229        /* Configure the number of valid bits in last word of the Input data */
;;;230        HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
000090  f8bd002c          LDRH     r0,[sp,#0x2c]
000094  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;231    
;;;232        /* Write the Input block in the IN FIFO */
;;;233        for(i=0; i<Ilen; i+=4)
000098  2700              MOVS     r7,#0
00009a  e004              B        |L2.166|
                  |L2.156|
;;;234        {
;;;235          HASH_DataIn(*(uint32_t*)inputaddr);
00009c  6820              LDR      r0,[r4,#0]
00009e  f7fffffe          BL       HASH_DataIn
0000a2  1d24              ADDS     r4,r4,#4
0000a4  1d3f              ADDS     r7,r7,#4
                  |L2.166|
0000a6  4557              CMP      r7,r10                ;233
0000a8  d3f8              BCC      |L2.156|
;;;236          inputaddr+=4;
;;;237        }
;;;238    
;;;239        /* Start the HASH processor */
;;;240        HASH_StartDigest();
0000aa  f7fffffe          BL       HASH_StartDigest
;;;241    
;;;242    
;;;243        /* wait until the Busy flag is RESET */
;;;244        counter =0;
0000ae  f8cdb000          STR      r11,[sp,#0]
                  |L2.178|
;;;245        do
;;;246        {
;;;247          busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
0000b2  2008              MOVS     r0,#8
0000b4  f7fffffe          BL       HASH_GetFlagStatus
;;;248          counter++;
0000b8  9900              LDR      r1,[sp,#0]
0000ba  1c49              ADDS     r1,r1,#1
;;;249        }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
0000bc  9100              STR      r1,[sp,#0]
0000be  42a9              CMP      r1,r5
0000c0  d002              BEQ      |L2.200|
0000c2  2800              CMP      r0,#0
0000c4  d1f5              BNE      |L2.178|
0000c6  e000              B        |L2.202|
                  |L2.200|
;;;250    
;;;251        if (busystatus != RESET)
0000c8  b9e0              CBNZ     r0,|L2.260|
                  |L2.202|
;;;252        {
;;;253          status = ERROR;
;;;254        }
;;;255        else
;;;256        {  
;;;257          /* Configure the number of valid bits in last word of the Key */
;;;258          HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
0000ca  f8bd0028          LDRH     r0,[sp,#0x28]
0000ce  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;259    
;;;260          /* Write the Key */
;;;261          keyaddr = (uint32_t)Key;
;;;262          for(i=0; i<Keylen; i+=4)
0000d2  2700              MOVS     r7,#0
0000d4  9c0d              LDR      r4,[sp,#0x34]
0000d6  e004              B        |L2.226|
                  |L2.216|
;;;263          {
;;;264            HASH_DataIn(*(uint32_t*)keyaddr);
0000d8  6820              LDR      r0,[r4,#0]
0000da  f7fffffe          BL       HASH_DataIn
0000de  1d24              ADDS     r4,r4,#4
0000e0  1d3f              ADDS     r7,r7,#4
                  |L2.226|
0000e2  42b7              CMP      r7,r6                 ;262
0000e4  d3f8              BCC      |L2.216|
;;;265            keyaddr+=4;
;;;266          }
;;;267    
;;;268          /* Start the HASH processor */
;;;269          HASH_StartDigest();
0000e6  f7fffffe          BL       HASH_StartDigest
;;;270    
;;;271          /* wait until the Busy flag is RESET */
;;;272          counter =0;
0000ea  f8cdb000          STR      r11,[sp,#0]
                  |L2.238|
;;;273          do
;;;274          {
;;;275            busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
0000ee  2008              MOVS     r0,#8
0000f0  f7fffffe          BL       HASH_GetFlagStatus
;;;276            counter++;
0000f4  9900              LDR      r1,[sp,#0]
0000f6  1c49              ADDS     r1,r1,#1
;;;277          }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
0000f8  9100              STR      r1,[sp,#0]
0000fa  42a9              CMP      r1,r5
0000fc  d003              BEQ      |L2.262|
0000fe  2800              CMP      r0,#0
000100  d1f5              BNE      |L2.238|
000102  e004              B        |L2.270|
                  |L2.260|
000104  e000              B        |L2.264|
                  |L2.262|
;;;278    
;;;279          if (busystatus != RESET)
000106  b110              CBZ      r0,|L2.270|
                  |L2.264|
;;;280          {
;;;281            status = ERROR;
000108  f04f0800          MOV      r8,#0
00010c  e016              B        |L2.316|
                  |L2.270|
;;;282          }
;;;283          else
;;;284          {
;;;285            /* Read the message digest */
;;;286            HASH_GetDigest(&SHA1_MessageDigest);
00010e  a801              ADD      r0,sp,#4
000110  f7fffffe          BL       HASH_GetDigest
;;;287            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
000114  9801              LDR      r0,[sp,#4]
000116  ba01              REV      r1,r0
;;;288            outputaddr+=4;
;;;289            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
000118  f8c91000          STR      r1,[r9,#0]
00011c  9902              LDR      r1,[sp,#8]
00011e  ba09              REV      r1,r1
;;;290            outputaddr+=4;
;;;291            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
000120  f8c91004          STR      r1,[r9,#4]
000124  9903              LDR      r1,[sp,#0xc]
000126  ba09              REV      r1,r1
;;;292            outputaddr+=4;
;;;293            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
000128  f8c91008          STR      r1,[r9,#8]
00012c  9904              LDR      r1,[sp,#0x10]
00012e  ba09              REV      r1,r1
;;;294            outputaddr+=4;
;;;295            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
000130  f8c9100c          STR      r1,[r9,#0xc]
000134  9905              LDR      r1,[sp,#0x14]
000136  ba09              REV      r1,r1
000138  f8c91010          STR      r1,[r9,#0x10]
                  |L2.316|
;;;296          }
;;;297        }  
;;;298      }
;;;299      return status;  
;;;300    }
00013c  b011              ADD      sp,sp,#0x44
00013e  4640              MOV      r0,r8                 ;299
000140  e8bd8ff0          POP      {r4-r11,pc}
;;;301    /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_hash_sha1.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REVSH|
#line 128
|__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
