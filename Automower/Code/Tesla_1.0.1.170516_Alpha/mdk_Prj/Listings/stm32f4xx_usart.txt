; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_usart.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_usart.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=2

                  USART_ClearFlag PROC
;;;1320     */
;;;1321   void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1322   {
;;;1323     /* Check the parameters */
;;;1324     assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4e1b              LDR      r6,|L1.116|
000006  4f1c              LDR      r7,|L1.120|
000008  f8df8070          LDR      r8,|L1.124|
00000c  f8df9070          LDR      r9,|L1.128|
000010  460d              MOV      r5,r1                 ;1322
000012  4604              MOV      r4,r0                 ;1322
000014  42b0              CMP      r0,r6
000016  d010              BEQ      |L1.58|
000018  42bc              CMP      r4,r7
00001a  d00e              BEQ      |L1.58|
00001c  4544              CMP      r4,r8
00001e  d00c              BEQ      |L1.58|
000020  4818              LDR      r0,|L1.132|
000022  4284              CMP      r4,r0
000024  d009              BEQ      |L1.58|
000026  4818              LDR      r0,|L1.136|
000028  4284              CMP      r4,r0
00002a  d006              BEQ      |L1.58|
00002c  454c              CMP      r4,r9
00002e  d004              BEQ      |L1.58|
000030  f240512c          MOV      r1,#0x52c
000034  4815              LDR      r0,|L1.140|
000036  f7fffffe          BL       assert_failed
                  |L1.58|
;;;1325     assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
00003a  f4357058          BICS     r0,r5,#0x360
00003e  d100              BNE      |L1.66|
000040  b925              CBNZ     r5,|L1.76|
                  |L1.66|
000042  f240512d          MOV      r1,#0x52d
000046  4811              LDR      r0,|L1.140|
000048  f7fffffe          BL       assert_failed
                  |L1.76|
;;;1326   
;;;1327     /* The CTS flag is not available for UART4 and UART5 */
;;;1328     if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
00004c  05a8              LSLS     r0,r5,#22
00004e  d50c              BPL      |L1.106|
;;;1329     {
;;;1330       assert_param(IS_USART_1236_PERIPH(USARTx));
000050  42b4              CMP      r4,r6
000052  d00a              BEQ      |L1.106|
000054  42bc              CMP      r4,r7
000056  d008              BEQ      |L1.106|
000058  4544              CMP      r4,r8
00005a  d006              BEQ      |L1.106|
00005c  454c              CMP      r4,r9
00005e  d004              BEQ      |L1.106|
000060  f2405132          MOV      r1,#0x532
000064  4809              LDR      r0,|L1.140|
000066  f7fffffe          BL       assert_failed
                  |L1.106|
;;;1331     } 
;;;1332          
;;;1333     USARTx->SR = (uint16_t)~USART_FLAG;
00006a  43e8              MVNS     r0,r5
00006c  8020              STRH     r0,[r4,#0]
;;;1334   }
00006e  e8bd87f0          POP      {r4-r10,pc}
;;;1335   
                          ENDP

000072  0000              DCW      0x0000
                  |L1.116|
                          DCD      0x40011000
                  |L1.120|
                          DCD      0x40004400
                  |L1.124|
                          DCD      0x40004800
                  |L1.128|
                          DCD      0x40011400
                  |L1.132|
                          DCD      0x40004c00
                  |L1.136|
                          DCD      0x40005000
                  |L1.140|
                          DCD      ||.conststring||

                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  USART_ClearITPendingBit PROC
;;;1428     */
;;;1429   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1430   {
;;;1431     uint16_t bitpos = 0x00, itmask = 0x00;
;;;1432     /* Check the parameters */
;;;1433     assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4e22              LDR      r6,|L2.144|
000006  4f23              LDR      r7,|L2.148|
000008  f8df908c          LDR      r9,|L2.152|
00000c  f8dfa08c          LDR      r10,|L2.156|
000010  460d              MOV      r5,r1                 ;1430
000012  4604              MOV      r4,r0                 ;1430
000014  42b0              CMP      r0,r6
000016  d010              BEQ      |L2.58|
000018  42bc              CMP      r4,r7
00001a  d00e              BEQ      |L2.58|
00001c  454c              CMP      r4,r9
00001e  d00c              BEQ      |L2.58|
000020  481f              LDR      r0,|L2.160|
000022  4284              CMP      r4,r0
000024  d009              BEQ      |L2.58|
000026  481f              LDR      r0,|L2.164|
000028  4284              CMP      r4,r0
00002a  d006              BEQ      |L2.58|
00002c  4554              CMP      r4,r10
00002e  d004              BEQ      |L2.58|
000030  f2405199          MOV      r1,#0x599
000034  481c              LDR      r0,|L2.168|
000036  f7fffffe          BL       assert_failed
                  |L2.58|
;;;1434     assert_param(IS_USART_CLEAR_IT(USART_IT)); 
00003a  f5a560c0          SUB      r0,r5,#0x600
00003e  f640186a          MOV      r8,#0x96a
000042  3826              SUBS     r0,r0,#0x26
000044  d00e              BEQ      |L2.100|
000046  f5a560a0          SUB      r0,r5,#0x500
00004a  3825              SUBS     r0,r0,#0x25
00004c  d00a              BEQ      |L2.100|
00004e  f5a56000          SUB      r0,r5,#0x800
000052  3846              SUBS     r0,r0,#0x46
000054  d006              BEQ      |L2.100|
000056  4545              CMP      r5,r8
000058  d004              BEQ      |L2.100|
00005a  f240519a          MOV      r1,#0x59a
00005e  4812              LDR      r0,|L2.168|
000060  f7fffffe          BL       assert_failed
                  |L2.100|
;;;1435   
;;;1436     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1437     if (USART_IT == USART_IT_CTS)
000064  4545              CMP      r5,r8
000066  d10c              BNE      |L2.130|
;;;1438     {
;;;1439       assert_param(IS_USART_1236_PERIPH(USARTx));
000068  42b4              CMP      r4,r6
00006a  d00a              BEQ      |L2.130|
00006c  42bc              CMP      r4,r7
00006e  d008              BEQ      |L2.130|
000070  454c              CMP      r4,r9
000072  d006              BEQ      |L2.130|
000074  4554              CMP      r4,r10
000076  d004              BEQ      |L2.130|
000078  f240519f          MOV      r1,#0x59f
00007c  480a              LDR      r0,|L2.168|
00007e  f7fffffe          BL       assert_failed
                  |L2.130|
;;;1440     } 
;;;1441       
;;;1442     bitpos = USART_IT >> 0x08;
000082  0a29              LSRS     r1,r5,#8
;;;1443     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
000084  2001              MOVS     r0,#1
000086  4088              LSLS     r0,r0,r1
;;;1444     USARTx->SR = (uint16_t)~itmask;
000088  43c0              MVNS     r0,r0
00008a  8020              STRH     r0,[r4,#0]
;;;1445   }
00008c  e8bd87f0          POP      {r4-r10,pc}
;;;1446   
                          ENDP

                  |L2.144|
                          DCD      0x40011000
                  |L2.148|
                          DCD      0x40004400
                  |L2.152|
                          DCD      0x40004800
                  |L2.156|
                          DCD      0x40011400
                  |L2.160|
                          DCD      0x40004c00
                  |L2.164|
                          DCD      0x40005000
                  |L2.168|
                          DCD      ||.conststring||

                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=2

                  USART_ClockInit PROC
;;;359      */
;;;360    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;361    {
000002  4605              MOV      r5,r0
;;;362      uint32_t tmpreg = 0x00;
;;;363      /* Check the parameters */
;;;364      assert_param(IS_USART_1236_PERIPH(USARTx));
000004  4823              LDR      r0,|L3.148|
000006  460c              MOV      r4,r1                 ;361
000008  4285              CMP      r5,r0
00000a  d00d              BEQ      |L3.40|
00000c  4822              LDR      r0,|L3.152|
00000e  4285              CMP      r5,r0
000010  d00a              BEQ      |L3.40|
000012  4822              LDR      r0,|L3.156|
000014  4285              CMP      r5,r0
000016  d007              BEQ      |L3.40|
000018  4821              LDR      r0,|L3.160|
00001a  4285              CMP      r5,r0
00001c  d004              BEQ      |L3.40|
00001e  f44f71b6          MOV      r1,#0x16c
000022  4820              LDR      r0,|L3.164|
000024  f7fffffe          BL       assert_failed
                  |L3.40|
;;;365      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
000028  8820              LDRH     r0,[r4,#0]
00002a  b138              CBZ      r0,|L3.60|
00002c  f5b06f00          CMP      r0,#0x800
000030  d004              BEQ      |L3.60|
000032  f240116d          MOV      r1,#0x16d
000036  481b              LDR      r0,|L3.164|
000038  f7fffffe          BL       assert_failed
                  |L3.60|
;;;366      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
00003c  8860              LDRH     r0,[r4,#2]
00003e  b138              CBZ      r0,|L3.80|
000040  f5b06f80          CMP      r0,#0x400
000044  d004              BEQ      |L3.80|
000046  f44f71b7          MOV      r1,#0x16e
00004a  4816              LDR      r0,|L3.164|
00004c  f7fffffe          BL       assert_failed
                  |L3.80|
;;;367      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
000050  88a0              LDRH     r0,[r4,#4]
000052  b138              CBZ      r0,|L3.100|
000054  f5b07f00          CMP      r0,#0x200
000058  d004              BEQ      |L3.100|
00005a  f240116f          MOV      r1,#0x16f
00005e  4811              LDR      r0,|L3.164|
000060  f7fffffe          BL       assert_failed
                  |L3.100|
;;;368      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
000064  88e0              LDRH     r0,[r4,#6]
000066  b138              CBZ      r0,|L3.120|
000068  f5b07f80          CMP      r0,#0x100
00006c  d004              BEQ      |L3.120|
00006e  f44f71b8          MOV      r1,#0x170
000072  480c              LDR      r0,|L3.164|
000074  f7fffffe          BL       assert_failed
                  |L3.120|
;;;369      
;;;370    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;371      tmpreg = USARTx->CR2;
000078  8a28              LDRH     r0,[r5,#0x10]
;;;372      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;373      tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
;;;374      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;375      /* Set CLKEN bit according to USART_Clock value */
;;;376      /* Set CPOL bit according to USART_CPOL value */
;;;377      /* Set CPHA bit according to USART_CPHA value */
;;;378      /* Set LBCL bit according to USART_LastBit value */
;;;379      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00007a  8862              LDRH     r2,[r4,#2]
00007c  f4206170          BIC      r1,r0,#0xf00          ;373
000080  8820              LDRH     r0,[r4,#0]
000082  88e3              LDRH     r3,[r4,#6]
000084  4310              ORRS     r0,r0,r2
000086  88a2              LDRH     r2,[r4,#4]
000088  431a              ORRS     r2,r2,r3
00008a  4310              ORRS     r0,r0,r2
00008c  4308              ORRS     r0,r0,r1
;;;380                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;381      /* Write to USART CR2 */
;;;382      USARTx->CR2 = (uint16_t)tmpreg;
00008e  8228              STRH     r0,[r5,#0x10]
;;;383    }
000090  bd70              POP      {r4-r6,pc}
;;;384    
                          ENDP

000092  0000              DCW      0x0000
                  |L3.148|
                          DCD      0x40011000
                  |L3.152|
                          DCD      0x40004400
                  |L3.156|
                          DCD      0x40004800
                  |L3.160|
                          DCD      0x40011400
                  |L3.164|
                          DCD      ||.conststring||

                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;390      */
;;;391    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;392    {
;;;393      /* USART_ClockInitStruct members default value */
;;;394      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;395      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;396      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;397      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;398    }
00000a  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=2

                  USART_Cmd PROC
;;;407      */
;;;408    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;409    {
000002  4604              MOV      r4,r0
;;;410      /* Check the parameters */
;;;411      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4814              LDR      r0,|L5.88|
000006  460d              MOV      r5,r1                 ;409
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L5.52|
00000c  4813              LDR      r0,|L5.92|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L5.52|
000012  4813              LDR      r0,|L5.96|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L5.52|
000018  4812              LDR      r0,|L5.100|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L5.52|
00001e  4812              LDR      r0,|L5.104|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L5.52|
000024  4811              LDR      r0,|L5.108|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L5.52|
00002a  f240119b          MOV      r1,#0x19b
00002e  4810              LDR      r0,|L5.112|
000030  f7fffffe          BL       assert_failed
                  |L5.52|
;;;412      assert_param(IS_FUNCTIONAL_STATE(NewState));
000034  b155              CBZ      r5,|L5.76|
000036  2d01              CMP      r5,#1
000038  d004              BEQ      |L5.68|
00003a  f44f71ce          MOV      r1,#0x19c
00003e  480c              LDR      r0,|L5.112|
000040  f7fffffe          BL       assert_failed
                  |L5.68|
;;;413      
;;;414      if (NewState != DISABLE)
;;;415      {
;;;416        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;417        USARTx->CR1 |= USART_CR1_UE;
000044  89a0              LDRH     r0,[r4,#0xc]
000046  f4405000          ORR      r0,r0,#0x2000
00004a  e002              B        |L5.82|
                  |L5.76|
;;;418      }
;;;419      else
;;;420      {
;;;421        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;422        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
00004c  89a0              LDRH     r0,[r4,#0xc]
00004e  f4205000          BIC      r0,r0,#0x2000
                  |L5.82|
000052  81a0              STRH     r0,[r4,#0xc]          ;417
;;;423      }
;;;424    }
000054  bd70              POP      {r4-r6,pc}
;;;425    
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      0x40011000
                  |L5.92|
                          DCD      0x40004400
                  |L5.96|
                          DCD      0x40004800
                  |L5.100|
                          DCD      0x40004c00
                  |L5.104|
                          DCD      0x40005000
                  |L5.108|
                          DCD      0x40011400
                  |L5.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=2

                  USART_DMACmd PROC
;;;1079     */
;;;1080   void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1081   {
000002  4604              MOV      r4,r0
;;;1082     /* Check the parameters */
;;;1083     assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4818              LDR      r0,|L6.104|
000006  4616              MOV      r6,r2                 ;1081
000008  460d              MOV      r5,r1                 ;1081
00000a  4284              CMP      r4,r0
00000c  d013              BEQ      |L6.54|
00000e  4817              LDR      r0,|L6.108|
000010  4284              CMP      r4,r0
000012  d010              BEQ      |L6.54|
000014  4816              LDR      r0,|L6.112|
000016  4284              CMP      r4,r0
000018  d00d              BEQ      |L6.54|
00001a  4816              LDR      r0,|L6.116|
00001c  4284              CMP      r4,r0
00001e  d00a              BEQ      |L6.54|
000020  4815              LDR      r0,|L6.120|
000022  4284              CMP      r4,r0
000024  d007              BEQ      |L6.54|
000026  4815              LDR      r0,|L6.124|
000028  4284              CMP      r4,r0
00002a  d004              BEQ      |L6.54|
00002c  f240413b          MOV      r1,#0x43b
000030  4813              LDR      r0,|L6.128|
000032  f7fffffe          BL       assert_failed
                  |L6.54|
;;;1084     assert_param(IS_USART_DMAREQ(USART_DMAReq));  
000036  f03500c0          BICS     r0,r5,#0xc0
00003a  d100              BNE      |L6.62|
00003c  b925              CBNZ     r5,|L6.72|
                  |L6.62|
00003e  f240413c          MOV      r1,#0x43c
000042  480f              LDR      r0,|L6.128|
000044  f7fffffe          BL       assert_failed
                  |L6.72|
;;;1085     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
000048  b14e              CBZ      r6,|L6.94|
00004a  2e01              CMP      r6,#1
00004c  d004              BEQ      |L6.88|
00004e  f240413d          MOV      r1,#0x43d
000052  480b              LDR      r0,|L6.128|
000054  f7fffffe          BL       assert_failed
                  |L6.88|
;;;1086   
;;;1087     if (NewState != DISABLE)
;;;1088     {
;;;1089       /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;1090          DMAR bits in the USART CR3 register */
;;;1091       USARTx->CR3 |= USART_DMAReq;
000058  8aa0              LDRH     r0,[r4,#0x14]
00005a  4328              ORRS     r0,r0,r5
00005c  e001              B        |L6.98|
                  |L6.94|
;;;1092     }
;;;1093     else
;;;1094     {
;;;1095       /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;1096          DMAR bits in the USART CR3 register */
;;;1097       USARTx->CR3 &= (uint16_t)~USART_DMAReq;
00005e  8aa0              LDRH     r0,[r4,#0x14]
000060  43a8              BICS     r0,r0,r5
                  |L6.98|
000062  82a0              STRH     r0,[r4,#0x14]         ;1091
;;;1098     }
;;;1099   }
000064  bd70              POP      {r4-r6,pc}
;;;1100   
                          ENDP

000066  0000              DCW      0x0000
                  |L6.104|
                          DCD      0x40011000
                  |L6.108|
                          DCD      0x40004400
                  |L6.112|
                          DCD      0x40004800
                  |L6.116|
                          DCD      0x40004c00
                  |L6.120|
                          DCD      0x40005000
                  |L6.124|
                          DCD      0x40011400
                  |L6.128|
                          DCD      ||.conststring||

                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;177      */
;;;178    void USART_DeInit(USART_TypeDef* USARTx)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;179    {
;;;180      /* Check the parameters */
;;;181      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4d26              LDR      r5,|L7.160|
000006  4e27              LDR      r6,|L7.164|
000008  4f27              LDR      r7,|L7.168|
00000a  f8df80a0          LDR      r8,|L7.172|
00000e  f8df90a0          LDR      r9,|L7.176|
000012  f8dfa0a0          LDR      r10,|L7.180|
000016  4604              MOV      r4,r0                 ;179
000018  42a8              CMP      r0,r5
00001a  d00d              BEQ      |L7.56|
00001c  42b4              CMP      r4,r6
00001e  d00b              BEQ      |L7.56|
000020  42bc              CMP      r4,r7
000022  d009              BEQ      |L7.56|
000024  4544              CMP      r4,r8
000026  d007              BEQ      |L7.56|
000028  454c              CMP      r4,r9
00002a  d005              BEQ      |L7.56|
00002c  4554              CMP      r4,r10
00002e  d003              BEQ      |L7.56|
000030  21b5              MOVS     r1,#0xb5
000032  4821              LDR      r0,|L7.184|
000034  f7fffffe          BL       assert_failed
                  |L7.56|
;;;182    
;;;183      if (USARTx == USART1)
000038  42ac              CMP      r4,r5
00003a  d106              BNE      |L7.74|
;;;184      {
;;;185        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  2010              MOVS     r0,#0x10
000040  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;186        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000044  2100              MOVS     r1,#0
000046  2010              MOVS     r0,#0x10
000048  e023              B        |L7.146|
                  |L7.74|
;;;187      }
;;;188      else if (USARTx == USART2)
00004a  42b4              CMP      r4,r6
00004c  d102              BNE      |L7.84|
;;;189      {
;;;190        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
00004e  2101              MOVS     r1,#1
000050  044c              LSLS     r4,r1,#17
;;;191        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000052  e00d              B        |L7.112|
                  |L7.84|
;;;192      }
;;;193      else if (USARTx == USART3)
000054  42bc              CMP      r4,r7
000056  d102              BNE      |L7.94|
;;;194      {
;;;195        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000058  2101              MOVS     r1,#1
00005a  048c              LSLS     r4,r1,#18
;;;196        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
00005c  e008              B        |L7.112|
                  |L7.94|
;;;197      }    
;;;198      else if (USARTx == UART4)
00005e  4544              CMP      r4,r8
000060  d102              BNE      |L7.104|
;;;199      {
;;;200        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000062  2101              MOVS     r1,#1
000064  04cc              LSLS     r4,r1,#19
;;;201        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000066  e003              B        |L7.112|
                  |L7.104|
;;;202      }
;;;203      else if (USARTx == UART5)
000068  454c              CMP      r4,r9
00006a  d10a              BNE      |L7.130|
;;;204      {
;;;205        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  050c              LSLS     r4,r1,#20
                  |L7.112|
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;206        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000076  4620              MOV      r0,r4
000078  e8bd47f0          POP      {r4-r10,lr}
00007c  2100              MOVS     r1,#0
00007e  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.130|
;;;207      }     
;;;208      else
;;;209      {
;;;210        if (USARTx == USART6)
000082  4554              CMP      r4,r10
000084  d109              BNE      |L7.154|
;;;211        { 
;;;212          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
000086  2101              MOVS     r1,#1
000088  2020              MOVS     r0,#0x20
00008a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;213          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
00008e  2100              MOVS     r1,#0
000090  2020              MOVS     r0,#0x20
                  |L7.146|
000092  e8bd47f0          POP      {r4-r10,lr}
000096  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L7.154|
;;;214        }
;;;215      }
;;;216    }
00009a  e8bd87f0          POP      {r4-r10,pc}
;;;217    
                          ENDP

00009e  0000              DCW      0x0000
                  |L7.160|
                          DCD      0x40011000
                  |L7.164|
                          DCD      0x40004400
                  |L7.168|
                          DCD      0x40004800
                  |L7.172|
                          DCD      0x40004c00
                  |L7.176|
                          DCD      0x40005000
                  |L7.180|
                          DCD      0x40011400
                  |L7.184|
                          DCD      ||.conststring||

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  USART_GetFlagStatus PROC
;;;1271     */
;;;1272   FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1273   {
;;;1274     FlagStatus bitstatus = RESET;
;;;1275     /* Check the parameters */
;;;1276     assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4f24              LDR      r7,|L8.152|
000006  2600              MOVS     r6,#0                 ;1274
000008  f8df8090          LDR      r8,|L8.156|
00000c  f8df9090          LDR      r9,|L8.160|
000010  f8dfa090          LDR      r10,|L8.164|
000014  460c              MOV      r4,r1                 ;1273
000016  4605              MOV      r5,r0                 ;1273
000018  42b8              CMP      r0,r7
00001a  d010              BEQ      |L8.62|
00001c  4545              CMP      r5,r8
00001e  d00e              BEQ      |L8.62|
000020  454d              CMP      r5,r9
000022  d00c              BEQ      |L8.62|
000024  4820              LDR      r0,|L8.168|
000026  4285              CMP      r5,r0
000028  d009              BEQ      |L8.62|
00002a  4820              LDR      r0,|L8.172|
00002c  4285              CMP      r5,r0
00002e  d006              BEQ      |L8.62|
000030  4555              CMP      r5,r10
000032  d004              BEQ      |L8.62|
000034  f24041fc          MOV      r1,#0x4fc
000038  481d              LDR      r0,|L8.176|
00003a  f7fffffe          BL       assert_failed
                  |L8.62|
;;;1277     assert_param(IS_USART_FLAG(USART_FLAG));
00003e  2c01              CMP      r4,#1
000040  d023              BEQ      |L8.138|
000042  2c80              CMP      r4,#0x80
000044  d021              BEQ      |L8.138|
000046  2c40              CMP      r4,#0x40
000048  d01f              BEQ      |L8.138|
00004a  2c20              CMP      r4,#0x20
00004c  d01d              BEQ      |L8.138|
00004e  2c10              CMP      r4,#0x10
000050  d01b              BEQ      |L8.138|
000052  f5b47f80          CMP      r4,#0x100
000056  d018              BEQ      |L8.138|
000058  f5b47f00          CMP      r4,#0x200
00005c  d008              BEQ      |L8.112|
00005e  2c08              CMP      r4,#8
000060  d013              BEQ      |L8.138|
000062  2c04              CMP      r4,#4
000064  d011              BEQ      |L8.138|
000066  2c02              CMP      r4,#2
000068  d00f              BEQ      |L8.138|
00006a  f24041fd          MOV      r1,#0x4fd
00006e  e009              B        |L8.132|
                  |L8.112|
;;;1278   
;;;1279     /* The CTS flag is not available for UART4 and UART5 */
;;;1280     if (USART_FLAG == USART_FLAG_CTS)
;;;1281     {
;;;1282       assert_param(IS_USART_1236_PERIPH(USARTx));
000070  42bd              CMP      r5,r7
000072  d00a              BEQ      |L8.138|
000074  4545              CMP      r5,r8
000076  d008              BEQ      |L8.138|
000078  454d              CMP      r5,r9
00007a  d006              BEQ      |L8.138|
00007c  4555              CMP      r5,r10
00007e  d004              BEQ      |L8.138|
000080  f2405102          MOV      r1,#0x502
                  |L8.132|
000084  480a              LDR      r0,|L8.176|
000086  f7fffffe          BL       assert_failed
                  |L8.138|
;;;1283     } 
;;;1284       
;;;1285     if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
00008a  8828              LDRH     r0,[r5,#0]
00008c  4220              TST      r0,r4
00008e  d000              BEQ      |L8.146|
;;;1286     {
;;;1287       bitstatus = SET;
000090  2601              MOVS     r6,#1
                  |L8.146|
;;;1288     }
;;;1289     else
;;;1290     {
;;;1291       bitstatus = RESET;
;;;1292     }
;;;1293     return bitstatus;
000092  4630              MOV      r0,r6
;;;1294   }
000094  e8bd87f0          POP      {r4-r10,pc}
;;;1295   
                          ENDP

                  |L8.152|
                          DCD      0x40011000
                  |L8.156|
                          DCD      0x40004400
                  |L8.160|
                          DCD      0x40004800
                  |L8.164|
                          DCD      0x40011400
                  |L8.168|
                          DCD      0x40004c00
                  |L8.172|
                          DCD      0x40005000
                  |L8.176|
                          DCD      ||.conststring||

                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=2

                  USART_GetITStatus PROC
;;;1354     */
;;;1355   ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1356   {
;;;1357     uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;1358     ITStatus bitstatus = RESET;
;;;1359     /* Check the parameters */
;;;1360     assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4f3a              LDR      r7,|L9.240|
000006  2600              MOVS     r6,#0                 ;1358
000008  f8df80e8          LDR      r8,|L9.244|
00000c  f8dfa0e8          LDR      r10,|L9.248|
000010  f8dfb0e8          LDR      r11,|L9.252|
000014  460c              MOV      r4,r1                 ;1356
000016  4605              MOV      r5,r0                 ;1356
000018  42b8              CMP      r0,r7
00001a  d010              BEQ      |L9.62|
00001c  4545              CMP      r5,r8
00001e  d00e              BEQ      |L9.62|
000020  4555              CMP      r5,r10
000022  d00c              BEQ      |L9.62|
000024  4836              LDR      r0,|L9.256|
000026  4285              CMP      r5,r0
000028  d009              BEQ      |L9.62|
00002a  4836              LDR      r0,|L9.260|
00002c  4285              CMP      r5,r0
00002e  d006              BEQ      |L9.62|
000030  455d              CMP      r5,r11
000032  d004              BEQ      |L9.62|
000034  f44f61aa          MOV      r1,#0x550
000038  4833              LDR      r0,|L9.264|
00003a  f7fffffe          BL       assert_failed
                  |L9.62|
;;;1361     assert_param(IS_USART_GET_IT(USART_IT)); 
00003e  2c28              CMP      r4,#0x28
000040  d038              BEQ      |L9.180|
000042  f5a460e0          SUB      r0,r4,#0x700
000046  f640196a          MOV      r9,#0x96a
00004a  3827              SUBS     r0,r0,#0x27
00004c  d023              BEQ      |L9.150|
00004e  f5a460c0          SUB      r0,r4,#0x600
000052  3826              SUBS     r0,r0,#0x26
000054  d01f              BEQ      |L9.150|
000056  f5a460a0          SUB      r0,r4,#0x500
00005a  3825              SUBS     r0,r0,#0x25
00005c  d01b              BEQ      |L9.150|
00005e  f5a46080          SUB      r0,r4,#0x400
000062  3824              SUBS     r0,r0,#0x24
000064  d017              BEQ      |L9.150|
000066  f5a46000          SUB      r0,r4,#0x800
00006a  3846              SUBS     r0,r0,#0x46
00006c  d013              BEQ      |L9.150|
00006e  454c              CMP      r4,r9
000070  d011              BEQ      |L9.150|
000072  f5b47f58          CMP      r4,#0x360
000076  d01d              BEQ      |L9.180|
000078  f5a47040          SUB      r0,r4,#0x300
00007c  3825              SUBS     r0,r0,#0x25
00007e  d00a              BEQ      |L9.150|
000080  f5b47f18          CMP      r4,#0x260
000084  d016              BEQ      |L9.180|
000086  f5b47fb0          CMP      r4,#0x160
00008a  d013              BEQ      |L9.180|
00008c  f2405151          MOV      r1,#0x551
000090  481d              LDR      r0,|L9.264|
000092  f7fffffe          BL       assert_failed
                  |L9.150|
;;;1362   
;;;1363     /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;1364     if (USART_IT == USART_IT_CTS)
000096  454c              CMP      r4,r9
000098  d10c              BNE      |L9.180|
;;;1365     {
;;;1366       assert_param(IS_USART_1236_PERIPH(USARTx));
00009a  42bd              CMP      r5,r7
00009c  d00a              BEQ      |L9.180|
00009e  4545              CMP      r5,r8
0000a0  d008              BEQ      |L9.180|
0000a2  4555              CMP      r5,r10
0000a4  d006              BEQ      |L9.180|
0000a6  455d              CMP      r5,r11
0000a8  d004              BEQ      |L9.180|
0000aa  f2405156          MOV      r1,#0x556
0000ae  4816              LDR      r0,|L9.264|
0000b0  f7fffffe          BL       assert_failed
                  |L9.180|
;;;1367     } 
;;;1368       
;;;1369     /* Get the USART register index */
;;;1370     usartreg = (((uint8_t)USART_IT) >> 0x05);
;;;1371     /* Get the interrupt position */
;;;1372     itmask = USART_IT & IT_MASK;
0000b4  f004021f          AND      r2,r4,#0x1f
;;;1373     itmask = (uint32_t)0x01 << itmask;
0000b8  2301              MOVS     r3,#1
0000ba  f3c41142          UBFX     r1,r4,#5,#3           ;1370
0000be  fa03f002          LSL      r0,r3,r2
;;;1374     
;;;1375     if (usartreg == 0x01) /* The IT  is in CR1 register */
0000c2  2901              CMP      r1,#1
0000c4  d010              BEQ      |L9.232|
;;;1376     {
;;;1377       itmask &= USARTx->CR1;
;;;1378     }
;;;1379     else if (usartreg == 0x02) /* The IT  is in CR2 register */
0000c6  2902              CMP      r1,#2
0000c8  d010              BEQ      |L9.236|
;;;1380     {
;;;1381       itmask &= USARTx->CR2;
;;;1382     }
;;;1383     else /* The IT  is in CR3 register */
;;;1384     {
;;;1385       itmask &= USARTx->CR3;
0000ca  8aa9              LDRH     r1,[r5,#0x14]
                  |L9.204|
;;;1386     }
;;;1387     
;;;1388     bitpos = USART_IT >> 0x08;
0000cc  ea4f2214          LSR      r2,r4,#8
;;;1389     bitpos = (uint32_t)0x01 << bitpos;
0000d0  fa03f302          LSL      r3,r3,r2
;;;1390     bitpos &= USARTx->SR;
0000d4  882a              LDRH     r2,[r5,#0]
0000d6  4201              TST      r1,r0                 ;1381
0000d8  ea020203          AND      r2,r2,r3
0000dc  d001              BEQ      |L9.226|
;;;1391     if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
0000de  b102              CBZ      r2,|L9.226|
;;;1392     {
;;;1393       bitstatus = SET;
0000e0  2601              MOVS     r6,#1
                  |L9.226|
;;;1394     }
;;;1395     else
;;;1396     {
;;;1397       bitstatus = RESET;
;;;1398     }
;;;1399     
;;;1400     return bitstatus;  
0000e2  4630              MOV      r0,r6
;;;1401   }
0000e4  e8bd9ff0          POP      {r4-r12,pc}
                  |L9.232|
0000e8  89a9              LDRH     r1,[r5,#0xc]          ;1377
0000ea  e7ef              B        |L9.204|
                  |L9.236|
0000ec  8a29              LDRH     r1,[r5,#0x10]         ;1381
0000ee  e7ed              B        |L9.204|
;;;1402   
                          ENDP

                  |L9.240|
                          DCD      0x40011000
                  |L9.244|
                          DCD      0x40004400
                  |L9.248|
                          DCD      0x40004800
                  |L9.252|
                          DCD      0x40011400
                  |L9.256|
                          DCD      0x40004c00
                  |L9.260|
                          DCD      0x40005000
                  |L9.264|
                          DCD      ||.conststring||

                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=2

                  USART_HalfDuplexCmd PROC
;;;815      */
;;;816    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;817    {
000002  4604              MOV      r4,r0
;;;818      /* Check the parameters */
;;;819      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4814              LDR      r0,|L10.88|
000006  460d              MOV      r5,r1                 ;817
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L10.52|
00000c  4813              LDR      r0,|L10.92|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L10.52|
000012  4813              LDR      r0,|L10.96|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L10.52|
000018  4812              LDR      r0,|L10.100|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L10.52|
00001e  4812              LDR      r0,|L10.104|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L10.52|
000024  4811              LDR      r0,|L10.108|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L10.52|
00002a  f2403133          MOV      r1,#0x333
00002e  4810              LDR      r0,|L10.112|
000030  f7fffffe          BL       assert_failed
                  |L10.52|
;;;820      assert_param(IS_FUNCTIONAL_STATE(NewState));
000034  b155              CBZ      r5,|L10.76|
000036  2d01              CMP      r5,#1
000038  d004              BEQ      |L10.68|
00003a  f44f714d          MOV      r1,#0x334
00003e  480c              LDR      r0,|L10.112|
000040  f7fffffe          BL       assert_failed
                  |L10.68|
;;;821      
;;;822      if (NewState != DISABLE)
;;;823      {
;;;824        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;825        USARTx->CR3 |= USART_CR3_HDSEL;
000044  8aa0              LDRH     r0,[r4,#0x14]
000046  f0400008          ORR      r0,r0,#8
00004a  e002              B        |L10.82|
                  |L10.76|
;;;826      }
;;;827      else
;;;828      {
;;;829        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;830        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
00004c  8aa0              LDRH     r0,[r4,#0x14]
00004e  f0200008          BIC      r0,r0,#8
                  |L10.82|
000052  82a0              STRH     r0,[r4,#0x14]         ;825
;;;831      }
;;;832    }
000054  bd70              POP      {r4-r6,pc}
;;;833    
                          ENDP

000056  0000              DCW      0x0000
                  |L10.88|
                          DCD      0x40011000
                  |L10.92|
                          DCD      0x40004400
                  |L10.96|
                          DCD      0x40004800
                  |L10.100|
                          DCD      0x40004c00
                  |L10.104|
                          DCD      0x40005000
                  |L10.108|
                          DCD      0x40011400
                  |L10.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=2

                  USART_ITConfig PROC
;;;1207     */
;;;1208   void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1209   {
;;;1210     uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;1211     uint32_t usartxbase = 0x00;
;;;1212     /* Check the parameters */
;;;1213     assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4f35              LDR      r7,|L11.220|
000006  f8df80d8          LDR      r8,|L11.224|
00000a  f8dfa0d8          LDR      r10,|L11.228|
00000e  f8dfb0d8          LDR      r11,|L11.232|
000012  4616              MOV      r6,r2                 ;1209
000014  460d              MOV      r5,r1                 ;1209
000016  4604              MOV      r4,r0                 ;1209
000018  42b8              CMP      r0,r7
00001a  d010              BEQ      |L11.62|
00001c  4544              CMP      r4,r8
00001e  d00e              BEQ      |L11.62|
000020  4554              CMP      r4,r10
000022  d00c              BEQ      |L11.62|
000024  4831              LDR      r0,|L11.236|
000026  4284              CMP      r4,r0
000028  d009              BEQ      |L11.62|
00002a  4831              LDR      r0,|L11.240|
00002c  4284              CMP      r4,r0
00002e  d006              BEQ      |L11.62|
000030  455c              CMP      r4,r11
000032  d004              BEQ      |L11.62|
000034  f24041bd          MOV      r1,#0x4bd
000038  482e              LDR      r0,|L11.244|
00003a  f7fffffe          BL       assert_failed
                  |L11.62|
;;;1214     assert_param(IS_USART_CONFIG_IT(USART_IT));
00003e  f640196a          MOV      r9,#0x96a
000042  2d28              CMP      r5,#0x28
000044  d01c              BEQ      |L11.128|
000046  f5a560e0          SUB      r0,r5,#0x700
00004a  3827              SUBS     r0,r0,#0x27
00004c  d018              BEQ      |L11.128|
00004e  f5a560c0          SUB      r0,r5,#0x600
000052  3826              SUBS     r0,r0,#0x26
000054  d014              BEQ      |L11.128|
000056  f5a560a0          SUB      r0,r5,#0x500
00005a  3825              SUBS     r0,r0,#0x25
00005c  d010              BEQ      |L11.128|
00005e  f5a56080          SUB      r0,r5,#0x400
000062  3824              SUBS     r0,r0,#0x24
000064  d00c              BEQ      |L11.128|
000066  f5a56000          SUB      r0,r5,#0x800
00006a  3846              SUBS     r0,r0,#0x46
00006c  d008              BEQ      |L11.128|
00006e  454d              CMP      r5,r9
000070  d006              BEQ      |L11.128|
000072  2d60              CMP      r5,#0x60
000074  d004              BEQ      |L11.128|
000076  f24041be          MOV      r1,#0x4be
00007a  481e              LDR      r0,|L11.244|
00007c  f7fffffe          BL       assert_failed
                  |L11.128|
;;;1215     assert_param(IS_FUNCTIONAL_STATE(NewState));
000080  b136              CBZ      r6,|L11.144|
000082  2e01              CMP      r6,#1
000084  d004              BEQ      |L11.144|
000086  f24041bf          MOV      r1,#0x4bf
00008a  481a              LDR      r0,|L11.244|
00008c  f7fffffe          BL       assert_failed
                  |L11.144|
;;;1216   
;;;1217     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1218     if (USART_IT == USART_IT_CTS)
000090  454d              CMP      r5,r9
000092  d10c              BNE      |L11.174|
;;;1219     {
;;;1220       assert_param(IS_USART_1236_PERIPH(USARTx));
000094  42bc              CMP      r4,r7
000096  d00a              BEQ      |L11.174|
000098  4544              CMP      r4,r8
00009a  d008              BEQ      |L11.174|
00009c  4554              CMP      r4,r10
00009e  d006              BEQ      |L11.174|
0000a0  455c              CMP      r4,r11
0000a2  d004              BEQ      |L11.174|
0000a4  f24041c4          MOV      r1,#0x4c4
0000a8  4812              LDR      r0,|L11.244|
0000aa  f7fffffe          BL       assert_failed
                  |L11.174|
;;;1221     } 
;;;1222       
;;;1223     usartxbase = (uint32_t)USARTx;
;;;1224   
;;;1225     /* Get the USART register index */
;;;1226     usartreg = (((uint8_t)USART_IT) >> 0x05);
;;;1227   
;;;1228     /* Get the interrupt position */
;;;1229     itpos = USART_IT & IT_MASK;
0000ae  f005021f          AND      r2,r5,#0x1f
;;;1230     itmask = (((uint32_t)0x01) << itpos);
0000b2  2101              MOVS     r1,#1
0000b4  f3c51042          UBFX     r0,r5,#5,#3           ;1226
0000b8  4091              LSLS     r1,r1,r2
;;;1231       
;;;1232     if (usartreg == 0x01) /* The IT is in CR1 register */
0000ba  2801              CMP      r0,#1
0000bc  d006              BEQ      |L11.204|
;;;1233     {
;;;1234       usartxbase += 0x0C;
;;;1235     }
;;;1236     else if (usartreg == 0x02) /* The IT is in CR2 register */
0000be  2802              CMP      r0,#2
0000c0  d006              BEQ      |L11.208|
0000c2  3414              ADDS     r4,r4,#0x14
                  |L11.196|
;;;1237     {
;;;1238       usartxbase += 0x10;
;;;1239     }
;;;1240     else /* The IT is in CR3 register */
;;;1241     {
;;;1242       usartxbase += 0x14; 
;;;1243     }
;;;1244     if (NewState != DISABLE)
;;;1245     {
;;;1246       *(__IO uint32_t*)usartxbase  |= itmask;
;;;1247     }
;;;1248     else
;;;1249     {
;;;1250       *(__IO uint32_t*)usartxbase &= ~itmask;
0000c4  6820              LDR      r0,[r4,#0]
0000c6  b12e              CBZ      r6,|L11.212|
0000c8  4308              ORRS     r0,r0,r1              ;1246
0000ca  e004              B        |L11.214|
                  |L11.204|
0000cc  340c              ADDS     r4,r4,#0xc            ;1246
0000ce  e7f9              B        |L11.196|
                  |L11.208|
0000d0  3410              ADDS     r4,r4,#0x10           ;1234
0000d2  e7f7              B        |L11.196|
                  |L11.212|
0000d4  4388              BICS     r0,r0,r1
                  |L11.214|
0000d6  6020              STR      r0,[r4,#0]            ;1246
;;;1251     }
;;;1252   }
0000d8  e8bd9ff0          POP      {r4-r12,pc}
;;;1253   
                          ENDP

                  |L11.220|
                          DCD      0x40011000
                  |L11.224|
                          DCD      0x40004400
                  |L11.228|
                          DCD      0x40004800
                  |L11.232|
                          DCD      0x40011400
                  |L11.236|
                          DCD      0x40004c00
                  |L11.240|
                          DCD      0x40005000
                  |L11.244|
                          DCD      ||.conststring||

                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;226      */
;;;227    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;228    {
;;;229      uint32_t tmpreg = 0x00, apbclock = 0x00;
;;;230      uint32_t integerdivider = 0x00;
;;;231      uint32_t fractionaldivider = 0x00;
;;;232      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;233    
;;;234      /* Check the parameters */
;;;235      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4e5d              LDR      r6,|L12.380|
000006  f8df8178          LDR      r8,|L12.384|
00000a  f8df9178          LDR      r9,|L12.388|
00000e  4f5e              LDR      r7,|L12.392|
000010  460d              MOV      r5,r1                 ;228
000012  4604              MOV      r4,r0                 ;228
000014  42b0              CMP      r0,r6
000016  d00f              BEQ      |L12.56|
000018  4544              CMP      r4,r8
00001a  d00d              BEQ      |L12.56|
00001c  454c              CMP      r4,r9
00001e  d00b              BEQ      |L12.56|
000020  485a              LDR      r0,|L12.396|
000022  4284              CMP      r4,r0
000024  d008              BEQ      |L12.56|
000026  485a              LDR      r0,|L12.400|
000028  4284              CMP      r4,r0
00002a  d005              BEQ      |L12.56|
00002c  42bc              CMP      r4,r7
00002e  d003              BEQ      |L12.56|
000030  21eb              MOVS     r1,#0xeb
000032  4858              LDR      r0,|L12.404|
000034  f7fffffe          BL       assert_failed
                  |L12.56|
;;;236      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
000038  6828              LDR      r0,[r5,#0]
00003a  4957              LDR      r1,|L12.408|
00003c  1e40              SUBS     r0,r0,#1
00003e  4288              CMP      r0,r1
000040  d303              BCC      |L12.74|
000042  21ec              MOVS     r1,#0xec
000044  4853              LDR      r0,|L12.404|
000046  f7fffffe          BL       assert_failed
                  |L12.74|
;;;237      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
00004a  88a8              LDRH     r0,[r5,#4]
00004c  f44f5a80          MOV      r10,#0x1000
000050  b128              CBZ      r0,|L12.94|
000052  4550              CMP      r0,r10
000054  d003              BEQ      |L12.94|
000056  21ed              MOVS     r1,#0xed
000058  484e              LDR      r0,|L12.404|
00005a  f7fffffe          BL       assert_failed
                  |L12.94|
;;;238      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
00005e  88e8              LDRH     r0,[r5,#6]
000060  b158              CBZ      r0,|L12.122|
000062  4550              CMP      r0,r10
000064  d009              BEQ      |L12.122|
000066  f5b05f00          CMP      r0,#0x2000
00006a  d006              BEQ      |L12.122|
00006c  f5b05f40          CMP      r0,#0x3000
000070  d003              BEQ      |L12.122|
000072  21ee              MOVS     r1,#0xee
000074  4847              LDR      r0,|L12.404|
000076  f7fffffe          BL       assert_failed
                  |L12.122|
;;;239      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
00007a  8928              LDRH     r0,[r5,#8]
00007c  b148              CBZ      r0,|L12.146|
00007e  f5b06f80          CMP      r0,#0x400
000082  d006              BEQ      |L12.146|
000084  f5b06fc0          CMP      r0,#0x600
000088  d003              BEQ      |L12.146|
00008a  21ef              MOVS     r1,#0xef
00008c  4841              LDR      r0,|L12.404|
00008e  f7fffffe          BL       assert_failed
                  |L12.146|
;;;240      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
000092  8968              LDRH     r0,[r5,#0xa]
000094  f030010c          BICS     r1,r0,#0xc
000098  d100              BNE      |L12.156|
00009a  b918              CBNZ     r0,|L12.164|
                  |L12.156|
00009c  21f0              MOVS     r1,#0xf0
00009e  483d              LDR      r0,|L12.404|
0000a0  f7fffffe          BL       assert_failed
                  |L12.164|
;;;241      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
0000a4  89a8              LDRH     r0,[r5,#0xc]
0000a6  b1d0              CBZ      r0,|L12.222|
0000a8  f5b07f80          CMP      r0,#0x100
0000ac  d00b              BEQ      |L12.198|
0000ae  f5b07f00          CMP      r0,#0x200
0000b2  d008              BEQ      |L12.198|
0000b4  f5b07f40          CMP      r0,#0x300
0000b8  d005              BEQ      |L12.198|
0000ba  21f1              MOVS     r1,#0xf1
0000bc  4835              LDR      r0,|L12.404|
0000be  f7fffffe          BL       assert_failed
;;;242    
;;;243      /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
;;;244      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
0000c2  89a8              LDRH     r0,[r5,#0xc]
0000c4  b158              CBZ      r0,|L12.222|
                  |L12.198|
;;;245      {
;;;246        assert_param(IS_USART_1236_PERIPH(USARTx));
0000c6  42b4              CMP      r4,r6
0000c8  d009              BEQ      |L12.222|
0000ca  4544              CMP      r4,r8
0000cc  d007              BEQ      |L12.222|
0000ce  454c              CMP      r4,r9
0000d0  d005              BEQ      |L12.222|
0000d2  42bc              CMP      r4,r7
0000d4  d003              BEQ      |L12.222|
0000d6  21f6              MOVS     r1,#0xf6
0000d8  482e              LDR      r0,|L12.404|
0000da  f7fffffe          BL       assert_failed
                  |L12.222|
;;;247      }
;;;248    
;;;249    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;250      tmpreg = USARTx->CR2;
0000de  8a20              LDRH     r0,[r4,#0x10]
;;;251    
;;;252      /* Clear STOP[13:12] bits */
;;;253      tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
0000e0  f4205140          BIC      r1,r0,#0x3000
;;;254    
;;;255      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
;;;256          Set STOP[13:12] bits according to USART_StopBits value */
;;;257      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
0000e4  88e8              LDRH     r0,[r5,#6]
0000e6  4308              ORRS     r0,r0,r1
;;;258      
;;;259      /* Write to USART CR2 */
;;;260      USARTx->CR2 = (uint16_t)tmpreg;
0000e8  8220              STRH     r0,[r4,#0x10]
;;;261    
;;;262    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;263      tmpreg = USARTx->CR1;
0000ea  89a0              LDRH     r0,[r4,#0xc]
;;;264    
;;;265      /* Clear M, PCE, PS, TE and RE bits */
;;;266      tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
0000ec  f241610c          MOV      r1,#0x160c
0000f0  4388              BICS     r0,r0,r1
;;;267    
;;;268      /* Configure the USART Word Length, Parity and mode: 
;;;269         Set the M bits according to USART_WordLength value 
;;;270         Set PCE and PS bits according to USART_Parity value
;;;271         Set TE and RE bits according to USART_Mode value */
;;;272      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
0000f2  88a9              LDRH     r1,[r5,#4]
0000f4  892a              LDRH     r2,[r5,#8]
0000f6  4311              ORRS     r1,r1,r2
0000f8  896a              LDRH     r2,[r5,#0xa]
0000fa  4302              ORRS     r2,r2,r0
0000fc  4311              ORRS     r1,r1,r2
;;;273                USART_InitStruct->USART_Mode;
;;;274    
;;;275      /* Write to USART CR1 */
;;;276      USARTx->CR1 = (uint16_t)tmpreg;
0000fe  81a1              STRH     r1,[r4,#0xc]
;;;277    
;;;278    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;279      tmpreg = USARTx->CR3;
000100  8aa0              LDRH     r0,[r4,#0x14]
;;;280    
;;;281      /* Clear CTSE and RTSE bits */
;;;282      tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
000102  f4207140          BIC      r1,r0,#0x300
;;;283    
;;;284      /* Configure the USART HFC : 
;;;285          Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;286      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000106  89a8              LDRH     r0,[r5,#0xc]
000108  4308              ORRS     r0,r0,r1
;;;287    
;;;288      /* Write to USART CR3 */
;;;289      USARTx->CR3 = (uint16_t)tmpreg;
00010a  82a0              STRH     r0,[r4,#0x14]
;;;290    
;;;291    /*---------------------------- USART BRR Configuration -----------------------*/
;;;292      /* Configure the USART Baud Rate */
;;;293      RCC_GetClocksFreq(&RCC_ClocksStatus);
00010c  4668              MOV      r0,sp
00010e  f7fffffe          BL       RCC_GetClocksFreq
;;;294    
;;;295      if ((USARTx == USART1) || (USARTx == USART6))
000112  42b4              CMP      r4,r6
000114  d001              BEQ      |L12.282|
000116  42bc              CMP      r4,r7
000118  d101              BNE      |L12.286|
                  |L12.282|
;;;296      {
;;;297        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
00011a  9803              LDR      r0,[sp,#0xc]
00011c  e000              B        |L12.288|
                  |L12.286|
;;;298      }
;;;299      else
;;;300      {
;;;301        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
00011e  9802              LDR      r0,[sp,#8]
                  |L12.288|
;;;302      }
;;;303      
;;;304      /* Determine the integer part */
;;;305      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
000120  89a1              LDRH     r1,[r4,#0xc]
000122  0409              LSLS     r1,r1,#16
;;;306      {
;;;307        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;308        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
;;;309      }
;;;310      else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;311      {
;;;312        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;313        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
000124  eb0001c0          ADD      r1,r0,r0,LSL #3
000128  eb011000          ADD      r0,r1,r0,LSL #4
00012c  6829              LDR      r1,[r5,#0]            ;305
00012e  d501              BPL      |L12.308|
000130  0049              LSLS     r1,r1,#1              ;308
000132  e000              B        |L12.310|
                  |L12.308|
000134  0089              LSLS     r1,r1,#2
                  |L12.310|
000136  fbb0f0f1          UDIV     r0,r0,r1
;;;314      }
;;;315      tmpreg = (integerdivider / 100) << 4;
00013a  2264              MOVS     r2,#0x64
00013c  fbb0f1f2          UDIV     r1,r0,r2
000140  0109              LSLS     r1,r1,#4
;;;316    
;;;317      /* Determine the fractional part */
;;;318      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
000142  090b              LSRS     r3,r1,#4
000144  f06f0518          MVN      r5,#0x18
000148  436b              MULS     r3,r5,r3
00014a  eb000083          ADD      r0,r0,r3,LSL #2
;;;319    
;;;320      /* Implement the fractional part in the register */
;;;321      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
00014e  89a3              LDRH     r3,[r4,#0xc]
000150  041d              LSLS     r5,r3,#16
;;;322      {
;;;323        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
000152  f04f0332          MOV      r3,#0x32
000156  d506              BPL      |L12.358|
000158  eb0300c0          ADD      r0,r3,r0,LSL #3
00015c  fbb0f0f2          UDIV     r0,r0,r2
000160  f0000007          AND      r0,r0,#7
000164  e005              B        |L12.370|
                  |L12.358|
;;;324      }
;;;325      else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;326      {
;;;327        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
000166  eb031000          ADD      r0,r3,r0,LSL #4
00016a  fbb0f0f2          UDIV     r0,r0,r2
00016e  f000000f          AND      r0,r0,#0xf
                  |L12.370|
000172  4308              ORRS     r0,r0,r1
;;;328      }
;;;329      
;;;330      /* Write to USART BRR register */
;;;331      USARTx->BRR = (uint16_t)tmpreg;
000174  8120              STRH     r0,[r4,#8]
;;;332    }
000176  e8bd87ff          POP      {r0-r10,pc}
;;;333    
                          ENDP

00017a  0000              DCW      0x0000
                  |L12.380|
                          DCD      0x40011000
                  |L12.384|
                          DCD      0x40004400
                  |L12.388|
                          DCD      0x40004800
                  |L12.392|
                          DCD      0x40011400
                  |L12.396|
                          DCD      0x40004c00
                  |L12.400|
                          DCD      0x40005000
                  |L12.404|
                          DCD      ||.conststring||
                  |L12.408|
                          DCD      0x007270e0

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=2

                  USART_IrDACmd PROC
;;;1033     */
;;;1034   void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1035   {
000002  4604              MOV      r4,r0
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4814              LDR      r0,|L13.88|
000006  460d              MOV      r5,r1                 ;1035
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L13.52|
00000c  4813              LDR      r0,|L13.92|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L13.52|
000012  4813              LDR      r0,|L13.96|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L13.52|
000018  4812              LDR      r0,|L13.100|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L13.52|
00001e  4812              LDR      r0,|L13.104|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L13.52|
000024  4811              LDR      r0,|L13.108|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L13.52|
00002a  f240410d          MOV      r1,#0x40d
00002e  4810              LDR      r0,|L13.112|
000030  f7fffffe          BL       assert_failed
                  |L13.52|
;;;1038     assert_param(IS_FUNCTIONAL_STATE(NewState));
000034  b155              CBZ      r5,|L13.76|
000036  2d01              CMP      r5,#1
000038  d004              BEQ      |L13.68|
00003a  f240410e          MOV      r1,#0x40e
00003e  480c              LDR      r0,|L13.112|
000040  f7fffffe          BL       assert_failed
                  |L13.68|
;;;1039       
;;;1040     if (NewState != DISABLE)
;;;1041     {
;;;1042       /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;1043       USARTx->CR3 |= USART_CR3_IREN;
000044  8aa0              LDRH     r0,[r4,#0x14]
000046  f0400002          ORR      r0,r0,#2
00004a  e002              B        |L13.82|
                  |L13.76|
;;;1044     }
;;;1045     else
;;;1046     {
;;;1047       /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;1048       USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
00004c  8aa0              LDRH     r0,[r4,#0x14]
00004e  f0200002          BIC      r0,r0,#2
                  |L13.82|
000052  82a0              STRH     r0,[r4,#0x14]         ;1043
;;;1049     }
;;;1050   }
000054  bd70              POP      {r4-r6,pc}
;;;1051   
                          ENDP

000056  0000              DCW      0x0000
                  |L13.88|
                          DCD      0x40011000
                  |L13.92|
                          DCD      0x40004400
                  |L13.96|
                          DCD      0x40004800
                  |L13.100|
                          DCD      0x40004c00
                  |L13.104|
                          DCD      0x40005000
                  |L13.108|
                          DCD      0x40011400
                  |L13.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=2

                  USART_IrDAConfig PROC
;;;1015     */
;;;1016   void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
000000  b570              PUSH     {r4-r6,lr}
;;;1017   {
000002  4604              MOV      r4,r0
;;;1018     /* Check the parameters */
;;;1019     assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4813              LDR      r0,|L14.84|
000006  460d              MOV      r5,r1                 ;1017
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L14.52|
00000c  4812              LDR      r0,|L14.88|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L14.52|
000012  4812              LDR      r0,|L14.92|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L14.52|
000018  4811              LDR      r0,|L14.96|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L14.52|
00001e  4811              LDR      r0,|L14.100|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L14.52|
000024  4810              LDR      r0,|L14.104|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L14.52|
00002a  f24031fb          MOV      r1,#0x3fb
00002e  480f              LDR      r0,|L14.108|
000030  f7fffffe          BL       assert_failed
                  |L14.52|
;;;1020     assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
000034  2d04              CMP      r5,#4
000036  d005              BEQ      |L14.68|
000038  b125              CBZ      r5,|L14.68|
00003a  f44f717f          MOV      r1,#0x3fc
00003e  480b              LDR      r0,|L14.108|
000040  f7fffffe          BL       assert_failed
                  |L14.68|
;;;1021       
;;;1022     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
000044  8aa0              LDRH     r0,[r4,#0x14]
000046  f0200004          BIC      r0,r0,#4
00004a  82a0              STRH     r0,[r4,#0x14]
;;;1023     USARTx->CR3 |= USART_IrDAMode;
00004c  8aa0              LDRH     r0,[r4,#0x14]
00004e  4328              ORRS     r0,r0,r5
000050  82a0              STRH     r0,[r4,#0x14]
;;;1024   }
000052  bd70              POP      {r4-r6,pc}
;;;1025   
                          ENDP

                  |L14.84|
                          DCD      0x40011000
                  |L14.88|
                          DCD      0x40004400
                  |L14.92|
                          DCD      0x40004800
                  |L14.96|
                          DCD      0x40004c00
                  |L14.100|
                          DCD      0x40005000
                  |L14.104|
                          DCD      0x40011400
                  |L14.108|
                          DCD      ||.conststring||

                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=2

                  USART_LINBreakDetectLengthConfig PROC
;;;720      */
;;;721    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;722    {
000002  4604              MOV      r4,r0
;;;723      /* Check the parameters */
;;;724      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4813              LDR      r0,|L15.84|
000006  460d              MOV      r5,r1                 ;722
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L15.52|
00000c  4812              LDR      r0,|L15.88|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L15.52|
000012  4812              LDR      r0,|L15.92|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L15.52|
000018  4811              LDR      r0,|L15.96|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L15.52|
00001e  4811              LDR      r0,|L15.100|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L15.52|
000024  4810              LDR      r0,|L15.104|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L15.52|
00002a  f44f7135          MOV      r1,#0x2d4
00002e  480f              LDR      r0,|L15.108|
000030  f7fffffe          BL       assert_failed
                  |L15.52|
;;;725      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
000034  b135              CBZ      r5,|L15.68|
000036  2d20              CMP      r5,#0x20
000038  d004              BEQ      |L15.68|
00003a  f24021d5          MOV      r1,#0x2d5
00003e  480b              LDR      r0,|L15.108|
000040  f7fffffe          BL       assert_failed
                  |L15.68|
;;;726      
;;;727      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
000044  8a20              LDRH     r0,[r4,#0x10]
000046  f0200020          BIC      r0,r0,#0x20
00004a  8220              STRH     r0,[r4,#0x10]
;;;728      USARTx->CR2 |= USART_LINBreakDetectLength;  
00004c  8a20              LDRH     r0,[r4,#0x10]
00004e  4328              ORRS     r0,r0,r5
000050  8220              STRH     r0,[r4,#0x10]
;;;729    }
000052  bd70              POP      {r4-r6,pc}
;;;730    
                          ENDP

                  |L15.84|
                          DCD      0x40011000
                  |L15.88|
                          DCD      0x40004400
                  |L15.92|
                          DCD      0x40004800
                  |L15.96|
                          DCD      0x40004c00
                  |L15.100|
                          DCD      0x40005000
                  |L15.104|
                          DCD      0x40011400
                  |L15.108|
                          DCD      ||.conststring||

                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=2

                  USART_LINCmd PROC
;;;738      */
;;;739    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;740    {
000002  4604              MOV      r4,r0
;;;741      /* Check the parameters */
;;;742      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4814              LDR      r0,|L16.88|
000006  460d              MOV      r5,r1                 ;740
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L16.52|
00000c  4813              LDR      r0,|L16.92|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L16.52|
000012  4813              LDR      r0,|L16.96|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L16.52|
000018  4812              LDR      r0,|L16.100|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L16.52|
00001e  4812              LDR      r0,|L16.104|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L16.52|
000024  4811              LDR      r0,|L16.108|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L16.52|
00002a  f24021e6          MOV      r1,#0x2e6
00002e  4810              LDR      r0,|L16.112|
000030  f7fffffe          BL       assert_failed
                  |L16.52|
;;;743      assert_param(IS_FUNCTIONAL_STATE(NewState));
000034  b155              CBZ      r5,|L16.76|
000036  2d01              CMP      r5,#1
000038  d004              BEQ      |L16.68|
00003a  f24021e7          MOV      r1,#0x2e7
00003e  480c              LDR      r0,|L16.112|
000040  f7fffffe          BL       assert_failed
                  |L16.68|
;;;744      
;;;745      if (NewState != DISABLE)
;;;746      {
;;;747        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;748        USARTx->CR2 |= USART_CR2_LINEN;
000044  8a20              LDRH     r0,[r4,#0x10]
000046  f4404080          ORR      r0,r0,#0x4000
00004a  e002              B        |L16.82|
                  |L16.76|
;;;749      }
;;;750      else
;;;751      {
;;;752        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;753        USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
00004c  8a20              LDRH     r0,[r4,#0x10]
00004e  f4204080          BIC      r0,r0,#0x4000
                  |L16.82|
000052  8220              STRH     r0,[r4,#0x10]         ;748
;;;754      }
;;;755    }
000054  bd70              POP      {r4-r6,pc}
;;;756    
                          ENDP

000056  0000              DCW      0x0000
                  |L16.88|
                          DCD      0x40011000
                  |L16.92|
                          DCD      0x40004400
                  |L16.96|
                          DCD      0x40004800
                  |L16.100|
                          DCD      0x40004c00
                  |L16.104|
                          DCD      0x40005000
                  |L16.108|
                          DCD      0x40011400
                  |L16.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=2

                  USART_OneBitMethodCmd PROC
;;;480      */
;;;481    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;482    {
000002  4604              MOV      r4,r0
;;;483      /* Check the parameters */
;;;484      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4814              LDR      r0,|L17.88|
000006  460d              MOV      r5,r1                 ;482
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L17.52|
00000c  4813              LDR      r0,|L17.92|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L17.52|
000012  4813              LDR      r0,|L17.96|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L17.52|
000018  4812              LDR      r0,|L17.100|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L17.52|
00001e  4812              LDR      r0,|L17.104|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L17.52|
000024  4811              LDR      r0,|L17.108|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L17.52|
00002a  f44f71f2          MOV      r1,#0x1e4
00002e  4810              LDR      r0,|L17.112|
000030  f7fffffe          BL       assert_failed
                  |L17.52|
;;;485      assert_param(IS_FUNCTIONAL_STATE(NewState));
000034  b155              CBZ      r5,|L17.76|
000036  2d01              CMP      r5,#1
000038  d004              BEQ      |L17.68|
00003a  f24011e5          MOV      r1,#0x1e5
00003e  480c              LDR      r0,|L17.112|
000040  f7fffffe          BL       assert_failed
                  |L17.68|
;;;486      
;;;487      if (NewState != DISABLE)
;;;488      {
;;;489        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;490        USARTx->CR3 |= USART_CR3_ONEBIT;
000044  8aa0              LDRH     r0,[r4,#0x14]
000046  f4406000          ORR      r0,r0,#0x800
00004a  e002              B        |L17.82|
                  |L17.76|
;;;491      }
;;;492      else
;;;493      {
;;;494        /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
;;;495        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
00004c  8aa0              LDRH     r0,[r4,#0x14]
00004e  f4206000          BIC      r0,r0,#0x800
                  |L17.82|
000052  82a0              STRH     r0,[r4,#0x14]         ;490
;;;496      }
;;;497    }
000054  bd70              POP      {r4-r6,pc}
;;;498    
                          ENDP

000056  0000              DCW      0x0000
                  |L17.88|
                          DCD      0x40011000
                  |L17.92|
                          DCD      0x40004400
                  |L17.96|
                          DCD      0x40004800
                  |L17.100|
                          DCD      0x40004c00
                  |L17.104|
                          DCD      0x40005000
                  |L17.108|
                          DCD      0x40011400
                  |L17.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=2

                  USART_OverSampling8Cmd PROC
;;;454      */
;;;455    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;456    {
000002  4604              MOV      r4,r0
;;;457      /* Check the parameters */
;;;458      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4814              LDR      r0,|L18.88|
000006  460d              MOV      r5,r1                 ;456
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L18.52|
00000c  4813              LDR      r0,|L18.92|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L18.52|
000012  4813              LDR      r0,|L18.96|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L18.52|
000018  4812              LDR      r0,|L18.100|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L18.52|
00001e  4812              LDR      r0,|L18.104|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L18.52|
000024  4811              LDR      r0,|L18.108|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L18.52|
00002a  f44f71e5          MOV      r1,#0x1ca
00002e  4810              LDR      r0,|L18.112|
000030  f7fffffe          BL       assert_failed
                  |L18.52|
;;;459      assert_param(IS_FUNCTIONAL_STATE(NewState));
000034  b155              CBZ      r5,|L18.76|
000036  2d01              CMP      r5,#1
000038  d004              BEQ      |L18.68|
00003a  f24011cb          MOV      r1,#0x1cb
00003e  480c              LDR      r0,|L18.112|
000040  f7fffffe          BL       assert_failed
                  |L18.68|
;;;460      
;;;461      if (NewState != DISABLE)
;;;462      {
;;;463        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;464        USARTx->CR1 |= USART_CR1_OVER8;
000044  89a0              LDRH     r0,[r4,#0xc]
000046  f4404000          ORR      r0,r0,#0x8000
00004a  e002              B        |L18.82|
                  |L18.76|
;;;465      }
;;;466      else
;;;467      {
;;;468        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;469        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
00004c  89a0              LDRH     r0,[r4,#0xc]
00004e  f3c0000e          UBFX     r0,r0,#0,#15
                  |L18.82|
000052  81a0              STRH     r0,[r4,#0xc]          ;464
;;;470      }
;;;471    }  
000054  bd70              POP      {r4-r6,pc}
;;;472    
                          ENDP

000056  0000              DCW      0x0000
                  |L18.88|
                          DCD      0x40011000
                  |L18.92|
                          DCD      0x40004400
                  |L18.96|
                          DCD      0x40004800
                  |L18.100|
                          DCD      0x40004c00
                  |L18.104|
                          DCD      0x40005000
                  |L18.108|
                          DCD      0x40011400
                  |L18.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=2

                  USART_ReceiveData PROC
;;;553      */
;;;554    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;555    {
000002  4604              MOV      r4,r0
;;;556      /* Check the parameters */
;;;557      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  480d              LDR      r0,|L19.60|
000006  4284              CMP      r4,r0
000008  d013              BEQ      |L19.50|
00000a  480d              LDR      r0,|L19.64|
00000c  4284              CMP      r4,r0
00000e  d010              BEQ      |L19.50|
000010  480c              LDR      r0,|L19.68|
000012  4284              CMP      r4,r0
000014  d00d              BEQ      |L19.50|
000016  480c              LDR      r0,|L19.72|
000018  4284              CMP      r4,r0
00001a  d00a              BEQ      |L19.50|
00001c  480b              LDR      r0,|L19.76|
00001e  4284              CMP      r4,r0
000020  d007              BEQ      |L19.50|
000022  480b              LDR      r0,|L19.80|
000024  4284              CMP      r4,r0
000026  d004              BEQ      |L19.50|
000028  f240212d          MOV      r1,#0x22d
00002c  4809              LDR      r0,|L19.84|
00002e  f7fffffe          BL       assert_failed
                  |L19.50|
;;;558      
;;;559      /* Receive Data */
;;;560      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000032  88a0              LDRH     r0,[r4,#4]
000034  f3c00008          UBFX     r0,r0,#0,#9
;;;561    }
000038  bd10              POP      {r4,pc}
;;;562    
                          ENDP

00003a  0000              DCW      0x0000
                  |L19.60|
                          DCD      0x40011000
                  |L19.64|
                          DCD      0x40004400
                  |L19.68|
                          DCD      0x40004800
                  |L19.72|
                          DCD      0x40004c00
                  |L19.76|
                          DCD      0x40005000
                  |L19.80|
                          DCD      0x40011400
                  |L19.84|
                          DCD      ||.conststring||

                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=2

                  USART_ReceiverWakeUpCmd PROC
;;;624      */
;;;625    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;626    {
000002  4604              MOV      r4,r0
;;;627      /* Check the parameters */
;;;628      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4814              LDR      r0,|L20.88|
000006  460d              MOV      r5,r1                 ;626
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L20.52|
00000c  4813              LDR      r0,|L20.92|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L20.52|
000012  4813              LDR      r0,|L20.96|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L20.52|
000018  4812              LDR      r0,|L20.100|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L20.52|
00001e  4812              LDR      r0,|L20.104|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L20.52|
000024  4811              LDR      r0,|L20.108|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L20.52|
00002a  f44f711d          MOV      r1,#0x274
00002e  4810              LDR      r0,|L20.112|
000030  f7fffffe          BL       assert_failed
                  |L20.52|
;;;629      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
000034  b155              CBZ      r5,|L20.76|
000036  2d01              CMP      r5,#1
000038  d004              BEQ      |L20.68|
00003a  f2402175          MOV      r1,#0x275
00003e  480c              LDR      r0,|L20.112|
000040  f7fffffe          BL       assert_failed
                  |L20.68|
;;;630      
;;;631      if (NewState != DISABLE)
;;;632      {
;;;633        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;634        USARTx->CR1 |= USART_CR1_RWU;
000044  89a0              LDRH     r0,[r4,#0xc]
000046  f0400002          ORR      r0,r0,#2
00004a  e002              B        |L20.82|
                  |L20.76|
;;;635      }
;;;636      else
;;;637      {
;;;638        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;639        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
00004c  89a0              LDRH     r0,[r4,#0xc]
00004e  f0200002          BIC      r0,r0,#2
                  |L20.82|
000052  81a0              STRH     r0,[r4,#0xc]          ;634
;;;640      }
;;;641    }
000054  bd70              POP      {r4-r6,pc}
;;;642    /**
                          ENDP

000056  0000              DCW      0x0000
                  |L20.88|
                          DCD      0x40011000
                  |L20.92|
                          DCD      0x40004400
                  |L20.96|
                          DCD      0x40004800
                  |L20.100|
                          DCD      0x40004c00
                  |L20.104|
                          DCD      0x40005000
                  |L20.108|
                          DCD      0x40011400
                  |L20.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=2

                  USART_SendBreak PROC
;;;762      */
;;;763    void USART_SendBreak(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;764    {
000002  4604              MOV      r4,r0
;;;765      /* Check the parameters */
;;;766      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  480d              LDR      r0,|L21.60|
000006  4284              CMP      r4,r0
000008  d013              BEQ      |L21.50|
00000a  480d              LDR      r0,|L21.64|
00000c  4284              CMP      r4,r0
00000e  d010              BEQ      |L21.50|
000010  480c              LDR      r0,|L21.68|
000012  4284              CMP      r4,r0
000014  d00d              BEQ      |L21.50|
000016  480c              LDR      r0,|L21.72|
000018  4284              CMP      r4,r0
00001a  d00a              BEQ      |L21.50|
00001c  480b              LDR      r0,|L21.76|
00001e  4284              CMP      r4,r0
000020  d007              BEQ      |L21.50|
000022  480b              LDR      r0,|L21.80|
000024  4284              CMP      r4,r0
000026  d004              BEQ      |L21.50|
000028  f24021fe          MOV      r1,#0x2fe
00002c  4809              LDR      r0,|L21.84|
00002e  f7fffffe          BL       assert_failed
                  |L21.50|
;;;767      
;;;768      /* Send break characters */
;;;769      USARTx->CR1 |= USART_CR1_SBK;
000032  89a0              LDRH     r0,[r4,#0xc]
000034  f0400001          ORR      r0,r0,#1
000038  81a0              STRH     r0,[r4,#0xc]
;;;770    }
00003a  bd10              POP      {r4,pc}
;;;771    
                          ENDP

                  |L21.60|
                          DCD      0x40011000
                  |L21.64|
                          DCD      0x40004400
                  |L21.68|
                          DCD      0x40004800
                  |L21.72|
                          DCD      0x40004c00
                  |L21.76|
                          DCD      0x40005000
                  |L21.80|
                          DCD      0x40011400
                  |L21.84|
                          DCD      ||.conststring||

                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=2

                  USART_SendData PROC
;;;537      */
;;;538    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;539    {
000002  4604              MOV      r4,r0
;;;540      /* Check the parameters */
;;;541      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4811              LDR      r0,|L22.76|
000006  460d              MOV      r5,r1                 ;539
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L22.52|
00000c  4810              LDR      r0,|L22.80|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L22.52|
000012  4810              LDR      r0,|L22.84|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L22.52|
000018  480f              LDR      r0,|L22.88|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L22.52|
00001e  480f              LDR      r0,|L22.92|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L22.52|
000024  480e              LDR      r0,|L22.96|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L22.52|
00002a  f240211d          MOV      r1,#0x21d
00002e  480d              LDR      r0,|L22.100|
000030  f7fffffe          BL       assert_failed
                  |L22.52|
;;;542      assert_param(IS_USART_DATA(Data)); 
000034  f5b57f00          CMP      r5,#0x200
000038  d304              BCC      |L22.68|
00003a  f240211e          MOV      r1,#0x21e
00003e  4809              LDR      r0,|L22.100|
000040  f7fffffe          BL       assert_failed
                  |L22.68|
;;;543        
;;;544      /* Transmit Data */
;;;545      USARTx->DR = (Data & (uint16_t)0x01FF);
000044  f3c50008          UBFX     r0,r5,#0,#9
000048  80a0              STRH     r0,[r4,#4]
;;;546    }
00004a  bd70              POP      {r4-r6,pc}
;;;547    
                          ENDP

                  |L22.76|
                          DCD      0x40011000
                  |L22.80|
                          DCD      0x40004400
                  |L22.84|
                          DCD      0x40004800
                  |L22.88|
                          DCD      0x40004c00
                  |L22.92|
                          DCD      0x40005000
                  |L22.96|
                          DCD      0x40011400
                  |L22.100|
                          DCD      ||.conststring||

                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=2

                  USART_SetAddress PROC
;;;604      */
;;;605    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;606    {
000002  4604              MOV      r4,r0
;;;607      /* Check the parameters */
;;;608      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4813              LDR      r0,|L23.84|
000006  460d              MOV      r5,r1                 ;606
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L23.52|
00000c  4812              LDR      r0,|L23.88|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L23.52|
000012  4812              LDR      r0,|L23.92|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L23.52|
000018  4811              LDR      r0,|L23.96|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L23.52|
00001e  4811              LDR      r0,|L23.100|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L23.52|
000024  4810              LDR      r0,|L23.104|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L23.52|
00002a  f44f7118          MOV      r1,#0x260
00002e  480f              LDR      r0,|L23.108|
000030  f7fffffe          BL       assert_failed
                  |L23.52|
;;;609      assert_param(IS_USART_ADDRESS(USART_Address)); 
000034  2d0f              CMP      r5,#0xf
000036  d904              BLS      |L23.66|
000038  f2402161          MOV      r1,#0x261
00003c  480b              LDR      r0,|L23.108|
00003e  f7fffffe          BL       assert_failed
                  |L23.66|
;;;610        
;;;611      /* Clear the USART address */
;;;612      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
000042  8a20              LDRH     r0,[r4,#0x10]
000044  f020000f          BIC      r0,r0,#0xf
000048  8220              STRH     r0,[r4,#0x10]
;;;613      /* Set the USART address node */
;;;614      USARTx->CR2 |= USART_Address;
00004a  8a20              LDRH     r0,[r4,#0x10]
00004c  4328              ORRS     r0,r0,r5
00004e  8220              STRH     r0,[r4,#0x10]
;;;615    }
000050  bd70              POP      {r4-r6,pc}
;;;616    
                          ENDP

000052  0000              DCW      0x0000
                  |L23.84|
                          DCD      0x40011000
                  |L23.88|
                          DCD      0x40004400
                  |L23.92|
                          DCD      0x40004800
                  |L23.96|
                          DCD      0x40004c00
                  |L23.100|
                          DCD      0x40005000
                  |L23.104|
                          DCD      0x40011400
                  |L23.108|
                          DCD      ||.conststring||

                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=2

                  USART_SetGuardTime PROC
;;;900      */
;;;901    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  b570              PUSH     {r4-r6,lr}
;;;902    {    
000002  4604              MOV      r4,r0
;;;903      /* Check the parameters */
;;;904      assert_param(IS_USART_1236_PERIPH(USARTx));
000004  480c              LDR      r0,|L24.56|
000006  460d              MOV      r5,r1                 ;902
000008  4284              CMP      r4,r0
00000a  d00d              BEQ      |L24.40|
00000c  480b              LDR      r0,|L24.60|
00000e  4284              CMP      r4,r0
000010  d00a              BEQ      |L24.40|
000012  480b              LDR      r0,|L24.64|
000014  4284              CMP      r4,r0
000016  d007              BEQ      |L24.40|
000018  480a              LDR      r0,|L24.68|
00001a  4284              CMP      r4,r0
00001c  d004              BEQ      |L24.40|
00001e  f44f7162          MOV      r1,#0x388
000022  4809              LDR      r0,|L24.72|
000024  f7fffffe          BL       assert_failed
                  |L24.40|
;;;905      
;;;906      /* Clear the USART Guard time */
;;;907      USARTx->GTPR &= USART_GTPR_PSC;
000028  8b20              LDRH     r0,[r4,#0x18]
00002a  b2c0              UXTB     r0,r0
00002c  8320              STRH     r0,[r4,#0x18]
;;;908      /* Set the USART guard time */
;;;909      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
00002e  8b20              LDRH     r0,[r4,#0x18]
000030  ea402005          ORR      r0,r0,r5,LSL #8
000034  8320              STRH     r0,[r4,#0x18]
;;;910    }
000036  bd70              POP      {r4-r6,pc}
;;;911    
                          ENDP

                  |L24.56|
                          DCD      0x40011000
                  |L24.60|
                          DCD      0x40004400
                  |L24.64|
                          DCD      0x40004800
                  |L24.68|
                          DCD      0x40011400
                  |L24.72|
                          DCD      ||.conststring||

                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=2

                  USART_SetPrescaler PROC
;;;433      */
;;;434    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  b570              PUSH     {r4-r6,lr}
;;;435    { 
000002  4604              MOV      r4,r0
;;;436      /* Check the parameters */
;;;437      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  480f              LDR      r0,|L25.68|
000006  460d              MOV      r5,r1                 ;435
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L25.52|
00000c  480e              LDR      r0,|L25.72|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L25.52|
000012  480e              LDR      r0,|L25.76|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L25.52|
000018  480d              LDR      r0,|L25.80|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L25.52|
00001e  480d              LDR      r0,|L25.84|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L25.52|
000024  480c              LDR      r0,|L25.88|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L25.52|
00002a  f24011b5          MOV      r1,#0x1b5
00002e  480b              LDR      r0,|L25.92|
000030  f7fffffe          BL       assert_failed
                  |L25.52|
;;;438      
;;;439      /* Clear the USART prescaler */
;;;440      USARTx->GTPR &= USART_GTPR_GT;
000034  8b20              LDRH     r0,[r4,#0x18]
000036  f400407f          AND      r0,r0,#0xff00
00003a  8320              STRH     r0,[r4,#0x18]
;;;441      /* Set the USART prescaler */
;;;442      USARTx->GTPR |= USART_Prescaler;
00003c  8b20              LDRH     r0,[r4,#0x18]
00003e  4328              ORRS     r0,r0,r5
000040  8320              STRH     r0,[r4,#0x18]
;;;443    }
000042  bd70              POP      {r4-r6,pc}
;;;444    
                          ENDP

                  |L25.68|
                          DCD      0x40011000
                  |L25.72|
                          DCD      0x40004400
                  |L25.76|
                          DCD      0x40004800
                  |L25.80|
                          DCD      0x40004c00
                  |L25.84|
                          DCD      0x40005000
                  |L25.88|
                          DCD      0x40011400
                  |L25.92|
                          DCD      ||.conststring||

                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=2

                  USART_SmartCardCmd PROC
;;;919      */
;;;920    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;921    {
000002  4604              MOV      r4,r0
;;;922      /* Check the parameters */
;;;923      assert_param(IS_USART_1236_PERIPH(USARTx));
000004  4811              LDR      r0,|L26.76|
000006  460d              MOV      r5,r1                 ;921
000008  4284              CMP      r4,r0
00000a  d00d              BEQ      |L26.40|
00000c  4810              LDR      r0,|L26.80|
00000e  4284              CMP      r4,r0
000010  d00a              BEQ      |L26.40|
000012  4810              LDR      r0,|L26.84|
000014  4284              CMP      r4,r0
000016  d007              BEQ      |L26.40|
000018  480f              LDR      r0,|L26.88|
00001a  4284              CMP      r4,r0
00001c  d004              BEQ      |L26.40|
00001e  f240319b          MOV      r1,#0x39b
000022  480e              LDR      r0,|L26.92|
000024  f7fffffe          BL       assert_failed
                  |L26.40|
;;;924      assert_param(IS_FUNCTIONAL_STATE(NewState));
000028  b155              CBZ      r5,|L26.64|
00002a  2d01              CMP      r5,#1
00002c  d004              BEQ      |L26.56|
00002e  f44f7167          MOV      r1,#0x39c
000032  480a              LDR      r0,|L26.92|
000034  f7fffffe          BL       assert_failed
                  |L26.56|
;;;925      if (NewState != DISABLE)
;;;926      {
;;;927        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;928        USARTx->CR3 |= USART_CR3_SCEN;
000038  8aa0              LDRH     r0,[r4,#0x14]
00003a  f0400020          ORR      r0,r0,#0x20
00003e  e002              B        |L26.70|
                  |L26.64|
;;;929      }
;;;930      else
;;;931      {
;;;932        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;933        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
000040  8aa0              LDRH     r0,[r4,#0x14]
000042  f0200020          BIC      r0,r0,#0x20
                  |L26.70|
000046  82a0              STRH     r0,[r4,#0x14]         ;928
;;;934      }
;;;935    }
000048  bd70              POP      {r4-r6,pc}
;;;936    
                          ENDP

00004a  0000              DCW      0x0000
                  |L26.76|
                          DCD      0x40011000
                  |L26.80|
                          DCD      0x40004400
                  |L26.84|
                          DCD      0x40004800
                  |L26.88|
                          DCD      0x40011400
                  |L26.92|
                          DCD      ||.conststring||

                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=2

                  USART_SmartCardNACKCmd PROC
;;;944      */
;;;945    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;946    {
000002  4604              MOV      r4,r0
;;;947      /* Check the parameters */
;;;948      assert_param(IS_USART_1236_PERIPH(USARTx)); 
000004  4811              LDR      r0,|L27.76|
000006  460d              MOV      r5,r1                 ;946
000008  4284              CMP      r4,r0
00000a  d00d              BEQ      |L27.40|
00000c  4810              LDR      r0,|L27.80|
00000e  4284              CMP      r4,r0
000010  d00a              BEQ      |L27.40|
000012  4810              LDR      r0,|L27.84|
000014  4284              CMP      r4,r0
000016  d007              BEQ      |L27.40|
000018  480f              LDR      r0,|L27.88|
00001a  4284              CMP      r4,r0
00001c  d004              BEQ      |L27.40|
00001e  f44f716d          MOV      r1,#0x3b4
000022  480e              LDR      r0,|L27.92|
000024  f7fffffe          BL       assert_failed
                  |L27.40|
;;;949      assert_param(IS_FUNCTIONAL_STATE(NewState));
000028  b155              CBZ      r5,|L27.64|
00002a  2d01              CMP      r5,#1
00002c  d004              BEQ      |L27.56|
00002e  f24031b5          MOV      r1,#0x3b5
000032  480a              LDR      r0,|L27.92|
000034  f7fffffe          BL       assert_failed
                  |L27.56|
;;;950      if (NewState != DISABLE)
;;;951      {
;;;952        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;953        USARTx->CR3 |= USART_CR3_NACK;
000038  8aa0              LDRH     r0,[r4,#0x14]
00003a  f0400010          ORR      r0,r0,#0x10
00003e  e002              B        |L27.70|
                  |L27.64|
;;;954      }
;;;955      else
;;;956      {
;;;957        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;958        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
000040  8aa0              LDRH     r0,[r4,#0x14]
000042  f0200010          BIC      r0,r0,#0x10
                  |L27.70|
000046  82a0              STRH     r0,[r4,#0x14]         ;953
;;;959      }
;;;960    }
000048  bd70              POP      {r4-r6,pc}
;;;961    
                          ENDP

00004a  0000              DCW      0x0000
                  |L27.76|
                          DCD      0x40011000
                  |L27.80|
                          DCD      0x40004400
                  |L27.84|
                          DCD      0x40004800
                  |L27.88|
                          DCD      0x40011400
                  |L27.92|
                          DCD      ||.conststring||

                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;339      */
;;;340    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;341    {
;;;342      /* USART_InitStruct members default value */
;;;343      USART_InitStruct->USART_BaudRate = 9600;
;;;344      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;345      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;346      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;347      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  220c              MOVS     r2,#0xc
000010  8142              STRH     r2,[r0,#0xa]
;;;348      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  8181              STRH     r1,[r0,#0xc]
;;;349    }
000014  4770              BX       lr
;;;350    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=2

                  USART_WakeUpConfig PROC
;;;651      */
;;;652    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  b570              PUSH     {r4-r6,lr}
;;;653    {
000002  4604              MOV      r4,r0
;;;654      /* Check the parameters */
;;;655      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  4814              LDR      r0,|L29.88|
000006  460d              MOV      r5,r1                 ;653
000008  4284              CMP      r4,r0
00000a  d013              BEQ      |L29.52|
00000c  4813              LDR      r0,|L29.92|
00000e  4284              CMP      r4,r0
000010  d010              BEQ      |L29.52|
000012  4813              LDR      r0,|L29.96|
000014  4284              CMP      r4,r0
000016  d00d              BEQ      |L29.52|
000018  4812              LDR      r0,|L29.100|
00001a  4284              CMP      r4,r0
00001c  d00a              BEQ      |L29.52|
00001e  4812              LDR      r0,|L29.104|
000020  4284              CMP      r4,r0
000022  d007              BEQ      |L29.52|
000024  4811              LDR      r0,|L29.108|
000026  4284              CMP      r4,r0
000028  d004              BEQ      |L29.52|
00002a  f240218f          MOV      r1,#0x28f
00002e  4810              LDR      r0,|L29.112|
000030  f7fffffe          BL       assert_failed
                  |L29.52|
;;;656      assert_param(IS_USART_WAKEUP(USART_WakeUp));
000034  b13d              CBZ      r5,|L29.70|
000036  f5b56f00          CMP      r5,#0x800
00003a  d004              BEQ      |L29.70|
00003c  f44f7124          MOV      r1,#0x290
000040  480b              LDR      r0,|L29.112|
000042  f7fffffe          BL       assert_failed
                  |L29.70|
;;;657      
;;;658      USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
000046  89a0              LDRH     r0,[r4,#0xc]
000048  f4206000          BIC      r0,r0,#0x800
00004c  81a0              STRH     r0,[r4,#0xc]
;;;659      USARTx->CR1 |= USART_WakeUp;
00004e  89a0              LDRH     r0,[r4,#0xc]
000050  4328              ORRS     r0,r0,r5
000052  81a0              STRH     r0,[r4,#0xc]
;;;660    }
000054  bd70              POP      {r4-r6,pc}
;;;661    
                          ENDP

000056  0000              DCW      0x0000
                  |L29.88|
                          DCD      0x40011000
                  |L29.92|
                          DCD      0x40004400
                  |L29.96|
                          DCD      0x40004800
                  |L29.100|
                          DCD      0x40004c00
                  |L29.104|
                          DCD      0x40005000
                  |L29.108|
                          DCD      0x40011400
                  |L29.112|
                          DCD      ||.conststring||

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_usart.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f757361
00004a  72742e63
00004e  00      

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_usart.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_usart_c_9565154b____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f4xx_usart_c_9565154b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_usart_c_9565154b____REVSH|
#line 128
|__asm___17_stm32f4xx_usart_c_9565154b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
