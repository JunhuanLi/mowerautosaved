; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\sys.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\sys.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\sys.crf ..\ext\sys\sys.c]
                          THUMB

                          AREA ||i.Ex_NVIC_Config||, CODE, READONLY, ALIGN=2

                  Ex_NVIC_Config PROC
;;;70     //该函数会自动开启对应中断,以及屏蔽线   	    
;;;71     void Ex_NVIC_Config(u8 GPIOx,u8 BITx,u8 TRIM) 
000000  b570              PUSH     {r4-r6,lr}
;;;72     { 
;;;73     	u8 EXTOFFSET=(BITx%4)*4;  
000002  078b              LSLS     r3,r1,#30
000004  0f1c              LSRS     r4,r3,#28
;;;74     	RCC->APB2ENR|=1<<14;  						//使能SYSCFG时钟  
000006  4b15              LDR      r3,|L1.92|
000008  681d              LDR      r5,[r3,#0]
00000a  f4454580          ORR      r5,r5,#0x4000
00000e  601d              STR      r5,[r3,#0]
;;;75     	SYSCFG->EXTICR[BITx/4]&=~(0x000F<<EXTOFFSET);//清除原来设置！！！
000010  4b13              LDR      r3,|L1.96|
000012  f0210503          BIC      r5,r1,#3
000016  442b              ADD      r3,r3,r5
000018  f8d35808          LDR      r5,[r3,#0x808]
00001c  260f              MOVS     r6,#0xf
00001e  40a6              LSLS     r6,r6,r4
000020  43b5              BICS     r5,r5,r6
000022  f8c35808          STR      r5,[r3,#0x808]
;;;76     	SYSCFG->EXTICR[BITx/4]|=GPIOx<<EXTOFFSET;	//EXTI.BITx映射到GPIOx.BITx 
000026  f8d35808          LDR      r5,[r3,#0x808]
00002a  40a0              LSLS     r0,r0,r4
00002c  4305              ORRS     r5,r5,r0
00002e  f8c35808          STR      r5,[r3,#0x808]
;;;77     	//自动设置
;;;78     	EXTI->IMR|=1<<BITx;					//开启line BITx上的中断(如果要禁止中断，则反操作即可)
000032  4b0c              LDR      r3,|L1.100|
000034  681c              LDR      r4,[r3,#0]
000036  2001              MOVS     r0,#1
000038  4088              LSLS     r0,r0,r1
00003a  4304              ORRS     r4,r4,r0
00003c  601c              STR      r4,[r3,#0]
;;;79     	if(TRIM&0x01)EXTI->FTSR|=1<<BITx;	//line BITx上事件下降沿触发
00003e  07d1              LSLS     r1,r2,#31
000040  d004              BEQ      |L1.76|
000042  4908              LDR      r1,|L1.100|
000044  310c              ADDS     r1,r1,#0xc
000046  680b              LDR      r3,[r1,#0]
000048  4303              ORRS     r3,r3,r0
00004a  600b              STR      r3,[r1,#0]
                  |L1.76|
;;;80     	if(TRIM&0x02)EXTI->RTSR|=1<<BITx;	//line BITx上事件上升降沿触发
00004c  0791              LSLS     r1,r2,#30
00004e  d504              BPL      |L1.90|
000050  4904              LDR      r1,|L1.100|
000052  3108              ADDS     r1,r1,#8
000054  680a              LDR      r2,[r1,#0]
000056  4302              ORRS     r2,r2,r0
000058  600a              STR      r2,[r1,#0]
                  |L1.90|
;;;81     } 	
00005a  bd70              POP      {r4-r6,pc}
;;;82     //GPIO复用设置
                          ENDP

                  |L1.92|
                          DCD      0x40023844
                  |L1.96|
                          DCD      0x40013000
                  |L1.100|
                          DCD      0x40013c00

                          AREA ||i.GPIO_AF_Set||, CODE, READONLY, ALIGN=1

                  GPIO_AF_Set PROC
;;;90     //AF12:FMC/SDIO/OTG/HS   		AF13:DCIM                 		AF14:LCD;                  		AF15:EVENTOUT
;;;91     void GPIO_AF_Set(GPIO_TypeDef* GPIOx,u8 BITx,u8 AFx)
000000  08cb              LSRS     r3,r1,#3
;;;92     {  
000002  b510              PUSH     {r4,lr}
;;;93     	GPIOx->AFR[BITx>>3]&=~(0X0F<<((BITx&0X07)*4));
000004  eb000083          ADD      r0,r0,r3,LSL #2
000008  6a03              LDR      r3,[r0,#0x20]
00000a  0749              LSLS     r1,r1,#29
00000c  0ec9              LSRS     r1,r1,#27
00000e  240f              MOVS     r4,#0xf
000010  408c              LSLS     r4,r4,r1
000012  43a3              BICS     r3,r3,r4
000014  6203              STR      r3,[r0,#0x20]
;;;94     	GPIOx->AFR[BITx>>3]|=(u32)AFx<<((BITx&0X07)*4);
000016  6a03              LDR      r3,[r0,#0x20]
000018  408a              LSLS     r2,r2,r1
00001a  4313              ORRS     r3,r3,r2
00001c  6203              STR      r3,[r0,#0x20]
;;;95     }   
00001e  bd10              POP      {r4,pc}
;;;96     //GPIO通用设置 
                          ENDP


                          AREA ||i.GPIO_Set||, CODE, READONLY, ALIGN=1

                  GPIO_Set PROC
;;;103    //注意:在输入模式(普通输入/模拟输入)下,OTYPE和OSPEED参数无效!!
;;;104    void GPIO_Set(GPIO_TypeDef* GPIOx,u32 BITx,u32 MODE,u32 OTYPE,u32 OSPEED,u32 PUPD)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;105    {  
000004  4699              MOV      r9,r3
000006  e9ddac09          LDRD     r10,r12,[sp,#0x24]
;;;106    	u32 pinpos=0,pos=0,curpin=0;
00000a  2300              MOVS     r3,#0
;;;107    	for(pinpos=0;pinpos<16;pinpos++)
;;;108    	{
;;;109    		pos=1<<pinpos;	//一个个位检查 
00000c  f04f0b01          MOV      r11,#1
;;;110    		curpin=BITx&pos;//检查引脚是否要设置
;;;111    		if(curpin==pos)	//需要设置
;;;112    		{
;;;113    			GPIOx->MODER&=~(3<<(pinpos*2));	//先清除原来的设置
000010  f04f0e03          MOV      lr,#3
                  |L3.20|
000014  fa0bf503          LSL      r5,r11,r3             ;109
000018  ea010405          AND      r4,r1,r5              ;110
00001c  42ac              CMP      r4,r5                 ;111
00001e  d12a              BNE      |L3.118|
000020  6807              LDR      r7,[r0,#0]
000022  005c              LSLS     r4,r3,#1
000024  fa0ef604          LSL      r6,lr,r4
000028  43b7              BICS     r7,r7,r6
00002a  6007              STR      r7,[r0,#0]
;;;114    			GPIOx->MODER|=MODE<<(pinpos*2);	//设置新的模式 
00002c  6807              LDR      r7,[r0,#0]
00002e  fa02f804          LSL      r8,r2,r4
000032  ea470708          ORR      r7,r7,r8
000036  6007              STR      r7,[r0,#0]
;;;115    			if((MODE==0X01)||(MODE==0X02))	//如果是输出模式/复用功能模式
000038  2a01              CMP      r2,#1
00003a  d001              BEQ      |L3.64|
00003c  2a02              CMP      r2,#2
00003e  d112              BNE      |L3.102|
                  |L3.64|
;;;116    			{  
;;;117    				GPIOx->OSPEEDR&=~(3<<(pinpos*2));	//清除原来的设置
000040  6887              LDR      r7,[r0,#8]
000042  43b7              BICS     r7,r7,r6
000044  6087              STR      r7,[r0,#8]
;;;118    				GPIOx->OSPEEDR|=(OSPEED<<(pinpos*2));//设置新的速度值  
000046  f8d08008          LDR      r8,[r0,#8]
00004a  fa0af704          LSL      r7,r10,r4
00004e  ea480807          ORR      r8,r8,r7
000052  f8c08008          STR      r8,[r0,#8]
;;;119    				GPIOx->OTYPER&=~(1<<pinpos) ;		//清除原来的设置
000056  6847              LDR      r7,[r0,#4]
000058  43af              BICS     r7,r7,r5
00005a  6047              STR      r7,[r0,#4]
;;;120    				GPIOx->OTYPER|=OTYPE<<pinpos;		//设置新的输出模式
00005c  6847              LDR      r7,[r0,#4]
00005e  fa09f503          LSL      r5,r9,r3
000062  432f              ORRS     r7,r7,r5
000064  6047              STR      r7,[r0,#4]
                  |L3.102|
;;;121    			}  
;;;122    			GPIOx->PUPDR&=~(3<<(pinpos*2));	//先清除原来的设置
000066  68c5              LDR      r5,[r0,#0xc]
000068  43b5              BICS     r5,r5,r6
00006a  60c5              STR      r5,[r0,#0xc]
;;;123    			GPIOx->PUPDR|=PUPD<<(pinpos*2);	//设置新的上下拉
00006c  68c5              LDR      r5,[r0,#0xc]
00006e  fa0cf404          LSL      r4,r12,r4
000072  4325              ORRS     r5,r5,r4
000074  60c5              STR      r5,[r0,#0xc]
                  |L3.118|
000076  1c5b              ADDS     r3,r3,#1
000078  2b10              CMP      r3,#0x10              ;107
00007a  d3cb              BCC      |L3.20|
;;;124    		}
;;;125    	}
;;;126    } 
00007c  e8bd8ff0          POP      {r4-r11,pc}
;;;127    
                          ENDP


                          AREA ||i.INTX_DISABLE||, CODE, READONLY, ALIGN=1

                  INTX_DISABLE PROC
;;;134    //关闭所有中断(但是不包括fault和NMI中断)
;;;135    void INTX_DISABLE(void)
000000  b672              CPSID    i
;;;136    {
;;;137    	__ASM volatile("cpsid i");
;;;138    }
000002  4770              BX       lr
;;;139    //开启所有中断
                          ENDP


                          AREA ||i.INTX_ENABLE||, CODE, READONLY, ALIGN=1

                  INTX_ENABLE PROC
;;;139    //开启所有中断
;;;140    void INTX_ENABLE(void)
000000  b662              CPSIE    i
;;;141    {
;;;142    	__ASM volatile("cpsie i");		  
;;;143    }
000002  4770              BX       lr
;;;144    //设置栈顶地址
                          ENDP


                          AREA ||i.MY_NVIC_Init||, CODE, READONLY, ALIGN=1

                  MY_NVIC_Init PROC
;;;52     //NVIC_SubPriority和NVIC_PreemptionPriority的原则是,数值越小,越优先	   
;;;53     void MY_NVIC_Init(u8 NVIC_PreemptionPriority,u8 NVIC_SubPriority,u8 NVIC_Channel,u8 NVIC_Group)	 
000000  b5f0              PUSH     {r4-r7,lr}
;;;54     { 
000002  4606              MOV      r6,r0
000004  4614              MOV      r4,r2
000006  460f              MOV      r7,r1
000008  461d              MOV      r5,r3
;;;55     	u32 temp;	  
;;;56     	MY_NVIC_PriorityGroupConfig(NVIC_Group);//设置分组
00000a  4618              MOV      r0,r3
00000c  f7fffffe          BL       MY_NVIC_PriorityGroupConfig
;;;57     	temp=NVIC_PreemptionPriority<<(4-NVIC_Group);	  
000010  f1c50004          RSB      r0,r5,#4
000014  4086              LSLS     r6,r6,r0
;;;58     	temp|=NVIC_SubPriority&(0x0f>>NVIC_Group);
000016  210f              MOVS     r1,#0xf
000018  40e9              LSRS     r1,r1,r5
00001a  4039              ANDS     r1,r1,r7
00001c  4331              ORRS     r1,r1,r6
;;;59     	temp&=0xf;								//取低四位
;;;60     	NVIC->ISER[NVIC_Channel/32]|=1<<NVIC_Channel%32;//使能中断位(要清除的话,设置ICER对应位为1即可)
00001e  0960              LSRS     r0,r4,#5
000020  0080              LSLS     r0,r0,#2
000022  f10020e0          ADD      r0,r0,#0xe000e000
000026  f8d02100          LDR      r2,[r0,#0x100]
00002a  f004051f          AND      r5,r4,#0x1f
00002e  2301              MOVS     r3,#1
000030  40ab              LSLS     r3,r3,r5
000032  431a              ORRS     r2,r2,r3
000034  f8c02100          STR      r2,[r0,#0x100]
000038  f10424e0          ADD      r4,r4,#0xe000e000
;;;61     	NVIC->IP[NVIC_Channel]|=temp<<4;				//设置响应优先级和抢断优先级   	    	  				   
00003c  f8940400          LDRB     r0,[r4,#0x400]
000040  ea401001          ORR      r0,r0,r1,LSL #4
000044  f8840400          STRB     r0,[r4,#0x400]
;;;62     } 
000048  bdf0              POP      {r4-r7,pc}
;;;63     //外部中断配置函数
                          ENDP


                          AREA ||i.MY_NVIC_PriorityGroupConfig||, CODE, READONLY, ALIGN=2

                  MY_NVIC_PriorityGroupConfig PROC
;;;28     //NVIC_Group:NVIC分组 0~4 总共5组 		   
;;;29     void MY_NVIC_PriorityGroupConfig(u8 NVIC_Group)	 
000000  4a06              LDR      r2,|L7.28|
;;;30     { 
;;;31     	u32 temp,temp1;	  
;;;32     	temp1=(~NVIC_Group)&0x07;//取后三位
000002  2107              MOVS     r1,#7
000004  4381              BICS     r1,r1,r0
;;;33     	temp1<<=8;
;;;34     	temp=SCB->AIRCR;  //读取先前的设置
000006  6810              LDR      r0,[r2,#0]
;;;35     	temp&=0X0000F8FF; //清空先前分组
000008  f64f03ff          MOV      r3,#0xf8ff
00000c  4018              ANDS     r0,r0,r3
;;;36     	temp|=0X05FA0000; //写入钥匙
00000e  4b04              LDR      r3,|L7.32|
000010  4318              ORRS     r0,r0,r3
;;;37     	temp|=temp1;	   
000012  ea402001          ORR      r0,r0,r1,LSL #8
;;;38     	SCB->AIRCR=temp;  //设置分组	    	  				   
000016  6010              STR      r0,[r2,#0]
;;;39     }
000018  4770              BX       lr
;;;40     //设置NVIC 
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0xe000ed0c
                  |L7.32|
                          DCD      0x05fa0000

                          AREA ||i.MY_NVIC_SetVectorTable||, CODE, READONLY, ALIGN=2

                  MY_NVIC_SetVectorTable PROC
;;;22     //Offset:偏移量		 
;;;23     void MY_NVIC_SetVectorTable(u32 NVIC_VectTab,u32 Offset)	 
000000  f36f0108          BFC      r1,#0,#9
;;;24     { 	   	  
;;;25     	SCB->VTOR=NVIC_VectTab|(Offset&(u32)0xFFFFFE00);//设置NVIC的向量表偏移寄存器,VTOR低9位保留,即[8:0]保留。
000004  4301              ORRS     r1,r1,r0
000006  4801              LDR      r0,|L8.12|
000008  6001              STR      r1,[r0,#0]
;;;26     }
00000a  4770              BX       lr
;;;27     //设置NVIC分组
                          ENDP

                  |L8.12|
                          DCD      0xe000ed08

                          AREA ||i.Stm32_Clock_Init||, CODE, READONLY, ALIGN=2

                  Stm32_Clock_Init PROC
;;;216    //pllq:USB/SDIO/随机数产生器等的主PLL分频系数(PLL之后的分频),取值范围:2~15.
;;;217    void Stm32_Clock_Init(u32 plln,u32 pllm,u32 pllp,u32 pllq)
000000  b5f0              PUSH     {r4-r7,lr}
;;;218    {  
;;;219    	RCC->CR|=0x00000001;		//设置HISON,开启内部高速RC振荡
000002  4c0f              LDR      r4,|L9.64|
000004  6825              LDR      r5,[r4,#0]
000006  f0450501          ORR      r5,r5,#1
00000a  6025              STR      r5,[r4,#0]
;;;220    	RCC->CFGR=0x00000000;		//CFGR清零 
00000c  4e0c              LDR      r6,|L9.64|
00000e  2500              MOVS     r5,#0
000010  3608              ADDS     r6,r6,#8
000012  6035              STR      r5,[r6,#0]
;;;221    	RCC->CR&=0xFEF6FFFF;		//HSEON,CSSON,PLLON清零 
000014  6826              LDR      r6,[r4,#0]
000016  4f0b              LDR      r7,|L9.68|
000018  403e              ANDS     r6,r6,r7
00001a  6026              STR      r6,[r4,#0]
;;;222    	RCC->PLLCFGR=0x24003010;	//PLLCFGR恢复复位值 
00001c  1d27              ADDS     r7,r4,#4
00001e  4e0a              LDR      r6,|L9.72|
000020  603e              STR      r6,[r7,#0]
;;;223    	RCC->CR&=~(1<<18);			//HSEBYP清零,外部晶振不旁路
000022  6826              LDR      r6,[r4,#0]
000024  f4262680          BIC      r6,r6,#0x40000
000028  6026              STR      r6,[r4,#0]
;;;224    	RCC->CIR=0x00000000;		//禁止RCC时钟中断 
00002a  4c05              LDR      r4,|L9.64|
00002c  340c              ADDS     r4,r4,#0xc
00002e  6025              STR      r5,[r4,#0]
;;;225    	Sys_Clock_Set(plln,pllm,pllp,pllq);//设置时钟 
000030  f7fffffe          BL       Sys_Clock_Set
;;;226    	//配置向量表				  
;;;227    #ifdef  VECT_TAB_RAM
;;;228    	MY_NVIC_SetVectorTable(1<<29,0x0);
;;;229    #else   
;;;230    	MY_NVIC_SetVectorTable(0,0x0);
000034  e8bd40f0          POP      {r4-r7,lr}
000038  2100              MOVS     r1,#0
00003a  4608              MOV      r0,r1
00003c  f7ffbffe          B.W      MY_NVIC_SetVectorTable
;;;231    #endif 
;;;232    }		    
;;;233    
                          ENDP

                  |L9.64|
                          DCD      0x40023800
                  |L9.68|
                          DCD      0xfef6ffff
                  |L9.72|
                          DCD      0x24003010

                          AREA ||i.Sys_Clock_Set||, CODE, READONLY, ALIGN=2

                  Sys_Clock_Set PROC
;;;184    //返回值:0,成功;1,失败。
;;;185    u8 Sys_Clock_Set(u32 plln,u32 pllm,u32 pllp,u32 pllq)
000000  b5f0              PUSH     {r4-r7,lr}
;;;186    { 
;;;187    	u16 retry=0;
;;;188    	u8 status=0;
;;;189    	RCC->CR|=1<<16;				//HSE 开启 
000002  4d30              LDR      r5,|L10.196|
000004  4606              MOV      r6,r0                 ;186
000006  2400              MOVS     r4,#0                 ;187
000008  682f              LDR      r7,[r5,#0]
00000a  4620              MOV      r0,r4                 ;188
00000c  f4473780          ORR      r7,r7,#0x10000
000010  602f              STR      r7,[r5,#0]
;;;190    	while(((RCC->CR&(1<<17))==0)&&(retry<0X1FFF))retry++;//等待HSE RDY
000012  f64177ff          MOV      r7,#0x1fff
000016  e001              B        |L10.28|
                  |L10.24|
000018  1c64              ADDS     r4,r4,#1              ;186
00001a  b2a4              UXTH     r4,r4
                  |L10.28|
00001c  f8d5c000          LDR      r12,[r5,#0]
000020  ea5f3c8c          LSLS     r12,r12,#14
000024  d401              BMI      |L10.42|
000026  42bc              CMP      r4,r7
000028  d3f6              BCC      |L10.24|
                  |L10.42|
;;;191    	if(retry==0X1FFF)status=1;	//HSE无法就绪
00002a  42bc              CMP      r4,r7
00002c  d101              BNE      |L10.50|
00002e  2001              MOVS     r0,#1
;;;192    	else   
;;;193    	{
;;;194    		RCC->APB1ENR|=1<<28;	//电源接口时钟使能
;;;195    		PWR->CR|=3<<14; 		//高性能模式,时钟可到180Mhz
;;;196    		RCC->CFGR|=(0<<4)|(5<<10)|(4<<13);//HCLK 不分频;APB1 4分频;APB2 2分频. 
;;;197    		RCC->CR&=~(1<<24);	//关闭主PLL
;;;198    		RCC->PLLCFGR=pllm|(plln<<6)|(((pllp>>1)-1)<<16)|(pllq<<24)|(1<<22);//配置主PLL,PLL时钟源来自HSE
;;;199    		RCC->CR|=1<<24;			//打开主PLL
;;;200    		while((RCC->CR&(1<<25))==0);//等待PLL准备好 
;;;201    		FLASH->ACR|=1<<8;		//指令预取使能.
;;;202    		FLASH->ACR|=1<<9;		//指令cache使能.
;;;203    		FLASH->ACR|=1<<10;		//数据cache使能.
;;;204    		FLASH->ACR|=5<<0;		//5个CPU等待周期. 
;;;205    		RCC->CFGR&=~(3<<0);		//清零
;;;206    		RCC->CFGR|=2<<0;		//选择主PLL作为系统时钟	 
;;;207    		while((RCC->CFGR&(3<<2))!=(2<<2));//等待主PLL作为系统时钟成功. 
;;;208    	} 
;;;209    	return status;
;;;210    }  
000030  bdf0              POP      {r4-r7,pc}
                  |L10.50|
000032  4c24              LDR      r4,|L10.196|
000034  3440              ADDS     r4,r4,#0x40           ;194
000036  6827              LDR      r7,[r4,#0]            ;194
000038  f0475780          ORR      r7,r7,#0x10000000     ;194
00003c  6027              STR      r7,[r4,#0]            ;194
00003e  4c22              LDR      r4,|L10.200|
000040  6827              LDR      r7,[r4,#0]            ;195
000042  f4474740          ORR      r7,r7,#0xc000         ;195
000046  6027              STR      r7,[r4,#0]            ;195
000048  4c1e              LDR      r4,|L10.196|
00004a  3408              ADDS     r4,r4,#8              ;196
00004c  6827              LDR      r7,[r4,#0]            ;196
00004e  f4474714          ORR      r7,r7,#0x9400         ;196
000052  6027              STR      r7,[r4,#0]            ;196
000054  682f              LDR      r7,[r5,#0]            ;197
000056  f0277780          BIC      r7,r7,#0x1000000      ;197
00005a  602f              STR      r7,[r5,#0]            ;197
00005c  ea411186          ORR      r1,r1,r6,LSL #6       ;198
000060  4e1a              LDR      r6,|L10.204|
000062  0852              LSRS     r2,r2,#1              ;198
000064  eb064202          ADD      r2,r6,r2,LSL #16      ;198
000068  4311              ORRS     r1,r1,r2              ;198
00006a  ea416103          ORR      r1,r1,r3,LSL #24      ;198
00006e  1f22              SUBS     r2,r4,#4              ;198
000070  f4410180          ORR      r1,r1,#0x400000       ;198
000074  6011              STR      r1,[r2,#0]            ;198
000076  6829              LDR      r1,[r5,#0]            ;199
000078  f0417180          ORR      r1,r1,#0x1000000      ;199
00007c  6029              STR      r1,[r5,#0]            ;199
                  |L10.126|
00007e  6829              LDR      r1,[r5,#0]            ;200
000080  0189              LSLS     r1,r1,#6              ;200
000082  d5fc              BPL      |L10.126|
000084  4912              LDR      r1,|L10.208|
000086  680a              LDR      r2,[r1,#0]            ;201
000088  f4427280          ORR      r2,r2,#0x100          ;201
00008c  600a              STR      r2,[r1,#0]            ;201
00008e  680a              LDR      r2,[r1,#0]            ;202
000090  f4427200          ORR      r2,r2,#0x200          ;202
000094  600a              STR      r2,[r1,#0]            ;202
000096  680a              LDR      r2,[r1,#0]            ;203
000098  f4426280          ORR      r2,r2,#0x400          ;203
00009c  600a              STR      r2,[r1,#0]            ;203
00009e  680a              LDR      r2,[r1,#0]            ;204
0000a0  f0420205          ORR      r2,r2,#5              ;204
0000a4  600a              STR      r2,[r1,#0]            ;204
0000a6  6821              LDR      r1,[r4,#0]            ;205
0000a8  f0210103          BIC      r1,r1,#3              ;205
0000ac  6021              STR      r1,[r4,#0]            ;205
0000ae  6821              LDR      r1,[r4,#0]            ;206
0000b0  f0410102          ORR      r1,r1,#2              ;206
0000b4  6021              STR      r1,[r4,#0]            ;206
                  |L10.182|
0000b6  6821              LDR      r1,[r4,#0]            ;207
0000b8  f3c10181          UBFX     r1,r1,#2,#2           ;207
0000bc  2902              CMP      r1,#2                 ;207
0000be  d1fa              BNE      |L10.182|
0000c0  bdf0              POP      {r4-r7,pc}
;;;211    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L10.196|
                          DCD      0x40023800
                  |L10.200|
                          DCD      0x40007000
                  |L10.204|
                          DCD      0xffff0000
                  |L10.208|
                          DCD      0x40023c00

                          AREA ||i.Sys_Soft_Reset||, CODE, READONLY, ALIGN=2

                  Sys_Soft_Reset PROC
;;;161    //系统软复位   
;;;162    void Sys_Soft_Reset(void)
000000  4902              LDR      r1,|L11.12|
;;;163    {   
;;;164    	SCB->AIRCR =0X05FA0000|(u32)0x04;	  
000002  4801              LDR      r0,|L11.8|
000004  6008              STR      r0,[r1,#0]
;;;165    } 		 
000006  4770              BX       lr
;;;166    //时钟设置函数
                          ENDP

                  |L11.8|
                          DCD      0x05fa0004
                  |L11.12|
                          DCD      0xe000ed0c

                          AREA ||i.Sys_Standby||, CODE, READONLY, ALIGN=2

                  Sys_Standby PROC
;;;151    //进入待机模式	  
;;;152    void Sys_Standby(void)
000000  480c              LDR      r0,|L12.52|
;;;153    { 
;;;154    	SCB->SCR|=1<<2;		//使能SLEEPDEEP位 (SYS->CTRL)	   
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;155    	RCC->APB1ENR|=1<<28;//使能电源时钟 
00000a  480b              LDR      r0,|L12.56|
00000c  6801              LDR      r1,[r0,#0]
00000e  f0415180          ORR      r1,r1,#0x10000000
000012  6001              STR      r1,[r0,#0]
;;;156    	PWR->CSR|=1<<8;     //设置WKUP用于唤醒
000014  4809              LDR      r0,|L12.60|
000016  6841              LDR      r1,[r0,#4]
000018  f4417180          ORR      r1,r1,#0x100
00001c  6041              STR      r1,[r0,#4]
;;;157    	PWR->CR|=1<<2;      //清除Wake-up 标志
00001e  6801              LDR      r1,[r0,#0]
000020  f0410104          ORR      r1,r1,#4
000024  6001              STR      r1,[r0,#0]
;;;158    	PWR->CR|=1<<1;      //PDDS置位   	
000026  6801              LDR      r1,[r0,#0]
000028  f0410102          ORR      r1,r1,#2
00002c  6001              STR      r1,[r0,#0]
00002e  bf30              WFI      
;;;159    	WFI_SET();			//执行WFI指令,进入待机模式		 
;;;160    }	     
000030  4770              BX       lr
;;;161    //系统软复位   
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      0xe000ed10
                  |L12.56|
                          DCD      0x40023840
                  |L12.60|
                          DCD      0x40007000

                          AREA ||i.WFI_SET||, CODE, READONLY, ALIGN=1

                  WFI_SET PROC
;;;129    //采用如下方法实现执行汇编指令WFI  
;;;130    void WFI_SET(void)
000000  bf30              WFI      
;;;131    {
;;;132    	__ASM volatile("wfi");		  
;;;133    }
000002  4770              BX       lr
;;;134    //关闭所有中断(但是不包括fault和NMI中断)
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\ext\\sys\\sys.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_sys_c_d144038c____REV16|
#line 388 "..\\ext\\inc\\cmsis_armcc.h"
|__asm___5_sys_c_d144038c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_sys_c_d144038c____REVSH|
#line 402
|__asm___5_sys_c_d144038c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_sys_c_d144038c____RRX|
#line 587
|__asm___5_sys_c_d144038c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |MSR_MSP|
#line 146 "..\\ext\\sys\\sys.c"
|MSR_MSP| PROC
#line 147

 MSR MSP, r0  
 BX r14
	ENDP

;*** End   embedded assembler ***
