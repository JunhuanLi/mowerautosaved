; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_cryp_aes.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_cryp_aes.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_cryp_aes.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_aes.c]
                          THUMB

                          AREA ||i.CRYP_AES_CBC||, CODE, READONLY, ALIGN=1

                  CRYP_AES_CBC PROC
;;;278      */
;;;279    ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;280                             uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
;;;281                             uint8_t *Output)
;;;282    {
000004  b08f              SUB      sp,sp,#0x3c
;;;283      CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;284      CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;285      CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
;;;286      __IO uint32_t counter = 0;
000006  f04f0800          MOV      r8,#0
00000a  e9dd4a1c          LDRD     r4,r10,[sp,#0x70]     ;282
00000e  9d1e              LDR      r5,[sp,#0x78]
000010  469b              MOV      r11,r3                ;282
000012  4616              MOV      r6,r2                 ;282
;;;287      uint32_t busystatus = 0;
;;;288      ErrorStatus status = SUCCESS;
000014  2701              MOVS     r7,#1
;;;289      uint32_t keyaddr    = (uint32_t)Key;
;;;290      uint32_t inputaddr  = (uint32_t)Input;
;;;291      uint32_t outputaddr = (uint32_t)Output;
;;;292      uint32_t ivaddr     = (uint32_t)InitVectors;
000016  4689              MOV      r9,r1
;;;293      uint32_t i = 0;
;;;294    
;;;295      /* Crypto structures initialisation*/
;;;296      CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
000018  4668              MOV      r0,sp
00001a  f8cd8028          STR      r8,[sp,#0x28]
00001e  f7fffffe          BL       CRYP_KeyStructInit
;;;297    
;;;298      switch(Keysize)
000022  4658              MOV      r0,r11
000024  f1bb0f80          CMP      r11,#0x80
000028  d01e              BEQ      |L1.104|
00002a  0239              LSLS     r1,r7,#8
00002c  28c0              CMP      r0,#0xc0
00002e  d028              BEQ      |L1.130|
000030  458b              CMP      r11,r1
000032  d13a              BNE      |L1.170|
;;;299      {
;;;300        case 128:
;;;301        AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
;;;302        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;303        keyaddr+=4;
;;;304        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;305        keyaddr+=4;
;;;306        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;307        keyaddr+=4;
;;;308        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;309        break;
;;;310        case 192:
;;;311        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
;;;312        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
;;;313        keyaddr+=4;
;;;314        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
;;;315        keyaddr+=4;
;;;316        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;317        keyaddr+=4;
;;;318        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;319        keyaddr+=4;
;;;320        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;321        keyaddr+=4;
;;;322        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;323        break;
;;;324        case 256:
;;;325        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000034  0048              LSLS     r0,r1,#1
000036  f8ad0026          STRH     r0,[sp,#0x26]
;;;326        AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
00003a  6830              LDR      r0,[r6,#0]
00003c  ba00              REV      r0,r0
;;;327        keyaddr+=4;
;;;328        AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
00003e  9000              STR      r0,[sp,#0]
000040  6870              LDR      r0,[r6,#4]
000042  ba00              REV      r0,r0
;;;329        keyaddr+=4;
;;;330        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000044  9001              STR      r0,[sp,#4]
000046  68b0              LDR      r0,[r6,#8]
000048  ba00              REV      r0,r0
;;;331        keyaddr+=4;
;;;332        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
00004a  9002              STR      r0,[sp,#8]
00004c  68f0              LDR      r0,[r6,#0xc]
00004e  ba00              REV      r0,r0
;;;333        keyaddr+=4;
;;;334        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000050  9003              STR      r0,[sp,#0xc]
000052  6930              LDR      r0,[r6,#0x10]
000054  ba00              REV      r0,r0
;;;335        keyaddr+=4;
;;;336        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000056  9004              STR      r0,[sp,#0x10]
000058  6970              LDR      r0,[r6,#0x14]
00005a  ba00              REV      r0,r0
;;;337        keyaddr+=4;
;;;338        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
00005c  9005              STR      r0,[sp,#0x14]
00005e  69b0              LDR      r0,[r6,#0x18]
000060  ba00              REV      r0,r0
;;;339        keyaddr+=4;
;;;340        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000062  9006              STR      r0,[sp,#0x18]
;;;341        break;
000064  69f0              LDR      r0,[r6,#0x1c]
000066  e01e              B        |L1.166|
                  |L1.104|
000068  f8ad8026          STRH     r8,[sp,#0x26]         ;301
00006c  6830              LDR      r0,[r6,#0]            ;302
00006e  ba00              REV      r0,r0                 ;302
000070  9004              STR      r0,[sp,#0x10]         ;304
000072  6870              LDR      r0,[r6,#4]            ;304
000074  ba00              REV      r0,r0                 ;304
000076  9005              STR      r0,[sp,#0x14]         ;306
000078  68b0              LDR      r0,[r6,#8]            ;306
00007a  ba00              REV      r0,r0                 ;306
00007c  9006              STR      r0,[sp,#0x18]         ;308
00007e  68f0              LDR      r0,[r6,#0xc]          ;309
000080  e011              B        |L1.166|
                  |L1.130|
000082  f8ad1026          STRH     r1,[sp,#0x26]         ;311
000086  6830              LDR      r0,[r6,#0]            ;312
000088  ba00              REV      r0,r0                 ;312
00008a  9002              STR      r0,[sp,#8]            ;314
00008c  6870              LDR      r0,[r6,#4]            ;314
00008e  ba00              REV      r0,r0                 ;314
000090  9003              STR      r0,[sp,#0xc]          ;316
000092  68b0              LDR      r0,[r6,#8]            ;316
000094  ba00              REV      r0,r0                 ;316
000096  9004              STR      r0,[sp,#0x10]         ;318
000098  68f0              LDR      r0,[r6,#0xc]          ;318
00009a  ba00              REV      r0,r0                 ;318
00009c  9005              STR      r0,[sp,#0x14]         ;320
00009e  6930              LDR      r0,[r6,#0x10]         ;320
0000a0  ba00              REV      r0,r0                 ;320
0000a2  9006              STR      r0,[sp,#0x18]         ;322
0000a4  6970              LDR      r0,[r6,#0x14]         ;322
                  |L1.166|
0000a6  ba00              REV      r0,r0                 ;308
0000a8  9007              STR      r0,[sp,#0x1c]         ;308
                  |L1.170|
;;;342        default:
;;;343        break;
;;;344      }
;;;345    
;;;346      /* CRYP Initialization Vectors */
;;;347      AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
0000aa  f8d90000          LDR      r0,[r9,#0]
0000ae  ba00              REV      r0,r0
;;;348      ivaddr+=4;
;;;349      AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
0000b0  900b              STR      r0,[sp,#0x2c]
0000b2  f8d91004          LDR      r1,[r9,#4]
0000b6  ba09              REV      r1,r1
;;;350      ivaddr+=4;
;;;351      AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
0000b8  910c              STR      r1,[sp,#0x30]
0000ba  f8d91008          LDR      r1,[r9,#8]
0000be  ba09              REV      r1,r1
;;;352      ivaddr+=4;
;;;353      AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
0000c0  910d              STR      r1,[sp,#0x34]
0000c2  f8d9000c          LDR      r0,[r9,#0xc]
;;;354    
;;;355    
;;;356      /*------------------ AES Decryption ------------------*/
;;;357      if(Mode == MODE_DECRYPT) /* AES decryption */
;;;358      {
;;;359        /* Flush IN/OUT FIFOs */
;;;360        CRYP_FIFOFlush();
;;;361    
;;;362        /* Crypto Init for Key preparation for decryption process */
;;;363        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;364        AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
;;;365        AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
;;;366    
;;;367        CRYP_Init(&AES_CRYP_InitStructure);
;;;368    
;;;369        /* Key Initialisation */
;;;370        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
;;;371    
;;;372        /* Enable Crypto processor */
;;;373        CRYP_Cmd(ENABLE);
;;;374    
;;;375        /* wait until the Busy flag is RESET */
;;;376        do
;;;377        {
;;;378          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;379          counter++;
;;;380        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
0000c6  f44f3980          MOV      r9,#0x10000
0000ca  ba00              REV      r0,r0                 ;353
0000cc  900e              STR      r0,[sp,#0x38]         ;357
0000ce  980f              LDR      r0,[sp,#0x3c]         ;357
0000d0  b1b8              CBZ      r0,|L1.258|
;;;381    
;;;382        if (busystatus != RESET)
;;;383       {
;;;384           status = ERROR;
;;;385        }
;;;386        else
;;;387        {
;;;388          /* Crypto Init for decryption process */  
;;;389          AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;390        }
;;;391      }
;;;392      /*------------------ AES Encryption ------------------*/
;;;393      else /* AES encryption */
;;;394      {
;;;395        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
0000d2  4668              MOV      r0,sp
0000d4  f7fffffe          BL       CRYP_KeyInit
;;;396    
;;;397        /* Crypto Init for Encryption process */
;;;398        AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
0000d8  f8ad8020          STRH     r8,[sp,#0x20]
                  |L1.220|
;;;399      }
;;;400      AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;
0000dc  2028              MOVS     r0,#0x28
0000de  f8ad0022          STRH     r0,[sp,#0x22]
;;;401      AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
0000e2  2080              MOVS     r0,#0x80
0000e4  f8ad0024          STRH     r0,[sp,#0x24]
;;;402      CRYP_Init(&AES_CRYP_InitStructure);
0000e8  a808              ADD      r0,sp,#0x20
0000ea  f7fffffe          BL       CRYP_Init
;;;403    
;;;404      /* CRYP Initialization Vectors */
;;;405      CRYP_IVInit(&AES_CRYP_IVInitStructure);
0000ee  a80b              ADD      r0,sp,#0x2c
0000f0  f7fffffe          BL       CRYP_IVInit
;;;406    
;;;407      /* Flush IN/OUT FIFOs */
;;;408      CRYP_FIFOFlush();
0000f4  f7fffffe          BL       CRYP_FIFOFlush
;;;409    
;;;410      /* Enable Crypto processor */
;;;411      CRYP_Cmd(ENABLE);
0000f8  2001              MOVS     r0,#1
0000fa  f7fffffe          BL       CRYP_Cmd
;;;412    
;;;413    
;;;414      for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
0000fe  2600              MOVS     r6,#0
000100  e051              B        |L1.422|
                  |L1.258|
000102  f7fffffe          BL       CRYP_FIFOFlush
000106  2604              MOVS     r6,#4                 ;363
000108  f8ad6020          STRH     r6,[sp,#0x20]         ;363
00010c  2038              MOVS     r0,#0x38              ;364
00010e  f8ad0022          STRH     r0,[sp,#0x22]         ;364
000112  f8ad8024          STRH     r8,[sp,#0x24]         ;365
000116  a808              ADD      r0,sp,#0x20           ;367
000118  f7fffffe          BL       CRYP_Init
00011c  4668              MOV      r0,sp                 ;370
00011e  f7fffffe          BL       CRYP_KeyInit
000122  2001              MOVS     r0,#1                 ;373
000124  f7fffffe          BL       CRYP_Cmd
                  |L1.296|
000128  2010              MOVS     r0,#0x10              ;378
00012a  f7fffffe          BL       CRYP_GetFlagStatus
00012e  990a              LDR      r1,[sp,#0x28]         ;379
000130  1c49              ADDS     r1,r1,#1              ;379
000132  910a              STR      r1,[sp,#0x28]         ;380
000134  4549              CMP      r1,r9                 ;380
000136  d002              BEQ      |L1.318|
000138  2800              CMP      r0,#0                 ;380
00013a  d1f5              BNE      |L1.296|
00013c  e002              B        |L1.324|
                  |L1.318|
00013e  b108              CBZ      r0,|L1.324|
000140  2700              MOVS     r7,#0                 ;384
000142  e7cb              B        |L1.220|
                  |L1.324|
000144  f8ad6020          STRH     r6,[sp,#0x20]         ;389
000148  e7c8              B        |L1.220|
                  |L1.330|
;;;415      {
;;;416    
;;;417        /* Write the Input block in the IN FIFO */
;;;418        CRYP_DataIn(*(uint32_t*)(inputaddr));
00014a  6820              LDR      r0,[r4,#0]
00014c  f7fffffe          BL       CRYP_DataIn
;;;419        inputaddr+=4;
;;;420        CRYP_DataIn(*(uint32_t*)(inputaddr));
000150  f8540f04          LDR      r0,[r4,#4]!
000154  f7fffffe          BL       CRYP_DataIn
;;;421        inputaddr+=4;
;;;422        CRYP_DataIn(*(uint32_t*)(inputaddr));
000158  f8540f04          LDR      r0,[r4,#4]!
00015c  f7fffffe          BL       CRYP_DataIn
;;;423        inputaddr+=4;
;;;424        CRYP_DataIn(*(uint32_t*)(inputaddr));
000160  f8540f04          LDR      r0,[r4,#4]!
000164  f7fffffe          BL       CRYP_DataIn
;;;425        inputaddr+=4;
;;;426        /* Wait until the complete message has been processed */
;;;427        counter = 0;
000168  1d24              ADDS     r4,r4,#4
00016a  f8cd8028          STR      r8,[sp,#0x28]
                  |L1.366|
;;;428        do
;;;429        {
;;;430          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
00016e  2010              MOVS     r0,#0x10
000170  f7fffffe          BL       CRYP_GetFlagStatus
;;;431          counter++;
000174  990a              LDR      r1,[sp,#0x28]
000176  1c49              ADDS     r1,r1,#1
;;;432        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
000178  910a              STR      r1,[sp,#0x28]
00017a  4549              CMP      r1,r9
00017c  d002              BEQ      |L1.388|
00017e  2800              CMP      r0,#0
000180  d1f5              BNE      |L1.366|
000182  e002              B        |L1.394|
                  |L1.388|
;;;433    
;;;434        if (busystatus != RESET)
000184  b108              CBZ      r0,|L1.394|
;;;435       {
;;;436           status = ERROR;
000186  2700              MOVS     r7,#0
000188  e00c              B        |L1.420|
                  |L1.394|
;;;437        }
;;;438        else
;;;439        {
;;;440    
;;;441          /* Read the Output block from the Output FIFO */
;;;442          *(uint32_t*)(outputaddr) = CRYP_DataOut();
00018a  f7fffffe          BL       CRYP_DataOut
;;;443          outputaddr+=4;
;;;444          *(uint32_t*)(outputaddr) = CRYP_DataOut();
00018e  6028              STR      r0,[r5,#0]
000190  f7fffffe          BL       CRYP_DataOut
;;;445          outputaddr+=4;
;;;446          *(uint32_t*)(outputaddr) = CRYP_DataOut();
000194  6068              STR      r0,[r5,#4]
000196  f7fffffe          BL       CRYP_DataOut
;;;447          outputaddr+=4;
;;;448          *(uint32_t*)(outputaddr) = CRYP_DataOut();
00019a  60a8              STR      r0,[r5,#8]
00019c  f7fffffe          BL       CRYP_DataOut
0001a0  60e8              STR      r0,[r5,#0xc]
0001a2  3510              ADDS     r5,r5,#0x10
                  |L1.420|
0001a4  3610              ADDS     r6,r6,#0x10
                  |L1.422|
0001a6  4556              CMP      r6,r10                ;414
0001a8  d201              BCS      |L1.430|
0001aa  2f00              CMP      r7,#0                 ;414
0001ac  d1cd              BNE      |L1.330|
                  |L1.430|
;;;449          outputaddr+=4;
;;;450        }
;;;451      }
;;;452    
;;;453      /* Disable Crypto */
;;;454      CRYP_Cmd(DISABLE);
0001ae  2000              MOVS     r0,#0
0001b0  f7fffffe          BL       CRYP_Cmd
;;;455    
;;;456      return status;
;;;457    }
0001b4  b013              ADD      sp,sp,#0x4c
0001b6  4638              MOV      r0,r7                 ;456
0001b8  e8bd8ff0          POP      {r4-r11,pc}
;;;458    
                          ENDP


                          AREA ||i.CRYP_AES_CTR||, CODE, READONLY, ALIGN=1

                  CRYP_AES_CTR PROC
;;;474      */
;;;475    ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, 
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;476                             uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
;;;477                             uint8_t *Output)
;;;478    {
000004  b08f              SUB      sp,sp,#0x3c
;;;479      CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;480      CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;481      CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
;;;482      __IO uint32_t counter = 0;
000006  f04f0900          MOV      r9,#0
00000a  e9dd4b1c          LDRD     r4,r11,[sp,#0x70]     ;478
00000e  4617              MOV      r7,r2                 ;478
000010  9d1e              LDR      r5,[sp,#0x78]
;;;483      uint32_t busystatus = 0;
;;;484      ErrorStatus status = SUCCESS;
000012  f04f0801          MOV      r8,#1
;;;485      uint32_t keyaddr    = (uint32_t)Key;
;;;486      uint32_t inputaddr  = (uint32_t)Input;
;;;487      uint32_t outputaddr = (uint32_t)Output;
;;;488      uint32_t ivaddr     = (uint32_t)InitVectors;
000016  468a              MOV      r10,r1
;;;489      uint32_t i = 0;
000018  464e              MOV      r6,r9
;;;490    
;;;491      /* Crypto structures initialisation*/
;;;492      CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
00001a  4668              MOV      r0,sp
00001c  f8cd9038          STR      r9,[sp,#0x38]
000020  f7fffffe          BL       CRYP_KeyStructInit
;;;493    
;;;494      switch(Keysize)
000024  9812              LDR      r0,[sp,#0x48]
000026  2880              CMP      r0,#0x80
000028  d01f              BEQ      |L2.106|
00002a  f44f7180          MOV      r1,#0x100
00002e  28c0              CMP      r0,#0xc0
000030  d028              BEQ      |L2.132|
000032  4288              CMP      r0,r1
000034  d13a              BNE      |L2.172|
;;;495      {
;;;496        case 128:
;;;497        AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
;;;498        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;499        keyaddr+=4;
;;;500        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;501        keyaddr+=4;
;;;502        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;503        keyaddr+=4;
;;;504        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;505        break;
;;;506        case 192:
;;;507        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
;;;508        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
;;;509        keyaddr+=4;
;;;510        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
;;;511        keyaddr+=4;
;;;512        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;513        keyaddr+=4;
;;;514        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;515        keyaddr+=4;
;;;516        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;517        keyaddr+=4;
;;;518        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;519        break;
;;;520        case 256:
;;;521        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000036  0040              LSLS     r0,r0,#1
000038  f8ad0026          STRH     r0,[sp,#0x26]
;;;522        AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
00003c  6838              LDR      r0,[r7,#0]
00003e  ba00              REV      r0,r0
;;;523        keyaddr+=4;
;;;524        AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
000040  9000              STR      r0,[sp,#0]
000042  6878              LDR      r0,[r7,#4]
000044  ba00              REV      r0,r0
;;;525        keyaddr+=4;
;;;526        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000046  9001              STR      r0,[sp,#4]
000048  68b8              LDR      r0,[r7,#8]
00004a  ba00              REV      r0,r0
;;;527        keyaddr+=4;
;;;528        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
00004c  9002              STR      r0,[sp,#8]
00004e  68f8              LDR      r0,[r7,#0xc]
000050  ba00              REV      r0,r0
;;;529        keyaddr+=4;
;;;530        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000052  9003              STR      r0,[sp,#0xc]
000054  6938              LDR      r0,[r7,#0x10]
000056  ba00              REV      r0,r0
;;;531        keyaddr+=4;
;;;532        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000058  9004              STR      r0,[sp,#0x10]
00005a  6978              LDR      r0,[r7,#0x14]
00005c  ba00              REV      r0,r0
;;;533        keyaddr+=4;
;;;534        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
00005e  9005              STR      r0,[sp,#0x14]
000060  69b8              LDR      r0,[r7,#0x18]
000062  ba00              REV      r0,r0
;;;535        keyaddr+=4;
;;;536        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000064  9006              STR      r0,[sp,#0x18]
;;;537        break;
000066  69f8              LDR      r0,[r7,#0x1c]
000068  e01e              B        |L2.168|
                  |L2.106|
00006a  f8ad9026          STRH     r9,[sp,#0x26]         ;497
00006e  6838              LDR      r0,[r7,#0]            ;498
000070  ba00              REV      r0,r0                 ;498
000072  9004              STR      r0,[sp,#0x10]         ;500
000074  6878              LDR      r0,[r7,#4]            ;500
000076  ba00              REV      r0,r0                 ;500
000078  9005              STR      r0,[sp,#0x14]         ;502
00007a  68b8              LDR      r0,[r7,#8]            ;502
00007c  ba00              REV      r0,r0                 ;502
00007e  9006              STR      r0,[sp,#0x18]         ;504
000080  68f8              LDR      r0,[r7,#0xc]          ;505
000082  e011              B        |L2.168|
                  |L2.132|
000084  f8ad1026          STRH     r1,[sp,#0x26]         ;507
000088  6838              LDR      r0,[r7,#0]            ;508
00008a  ba00              REV      r0,r0                 ;508
00008c  9002              STR      r0,[sp,#8]            ;510
00008e  6878              LDR      r0,[r7,#4]            ;510
000090  ba00              REV      r0,r0                 ;510
000092  9003              STR      r0,[sp,#0xc]          ;512
000094  68b8              LDR      r0,[r7,#8]            ;512
000096  ba00              REV      r0,r0                 ;512
000098  9004              STR      r0,[sp,#0x10]         ;514
00009a  68f8              LDR      r0,[r7,#0xc]          ;514
00009c  ba00              REV      r0,r0                 ;514
00009e  9005              STR      r0,[sp,#0x14]         ;516
0000a0  6938              LDR      r0,[r7,#0x10]         ;516
0000a2  ba00              REV      r0,r0                 ;516
0000a4  9006              STR      r0,[sp,#0x18]         ;518
0000a6  6978              LDR      r0,[r7,#0x14]         ;518
                  |L2.168|
0000a8  ba00              REV      r0,r0                 ;504
0000aa  9007              STR      r0,[sp,#0x1c]         ;504
                  |L2.172|
;;;538        default:
;;;539        break;
;;;540      }
;;;541      /* CRYP Initialization Vectors */
;;;542      AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
0000ac  f8da0000          LDR      r0,[r10,#0]
0000b0  ba00              REV      r0,r0
;;;543      ivaddr+=4;
;;;544      AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
0000b2  900a              STR      r0,[sp,#0x28]
0000b4  f8da1004          LDR      r1,[r10,#4]
0000b8  ba09              REV      r1,r1
;;;545      ivaddr+=4;
;;;546      AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
0000ba  910b              STR      r1,[sp,#0x2c]
0000bc  f8da1008          LDR      r1,[r10,#8]
0000c0  ba09              REV      r1,r1
;;;547      ivaddr+=4;
;;;548      AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
0000c2  910c              STR      r1,[sp,#0x30]
0000c4  f8da000c          LDR      r0,[r10,#0xc]
0000c8  ba00              REV      r0,r0
;;;549    
;;;550      /* Key Initialisation */
;;;551      CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
0000ca  900d              STR      r0,[sp,#0x34]
0000cc  4668              MOV      r0,sp
0000ce  f7fffffe          BL       CRYP_KeyInit
;;;552    
;;;553      /*------------------ AES Decryption ------------------*/
;;;554      if(Mode == MODE_DECRYPT) /* AES decryption */
0000d2  980f              LDR      r0,[sp,#0x3c]
0000d4  b198              CBZ      r0,|L2.254|
;;;555      {
;;;556        /* Crypto Init for decryption process */
;;;557        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;558      }
;;;559      /*------------------ AES Encryption ------------------*/
;;;560      else /* AES encryption */
;;;561      {
;;;562        /* Crypto Init for Encryption process */
;;;563        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
0000d6  f8ad9020          STRH     r9,[sp,#0x20]
                  |L2.218|
;;;564      }
;;;565      AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;
0000da  2030              MOVS     r0,#0x30
0000dc  f8ad0022          STRH     r0,[sp,#0x22]
;;;566      AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
0000e0  2080              MOVS     r0,#0x80
0000e2  f8ad0024          STRH     r0,[sp,#0x24]
;;;567      CRYP_Init(&AES_CRYP_InitStructure);
0000e6  a808              ADD      r0,sp,#0x20
0000e8  f7fffffe          BL       CRYP_Init
;;;568    
;;;569      /* CRYP Initialization Vectors */
;;;570      CRYP_IVInit(&AES_CRYP_IVInitStructure);
0000ec  a80a              ADD      r0,sp,#0x28
0000ee  f7fffffe          BL       CRYP_IVInit
;;;571    
;;;572      /* Flush IN/OUT FIFOs */
;;;573      CRYP_FIFOFlush();
0000f2  f7fffffe          BL       CRYP_FIFOFlush
;;;574    
;;;575      /* Enable Crypto processor */
;;;576      CRYP_Cmd(ENABLE);
0000f6  2001              MOVS     r0,#1
0000f8  f7fffffe          BL       CRYP_Cmd
;;;577    
;;;578      for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
0000fc  e034              B        |L2.360|
                  |L2.254|
0000fe  2004              MOVS     r0,#4                 ;557
000100  f8ad0020          STRH     r0,[sp,#0x20]         ;557
000104  e7e9              B        |L2.218|
                  |L2.262|
;;;579      {
;;;580    
;;;581        /* Write the Input block in the IN FIFO */
;;;582        CRYP_DataIn(*(uint32_t*)(inputaddr));
000106  6820              LDR      r0,[r4,#0]
000108  f7fffffe          BL       CRYP_DataIn
;;;583        inputaddr+=4;
;;;584        CRYP_DataIn(*(uint32_t*)(inputaddr));
00010c  f8540f04          LDR      r0,[r4,#4]!
000110  f7fffffe          BL       CRYP_DataIn
;;;585        inputaddr+=4;
;;;586        CRYP_DataIn(*(uint32_t*)(inputaddr));
000114  f8540f04          LDR      r0,[r4,#4]!
000118  f7fffffe          BL       CRYP_DataIn
;;;587        inputaddr+=4;
;;;588        CRYP_DataIn(*(uint32_t*)(inputaddr));
00011c  f8540f04          LDR      r0,[r4,#4]!
000120  f7fffffe          BL       CRYP_DataIn
;;;589        inputaddr+=4;
;;;590        /* Wait until the complete message has been processed */
;;;591        counter = 0;
;;;592        do
;;;593        {
;;;594          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;595          counter++;
;;;596        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
000124  f44f3780          MOV      r7,#0x10000
000128  1d24              ADDS     r4,r4,#4
00012a  f8cd9038          STR      r9,[sp,#0x38]
                  |L2.302|
00012e  2010              MOVS     r0,#0x10              ;594
000130  f7fffffe          BL       CRYP_GetFlagStatus
000134  990e              LDR      r1,[sp,#0x38]         ;595
000136  1c49              ADDS     r1,r1,#1              ;595
000138  910e              STR      r1,[sp,#0x38]
00013a  42b9              CMP      r1,r7
00013c  d002              BEQ      |L2.324|
00013e  2800              CMP      r0,#0
000140  d1f5              BNE      |L2.302|
000142  e003              B        |L2.332|
                  |L2.324|
;;;597    
;;;598        if (busystatus != RESET)
000144  b110              CBZ      r0,|L2.332|
;;;599       {
;;;600           status = ERROR;
000146  f04f0800          MOV      r8,#0
00014a  e00c              B        |L2.358|
                  |L2.332|
;;;601        }
;;;602        else
;;;603        {
;;;604    
;;;605          /* Read the Output block from the Output FIFO */
;;;606          *(uint32_t*)(outputaddr) = CRYP_DataOut();
00014c  f7fffffe          BL       CRYP_DataOut
;;;607          outputaddr+=4;
;;;608          *(uint32_t*)(outputaddr) = CRYP_DataOut();
000150  6028              STR      r0,[r5,#0]
000152  f7fffffe          BL       CRYP_DataOut
;;;609          outputaddr+=4;
;;;610          *(uint32_t*)(outputaddr) = CRYP_DataOut();
000156  6068              STR      r0,[r5,#4]
000158  f7fffffe          BL       CRYP_DataOut
;;;611          outputaddr+=4;
;;;612          *(uint32_t*)(outputaddr) = CRYP_DataOut();
00015c  60a8              STR      r0,[r5,#8]
00015e  f7fffffe          BL       CRYP_DataOut
000162  60e8              STR      r0,[r5,#0xc]
000164  3510              ADDS     r5,r5,#0x10
                  |L2.358|
000166  3610              ADDS     r6,r6,#0x10
                  |L2.360|
000168  455e              CMP      r6,r11                ;578
00016a  d202              BCS      |L2.370|
00016c  f1b80f00          CMP      r8,#0                 ;578
000170  d1c9              BNE      |L2.262|
                  |L2.370|
;;;613          outputaddr+=4;
;;;614        }
;;;615      }
;;;616      /* Disable Crypto */
;;;617      CRYP_Cmd(DISABLE);
000172  2000              MOVS     r0,#0
000174  f7fffffe          BL       CRYP_Cmd
;;;618    
;;;619      return status;
;;;620    }
000178  b013              ADD      sp,sp,#0x4c
00017a  4640              MOV      r0,r8                 ;619
00017c  e8bd8ff0          POP      {r4-r11,pc}
;;;621    /**
                          ENDP


                          AREA ||i.CRYP_AES_ECB||, CODE, READONLY, ALIGN=1

                  CRYP_AES_ECB PROC
;;;97       */
;;;98     ErrorStatus CRYP_AES_ECB(uint8_t Mode, uint8_t* Key, uint16_t Keysize,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;99                              uint8_t* Input, uint32_t Ilength, uint8_t* Output)
;;;100    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4683              MOV      r11,r0
000008  e9dda514          LDRD     r10,r5,[sp,#0x50]
;;;101      CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;102      CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;103      __IO uint32_t counter = 0;
00000c  f04f0800          MOV      r8,#0
000010  461c              MOV      r4,r3                 ;100
000012  4691              MOV      r9,r2                 ;100
000014  460e              MOV      r6,r1                 ;100
;;;104      uint32_t busystatus = 0;
;;;105      ErrorStatus status = SUCCESS;
000016  2701              MOVS     r7,#1
;;;106      uint32_t keyaddr    = (uint32_t)Key;
;;;107      uint32_t inputaddr  = (uint32_t)Input;
;;;108      uint32_t outputaddr = (uint32_t)Output;
;;;109      uint32_t i = 0;
;;;110    
;;;111      /* Crypto structures initialisation*/
;;;112      CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
000018  4668              MOV      r0,sp
00001a  f8cd8028          STR      r8,[sp,#0x28]
00001e  f7fffffe          BL       CRYP_KeyStructInit
;;;113    
;;;114      switch(Keysize)
000022  4648              MOV      r0,r9
000024  f1b90f80          CMP      r9,#0x80
000028  d01e              BEQ      |L3.104|
00002a  0239              LSLS     r1,r7,#8
00002c  28c0              CMP      r0,#0xc0
00002e  d028              BEQ      |L3.130|
000030  4589              CMP      r9,r1
000032  d13a              BNE      |L3.170|
;;;115      {
;;;116        case 128:
;;;117        AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
;;;118        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;119        keyaddr+=4;
;;;120        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;121        keyaddr+=4;
;;;122        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;123        keyaddr+=4;
;;;124        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;125        break;
;;;126        case 192:
;;;127        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
;;;128        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
;;;129        keyaddr+=4;
;;;130        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
;;;131        keyaddr+=4;
;;;132        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;133        keyaddr+=4;
;;;134        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;135        keyaddr+=4;
;;;136        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;137        keyaddr+=4;
;;;138        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;139        break;
;;;140        case 256:
;;;141        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000034  0048              LSLS     r0,r1,#1
000036  f8ad0026          STRH     r0,[sp,#0x26]
;;;142        AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
00003a  6830              LDR      r0,[r6,#0]
00003c  ba00              REV      r0,r0
;;;143        keyaddr+=4;
;;;144        AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
00003e  9000              STR      r0,[sp,#0]
000040  6870              LDR      r0,[r6,#4]
000042  ba00              REV      r0,r0
;;;145        keyaddr+=4;
;;;146        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000044  9001              STR      r0,[sp,#4]
000046  68b0              LDR      r0,[r6,#8]
000048  ba00              REV      r0,r0
;;;147        keyaddr+=4;
;;;148        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
00004a  9002              STR      r0,[sp,#8]
00004c  68f0              LDR      r0,[r6,#0xc]
00004e  ba00              REV      r0,r0
;;;149        keyaddr+=4;
;;;150        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000050  9003              STR      r0,[sp,#0xc]
000052  6930              LDR      r0,[r6,#0x10]
000054  ba00              REV      r0,r0
;;;151        keyaddr+=4;
;;;152        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000056  9004              STR      r0,[sp,#0x10]
000058  6970              LDR      r0,[r6,#0x14]
00005a  ba00              REV      r0,r0
;;;153        keyaddr+=4;
;;;154        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
00005c  9005              STR      r0,[sp,#0x14]
00005e  69b0              LDR      r0,[r6,#0x18]
000060  ba00              REV      r0,r0
;;;155        keyaddr+=4;
;;;156        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000062  9006              STR      r0,[sp,#0x18]
;;;157        break;
000064  69f0              LDR      r0,[r6,#0x1c]
000066  e01e              B        |L3.166|
                  |L3.104|
000068  f8ad8026          STRH     r8,[sp,#0x26]         ;117
00006c  6830              LDR      r0,[r6,#0]            ;118
00006e  ba00              REV      r0,r0                 ;118
000070  9004              STR      r0,[sp,#0x10]         ;120
000072  6870              LDR      r0,[r6,#4]            ;120
000074  ba00              REV      r0,r0                 ;120
000076  9005              STR      r0,[sp,#0x14]         ;122
000078  68b0              LDR      r0,[r6,#8]            ;122
00007a  ba00              REV      r0,r0                 ;122
00007c  9006              STR      r0,[sp,#0x18]         ;124
00007e  68f0              LDR      r0,[r6,#0xc]          ;125
000080  e011              B        |L3.166|
                  |L3.130|
000082  f8ad1026          STRH     r1,[sp,#0x26]         ;127
000086  6830              LDR      r0,[r6,#0]            ;128
000088  ba00              REV      r0,r0                 ;128
00008a  9002              STR      r0,[sp,#8]            ;130
00008c  6870              LDR      r0,[r6,#4]            ;130
00008e  ba00              REV      r0,r0                 ;130
000090  9003              STR      r0,[sp,#0xc]          ;132
000092  68b0              LDR      r0,[r6,#8]            ;132
000094  ba00              REV      r0,r0                 ;132
000096  9004              STR      r0,[sp,#0x10]         ;134
000098  68f0              LDR      r0,[r6,#0xc]          ;134
00009a  ba00              REV      r0,r0                 ;134
00009c  9005              STR      r0,[sp,#0x14]         ;136
00009e  6930              LDR      r0,[r6,#0x10]         ;136
0000a0  ba00              REV      r0,r0                 ;136
0000a2  9006              STR      r0,[sp,#0x18]         ;138
0000a4  6970              LDR      r0,[r6,#0x14]         ;138
                  |L3.166|
0000a6  ba00              REV      r0,r0                 ;124
0000a8  9007              STR      r0,[sp,#0x1c]         ;124
                  |L3.170|
;;;158        default:
;;;159        break;
;;;160      }
;;;161    
;;;162      /*------------------ AES Decryption ------------------*/
;;;163      if(Mode == MODE_DECRYPT) /* AES decryption */
;;;164      {
;;;165        /* Flush IN/OUT FIFOs */
;;;166        CRYP_FIFOFlush();
;;;167    
;;;168        /* Crypto Init for Key preparation for decryption process */
;;;169        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;170        AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
;;;171        AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
;;;172        CRYP_Init(&AES_CRYP_InitStructure);
;;;173    
;;;174        /* Key Initialisation */
;;;175        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
;;;176    
;;;177        /* Enable Crypto processor */
;;;178        CRYP_Cmd(ENABLE);
;;;179    
;;;180        /* wait until the Busy flag is RESET */
;;;181        do
;;;182        {
;;;183          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;184          counter++;
;;;185        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
0000aa  f44f3980          MOV      r9,#0x10000
0000ae  f1bb0f00          CMP      r11,#0                ;163
0000b2  d014              BEQ      |L3.222|
;;;186    
;;;187        if (busystatus != RESET)
;;;188       {
;;;189           status = ERROR;
;;;190        }
;;;191        else
;;;192        {
;;;193          /* Crypto Init for decryption process */  
;;;194          AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;195        }
;;;196      }
;;;197      /*------------------ AES Encryption ------------------*/
;;;198      else /* AES encryption */
;;;199      {
;;;200    
;;;201        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
0000b4  4668              MOV      r0,sp
0000b6  f7fffffe          BL       CRYP_KeyInit
;;;202    
;;;203        /* Crypto Init for Encryption process */
;;;204        AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
0000ba  f8ad8020          STRH     r8,[sp,#0x20]
                  |L3.190|
;;;205      }
;;;206    
;;;207      AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_ECB;
0000be  2020              MOVS     r0,#0x20
0000c0  f8ad0022          STRH     r0,[sp,#0x22]
;;;208      AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
0000c4  2080              MOVS     r0,#0x80
0000c6  f8ad0024          STRH     r0,[sp,#0x24]
;;;209      CRYP_Init(&AES_CRYP_InitStructure);
0000ca  a808              ADD      r0,sp,#0x20
0000cc  f7fffffe          BL       CRYP_Init
;;;210    
;;;211      /* Flush IN/OUT FIFOs */
;;;212      CRYP_FIFOFlush();
0000d0  f7fffffe          BL       CRYP_FIFOFlush
;;;213    
;;;214      /* Enable Crypto processor */
;;;215      CRYP_Cmd(ENABLE);
0000d4  2001              MOVS     r0,#1
0000d6  f7fffffe          BL       CRYP_Cmd
;;;216    
;;;217      for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
0000da  2600              MOVS     r6,#0
0000dc  e051              B        |L3.386|
                  |L3.222|
0000de  f7fffffe          BL       CRYP_FIFOFlush
0000e2  2604              MOVS     r6,#4                 ;169
0000e4  f8ad6020          STRH     r6,[sp,#0x20]         ;169
0000e8  2038              MOVS     r0,#0x38              ;170
0000ea  f8ad0022          STRH     r0,[sp,#0x22]         ;170
0000ee  f8ad8024          STRH     r8,[sp,#0x24]         ;171
0000f2  a808              ADD      r0,sp,#0x20           ;172
0000f4  f7fffffe          BL       CRYP_Init
0000f8  4668              MOV      r0,sp                 ;175
0000fa  f7fffffe          BL       CRYP_KeyInit
0000fe  2001              MOVS     r0,#1                 ;178
000100  f7fffffe          BL       CRYP_Cmd
                  |L3.260|
000104  2010              MOVS     r0,#0x10              ;183
000106  f7fffffe          BL       CRYP_GetFlagStatus
00010a  990a              LDR      r1,[sp,#0x28]         ;184
00010c  1c49              ADDS     r1,r1,#1              ;184
00010e  910a              STR      r1,[sp,#0x28]         ;185
000110  4549              CMP      r1,r9                 ;185
000112  d002              BEQ      |L3.282|
000114  2800              CMP      r0,#0                 ;185
000116  d1f5              BNE      |L3.260|
000118  e002              B        |L3.288|
                  |L3.282|
00011a  b108              CBZ      r0,|L3.288|
00011c  2700              MOVS     r7,#0                 ;189
00011e  e7ce              B        |L3.190|
                  |L3.288|
000120  f8ad6020          STRH     r6,[sp,#0x20]         ;194
000124  e7cb              B        |L3.190|
                  |L3.294|
;;;218      {
;;;219    
;;;220        /* Write the Input block in the IN FIFO */
;;;221        CRYP_DataIn(*(uint32_t*)(inputaddr));
000126  6820              LDR      r0,[r4,#0]
000128  f7fffffe          BL       CRYP_DataIn
;;;222        inputaddr+=4;
;;;223        CRYP_DataIn(*(uint32_t*)(inputaddr));
00012c  f8540f04          LDR      r0,[r4,#4]!
000130  f7fffffe          BL       CRYP_DataIn
;;;224        inputaddr+=4;
;;;225        CRYP_DataIn(*(uint32_t*)(inputaddr));
000134  f8540f04          LDR      r0,[r4,#4]!
000138  f7fffffe          BL       CRYP_DataIn
;;;226        inputaddr+=4;
;;;227        CRYP_DataIn(*(uint32_t*)(inputaddr));
00013c  f8540f04          LDR      r0,[r4,#4]!
000140  f7fffffe          BL       CRYP_DataIn
;;;228        inputaddr+=4;
;;;229    
;;;230        /* Wait until the complete message has been processed */
;;;231        counter = 0;
000144  1d24              ADDS     r4,r4,#4
000146  f8cd8028          STR      r8,[sp,#0x28]
                  |L3.330|
;;;232        do
;;;233        {
;;;234          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
00014a  2010              MOVS     r0,#0x10
00014c  f7fffffe          BL       CRYP_GetFlagStatus
;;;235          counter++;
000150  990a              LDR      r1,[sp,#0x28]
000152  1c49              ADDS     r1,r1,#1
;;;236        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
000154  910a              STR      r1,[sp,#0x28]
000156  4549              CMP      r1,r9
000158  d002              BEQ      |L3.352|
00015a  2800              CMP      r0,#0
00015c  d1f5              BNE      |L3.330|
00015e  e002              B        |L3.358|
                  |L3.352|
;;;237    
;;;238        if (busystatus != RESET)
000160  b108              CBZ      r0,|L3.358|
;;;239       {
;;;240           status = ERROR;
000162  2700              MOVS     r7,#0
000164  e00c              B        |L3.384|
                  |L3.358|
;;;241        }
;;;242        else
;;;243        {
;;;244    
;;;245          /* Read the Output block from the Output FIFO */
;;;246          *(uint32_t*)(outputaddr) = CRYP_DataOut();
000166  f7fffffe          BL       CRYP_DataOut
;;;247          outputaddr+=4;
;;;248          *(uint32_t*)(outputaddr) = CRYP_DataOut();
00016a  6028              STR      r0,[r5,#0]
00016c  f7fffffe          BL       CRYP_DataOut
;;;249          outputaddr+=4;
;;;250          *(uint32_t*)(outputaddr) = CRYP_DataOut();
000170  6068              STR      r0,[r5,#4]
000172  f7fffffe          BL       CRYP_DataOut
;;;251          outputaddr+=4;
;;;252          *(uint32_t*)(outputaddr) = CRYP_DataOut(); 
000176  60a8              STR      r0,[r5,#8]
000178  f7fffffe          BL       CRYP_DataOut
00017c  60e8              STR      r0,[r5,#0xc]
00017e  3510              ADDS     r5,r5,#0x10
                  |L3.384|
000180  3610              ADDS     r6,r6,#0x10
                  |L3.386|
000182  4556              CMP      r6,r10                ;217
000184  d201              BCS      |L3.394|
000186  2f00              CMP      r7,#0                 ;217
000188  d1cd              BNE      |L3.294|
                  |L3.394|
;;;253          outputaddr+=4;
;;;254        }
;;;255      }
;;;256    
;;;257      /* Disable Crypto */
;;;258      CRYP_Cmd(DISABLE);
00018a  2000              MOVS     r0,#0
00018c  f7fffffe          BL       CRYP_Cmd
;;;259    
;;;260      return status; 
;;;261    }
000190  b00b              ADD      sp,sp,#0x2c
000192  4638              MOV      r0,r7                 ;260
000194  e8bd8ff0          POP      {r4-r11,pc}
;;;262    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp_aes.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REVSH|
#line 128
|__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
