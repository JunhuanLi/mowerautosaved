; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\timer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\timer.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\timer.crf ..\OS\src\timer.c]
                          THUMB

                          AREA ||i._rt_timer_init||, CODE, READONLY, ALIGN=1

                  _rt_timer_init PROC
;;;79     
;;;80     static void _rt_timer_init(rt_timer_t timer,
000000  b510              PUSH     {r4,lr}
;;;81                                void (*timeout)(void *parameter),
;;;82                                void      *parameter,
;;;83                                rt_tick_t  time,
;;;84                                rt_uint8_t flag)
;;;85     {
;;;86         int i;
;;;87     
;;;88         /* set flag */
;;;89         timer->parent.flag  = flag;
;;;90     
;;;91         /* set deactivated */
;;;92         timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000002  9c02              LDR      r4,[sp,#8]
000004  f0240401          BIC      r4,r4,#1
000008  7244              STRB     r4,[r0,#9]
00000a  e9c01207          STRD     r1,r2,[r0,#0x1c]
;;;93     
;;;94         timer->timeout_func = timeout;
;;;95         timer->parameter    = parameter;
;;;96     
;;;97         timer->timeout_tick = 0;
00000e  2100              MOVS     r1,#0
000010  e9c03109          STRD     r3,r1,[r0,#0x24]
                  |L1.20|
;;;98         timer->init_tick    = time;
;;;99     
;;;100        /* initialize timer list */
;;;101        for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
;;;102        {
;;;103            rt_list_init(&(timer->row[i]));
000014  eb0002c1          ADD      r2,r0,r1,LSL #3
000018  3214              ADDS     r2,r2,#0x14
00001a  1c49              ADDS     r1,r1,#1
00001c  6052              STR      r2,[r2,#4]
00001e  6012              STR      r2,[r2,#0]
000020  2901              CMP      r1,#1                 ;101
000022  dbf7              BLT      |L1.20|
;;;104        }
;;;105    }
000024  bd10              POP      {r4,pc}
;;;106    
                          ENDP


                          AREA ||i._rt_timer_remove||, CODE, READONLY, ALIGN=1

                  _rt_timer_remove PROC
;;;120    
;;;121    rt_inline void _rt_timer_remove(rt_timer_t timer)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123        int i;
;;;124    
;;;125        for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
000002  2200              MOVS     r2,#0
                  |L2.4|
;;;126        {
;;;127            rt_list_remove(&timer->row[i]);
000004  eb0001c2          ADD      r1,r0,r2,LSL #3
000008  1c52              ADDS     r2,r2,#1
00000a  e9f13405          LDRD     r3,r4,[r1,#0x14]!
00000e  2a01              CMP      r2,#1                 ;125
000010  605c              STR      r4,[r3,#4]            ;125
000012  e9d13400          LDRD     r3,r4,[r1,#0]         ;125
000016  6023              STR      r3,[r4,#0]            ;125
000018  6049              STR      r1,[r1,#4]            ;125
00001a  6009              STR      r1,[r1,#0]            ;125
00001c  dbf2              BLT      |L2.4|
;;;128        }
;;;129    }
00001e  bd10              POP      {r4,pc}
;;;130    
                          ENDP


                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
;;;65         n->next = l->next;
000002  6051              STR      r1,[r2,#4]
000004  6802              LDR      r2,[r0,#0]
;;;66     
;;;67         l->next = n;
000006  600a              STR      r2,[r1,#0]
;;;68         n->prev = l;
000008  6001              STR      r1,[r0,#0]
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;101     */
;;;102    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  6801              LDR      r1,[r0,#0]
;;;103    {
;;;104        return l->next == l;
000002  4281              CMP      r1,r0
000004  d101              BNE      |L4.10|
000006  2001              MOVS     r0,#1
;;;105    }
000008  4770              BX       lr
                  |L4.10|
00000a  2000              MOVS     r0,#0                 ;104
00000c  4770              BX       lr
;;;106    
                          ENDP


                          AREA ||i.rt_system_timer_init||, CODE, READONLY, ALIGN=2

                  rt_system_timer_init PROC
;;;661     */
;;;662    void rt_system_timer_init(void)
000000  4a04              LDR      r2,|L5.20|
;;;663    {
;;;664        int i;
;;;665    
;;;666        for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
000002  2000              MOVS     r0,#0
                  |L5.4|
;;;667        {
;;;668            rt_list_init(rt_timer_list+i);
000004  eb0201c0          ADD      r1,r2,r0,LSL #3
000008  1c40              ADDS     r0,r0,#1
00000a  6049              STR      r1,[r1,#4]
00000c  6009              STR      r1,[r1,#0]
00000e  d0f9              BEQ      |L5.4|
;;;669        }
;;;670    }
000010  4770              BX       lr
;;;671    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      ||.data||+0x8

                          AREA ||i.rt_system_timer_thread_init||, CODE, READONLY, ALIGN=1

                  rt_system_timer_thread_init PROC
;;;676     */
;;;677    void rt_system_timer_thread_init(void)
000000  4770              BX       lr
;;;678    {
;;;679    #ifdef RT_USING_TIMER_SOFT
;;;680        int i;
;;;681    
;;;682        for (i = 0;
;;;683             i < sizeof(rt_soft_timer_list)/sizeof(rt_soft_timer_list[0]);
;;;684             i++)
;;;685        {
;;;686            rt_list_init(rt_soft_timer_list+i);
;;;687        }
;;;688    
;;;689        /* start software timer thread */
;;;690        rt_thread_init(&timer_thread,
;;;691                       "timer",
;;;692                       rt_thread_timer_entry,
;;;693                       RT_NULL,
;;;694                       &timer_thread_stack[0],
;;;695                       sizeof(timer_thread_stack),
;;;696                       RT_TIMER_THREAD_PRIO,
;;;697                       10);
;;;698    
;;;699        /* startup */
;;;700        rt_thread_startup(&timer_thread);
;;;701    #endif
;;;702    }
;;;703    
                          ENDP


                          AREA ||i.rt_timer_check||, CODE, READONLY, ALIGN=2

                  rt_timer_check PROC
;;;485     */
;;;486    void rt_timer_check(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;487    {
;;;488        struct rt_timer *t;
;;;489        rt_tick_t current_tick;
;;;490        register rt_base_t level;
;;;491    
;;;492        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));
;;;493    
;;;494        current_tick = rt_tick_get();
000004  f7fffffe          BL       rt_tick_get
000008  4605              MOV      r5,r0
;;;495    
;;;496        /* disable interrupt */
;;;497        level = rt_hw_interrupt_disable();
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4607              MOV      r7,r0
;;;498    
;;;499        while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
;;;500        {
;;;501            t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
;;;502                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
;;;503    
;;;504            /*
;;;505             * It supposes that the new tick shall less than the half duration of
;;;506             * tick max.
;;;507             */
;;;508            if ((current_tick - t->timeout_tick) < RT_TICK_MAX/2)
;;;509            {
;;;510                RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
000010  4e19              LDR      r6,|L7.120|
000012  e025              B        |L7.96|
                  |L7.20|
000014  4818              LDR      r0,|L7.120|
000016  f06f4100          MVN      r1,#0x80000000        ;508
00001a  3008              ADDS     r0,r0,#8              ;501
00001c  6804              LDR      r4,[r0,#0]            ;508  ; rt_timer_list
00001e  6960              LDR      r0,[r4,#0x14]         ;508
000020  3c14              SUBS     r4,r4,#0x14           ;508
000022  1a28              SUBS     r0,r5,r0              ;508
000024  4288              CMP      r0,r1                 ;508
000026  d221              BCS      |L7.108|
000028  6871              LDR      r1,[r6,#4]  ; rt_timer_timeout_hook
00002a  b109              CBZ      r1,|L7.48|
00002c  4620              MOV      r0,r4
00002e  4788              BLX      r1
                  |L7.48|
;;;511    
;;;512                /* remove timer from timer list firstly */
;;;513                _rt_timer_remove(t);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       _rt_timer_remove
000036  e9d41007          LDRD     r1,r0,[r4,#0x1c]
;;;514    
;;;515                /* call timeout function */
;;;516                t->timeout_func(t->parameter);
00003a  4788              BLX      r1
;;;517    
;;;518                /* re-get tick */
;;;519                current_tick = rt_tick_get();
00003c  f7fffffe          BL       rt_tick_get
000040  4605              MOV      r5,r0
;;;520    
;;;521                RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));
;;;522    
;;;523                if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
000042  7a60              LDRB     r0,[r4,#9]
000044  0781              LSLS     r1,r0,#30
000046  d508              BPL      |L7.90|
;;;524                    (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
000048  07c1              LSLS     r1,r0,#31
00004a  d006              BEQ      |L7.90|
;;;525                {
;;;526                    /* start it */
;;;527                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
00004c  f0200001          BIC      r0,r0,#1
000050  7260              STRB     r0,[r4,#9]
;;;528                    rt_timer_start(t);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       rt_timer_start
000058  e002              B        |L7.96|
                  |L7.90|
;;;529                }
;;;530                else
;;;531                {
;;;532                    /* stop timer */
;;;533                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
00005a  f0200001          BIC      r0,r0,#1
00005e  7260              STRB     r0,[r4,#9]
                  |L7.96|
000060  4805              LDR      r0,|L7.120|
000062  3008              ADDS     r0,r0,#8              ;499
000064  f7fffffe          BL       rt_list_isempty
000068  2800              CMP      r0,#0                 ;499
00006a  d0d3              BEQ      |L7.20|
                  |L7.108|
;;;534                }
;;;535            }
;;;536            else
;;;537                break;
;;;538        }
;;;539    
;;;540        /* enable interrupt */
;;;541        rt_hw_interrupt_enable(level);
00006c  4638              MOV      r0,r7
00006e  e8bd41f0          POP      {r4-r8,lr}
000072  f7ffbffe          B.W      rt_hw_interrupt_enable
;;;542    
;;;543        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
;;;544    }
;;;545    
                          ENDP

000076  0000              DCW      0x0000
                  |L7.120|
                          DCD      ||.data||

                          AREA ||i.rt_timer_control||, CODE, READONLY, ALIGN=2

                  rt_timer_control PROC
;;;451     */
;;;452    rt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;453    {
000002  4616              MOV      r6,r2
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d10c              BNE      |L8.36|
;;;454        /* timer check */
;;;455        RT_ASSERT(timer != RT_NULL);
00000a  f88d0000          STRB     r0,[sp,#0]
00000e  f24013c7          MOV      r3,#0x1c7
000012  4a10              LDR      r2,|L8.84|
000014  a110              ADR      r1,|L8.88|
000016  a015              ADR      r0,|L8.108|
000018  f7fffffe          BL       rt_kprintf
                  |L8.28|
00001c  f89d0000          LDRB     r0,[sp,#0]
000020  2800              CMP      r0,#0
000022  d0fb              BEQ      |L8.28|
                  |L8.36|
;;;456    
;;;457        switch (cmd)
000024  b14d              CBZ      r5,|L8.58|
000026  2d01              CMP      r5,#1
000028  d004              BEQ      |L8.52|
00002a  2d02              CMP      r5,#2
00002c  d008              BEQ      |L8.64|
00002e  2d03              CMP      r5,#3
000030  d10e              BNE      |L8.80|
000032  e009              B        |L8.72|
                  |L8.52|
;;;458        {
;;;459        case RT_TIMER_CTRL_GET_TIME:
;;;460            *(rt_tick_t *)arg = timer->init_tick;
000034  6a60              LDR      r0,[r4,#0x24]
;;;461            break;
000036  6030              STR      r0,[r6,#0]
000038  e00a              B        |L8.80|
                  |L8.58|
;;;462    
;;;463        case RT_TIMER_CTRL_SET_TIME:
;;;464            timer->init_tick = *(rt_tick_t *)arg;
00003a  6830              LDR      r0,[r6,#0]
;;;465            break;
00003c  6260              STR      r0,[r4,#0x24]
00003e  e007              B        |L8.80|
                  |L8.64|
;;;466    
;;;467        case RT_TIMER_CTRL_SET_ONESHOT:
;;;468            timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
000040  7a60              LDRB     r0,[r4,#9]
000042  f0200002          BIC      r0,r0,#2
;;;469            break;
000046  e002              B        |L8.78|
                  |L8.72|
;;;470    
;;;471        case RT_TIMER_CTRL_SET_PERIODIC:
;;;472            timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
000048  7a60              LDRB     r0,[r4,#9]
00004a  f0400002          ORR      r0,r0,#2
                  |L8.78|
00004e  7260              STRB     r0,[r4,#9]            ;468
                  |L8.80|
;;;473            break;
;;;474        }
;;;475    
;;;476        return RT_EOK;
000050  2000              MOVS     r0,#0
;;;477    }
000052  bdf8              POP      {r3-r7,pc}
;;;478    RTM_EXPORT(rt_timer_control);
                          ENDP

                  |L8.84|
                          DCD      ||.constdata||+0x4b
                  |L8.88|
000058  74696d65          DCB      "timer != RT_NULL",0
00005c  7220213d
000060  2052545f
000064  4e554c4c
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L8.108|
00006c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000070  20617373
000074  65727420
000078  6661696c
00007c  65642061
000080  74202573
000084  3a256420
000088  0a00    
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.rt_timer_create||, CODE, READONLY, ALIGN=1

                  rt_timer_create PROC
;;;234     */
;;;235    rt_timer_t rt_timer_create(const char *name,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;236                               void (*timeout)(void *parameter),
;;;237                               void       *parameter,
;;;238                               rt_tick_t   time,
;;;239                               rt_uint8_t  flag)
;;;240    {
000004  4688              MOV      r8,r1
;;;241        struct rt_timer *timer;
;;;242    
;;;243        /* allocate a object */
;;;244        timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
000006  4601              MOV      r1,r0
000008  461e              MOV      r6,r3                 ;240
00000a  4617              MOV      r7,r2                 ;240
00000c  2008              MOVS     r0,#8
00000e  9d08              LDR      r5,[sp,#0x20]
000010  f7fffffe          BL       rt_object_allocate
000014  0004              MOVS     r4,r0
;;;245        if (timer == RT_NULL)
000016  d008              BEQ      |L9.42|
;;;246        {
;;;247            return RT_NULL;
;;;248        }
;;;249    
;;;250        _rt_timer_init(timer, timeout, parameter, time, flag);
000018  4633              MOV      r3,r6
00001a  463a              MOV      r2,r7
00001c  4641              MOV      r1,r8
00001e  9500              STR      r5,[sp,#0]
000020  f7fffffe          BL       _rt_timer_init
;;;251    
;;;252        return timer;
000024  4620              MOV      r0,r4
                  |L9.38|
;;;253    }
000026  e8bd83f8          POP      {r3-r9,pc}
                  |L9.42|
00002a  2000              MOVS     r0,#0                 ;247
00002c  e7fb              B        |L9.38|
;;;254    RTM_EXPORT(rt_timer_create);
                          ENDP


                          AREA ||i.rt_timer_delete||, CODE, READONLY, ALIGN=2

                  rt_timer_delete PROC
;;;262     */
;;;263    rt_err_t rt_timer_delete(rt_timer_t timer)
000000  b538              PUSH     {r3-r5,lr}
;;;264    {
000002  0004              MOVS     r4,r0
000004  d10c              BNE      |L10.32|
;;;265        register rt_base_t level;
;;;266    
;;;267        /* timer check */
;;;268        RT_ASSERT(timer != RT_NULL);
000006  f88d0000          STRB     r0,[sp,#0]
00000a  f44f7386          MOV      r3,#0x10c
00000e  4a0b              LDR      r2,|L10.60|
000010  a10b              ADR      r1,|L10.64|
000012  a010              ADR      r0,|L10.84|
000014  f7fffffe          BL       rt_kprintf
                  |L10.24|
000018  f89d1000          LDRB     r1,[sp,#0]
00001c  2900              CMP      r1,#0
00001e  d0fb              BEQ      |L10.24|
                  |L10.32|
;;;269    
;;;270        /* disable interrupt */
;;;271        level = rt_hw_interrupt_disable();
000020  f7fffffe          BL       rt_hw_interrupt_disable
000024  4605              MOV      r5,r0
;;;272    
;;;273        _rt_timer_remove(timer);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       _rt_timer_remove
;;;274    
;;;275        /* enable interrupt */
;;;276        rt_hw_interrupt_enable(level);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       rt_hw_interrupt_enable
;;;277    
;;;278        rt_object_delete((rt_object_t)timer);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       rt_object_delete
;;;279    
;;;280        return -RT_EOK;
000038  2000              MOVS     r0,#0
;;;281    }
00003a  bd38              POP      {r3-r5,pc}
;;;282    RTM_EXPORT(rt_timer_delete);
                          ENDP

                  |L10.60|
                          DCD      ||.constdata||+0x1e
                  |L10.64|
000040  74696d65          DCB      "timer != RT_NULL",0
000044  7220213d
000048  2052545f
00004c  4e554c4c
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0
                  |L10.84|
000054  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000058  20617373
00005c  65727420
000060  6661696c
000064  65642061
000068  74202573
00006c  3a256420
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.rt_timer_detach||, CODE, READONLY, ALIGN=2

                  rt_timer_detach PROC
;;;201     */
;;;202    rt_err_t rt_timer_detach(rt_timer_t timer)
000000  b538              PUSH     {r3-r5,lr}
;;;203    {
000002  0004              MOVS     r4,r0
000004  d10b              BNE      |L11.30|
;;;204        register rt_base_t level;
;;;205    
;;;206        /* timer check */
;;;207        RT_ASSERT(timer != RT_NULL);
000006  f88d0000          STRB     r0,[sp,#0]
00000a  23cf              MOVS     r3,#0xcf
00000c  4a0b              LDR      r2,|L11.60|
00000e  a10c              ADR      r1,|L11.64|
000010  a010              ADR      r0,|L11.84|
000012  f7fffffe          BL       rt_kprintf
                  |L11.22|
000016  f89d1000          LDRB     r1,[sp,#0]
00001a  2900              CMP      r1,#0
00001c  d0fb              BEQ      |L11.22|
                  |L11.30|
;;;208    
;;;209        /* disable interrupt */
;;;210        level = rt_hw_interrupt_disable();
00001e  f7fffffe          BL       rt_hw_interrupt_disable
000022  4605              MOV      r5,r0
;;;211    
;;;212        _rt_timer_remove(timer);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       _rt_timer_remove
;;;213    
;;;214        /* enable interrupt */
;;;215        rt_hw_interrupt_enable(level);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       rt_hw_interrupt_enable
;;;216    
;;;217        rt_object_detach((rt_object_t)timer);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       rt_object_detach
;;;218    
;;;219        return -RT_EOK;
000036  2000              MOVS     r0,#0
;;;220    }
000038  bd38              POP      {r3-r5,pc}
;;;221    RTM_EXPORT(rt_timer_detach);
                          ENDP

00003a  0000              DCW      0x0000
                  |L11.60|
                          DCD      ||.constdata||+0xe
                  |L11.64|
000040  74696d65          DCB      "timer != RT_NULL",0
000044  7220213d
000048  2052545f
00004c  4e554c4c
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0
                  |L11.84|
000054  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000058  20617373
00005c  65727420
000060  6661696c
000064  65642061
000068  74202573
00006c  3a256420
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.rt_timer_init||, CODE, READONLY, ALIGN=2

                  rt_timer_init PROC
;;;177     */
;;;178    void rt_timer_init(rt_timer_t  timer,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;179                       const char *name,
;;;180                       void (*timeout)(void *parameter),
;;;181                       void       *parameter,
;;;182                       rt_tick_t   time,
;;;183                       rt_uint8_t  flag)
;;;184    {
000004  461e              MOV      r6,r3
000006  e9dd9508          LDRD     r9,r5,[sp,#0x20]
00000a  4690              MOV      r8,r2
00000c  460f              MOV      r7,r1
00000e  0004              MOVS     r4,r0
000010  d10b              BNE      |L12.42|
;;;185        /* timer check */
;;;186        RT_ASSERT(timer != RT_NULL);
000012  f88d0000          STRB     r0,[sp,#0]
000016  23ba              MOVS     r3,#0xba
000018  4a0b              LDR      r2,|L12.72|
00001a  a10c              ADR      r1,|L12.76|
00001c  a010              ADR      r0,|L12.96|
00001e  f7fffffe          BL       rt_kprintf
                  |L12.34|
000022  f89d0000          LDRB     r0,[sp,#0]
000026  2800              CMP      r0,#0
000028  d0fb              BEQ      |L12.34|
                  |L12.42|
;;;187    
;;;188        /* timer object initialization */
;;;189        rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);
00002a  463a              MOV      r2,r7
00002c  2108              MOVS     r1,#8
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       rt_object_init
;;;190    
;;;191        _rt_timer_init(timer, timeout, parameter, time, flag);
000034  464b              MOV      r3,r9
000036  4632              MOV      r2,r6
000038  4641              MOV      r1,r8
00003a  4620              MOV      r0,r4
00003c  9500              STR      r5,[sp,#0]
00003e  f7fffffe          BL       _rt_timer_init
;;;192    }
000042  e8bd83f8          POP      {r3-r9,pc}
;;;193    RTM_EXPORT(rt_timer_init);
                          ENDP

000046  0000              DCW      0x0000
                  |L12.72|
                          DCD      ||.constdata||
                  |L12.76|
00004c  74696d65          DCB      "timer != RT_NULL",0
000050  7220213d
000054  2052545f
000058  4e554c4c
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0
                  |L12.96|
000060  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000064  20617373
000068  65727420
00006c  6661696c
000070  65642061
000074  74202573
000078  3a256420
00007c  0a00    
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.rt_timer_next_timeout_tick||, CODE, READONLY, ALIGN=2

                  rt_timer_next_timeout_tick PROC
;;;550     */
;;;551    rt_tick_t rt_timer_next_timeout_tick(void)
000000  b510              PUSH     {r4,lr}
;;;552    {
;;;553        return rt_timer_list_next_timeout(rt_timer_list);
000002  4c05              LDR      r4,|L13.24|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       rt_list_isempty
00000a  b110              CBZ      r0,|L13.18|
00000c  f04f30ff          MOV      r0,#0xffffffff
;;;554    }
000010  bd10              POP      {r4,pc}
                  |L13.18|
000012  6820              LDR      r0,[r4,#0]
000014  6940              LDR      r0,[r0,#0x14]
000016  bd10              POP      {r4,pc}
;;;555    
                          ENDP

                  |L13.24|
                          DCD      ||.data||+0x8

                          AREA ||i.rt_timer_start||, CODE, READONLY, ALIGN=2

                  rt_timer_start PROC
;;;291     */
;;;292    rt_err_t rt_timer_start(rt_timer_t timer)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;293    {
000004  0004              MOVS     r4,r0
000006  f04f0500          MOV      r5,#0
00000a  d10c              BNE      |L14.38|
;;;294        int row_lvl;
;;;295        rt_list_t *timer_list;
;;;296        register rt_base_t level;
;;;297        rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
;;;298        unsigned int tst_nr;
;;;299        static unsigned int random_nr;
;;;300    
;;;301        /* timer check */
;;;302        RT_ASSERT(timer != RT_NULL);
00000c  f88d5004          STRB     r5,[sp,#4]
000010  f44f7397          MOV      r3,#0x12e
000014  4a34              LDR      r2,|L14.232|
000016  a135              ADR      r1,|L14.236|
000018  a039              ADR      r0,|L14.256|
00001a  f7fffffe          BL       rt_kprintf
                  |L14.30|
00001e  f89d0004          LDRB     r0,[sp,#4]
000022  2800              CMP      r0,#0
000024  d0fb              BEQ      |L14.30|
                  |L14.38|
;;;303    
;;;304    	/* stop timer firstly */
;;;305    	level = rt_hw_interrupt_disable();
000026  f7fffffe          BL       rt_hw_interrupt_disable
00002a  4606              MOV      r6,r0
;;;306    	/* remove timer from list */
;;;307        _rt_timer_remove(timer);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       _rt_timer_remove
;;;308        /* change status of timer */
;;;309        timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000032  7a60              LDRB     r0,[r4,#9]
000034  f0200001          BIC      r0,r0,#1
000038  7260              STRB     r0,[r4,#9]
;;;310        rt_hw_interrupt_enable(level);
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       rt_hw_interrupt_enable
;;;311    
;;;312        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
000040  4837              LDR      r0,|L14.288|
000042  6801              LDR      r1,[r0,#0]  ; rt_object_take_hook
000044  b109              CBZ      r1,|L14.74|
000046  4620              MOV      r0,r4
000048  4788              BLX      r1
                  |L14.74|
;;;313    
;;;314        /*
;;;315         * get timeout tick,
;;;316         * the max timeout tick shall not great than RT_TICK_MAX/2
;;;317         */
;;;318        RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
00004a  6a61              LDR      r1,[r4,#0x24]
00004c  f06f4800          MVN      r8,#0x80000000
000050  4541              CMP      r1,r8
000052  d30c              BCC      |L14.110|
000054  f88d5004          STRB     r5,[sp,#4]
000058  f44f739f          MOV      r3,#0x13e
00005c  4a22              LDR      r2,|L14.232|
00005e  a131              ADR      r1,|L14.292|
000060  a027              ADR      r0,|L14.256|
000062  f7fffffe          BL       rt_kprintf
                  |L14.102|
000066  f89d0004          LDRB     r0,[sp,#4]
00006a  2800              CMP      r0,#0
00006c  d0fb              BEQ      |L14.102|
                  |L14.110|
;;;319        timer->timeout_tick = rt_tick_get() + timer->init_tick;
00006e  f7fffffe          BL       rt_tick_get
000072  6a61              LDR      r1,[r4,#0x24]
000074  4408              ADD      r0,r0,r1
;;;320    
;;;321        /* disable interrupt */
;;;322        level = rt_hw_interrupt_disable();
000076  62a0              STR      r0,[r4,#0x28]
000078  f7fffffe          BL       rt_hw_interrupt_disable
;;;323    
;;;324    #ifdef RT_USING_TIMER_SOFT
;;;325        if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
;;;326        {
;;;327            /* insert timer to soft timer list */
;;;328            timer_list = rt_soft_timer_list;
;;;329        }
;;;330        else
;;;331    #endif
;;;332        {
;;;333            /* insert timer to system timer list */
;;;334            timer_list = rt_timer_list;
00007c  4f32              LDR      r7,|L14.328|
00007e  4681              MOV      r9,r0                 ;322
;;;335        }
;;;336    
;;;337        row_head[0]  = &timer_list[0];
;;;338        for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
000080  2200              MOVS     r2,#0
000082  466d              MOV      r5,sp                 ;297
000084  9700              STR      r7,[sp,#0]
000086  e00b              B        |L14.160|
                  |L14.136|
;;;339        {
;;;340            for (;row_head[row_lvl] != timer_list[row_lvl].prev;
;;;341                 row_head[row_lvl]  = row_head[row_lvl]->next)
;;;342            {
;;;343                struct rt_timer *t;
;;;344                rt_list_t *p = row_head[row_lvl]->next;
;;;345    
;;;346                /* fix up the entry pointer */
;;;347                t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
000088  6806              LDR      r6,[r0,#0]
;;;348    
;;;349                /* If we have two timers that timeout at the same time, it's
;;;350                 * preferred that the timer inserted early get called early.
;;;351                 * So insert the new timer to the end the the some-timeout timer
;;;352                 * list.
;;;353                 */
;;;354                if ((t->timeout_tick - timer->timeout_tick) == 0)
00008a  6aa3              LDR      r3,[r4,#0x28]
00008c  eba601c2          SUB      r1,r6,r2,LSL #3       ;347
000090  6949              LDR      r1,[r1,#0x14]
000092  4299              CMP      r1,r3
000094  d002              BEQ      |L14.156|
;;;355                {
;;;356                    continue;
;;;357                }
;;;358                else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
000096  1acb              SUBS     r3,r1,r3
000098  4543              CMP      r3,r8
00009a  d308              BCC      |L14.174|
                  |L14.156|
00009c  f8456022          STR      r6,[r5,r2,LSL #2]     ;341
                  |L14.160|
0000a0  eb0701c2          ADD      r1,r7,r2,LSL #3       ;340
0000a4  f8550022          LDR      r0,[r5,r2,LSL #2]     ;340
0000a8  6849              LDR      r1,[r1,#4]            ;340
0000aa  4288              CMP      r0,r1                 ;340
0000ac  d1ec              BNE      |L14.136|
                  |L14.174|
;;;359                {
;;;360                    break;
;;;361                }
;;;362            }
;;;363            if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
0000ae  b11a              CBZ      r2,|L14.184|
;;;364                row_head[row_lvl+1] = row_head[row_lvl]+1;
0000b0  eb050182          ADD      r1,r5,r2,LSL #2
0000b4  3008              ADDS     r0,r0,#8
0000b6  6048              STR      r0,[r1,#4]
                  |L14.184|
0000b8  1c52              ADDS     r2,r2,#1
0000ba  2a01              CMP      r2,#1                 ;338
0000bc  dbf0              BLT      |L14.160|
;;;365        }
;;;366    
;;;367        /* Interestingly, this super simple timer insert counter works very very
;;;368         * well on distributing the list height uniformly. By means of "very very
;;;369         * well", I mean it beats the randomness of timer->timeout_tick very easily
;;;370         * (actually, the timeout_tick is not random and easy to be attacked). */
;;;371        random_nr++;
0000be  4822              LDR      r0,|L14.328|
0000c0  3808              SUBS     r0,r0,#8
0000c2  6801              LDR      r1,[r0,#0]  ; random_nr
0000c4  1c49              ADDS     r1,r1,#1
;;;372        tst_nr = random_nr;
;;;373    
;;;374        rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
0000c6  6001              STR      r1,[r0,#0]  ; random_nr
0000c8  f1040114          ADD      r1,r4,#0x14
0000cc  9800              LDR      r0,[sp,#0]
0000ce  f7fffffe          BL       rt_list_insert_after
;;;375                             &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
;;;376        for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
;;;377        {
;;;378            if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
;;;379                rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
;;;380                                     &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
;;;381            else
;;;382                break;
;;;383            /* Shift over the bits we have tested. Works well with 1 bit and 2
;;;384             * bits. */
;;;385            tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
;;;386        }
;;;387    
;;;388        timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
0000d2  7a60              LDRB     r0,[r4,#9]
0000d4  f0400001          ORR      r0,r0,#1
0000d8  7260              STRB     r0,[r4,#9]
;;;389    
;;;390        /* enable interrupt */
;;;391        rt_hw_interrupt_enable(level);
0000da  4648              MOV      r0,r9
0000dc  f7fffffe          BL       rt_hw_interrupt_enable
;;;392    
;;;393    #ifdef RT_USING_TIMER_SOFT
;;;394        if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
;;;395        {
;;;396            /* check whether timer thread is ready */
;;;397            if (timer_thread.stat != RT_THREAD_READY)
;;;398            {
;;;399                /* resume timer thread to check soft timer */
;;;400                rt_thread_resume(&timer_thread);
;;;401                rt_schedule();
;;;402            }
;;;403        }
;;;404    #endif
;;;405    
;;;406        return -RT_EOK;
0000e0  2000              MOVS     r0,#0
;;;407    }
0000e2  e8bd87fc          POP      {r2-r10,pc}
;;;408    RTM_EXPORT(rt_timer_start);
                          ENDP

0000e6  0000              DCW      0x0000
                  |L14.232|
                          DCD      ||.constdata||+0x2e
                  |L14.236|
0000ec  74696d65          DCB      "timer != RT_NULL",0
0000f0  7220213d
0000f4  2052545f
0000f8  4e554c4c
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L14.256|
000100  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000104  20617373
000108  65727420
00010c  6661696c
000110  65642061
000114  74202573
000118  3a256420
00011c  0a00    
00011e  00                DCB      0
00011f  00                DCB      0
                  |L14.288|
                          DCD      rt_object_take_hook
                  |L14.292|
000124  74696d65          DCB      "timer->init_tick < RT_TICK_MAX / 2",0
000128  722d3e69
00012c  6e69745f
000130  7469636b
000134  203c2052
000138  545f5449
00013c  434b5f4d
000140  4158202f
000144  203200  
000147  00                DCB      0
                  |L14.328|
                          DCD      ||.data||+0x8

                          AREA ||i.rt_timer_stop||, CODE, READONLY, ALIGN=2

                  rt_timer_stop PROC
;;;416     */
;;;417    rt_err_t rt_timer_stop(rt_timer_t timer)
000000  b538              PUSH     {r3-r5,lr}
;;;418    {
000002  0004              MOVS     r4,r0
000004  d10c              BNE      |L15.32|
;;;419        register rt_base_t level;
;;;420    
;;;421        /* timer check */
;;;422        RT_ASSERT(timer != RT_NULL);
000006  f88d0000          STRB     r0,[sp,#0]
00000a  f44f73d3          MOV      r3,#0x1a6
00000e  4a11              LDR      r2,|L15.84|
000010  a111              ADR      r1,|L15.88|
000012  a016              ADR      r0,|L15.108|
000014  f7fffffe          BL       rt_kprintf
                  |L15.24|
000018  f89d0000          LDRB     r0,[sp,#0]
00001c  2800              CMP      r0,#0
00001e  d0fb              BEQ      |L15.24|
                  |L15.32|
;;;423        if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
000020  7a60              LDRB     r0,[r4,#9]
000022  07c0              LSLS     r0,r0,#31
000024  d013              BEQ      |L15.78|
;;;424            return -RT_ERROR;
;;;425    
;;;426        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
000026  4819              LDR      r0,|L15.140|
000028  6801              LDR      r1,[r0,#0]  ; rt_object_put_hook
00002a  b109              CBZ      r1,|L15.48|
00002c  4620              MOV      r0,r4
00002e  4788              BLX      r1
                  |L15.48|
;;;427    
;;;428        /* disable interrupt */
;;;429        level = rt_hw_interrupt_disable();
000030  f7fffffe          BL       rt_hw_interrupt_disable
000034  4605              MOV      r5,r0
;;;430    
;;;431        _rt_timer_remove(timer);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       _rt_timer_remove
;;;432    
;;;433        /* enable interrupt */
;;;434        rt_hw_interrupt_enable(level);
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       rt_hw_interrupt_enable
;;;435    
;;;436        /* change stat */
;;;437        timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000042  7a60              LDRB     r0,[r4,#9]
000044  f0200001          BIC      r0,r0,#1
000048  7260              STRB     r0,[r4,#9]
;;;438    
;;;439        return RT_EOK;
00004a  2000              MOVS     r0,#0
;;;440    }
00004c  bd38              POP      {r3-r5,pc}
                  |L15.78|
00004e  f04f30ff          MOV      r0,#0xffffffff        ;424
000052  bd38              POP      {r3-r5,pc}
;;;441    RTM_EXPORT(rt_timer_stop);
                          ENDP

                  |L15.84|
                          DCD      ||.constdata||+0x3d
                  |L15.88|
000058  74696d65          DCB      "timer != RT_NULL",0
00005c  7220213d
000060  2052545f
000064  4e554c4c
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L15.108|
00006c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000070  20617373
000074  65727420
000078  6661696c
00007c  65642061
000080  74202573
000084  3a256420
000088  0a00    
00008a  00                DCB      0
00008b  00                DCB      0
                  |L15.140|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_timer_timeout_sethook||, CODE, READONLY, ALIGN=2

                  rt_timer_timeout_sethook PROC
;;;71      */
;;;72     void rt_timer_timeout_sethook(void (*hook)(struct rt_timer *timer))
000000  4901              LDR      r1,|L16.8|
;;;73     {
;;;74         rt_timer_timeout_hook = hook;
000002  6048              STR      r0,[r1,#4]  ; rt_timer_timeout_hook
;;;75     }
000004  4770              BX       lr
;;;76     
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f74          DCB      0x72,0x74,0x5f,0x74
000004  696d6572          DCB      0x69,0x6d,0x65,0x72
000008  5f696e69          DCB      0x5f,0x69,0x6e,0x69
00000c  7400              DCB      0x74,0x00
                  |symbol_number.48|
00000e  7274              DCB      0x72,0x74
000010  5f74696d          DCB      0x5f,0x74,0x69,0x6d
000014  65725f64          DCB      0x65,0x72,0x5f,0x64
000018  65746163          DCB      0x65,0x74,0x61,0x63
00001c  6800              DCB      0x68,0x00
                  |symbol_number.49|
00001e  7274              DCB      0x72,0x74
000020  5f74696d          DCB      0x5f,0x74,0x69,0x6d
000024  65725f64          DCB      0x65,0x72,0x5f,0x64
000028  656c6574          DCB      0x65,0x6c,0x65,0x74
00002c  6500              DCB      0x65,0x00
                  |symbol_number.50|
00002e  7274              DCB      0x72,0x74
000030  5f74696d          DCB      0x5f,0x74,0x69,0x6d
000034  65725f73          DCB      0x65,0x72,0x5f,0x73
000038  74617274          DCB      0x74,0x61,0x72,0x74
00003c  00                DCB      0x00
                  |symbol_number.51|
00003d  72745f            DCB      0x72,0x74,0x5f
000040  74696d65          DCB      0x74,0x69,0x6d,0x65
000044  725f7374          DCB      0x72,0x5f,0x73,0x74
000048  6f7000            DCB      0x6f,0x70,0x00
                  |symbol_number.52|
00004b  72                DCB      0x72
00004c  745f7469          DCB      0x74,0x5f,0x74,0x69
000050  6d65725f          DCB      0x6d,0x65,0x72,0x5f
000054  636f6e74          DCB      0x63,0x6f,0x6e,0x74
000058  726f6c00          DCB      0x72,0x6f,0x6c,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  random_nr
                          DCD      0x00000000
                  rt_timer_timeout_hook
                          DCD      0x00000000
                  rt_timer_list
                          %        8
