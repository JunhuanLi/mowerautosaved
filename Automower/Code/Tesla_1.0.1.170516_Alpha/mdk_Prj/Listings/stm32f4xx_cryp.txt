; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_cryp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_cryp.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_cryp.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp.c]
                          THUMB

                          AREA ||i.CRYP_Cmd||, CODE, READONLY, ALIGN=2

                  CRYP_Cmd PROC
;;;369      */
;;;370    void CRYP_Cmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;371    {
;;;372      /* Check the parameters */
;;;373      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;374    
;;;375      if (NewState != DISABLE)
;;;376      {
;;;377        /* Enable the Cryptographic processor */
;;;378        CRYP->CR |= CRYP_CR_CRYPEN;
000002  4c09              LDR      r4,|L1.40|
000004  b150              CBZ      r0,|L1.28|
000006  2801              CMP      r0,#1                 ;373
000008  d004              BEQ      |L1.20|
00000a  f2401175          MOV      r1,#0x175             ;373
00000e  4807              LDR      r0,|L1.44|
000010  f7fffffe          BL       assert_failed
                  |L1.20|
000014  6820              LDR      r0,[r4,#0]
000016  f4404000          ORR      r0,r0,#0x8000
00001a  e002              B        |L1.34|
                  |L1.28|
;;;379      }
;;;380      else
;;;381      {
;;;382        /* Disable the Cryptographic processor */
;;;383        CRYP->CR &= ~CRYP_CR_CRYPEN;
00001c  6820              LDR      r0,[r4,#0]
00001e  f4204000          BIC      r0,r0,#0x8000
                  |L1.34|
000022  6020              STR      r0,[r4,#0]            ;378
;;;384      }
;;;385    }
000024  bd10              POP      {r4,pc}
;;;386    /**
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x50060000
                  |L1.44|
                          DCD      ||.conststring||

                          AREA ||i.CRYP_DMACmd||, CODE, READONLY, ALIGN=2

                  CRYP_DMACmd PROC
;;;611      */
;;;612    void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;613    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;614      /* Check the parameters */
;;;615      assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
000006  0880              LSRS     r0,r0,#2
000008  d100              BNE      |L2.12|
00000a  b924              CBNZ     r4,|L2.22|
                  |L2.12|
00000c  f2402167          MOV      r1,#0x267
000010  480a              LDR      r0,|L2.60|
000012  f7fffffe          BL       assert_failed
                  |L2.22|
;;;616      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;617    
;;;618      if (NewState != DISABLE)
;;;619      {
;;;620        /* Enable the selected CRYP DMA request */
;;;621        CRYP->DMACR |= CRYP_DMAReq;
000016  4e0a              LDR      r6,|L2.64|
000018  b14d              CBZ      r5,|L2.46|
00001a  2d01              CMP      r5,#1                 ;616
00001c  d004              BEQ      |L2.40|
00001e  f44f711a          MOV      r1,#0x268             ;616
000022  4806              LDR      r0,|L2.60|
000024  f7fffffe          BL       assert_failed
                  |L2.40|
000028  6930              LDR      r0,[r6,#0x10]
00002a  4320              ORRS     r0,r0,r4
00002c  e003              B        |L2.54|
                  |L2.46|
;;;622      }
;;;623      else
;;;624      {
;;;625        /* Disable the selected CRYP DMA request */
;;;626        CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
00002e  6930              LDR      r0,[r6,#0x10]
000030  43e1              MVNS     r1,r4
000032  b2c9              UXTB     r1,r1
000034  4008              ANDS     r0,r0,r1
                  |L2.54|
000036  6130              STR      r0,[r6,#0x10]         ;621
;;;627      }
;;;628    }
000038  bd70              POP      {r4-r6,pc}
;;;629    /**
                          ENDP

00003a  0000              DCW      0x0000
                  |L2.60|
                          DCD      ||.conststring||
                  |L2.64|
                          DCD      0x50060000

                          AREA ||i.CRYP_DataIn||, CODE, READONLY, ALIGN=2

                  CRYP_DataIn PROC
;;;412      */
;;;413    void CRYP_DataIn(uint32_t Data)
000000  4901              LDR      r1,|L3.8|
;;;414    {
;;;415      CRYP->DR = Data;
000002  6088              STR      r0,[r1,#8]
;;;416    }
000004  4770              BX       lr
;;;417    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      0x50060000

                          AREA ||i.CRYP_DataOut||, CODE, READONLY, ALIGN=2

                  CRYP_DataOut PROC
;;;422      */
;;;423    uint32_t CRYP_DataOut(void)
000000  4801              LDR      r0,|L4.8|
;;;424    {
;;;425      return CRYP->DOUT;
000002  68c0              LDR      r0,[r0,#0xc]
;;;426    }
000004  4770              BX       lr
;;;427    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x50060000

                          AREA ||i.CRYP_DeInit||, CODE, READONLY, ALIGN=1

                  CRYP_DeInit PROC
;;;214      */
;;;215    void CRYP_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;216    {
;;;217      /* Enable CRYP reset state */
;;;218      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;219    
;;;220      /* Release CRYP from reset state */
;;;221      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  e8bd4010          POP      {r4,lr}
000010  2010              MOVS     r0,#0x10
000012  f7ffbffe          B.W      RCC_AHB2PeriphResetCmd
;;;222    }
;;;223    
                          ENDP


                          AREA ||i.CRYP_FIFOFlush||, CODE, READONLY, ALIGN=2

                  CRYP_FIFOFlush PROC
;;;357      */
;;;358    void CRYP_FIFOFlush(void)
000000  4802              LDR      r0,|L6.12|
;;;359    {
;;;360      /* Reset the read and write pointers of the FIFOs */
;;;361      CRYP->CR |= CRYP_CR_FFLUSH;
000002  6801              LDR      r1,[r0,#0]
000004  f4414180          ORR      r1,r1,#0x4000
000008  6001              STR      r1,[r0,#0]
;;;362    }
00000a  4770              BX       lr
;;;363    
                          ENDP

                  |L6.12|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetFlagStatus PROC
;;;798      */
;;;799    FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;800    {
;;;801      FlagStatus bitstatus = RESET;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;800
;;;802      uint32_t tempreg = 0;
;;;803    
;;;804      /* Check the parameters */
;;;805      assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));
000006  2801              CMP      r0,#1
000008  d010              BEQ      |L7.44|
00000a  2c02              CMP      r4,#2
00000c  d00e              BEQ      |L7.44|
00000e  2c04              CMP      r4,#4
000010  d00c              BEQ      |L7.44|
000012  2c08              CMP      r4,#8
000014  d00a              BEQ      |L7.44|
000016  2c10              CMP      r4,#0x10
000018  d008              BEQ      |L7.44|
00001a  2c21              CMP      r4,#0x21
00001c  d006              BEQ      |L7.44|
00001e  2c22              CMP      r4,#0x22
000020  d004              BEQ      |L7.44|
000022  f2403125          MOV      r1,#0x325
000026  4807              LDR      r0,|L7.68|
000028  f7fffffe          BL       assert_failed
                  |L7.44|
;;;806    
;;;807      /* check if the FLAG is in RISR register */
;;;808      if ((CRYP_FLAG & FLAG_MASK) != 0x00) 
;;;809      {
;;;810        tempreg = CRYP->RISR;
00002c  4806              LDR      r0,|L7.72|
00002e  06a1              LSLS     r1,r4,#26             ;808
000030  d501              BPL      |L7.54|
000032  6980              LDR      r0,[r0,#0x18]
000034  e000              B        |L7.56|
                  |L7.54|
;;;811      }
;;;812      else  /* The FLAG is in SR register */
;;;813      {
;;;814        tempreg = CRYP->SR;
000036  6840              LDR      r0,[r0,#4]
                  |L7.56|
;;;815      }
;;;816    
;;;817    
;;;818      /* Check the status of the specified CRYP flag */
;;;819      if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)
000038  4220              TST      r0,r4
00003a  d000              BEQ      |L7.62|
;;;820      {
;;;821        /* CRYP_FLAG is set */
;;;822        bitstatus = SET;
00003c  2501              MOVS     r5,#1
                  |L7.62|
;;;823      }
;;;824      else
;;;825      {
;;;826        /* CRYP_FLAG is reset */
;;;827        bitstatus = RESET;
;;;828      }
;;;829    
;;;830      /* Return the CRYP_FLAG status */
;;;831      return  bitstatus;
00003e  4628              MOV      r0,r5
;;;832    }
000040  bd70              POP      {r4-r6,pc}
;;;833    
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      ||.conststring||
                  |L7.72|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetITStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetITStatus PROC
;;;764      */
;;;765    ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;766    {
;;;767      ITStatus bitstatus = RESET;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;766
;;;768      /* Check the parameters */
;;;769      assert_param(IS_CRYP_GET_IT(CRYP_IT));
000006  2801              CMP      r0,#1
000008  d006              BEQ      |L8.24|
00000a  2c02              CMP      r4,#2
00000c  d004              BEQ      |L8.24|
00000e  f2403101          MOV      r1,#0x301
000012  4805              LDR      r0,|L8.40|
000014  f7fffffe          BL       assert_failed
                  |L8.24|
;;;770    
;;;771      /* Check the status of the specified CRYP interrupt */
;;;772      if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)
000018  4804              LDR      r0,|L8.44|
00001a  69c0              LDR      r0,[r0,#0x1c]
00001c  4220              TST      r0,r4
00001e  d000              BEQ      |L8.34|
;;;773      {
;;;774        /* CRYP_IT is set */
;;;775        bitstatus = SET;
000020  2501              MOVS     r5,#1
                  |L8.34|
;;;776      }
;;;777      else
;;;778      {
;;;779        /* CRYP_IT is reset */
;;;780        bitstatus = RESET;
;;;781      }
;;;782      /* Return the CRYP_IT status */
;;;783      return bitstatus;
000022  4628              MOV      r0,r5
;;;784    }
000024  bd70              POP      {r4-r6,pc}
;;;785    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      ||.conststring||
                  |L8.44|
                          DCD      0x50060000

                          AREA ||i.CRYP_ITConfig||, CODE, READONLY, ALIGN=2

                  CRYP_ITConfig PROC
;;;736      */
;;;737    void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;738    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;739      /* Check the parameters */
;;;740      assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
000006  0880              LSRS     r0,r0,#2
000008  d100              BNE      |L9.12|
00000a  b924              CBNZ     r4,|L9.22|
                  |L9.12|
00000c  f44f7139          MOV      r1,#0x2e4
000010  480a              LDR      r0,|L9.60|
000012  f7fffffe          BL       assert_failed
                  |L9.22|
;;;741      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;742    
;;;743      if (NewState != DISABLE)
;;;744      {
;;;745        /* Enable the selected CRYP interrupt */
;;;746        CRYP->IMSCR |= CRYP_IT;
000016  4e0a              LDR      r6,|L9.64|
000018  b14d              CBZ      r5,|L9.46|
00001a  2d01              CMP      r5,#1                 ;741
00001c  d004              BEQ      |L9.40|
00001e  f24021e5          MOV      r1,#0x2e5             ;741
000022  4806              LDR      r0,|L9.60|
000024  f7fffffe          BL       assert_failed
                  |L9.40|
000028  6970              LDR      r0,[r6,#0x14]
00002a  4320              ORRS     r0,r0,r4
00002c  e003              B        |L9.54|
                  |L9.46|
;;;747      }
;;;748      else
;;;749      {
;;;750        /* Disable the selected CRYP interrupt */
;;;751        CRYP->IMSCR &= (uint8_t)~CRYP_IT;
00002e  6970              LDR      r0,[r6,#0x14]
000030  43e1              MVNS     r1,r4
000032  b2c9              UXTB     r1,r1
000034  4008              ANDS     r0,r0,r1
                  |L9.54|
000036  6170              STR      r0,[r6,#0x14]         ;746
;;;752      }
;;;753    }
000038  bd70              POP      {r4-r6,pc}
;;;754    
                          ENDP

00003a  0000              DCW      0x0000
                  |L9.60|
                          DCD      ||.conststring||
                  |L9.64|
                          DCD      0x50060000

                          AREA ||i.CRYP_IVInit||, CODE, READONLY, ALIGN=2

                  CRYP_IVInit PROC
;;;328      */
;;;329    void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
000000  4904              LDR      r1,|L10.20|
;;;330    {
;;;331      CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
000002  6802              LDR      r2,[r0,#0]
000004  640a              STR      r2,[r1,#0x40]
;;;332      CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
000006  6842              LDR      r2,[r0,#4]
000008  644a              STR      r2,[r1,#0x44]
;;;333      CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
00000a  6882              LDR      r2,[r0,#8]
00000c  648a              STR      r2,[r1,#0x48]
;;;334      CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
00000e  68c0              LDR      r0,[r0,#0xc]
000010  64c8              STR      r0,[r1,#0x4c]
;;;335    }
000012  4770              BX       lr
;;;336    
                          ENDP

                  |L10.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_IVStructInit||, CODE, READONLY, ALIGN=1

                  CRYP_IVStructInit PROC
;;;342      */
;;;343    void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
000000  2100              MOVS     r1,#0
;;;344    {
;;;345      CRYP_IVInitStruct->CRYP_IV0Left  = 0;
;;;346      CRYP_IVInitStruct->CRYP_IV0Right = 0;
000002  6001              STR      r1,[r0,#0]
;;;347      CRYP_IVInitStruct->CRYP_IV1Left  = 0;
000004  6041              STR      r1,[r0,#4]
;;;348      CRYP_IVInitStruct->CRYP_IV1Right = 0;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;349    }
00000a  4770              BX       lr
;;;350    
                          ENDP


                          AREA ||i.CRYP_Init||, CODE, READONLY, ALIGN=2

                  CRYP_Init PROC
;;;230      */
;;;231    void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;232    {
000002  4604              MOV      r4,r0
;;;233      /* Check the parameters */
;;;234      assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
000004  8840              LDRH     r0,[r0,#2]
000006  b188              CBZ      r0,|L12.44|
000008  2808              CMP      r0,#8
00000a  d00f              BEQ      |L12.44|
00000c  2810              CMP      r0,#0x10
00000e  d00d              BEQ      |L12.44|
000010  2818              CMP      r0,#0x18
000012  d00b              BEQ      |L12.44|
000014  2820              CMP      r0,#0x20
000016  d009              BEQ      |L12.44|
000018  2828              CMP      r0,#0x28
00001a  d007              BEQ      |L12.44|
00001c  2830              CMP      r0,#0x30
00001e  d005              BEQ      |L12.44|
000020  2838              CMP      r0,#0x38
000022  d003              BEQ      |L12.44|
000024  21ea              MOVS     r1,#0xea
000026  4827              LDR      r0,|L12.196|
000028  f7fffffe          BL       assert_failed
                  |L12.44|
;;;235      assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
00002c  88a0              LDRH     r0,[r4,#4]
00002e  b148              CBZ      r0,|L12.68|
000030  2840              CMP      r0,#0x40
000032  d007              BEQ      |L12.68|
000034  2880              CMP      r0,#0x80
000036  d005              BEQ      |L12.68|
000038  28c0              CMP      r0,#0xc0
00003a  d003              BEQ      |L12.68|
00003c  21eb              MOVS     r1,#0xeb
00003e  4821              LDR      r0,|L12.196|
000040  f7fffffe          BL       assert_failed
                  |L12.68|
;;;236      assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));
000044  8820              LDRH     r0,[r4,#0]
000046  b128              CBZ      r0,|L12.84|
000048  2804              CMP      r0,#4
00004a  d003              BEQ      |L12.84|
00004c  21ec              MOVS     r1,#0xec
00004e  481d              LDR      r0,|L12.196|
000050  f7fffffe          BL       assert_failed
                  |L12.84|
;;;237    
;;;238      /* Select Algorithm mode*/  
;;;239      CRYP->CR &= ~CRYP_CR_ALGOMODE;
000054  4d1c              LDR      r5,|L12.200|
000056  6828              LDR      r0,[r5,#0]
000058  f0200038          BIC      r0,r0,#0x38
00005c  6028              STR      r0,[r5,#0]
;;;240      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
00005e  6828              LDR      r0,[r5,#0]
000060  8861              LDRH     r1,[r4,#2]
000062  4308              ORRS     r0,r0,r1
000064  6028              STR      r0,[r5,#0]
;;;241    
;;;242      /* Select dataType */ 
;;;243      CRYP->CR &= ~CRYP_CR_DATATYPE;
000066  6828              LDR      r0,[r5,#0]
000068  f02000c0          BIC      r0,r0,#0xc0
00006c  6028              STR      r0,[r5,#0]
;;;244      CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
00006e  6828              LDR      r0,[r5,#0]
000070  88a1              LDRH     r1,[r4,#4]
000072  4308              ORRS     r0,r0,r1
000074  6028              STR      r0,[r5,#0]
;;;245    
;;;246      /* select Key size (used only with AES algorithm) */
;;;247      if ((CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_ECB) ||
000076  8860              LDRH     r0,[r4,#2]
000078  2820              CMP      r0,#0x20
00007a  d005              BEQ      |L12.136|
;;;248          (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CBC) ||
00007c  2828              CMP      r0,#0x28
00007e  d003              BEQ      |L12.136|
;;;249          (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CTR) ||
000080  2830              CMP      r0,#0x30
000082  d001              BEQ      |L12.136|
;;;250          (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_Key))
000084  2838              CMP      r0,#0x38
000086  d113              BNE      |L12.176|
                  |L12.136|
;;;251      {
;;;252        assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
000088  88e0              LDRH     r0,[r4,#6]
00008a  b148              CBZ      r0,|L12.160|
00008c  f5b07f80          CMP      r0,#0x100
000090  d006              BEQ      |L12.160|
000092  f5b07f00          CMP      r0,#0x200
000096  d003              BEQ      |L12.160|
000098  21fc              MOVS     r1,#0xfc
00009a  480a              LDR      r0,|L12.196|
00009c  f7fffffe          BL       assert_failed
                  |L12.160|
;;;253        CRYP->CR &= ~CRYP_CR_KEYSIZE;
0000a0  6828              LDR      r0,[r5,#0]
0000a2  f4207040          BIC      r0,r0,#0x300
0000a6  6028              STR      r0,[r5,#0]
;;;254        CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
0000a8  6828              LDR      r0,[r5,#0]
0000aa  88e1              LDRH     r1,[r4,#6]
0000ac  4308              ORRS     r0,r0,r1
0000ae  6028              STR      r0,[r5,#0]
                  |L12.176|
;;;255                                                      configured once the key has 
;;;256                                                      been prepared */
;;;257      }
;;;258    
;;;259      /* Select data Direction */ 
;;;260      CRYP->CR &= ~CRYP_CR_ALGODIR;
0000b0  6828              LDR      r0,[r5,#0]
0000b2  f0200004          BIC      r0,r0,#4
0000b6  6028              STR      r0,[r5,#0]
;;;261      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
0000b8  6828              LDR      r0,[r5,#0]
0000ba  8821              LDRH     r1,[r4,#0]
0000bc  4308              ORRS     r0,r0,r1
0000be  6028              STR      r0,[r5,#0]
;;;262    }
0000c0  bd70              POP      {r4-r6,pc}
;;;263    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L12.196|
                          DCD      ||.conststring||
                  |L12.200|
                          DCD      0x50060000

                          AREA ||i.CRYP_KeyInit||, CODE, READONLY, ALIGN=2

                  CRYP_KeyInit PROC
;;;291      */
;;;292    void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
000000  4908              LDR      r1,|L13.36|
;;;293    {
;;;294      /* Key Initialisation */
;;;295      CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
000002  6802              LDR      r2,[r0,#0]
000004  620a              STR      r2,[r1,#0x20]
;;;296      CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
000006  6842              LDR      r2,[r0,#4]
000008  624a              STR      r2,[r1,#0x24]
;;;297      CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
00000a  6882              LDR      r2,[r0,#8]
00000c  628a              STR      r2,[r1,#0x28]
;;;298      CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  62ca              STR      r2,[r1,#0x2c]
;;;299      CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
000012  6902              LDR      r2,[r0,#0x10]
000014  630a              STR      r2,[r1,#0x30]
;;;300      CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
000016  6942              LDR      r2,[r0,#0x14]
000018  634a              STR      r2,[r1,#0x34]
;;;301      CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
00001a  6982              LDR      r2,[r0,#0x18]
00001c  638a              STR      r2,[r1,#0x38]
;;;302      CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
00001e  69c0              LDR      r0,[r0,#0x1c]
000020  63c8              STR      r0,[r1,#0x3c]
;;;303    }
000022  4770              BX       lr
;;;304    
                          ENDP

                  |L13.36|
                          DCD      0x50060000

                          AREA ||i.CRYP_KeyStructInit||, CODE, READONLY, ALIGN=1

                  CRYP_KeyStructInit PROC
;;;310      */
;;;311    void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
000000  2100              MOVS     r1,#0
;;;312    {
;;;313      CRYP_KeyInitStruct->CRYP_Key0Left  = 0;
;;;314      CRYP_KeyInitStruct->CRYP_Key0Right = 0;
000002  6001              STR      r1,[r0,#0]
;;;315      CRYP_KeyInitStruct->CRYP_Key1Left  = 0;
000004  6041              STR      r1,[r0,#4]
;;;316      CRYP_KeyInitStruct->CRYP_Key1Right = 0;
000006  6081              STR      r1,[r0,#8]
;;;317      CRYP_KeyInitStruct->CRYP_Key2Left  = 0;
000008  60c1              STR      r1,[r0,#0xc]
;;;318      CRYP_KeyInitStruct->CRYP_Key2Right = 0;
00000a  6101              STR      r1,[r0,#0x10]
;;;319      CRYP_KeyInitStruct->CRYP_Key3Left  = 0;
00000c  6141              STR      r1,[r0,#0x14]
;;;320      CRYP_KeyInitStruct->CRYP_Key3Right = 0;
00000e  6181              STR      r1,[r0,#0x18]
000010  61c1              STR      r1,[r0,#0x1c]
;;;321    }
000012  4770              BX       lr
;;;322    /**
                          ENDP


                          AREA ||i.CRYP_RestoreContext||, CODE, READONLY, ALIGN=2

                  CRYP_RestoreContext PROC
;;;550      */
;;;551    void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)  
000000  490f              LDR      r1,|L15.64|
;;;552    {
;;;553    
;;;554      /* Configure the processor with the saved configuration */
;;;555      CRYP->CR = CRYP_ContextRestore->CR_bits9to2;
000002  6802              LDR      r2,[r0,#0]
000004  600a              STR      r2,[r1,#0]
;;;556    
;;;557      /* restore The key value */
;;;558      CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; 
000006  6942              LDR      r2,[r0,#0x14]
000008  620a              STR      r2,[r1,#0x20]
;;;559      CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;
00000a  6982              LDR      r2,[r0,#0x18]
00000c  624a              STR      r2,[r1,#0x24]
;;;560      CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;
00000e  69c2              LDR      r2,[r0,#0x1c]
000010  628a              STR      r2,[r1,#0x28]
;;;561      CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;
000012  6a02              LDR      r2,[r0,#0x20]
000014  62ca              STR      r2,[r1,#0x2c]
;;;562      CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;
000016  6a42              LDR      r2,[r0,#0x24]
000018  630a              STR      r2,[r1,#0x30]
;;;563      CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;
00001a  6a82              LDR      r2,[r0,#0x28]
00001c  634a              STR      r2,[r1,#0x34]
;;;564      CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;
00001e  6ac2              LDR      r2,[r0,#0x2c]
000020  638a              STR      r2,[r1,#0x38]
;;;565      CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;
000022  6b02              LDR      r2,[r0,#0x30]
000024  63ca              STR      r2,[r1,#0x3c]
;;;566    
;;;567      /* and the initialization vectors. */
;;;568      CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;
000026  6842              LDR      r2,[r0,#4]
000028  640a              STR      r2,[r1,#0x40]
;;;569      CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;
00002a  6882              LDR      r2,[r0,#8]
00002c  644a              STR      r2,[r1,#0x44]
;;;570      CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;
00002e  68c2              LDR      r2,[r0,#0xc]
000030  648a              STR      r2,[r1,#0x48]
;;;571      CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;
000032  6900              LDR      r0,[r0,#0x10]
000034  64c8              STR      r0,[r1,#0x4c]
;;;572    
;;;573      /* Enable the cryptographic processor */
;;;574      CRYP->CR |= CRYP_CR_CRYPEN;
000036  6808              LDR      r0,[r1,#0]
000038  f4404000          ORR      r0,r0,#0x8000
00003c  6008              STR      r0,[r1,#0]
;;;575    }
00003e  4770              BX       lr
;;;576    /**
                          ENDP

                  |L15.64|
                          DCD      0x50060000

                          AREA ||i.CRYP_SaveContext||, CODE, READONLY, ALIGN=2

                  CRYP_SaveContext PROC
;;;465      */
;;;466    ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
000000  b578              PUSH     {r3-r6,lr}
;;;467                                 CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
;;;468    {
;;;469      __IO uint32_t timeout = 0;
;;;470      uint32_t ckeckmask = 0, bitstatus;    
;;;471      ErrorStatus status = ERROR;
;;;472    
;;;473      /* Stop DMA transfers on the IN FIFO by clearing the DIEN bit in the CRYP_DMACR */
;;;474      CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DIEN;
000002  4b22              LDR      r3,|L16.140|
000004  2200              MOVS     r2,#0                 ;469
000006  9200              STR      r2,[sp,#0]
000008  691a              LDR      r2,[r3,#0x10]
00000a  f0220201          BIC      r2,r2,#1
00000e  611a              STR      r2,[r3,#0x10]
;;;475        
;;;476      /* Wait until both the IN and OUT FIFOs are empty  
;;;477        (IFEM=1 and OFNE=0 in the CRYP_SR register) and the 
;;;478         BUSY bit is cleared. */
;;;479    
;;;480      if ((CRYP->CR & (uint32_t)(CRYP_CR_ALGOMODE_TDES_ECB | CRYP_CR_ALGOMODE_TDES_CBC)) != (uint32_t)0 )/* TDES */
000010  681a              LDR      r2,[r3,#0]
000012  0712              LSLS     r2,r2,#28
000014  d501              BPL      |L16.26|
;;;481      { 
;;;482        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY ;
000016  2211              MOVS     r2,#0x11
000018  e000              B        |L16.28|
                  |L16.26|
;;;483      }
;;;484      else /* AES or DES */
;;;485      {
;;;486        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
00001a  2215              MOVS     r2,#0x15
                  |L16.28|
;;;487      }           
;;;488       
;;;489      do 
;;;490      {
;;;491        bitstatus = CRYP->SR & ckeckmask;
;;;492        timeout++;
;;;493      }
;;;494      while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
00001c  f64f76ff          MOV      r6,#0xffff
                  |L16.32|
000020  685c              LDR      r4,[r3,#4]            ;491
000022  9d00              LDR      r5,[sp,#0]            ;492
000024  4014              ANDS     r4,r4,r2              ;491
000026  1c6d              ADDS     r5,r5,#1              ;492
000028  9500              STR      r5,[sp,#0]
00002a  42b5              CMP      r5,r6
00002c  d001              BEQ      |L16.50|
00002e  2c01              CMP      r4,#1
000030  d1f6              BNE      |L16.32|
                  |L16.50|
;;;495         
;;;496      if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
000032  685c              LDR      r4,[r3,#4]
000034  4014              ANDS     r4,r4,r2
000036  2c01              CMP      r4,#1
000038  d001              BEQ      |L16.62|
;;;497      {
;;;498        status = ERROR;
00003a  2000              MOVS     r0,#0
;;;499      }
;;;500      else
;;;501      {      
;;;502        /* Stop DMA transfers on the OUT FIFO by 
;;;503           - writing the DOEN bit to 0 in the CRYP_DMACR register 
;;;504           - and clear the CRYPEN bit. */
;;;505    
;;;506        CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DOEN;
;;;507        CRYP->CR &= ~(uint32_t)CRYP_CR_CRYPEN;
;;;508    
;;;509        /* Save the current configuration (bits [9:2] in the CRYP_CR register) */
;;;510        CRYP_ContextSave->CR_bits9to2  = CRYP->CR & (CRYP_CR_KEYSIZE  | 
;;;511                                                     CRYP_CR_DATATYPE | 
;;;512                                                     CRYP_CR_ALGOMODE |
;;;513                                                     CRYP_CR_ALGODIR); 
;;;514    
;;;515        /* and, if not in ECB mode, the initialization vectors. */
;;;516        CRYP_ContextSave->CRYP_IV0LR = CRYP->IV0LR;
;;;517        CRYP_ContextSave->CRYP_IV0RR = CRYP->IV0RR;
;;;518        CRYP_ContextSave->CRYP_IV1LR = CRYP->IV1LR;
;;;519        CRYP_ContextSave->CRYP_IV1RR = CRYP->IV1RR;
;;;520    
;;;521        /* save The key value */
;;;522        CRYP_ContextSave->CRYP_K0LR = CRYP_KeyInitStruct->CRYP_Key0Left; 
;;;523        CRYP_ContextSave->CRYP_K0RR = CRYP_KeyInitStruct->CRYP_Key0Right; 
;;;524        CRYP_ContextSave->CRYP_K1LR = CRYP_KeyInitStruct->CRYP_Key1Left; 
;;;525        CRYP_ContextSave->CRYP_K1RR = CRYP_KeyInitStruct->CRYP_Key1Right; 
;;;526        CRYP_ContextSave->CRYP_K2LR = CRYP_KeyInitStruct->CRYP_Key2Left; 
;;;527        CRYP_ContextSave->CRYP_K2RR = CRYP_KeyInitStruct->CRYP_Key2Right; 
;;;528        CRYP_ContextSave->CRYP_K3LR = CRYP_KeyInitStruct->CRYP_Key3Left; 
;;;529        CRYP_ContextSave->CRYP_K3RR = CRYP_KeyInitStruct->CRYP_Key3Right; 
;;;530    
;;;531       /* When needed, save the DMA status (pointers for IN and OUT messages, 
;;;532          number of remaining bytes, etc.) */
;;;533         
;;;534        status = SUCCESS;
;;;535      }
;;;536    
;;;537       return status;
;;;538    }
00003c  bd78              POP      {r3-r6,pc}
                  |L16.62|
00003e  691a              LDR      r2,[r3,#0x10]         ;506
000040  f0220202          BIC      r2,r2,#2              ;506
000044  611a              STR      r2,[r3,#0x10]         ;506
000046  681a              LDR      r2,[r3,#0]            ;507
000048  f4224200          BIC      r2,r2,#0x8000         ;507
00004c  601a              STR      r2,[r3,#0]            ;507
00004e  681a              LDR      r2,[r3,#0]            ;510
000050  f402727f          AND      r2,r2,#0x3fc          ;510
000054  6002              STR      r2,[r0,#0]            ;516
000056  6c1a              LDR      r2,[r3,#0x40]         ;516
000058  6042              STR      r2,[r0,#4]            ;517
00005a  6c5a              LDR      r2,[r3,#0x44]         ;517
00005c  6082              STR      r2,[r0,#8]            ;518
00005e  6c9a              LDR      r2,[r3,#0x48]         ;518
000060  60c2              STR      r2,[r0,#0xc]          ;519
000062  6cda              LDR      r2,[r3,#0x4c]         ;519
000064  6102              STR      r2,[r0,#0x10]         ;522
000066  680a              LDR      r2,[r1,#0]            ;522
000068  6142              STR      r2,[r0,#0x14]         ;523
00006a  684a              LDR      r2,[r1,#4]            ;523
00006c  6182              STR      r2,[r0,#0x18]         ;524
00006e  688a              LDR      r2,[r1,#8]            ;524
000070  61c2              STR      r2,[r0,#0x1c]         ;525
000072  68ca              LDR      r2,[r1,#0xc]          ;525
000074  6202              STR      r2,[r0,#0x20]         ;526
000076  690a              LDR      r2,[r1,#0x10]         ;526
000078  6242              STR      r2,[r0,#0x24]         ;527
00007a  694a              LDR      r2,[r1,#0x14]         ;527
00007c  6282              STR      r2,[r0,#0x28]         ;528
00007e  698a              LDR      r2,[r1,#0x18]         ;528
000080  62c2              STR      r2,[r0,#0x2c]         ;529
000082  69c9              LDR      r1,[r1,#0x1c]         ;529
000084  6301              STR      r1,[r0,#0x30]         ;534
000086  2001              MOVS     r0,#1                 ;534
000088  bd78              POP      {r3-r6,pc}
;;;539    
                          ENDP

00008a  0000              DCW      0x0000
                  |L16.140|
                          DCD      0x50060000

                          AREA ||i.CRYP_StructInit||, CODE, READONLY, ALIGN=1

                  CRYP_StructInit PROC
;;;269      */
;;;270    void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
000000  2100              MOVS     r1,#0
;;;271    {
;;;272      /* Initialize the CRYP_AlgoDir member */
;;;273      CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
000002  8001              STRH     r1,[r0,#0]
;;;274    
;;;275      /* initialize the CRYP_AlgoMode member */
;;;276      CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
000004  8041              STRH     r1,[r0,#2]
;;;277    
;;;278      /* initialize the CRYP_DataType member */
;;;279      CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
000006  8081              STRH     r1,[r0,#4]
;;;280      
;;;281      /* Initialize the CRYP_KeySize member */
;;;282      CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
000008  80c1              STRH     r1,[r0,#6]
;;;283    }
00000a  4770              BX       lr
;;;284    
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_cryp.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f637279
00004a  702e6300

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_cryp_c_459f21d3____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_cryp_c_459f21d3____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_cryp_c_459f21d3____REVSH|
#line 128
|__asm___16_stm32f4xx_cryp_c_459f21d3____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
