; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_hash.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_hash.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_hash.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_hash.c]
                          THUMB

                          AREA ||i.HASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  HASH_ClearFlag PROC
;;;624      */
;;;625    void HASH_ClearFlag(uint16_t HASH_FLAG)
000000  b510              PUSH     {r4,lr}
;;;626    {
000002  4604              MOV      r4,r0
;;;627      /* Check the parameters */
;;;628      assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
000004  2801              CMP      r0,#1
000006  d006              BEQ      |L1.22|
000008  2c02              CMP      r4,#2
00000a  d004              BEQ      |L1.22|
00000c  f44f711d          MOV      r1,#0x274
000010  4803              LDR      r0,|L1.32|
000012  f7fffffe          BL       assert_failed
                  |L1.22|
;;;629      
;;;630      /* Clear the selected HASH flags */
;;;631      HASH->SR = ~(uint32_t)HASH_FLAG;
000016  4903              LDR      r1,|L1.36|
000018  43e0              MVNS     r0,r4
00001a  6008              STR      r0,[r1,#0]
;;;632    }
00001c  bd10              POP      {r4,pc}
;;;633    /**
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.conststring||
                  |L1.36|
                          DCD      0x50060424

                          AREA ||i.HASH_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  HASH_ClearITPendingBit PROC
;;;674      */
;;;675    void HASH_ClearITPendingBit(uint8_t HASH_IT)
000000  b510              PUSH     {r4,lr}
;;;676    {
000002  4604              MOV      r4,r0
;;;677      /* Check the parameters */
;;;678      assert_param(IS_HASH_IT(HASH_IT));
000004  0880              LSRS     r0,r0,#2
000006  d100              BNE      |L2.10|
000008  b924              CBNZ     r4,|L2.20|
                  |L2.10|
00000a  f24021a6          MOV      r1,#0x2a6
00000e  4804              LDR      r0,|L2.32|
000010  f7fffffe          BL       assert_failed
                  |L2.20|
;;;679    
;;;680      /* Clear the selected HASH interrupt pending bit */
;;;681      HASH->SR = (uint8_t)~HASH_IT;
000014  4903              LDR      r1,|L2.36|
000016  43e0              MVNS     r0,r4
000018  b2c0              UXTB     r0,r0
00001a  6008              STR      r0,[r1,#0]
;;;682    }
00001c  bd10              POP      {r4,pc}
;;;683    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      ||.conststring||
                  |L2.36|
                          DCD      0x50060424

                          AREA ||i.HASH_DMACmd||, CODE, READONLY, ALIGN=2

                  HASH_DMACmd PROC
;;;459      */
;;;460    void HASH_DMACmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;461    {
;;;462      /* Check the parameters */
;;;463      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;464    
;;;465      if (NewState != DISABLE)
;;;466      {
;;;467        /* Enable the HASH DMA request */
;;;468        HASH->CR |= HASH_CR_DMAE;
000002  4c09              LDR      r4,|L3.40|
000004  b150              CBZ      r0,|L3.28|
000006  2801              CMP      r0,#1                 ;463
000008  d004              BEQ      |L3.20|
00000a  f24011cf          MOV      r1,#0x1cf             ;463
00000e  4807              LDR      r0,|L3.44|
000010  f7fffffe          BL       assert_failed
                  |L3.20|
000014  6820              LDR      r0,[r4,#0]
000016  f0400008          ORR      r0,r0,#8
00001a  e002              B        |L3.34|
                  |L3.28|
;;;469      }
;;;470      else
;;;471      {
;;;472        /* Disable the HASH DMA request */
;;;473        HASH->CR &= ~HASH_CR_DMAE;
00001c  6820              LDR      r0,[r4,#0]
00001e  f0200008          BIC      r0,r0,#8
                  |L3.34|
000022  6020              STR      r0,[r4,#0]            ;468
;;;474      }
;;;475    }
000024  bd10              POP      {r4,pc}
;;;476    /**
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x50060400
                  |L3.44|
                          DCD      ||.conststring||

                          AREA ||i.HASH_DataIn||, CODE, READONLY, ALIGN=2

                  HASH_DataIn PROC
;;;305      */
;;;306    void HASH_DataIn(uint32_t Data)
000000  4901              LDR      r1,|L4.8|
;;;307    {
;;;308      /* Write in the DIN register a new data */
;;;309      HASH->DIN = Data;
000002  6008              STR      r0,[r1,#0]
;;;310    }
000004  4770              BX       lr
;;;311    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x50060404

                          AREA ||i.HASH_DeInit||, CODE, READONLY, ALIGN=1

                  HASH_DeInit PROC
;;;170      */
;;;171    void HASH_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173      /* Enable HASH reset state */
;;;174      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
000002  2101              MOVS     r1,#1
000004  2020              MOVS     r0,#0x20
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;175      /* Release HASH from reset state */
;;;176      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  e8bd4010          POP      {r4,lr}
000010  2020              MOVS     r0,#0x20
000012  f7ffbffe          B.W      RCC_AHB2PeriphResetCmd
;;;177    }
;;;178    
                          ENDP


                          AREA ||i.HASH_GetDigest||, CODE, READONLY, ALIGN=2

                  HASH_GetDigest PROC
;;;330      */
;;;331    void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
000000  4909              LDR      r1,|L6.40|
;;;332    {
;;;333      /* Get the data field */
;;;334      HASH_MessageDigest->Data[0] = HASH->HR[0];
000002  6809              LDR      r1,[r1,#0]
;;;335      HASH_MessageDigest->Data[1] = HASH->HR[1];
000004  6001              STR      r1,[r0,#0]
000006  4908              LDR      r1,|L6.40|
000008  1d09              ADDS     r1,r1,#4
00000a  6809              LDR      r1,[r1,#0]
;;;336      HASH_MessageDigest->Data[2] = HASH->HR[2];
00000c  6041              STR      r1,[r0,#4]
00000e  4906              LDR      r1,|L6.40|
000010  3108              ADDS     r1,r1,#8
000012  6809              LDR      r1,[r1,#0]
;;;337      HASH_MessageDigest->Data[3] = HASH->HR[3];
000014  6081              STR      r1,[r0,#8]
000016  4904              LDR      r1,|L6.40|
000018  310c              ADDS     r1,r1,#0xc
00001a  6809              LDR      r1,[r1,#0]
;;;338      HASH_MessageDigest->Data[4] = HASH->HR[4];
00001c  60c1              STR      r1,[r0,#0xc]
00001e  4902              LDR      r1,|L6.40|
000020  3110              ADDS     r1,r1,#0x10
000022  6809              LDR      r1,[r1,#0]
000024  6101              STR      r1,[r0,#0x10]
;;;339    }
000026  4770              BX       lr
;;;340    
                          ENDP

                  |L6.40|
                          DCD      0x5006040c

                          AREA ||i.HASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  HASH_GetFlagStatus PROC
;;;583      */
;;;584    FlagStatus HASH_GetFlagStatus(uint16_t HASH_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;585    {
;;;586      FlagStatus bitstatus = RESET;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;585
;;;587      uint32_t tempreg = 0;
;;;588    
;;;589      /* Check the parameters */
;;;590      assert_param(IS_HASH_GET_FLAG(HASH_FLAG));
000006  2801              CMP      r0,#1
000008  d00d              BEQ      |L7.38|
00000a  2c02              CMP      r4,#2
00000c  d00b              BEQ      |L7.38|
00000e  2c04              CMP      r4,#4
000010  d009              BEQ      |L7.38|
000012  2c08              CMP      r4,#8
000014  d007              BEQ      |L7.38|
000016  f5b45f80          CMP      r4,#0x1000
00001a  d004              BEQ      |L7.38|
00001c  f240214e          MOV      r1,#0x24e
000020  4807              LDR      r0,|L7.64|
000022  f7fffffe          BL       assert_failed
                  |L7.38|
;;;591    
;;;592      /* check if the FLAG is in CR register */
;;;593      if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint16_t)RESET ) 
000026  04e0              LSLS     r0,r4,#19
000028  d501              BPL      |L7.46|
;;;594      {
;;;595        tempreg = HASH->CR;
00002a  4806              LDR      r0,|L7.68|
00002c  e001              B        |L7.50|
                  |L7.46|
;;;596      }
;;;597      else /* The FLAG is in SR register */
;;;598      {
;;;599        tempreg = HASH->SR;
00002e  4805              LDR      r0,|L7.68|
000030  3024              ADDS     r0,r0,#0x24
                  |L7.50|
000032  6800              LDR      r0,[r0,#0]
;;;600      }
;;;601    
;;;602      /* Check the status of the specified HASH flag */
;;;603      if ((tempreg & HASH_FLAG) != (uint16_t)RESET)
000034  4220              TST      r0,r4
000036  d000              BEQ      |L7.58|
;;;604      {
;;;605        /* HASH is set */
;;;606        bitstatus = SET;
000038  2501              MOVS     r5,#1
                  |L7.58|
;;;607      }
;;;608      else
;;;609      {
;;;610        /* HASH_FLAG is reset */
;;;611        bitstatus = RESET;
;;;612      }
;;;613    
;;;614      /* Return the HASH_FLAG status */
;;;615      return  bitstatus;
00003a  4628              MOV      r0,r5
;;;616    }
00003c  bd70              POP      {r4-r6,pc}
;;;617    /**
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      ||.conststring||
                  |L7.68|
                          DCD      0x50060400

                          AREA ||i.HASH_GetITStatus||, CODE, READONLY, ALIGN=2

                  HASH_GetITStatus PROC
;;;640      */
;;;641    ITStatus HASH_GetITStatus(uint8_t HASH_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;642    {
;;;643      ITStatus bitstatus = RESET;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;642
;;;644      uint32_t tmpreg = 0;
;;;645    
;;;646      /* Check the parameters */
;;;647      assert_param(IS_HASH_GET_IT(HASH_IT));  
000006  2801              CMP      r0,#1
000008  d006              BEQ      |L8.24|
00000a  2c02              CMP      r4,#2
00000c  d004              BEQ      |L8.24|
00000e  f2402187          MOV      r1,#0x287
000012  4807              LDR      r0,|L8.48|
000014  f7fffffe          BL       assert_failed
                  |L8.24|
;;;648    
;;;649    
;;;650      /* Check the status of the specified HASH interrupt */
;;;651      tmpreg =  HASH->SR;
000018  4806              LDR      r0,|L8.52|
00001a  6800              LDR      r0,[r0,#0]
;;;652    
;;;653      if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
00001c  4905              LDR      r1,|L8.52|
00001e  1f09              SUBS     r1,r1,#4
000020  6809              LDR      r1,[r1,#0]
000022  4020              ANDS     r0,r0,r4
000024  4201              TST      r1,r0
000026  d000              BEQ      |L8.42|
;;;654      {
;;;655        /* HASH_IT is set */
;;;656        bitstatus = SET;
000028  2501              MOVS     r5,#1
                  |L8.42|
;;;657      }
;;;658      else
;;;659      {
;;;660        /* HASH_IT is reset */
;;;661        bitstatus = RESET;
;;;662      }
;;;663      /* Return the HASH_IT status */
;;;664      return bitstatus;
00002a  4628              MOV      r0,r5
;;;665    }
00002c  bd70              POP      {r4-r6,pc}
;;;666    
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      ||.conststring||
                  |L8.52|
                          DCD      0x50060424

                          AREA ||i.HASH_GetInFIFOWordsNbr||, CODE, READONLY, ALIGN=2

                  HASH_GetInFIFOWordsNbr PROC
;;;316      */
;;;317    uint8_t HASH_GetInFIFOWordsNbr(void)
000000  4802              LDR      r0,|L9.12|
;;;318    {
;;;319      /* Return the value of NBW bits */
;;;320      return ((HASH->CR & HASH_CR_NBW) >> 8);
000002  6800              LDR      r0,[r0,#0]
000004  f3c02003          UBFX     r0,r0,#8,#4
;;;321    }
000008  4770              BX       lr
;;;322    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0x50060400

                          AREA ||i.HASH_ITConfig||, CODE, READONLY, ALIGN=2

                  HASH_ITConfig PROC
;;;554      */
;;;555    void HASH_ITConfig(uint8_t HASH_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;556    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;557      /* Check the parameters */
;;;558      assert_param(IS_HASH_IT(HASH_IT));
000006  0880              LSRS     r0,r0,#2
000008  d100              BNE      |L10.12|
00000a  b924              CBNZ     r4,|L10.22|
                  |L10.12|
00000c  f240212e          MOV      r1,#0x22e
000010  480a              LDR      r0,|L10.60|
000012  f7fffffe          BL       assert_failed
                  |L10.22|
;;;559      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;560    
;;;561      if (NewState != DISABLE)
;;;562      {
;;;563        /* Enable the selected HASH interrupt */
;;;564        HASH->IMR |= HASH_IT;
000016  4e0a              LDR      r6,|L10.64|
000018  b14d              CBZ      r5,|L10.46|
00001a  2d01              CMP      r5,#1                 ;559
00001c  d004              BEQ      |L10.40|
00001e  f240212f          MOV      r1,#0x22f             ;559
000022  4806              LDR      r0,|L10.60|
000024  f7fffffe          BL       assert_failed
                  |L10.40|
000028  6830              LDR      r0,[r6,#0]
00002a  4320              ORRS     r0,r0,r4
00002c  e003              B        |L10.54|
                  |L10.46|
;;;565      }
;;;566      else
;;;567      {
;;;568        /* Disable the selected HASH interrupt */
;;;569        HASH->IMR &= (uint8_t) ~HASH_IT;
00002e  6830              LDR      r0,[r6,#0]
000030  43e1              MVNS     r1,r4
000032  b2c9              UXTB     r1,r1
000034  4008              ANDS     r0,r0,r1
                  |L10.54|
000036  6030              STR      r0,[r6,#0]            ;564
;;;570      }
;;;571    }
000038  bd70              POP      {r4-r6,pc}
;;;572    
                          ENDP

00003a  0000              DCW      0x0000
                  |L10.60|
                          DCD      ||.conststring||
                  |L10.64|
                          DCD      0x50060420

                          AREA ||i.HASH_Init||, CODE, READONLY, ALIGN=2

                  HASH_Init PROC
;;;190      */
;;;191    void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;192    {
000002  4604              MOV      r4,r0
;;;193      /* Check the parameters */
;;;194      assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
000004  6800              LDR      r0,[r0,#0]
000006  b128              CBZ      r0,|L11.20|
000008  2880              CMP      r0,#0x80
00000a  d003              BEQ      |L11.20|
00000c  21c2              MOVS     r1,#0xc2
00000e  481e              LDR      r0,|L11.136|
000010  f7fffffe          BL       assert_failed
                  |L11.20|
;;;195      assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
000014  68a0              LDR      r0,[r4,#8]
000016  b148              CBZ      r0,|L11.44|
000018  2810              CMP      r0,#0x10
00001a  d007              BEQ      |L11.44|
00001c  2820              CMP      r0,#0x20
00001e  d005              BEQ      |L11.44|
000020  2830              CMP      r0,#0x30
000022  d003              BEQ      |L11.44|
000024  21c3              MOVS     r1,#0xc3
000026  4818              LDR      r0,|L11.136|
000028  f7fffffe          BL       assert_failed
                  |L11.44|
;;;196      assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
00002c  6860              LDR      r0,[r4,#4]
00002e  b128              CBZ      r0,|L11.60|
000030  2840              CMP      r0,#0x40
000032  d003              BEQ      |L11.60|
000034  21c4              MOVS     r1,#0xc4
000036  4814              LDR      r0,|L11.136|
000038  f7fffffe          BL       assert_failed
                  |L11.60|
;;;197      
;;;198      /* Configure the Algorithm used, algorithm mode and the datatype */
;;;199      HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
00003c  4d13              LDR      r5,|L11.140|
00003e  6828              LDR      r0,[r5,#0]
000040  f02000f0          BIC      r0,r0,#0xf0
000044  6028              STR      r0,[r5,#0]
;;;200      HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
000046  6828              LDR      r0,[r5,#0]
000048  6821              LDR      r1,[r4,#0]
00004a  4308              ORRS     r0,r0,r1
00004c  e9d42101          LDRD     r2,r1,[r4,#4]
000050  4311              ORRS     r1,r1,r2
000052  4308              ORRS     r0,r0,r1
000054  6028              STR      r0,[r5,#0]
;;;201                   HASH_InitStruct->HASH_DataType | \
;;;202                   HASH_InitStruct->HASH_AlgoMode);
;;;203      
;;;204      /* if algorithm mode is HMAC, set the Key */  
;;;205      if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
000056  6860              LDR      r0,[r4,#4]
000058  2840              CMP      r0,#0x40
00005a  d110              BNE      |L11.126|
;;;206      {
;;;207        assert_param(IS_HASH_HMAC_KEYTYPE(HASH_InitStruct->HASH_HMACKeyType));
00005c  68e0              LDR      r0,[r4,#0xc]
00005e  b130              CBZ      r0,|L11.110|
000060  f5b03f80          CMP      r0,#0x10000
000064  d003              BEQ      |L11.110|
000066  21cf              MOVS     r1,#0xcf
000068  4807              LDR      r0,|L11.136|
00006a  f7fffffe          BL       assert_failed
                  |L11.110|
;;;208        HASH->CR &= ~HASH_CR_LKEY;
00006e  6828              LDR      r0,[r5,#0]
000070  f4203080          BIC      r0,r0,#0x10000
000074  6028              STR      r0,[r5,#0]
;;;209        HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
000076  6828              LDR      r0,[r5,#0]
000078  68e1              LDR      r1,[r4,#0xc]
00007a  4308              ORRS     r0,r0,r1
00007c  6028              STR      r0,[r5,#0]
                  |L11.126|
;;;210      }
;;;211    
;;;212      /* Reset the HASH processor core, so that the HASH will be ready to compute 
;;;213         the message digest of a new message */
;;;214      HASH->CR |= HASH_CR_INIT;  
00007e  6828              LDR      r0,[r5,#0]
000080  f0400004          ORR      r0,r0,#4
000084  6028              STR      r0,[r5,#0]
;;;215    }
000086  bd70              POP      {r4-r6,pc}
;;;216    
                          ENDP

                  |L11.136|
                          DCD      ||.conststring||
                  |L11.140|
                          DCD      0x50060400

                          AREA ||i.HASH_Reset||, CODE, READONLY, ALIGN=2

                  HASH_Reset PROC
;;;248      */
;;;249    void HASH_Reset(void)
000000  4802              LDR      r0,|L12.12|
;;;250    {
;;;251      /* Reset the HASH processor core */
;;;252      HASH->CR |= HASH_CR_INIT;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;253    }
00000a  4770              BX       lr
;;;254    /**
                          ENDP

                  |L12.12|
                          DCD      0x50060400

                          AREA ||i.HASH_RestoreContext||, CODE, READONLY, ALIGN=2

                  HASH_RestoreContext PROC
;;;410      */
;;;411    void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
000000  b510              PUSH     {r4,lr}
;;;412    {
;;;413      uint8_t i = 0;
;;;414      
;;;415      /* restore context registers */
;;;416      HASH->IMR = HASH_ContextRestore->HASH_IMR;   
000002  4b0e              LDR      r3,|L13.60|
000004  6802              LDR      r2,[r0,#0]
000006  2100              MOVS     r1,#0                 ;413
000008  601a              STR      r2,[r3,#0]
;;;417      HASH->STR = HASH_ContextRestore->HASH_STR;     
00000a  4b0c              LDR      r3,|L13.60|
00000c  6842              LDR      r2,[r0,#4]
00000e  3b18              SUBS     r3,r3,#0x18
000010  601a              STR      r2,[r3,#0]
;;;418      HASH->CR = HASH_ContextRestore->HASH_CR;
000012  4a0a              LDR      r2,|L13.60|
000014  6883              LDR      r3,[r0,#8]
000016  3a20              SUBS     r2,r2,#0x20
000018  6013              STR      r3,[r2,#0]
;;;419      
;;;420      /* Initialize the hash processor */
;;;421      HASH->CR |= HASH_CR_INIT; 
00001a  6813              LDR      r3,[r2,#0]
00001c  f0430304          ORR      r3,r3,#4
000020  6013              STR      r3,[r2,#0]
;;;422      
;;;423       /* continue restoring context registers */     
;;;424      for(i=0; i<=50;i++)
;;;425      {
;;;426         HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
000022  4a07              LDR      r2,|L13.64|
                  |L13.36|
000024  eb000381          ADD      r3,r0,r1,LSL #2
000028  eb020481          ADD      r4,r2,r1,LSL #2
00002c  68db              LDR      r3,[r3,#0xc]
00002e  f8c434f8          STR      r3,[r4,#0x4f8]
000032  1c49              ADDS     r1,r1,#1
000034  b2c9              UXTB     r1,r1                 ;424
000036  2932              CMP      r1,#0x32              ;424
000038  d9f4              BLS      |L13.36|
;;;427      }   
;;;428    }
00003a  bd10              POP      {r4,pc}
;;;429    /**
                          ENDP

                  |L13.60|
                          DCD      0x50060420
                  |L13.64|
                          DCD      0x50060000

                          AREA ||i.HASH_SaveContext||, CODE, READONLY, ALIGN=2

                  HASH_SaveContext PROC
;;;388      */
;;;389    void HASH_SaveContext(HASH_Context* HASH_ContextSave)
000000  4a0c              LDR      r2,|L14.52|
;;;390    {
000002  b510              PUSH     {r4,lr}
;;;391      uint8_t i = 0;
;;;392      
;;;393      /* save context registers */
;;;394      HASH_ContextSave->HASH_IMR = HASH->IMR;  
000004  6812              LDR      r2,[r2,#0]
000006  2100              MOVS     r1,#0                 ;391
;;;395      HASH_ContextSave->HASH_STR = HASH->STR;      
000008  6002              STR      r2,[r0,#0]
00000a  4a0a              LDR      r2,|L14.52|
00000c  3a18              SUBS     r2,r2,#0x18
00000e  6812              LDR      r2,[r2,#0]
;;;396      HASH_ContextSave->HASH_CR  = HASH->CR;     
000010  6042              STR      r2,[r0,#4]
000012  4a08              LDR      r2,|L14.52|
000014  3a20              SUBS     r2,r2,#0x20
000016  6812              LDR      r2,[r2,#0]
;;;397      for(i=0; i<=50;i++)
;;;398      {
;;;399         HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
000018  6082              STR      r2,[r0,#8]
00001a  4a07              LDR      r2,|L14.56|
                  |L14.28|
00001c  eb020381          ADD      r3,r2,r1,LSL #2
000020  f8d334f8          LDR      r3,[r3,#0x4f8]
000024  eb000481          ADD      r4,r0,r1,LSL #2
000028  1c49              ADDS     r1,r1,#1
00002a  b2c9              UXTB     r1,r1                 ;397
00002c  60e3              STR      r3,[r4,#0xc]          ;397
00002e  2932              CMP      r1,#0x32              ;397
000030  d9f4              BLS      |L14.28|
;;;400      }   
;;;401    }
000032  bd10              POP      {r4,pc}
;;;402    
                          ENDP

                  |L14.52|
                          DCD      0x50060420
                  |L14.56|
                          DCD      0x50060000

                          AREA ||i.HASH_SetLastWordValidBitsNbr||, CODE, READONLY, ALIGN=2

                  HASH_SetLastWordValidBitsNbr PROC
;;;290      */
;;;291    void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber)
000000  b510              PUSH     {r4,lr}
;;;292    {
000002  4604              MOV      r4,r0
;;;293      /* Check the parameters */
;;;294      assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
000004  281f              CMP      r0,#0x1f
000006  d904              BLS      |L15.18|
000008  f44f7193          MOV      r1,#0x126
00000c  4805              LDR      r0,|L15.36|
00000e  f7fffffe          BL       assert_failed
                  |L15.18|
;;;295      
;;;296      /* Configure the Number of valid bits in last word of the message */
;;;297      HASH->STR &= ~(HASH_STR_NBW);
000012  4905              LDR      r1,|L15.40|
000014  6808              LDR      r0,[r1,#0]
000016  f020001f          BIC      r0,r0,#0x1f
00001a  6008              STR      r0,[r1,#0]
;;;298      HASH->STR |= ValidNumber;
00001c  6808              LDR      r0,[r1,#0]
00001e  4320              ORRS     r0,r0,r4
000020  6008              STR      r0,[r1,#0]
;;;299    }
000022  bd10              POP      {r4,pc}
;;;300    
                          ENDP

                  |L15.36|
                          DCD      ||.conststring||
                  |L15.40|
                          DCD      0x50060408

                          AREA ||i.HASH_StartDigest||, CODE, READONLY, ALIGN=2

                  HASH_StartDigest PROC
;;;345      */
;;;346    void HASH_StartDigest(void)
000000  4802              LDR      r0,|L16.12|
;;;347    {
;;;348      /* Start the Digest calculation */
;;;349      HASH->STR |= HASH_STR_DCAL;
000002  6801              LDR      r1,[r0,#0]
000004  f4417180          ORR      r1,r1,#0x100
000008  6001              STR      r1,[r0,#0]
;;;350    }
00000a  4770              BX       lr
;;;351    /**
                          ENDP

                  |L16.12|
                          DCD      0x50060408

                          AREA ||i.HASH_StructInit||, CODE, READONLY, ALIGN=1

                  HASH_StructInit PROC
;;;224      */
;;;225    void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
000000  2100              MOVS     r1,#0
;;;226    {
;;;227      /* Initialize the HASH_AlgoSelection member */
;;;228      HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
;;;229    
;;;230      /* Initialize the HASH_AlgoMode member */
;;;231      HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
000002  6001              STR      r1,[r0,#0]
;;;232    
;;;233      /* Initialize the HASH_DataType member */
;;;234      HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
000004  6041              STR      r1,[r0,#4]
;;;235    
;;;236      /* Initialize the HASH_HMACKeyType member */
;;;237      HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;238    }
00000a  4770              BX       lr
;;;239    
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_hash.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f686173
00004a  682e6300

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_hash.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_hash_c_90573c7c____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_hash_c_90573c7c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_hash_c_90573c7c____REVSH|
#line 128
|__asm___16_stm32f4xx_hash_c_90573c7c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
