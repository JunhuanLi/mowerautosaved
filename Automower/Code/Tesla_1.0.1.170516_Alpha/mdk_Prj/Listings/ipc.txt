; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\ipc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ipc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\ipc.crf ..\OS\src\ipc.c]
                          THUMB

                          AREA ||i.rt_event_control||, CODE, READONLY, ALIGN=2

                  rt_event_control PROC
;;;1210    */
;;;1211   rt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1212   {
000002  460e              MOV      r6,r1
000004  0004              MOVS     r4,r0
000006  f04f0500          MOV      r5,#0
00000a  d10c              BNE      |L1.38|
;;;1213       rt_ubase_t level;
;;;1214       RT_ASSERT(event != RT_NULL);
00000c  f88d5000          STRB     r5,[sp,#0]
000010  f24043be          MOV      r3,#0x4be
000014  4a0e              LDR      r2,|L1.80|
000016  a10f              ADR      r1,|L1.84|
000018  a013              ADR      r0,|L1.104|
00001a  f7fffffe          BL       rt_kprintf
                  |L1.30|
00001e  f89d2000          LDRB     r2,[sp,#0]
000022  2a00              CMP      r2,#0
000024  d0fb              BEQ      |L1.30|
                  |L1.38|
;;;1215   
;;;1216       if (cmd == RT_IPC_CMD_RESET)
000026  2e01              CMP      r6,#1
000028  d002              BEQ      |L1.48|
;;;1217       {
;;;1218           /* disable interrupt */
;;;1219           level = rt_hw_interrupt_disable();
;;;1220   
;;;1221           /* resume all waiting thread */
;;;1222           rt_ipc_list_resume_all(&event->parent.suspend_thread);
;;;1223   
;;;1224           /* init event set */
;;;1225           event->set = 0;
;;;1226   
;;;1227           /* enable interrupt */
;;;1228           rt_hw_interrupt_enable(level);
;;;1229   
;;;1230           rt_schedule();
;;;1231   
;;;1232           return RT_EOK;
;;;1233       }
;;;1234   
;;;1235       return -RT_ERROR;
00002a  f04f30ff          MOV      r0,#0xffffffff
;;;1236   }
00002e  bdf8              POP      {r3-r7,pc}
                  |L1.48|
000030  f7fffffe          BL       rt_hw_interrupt_disable
000034  4606              MOV      r6,r0                 ;1219
000036  f1040014          ADD      r0,r4,#0x14           ;1222
00003a  f7fffffe          BL       rt_ipc_list_resume_all
00003e  4630              MOV      r0,r6                 ;1228
000040  61e5              STR      r5,[r4,#0x1c]         ;1228
000042  f7fffffe          BL       rt_hw_interrupt_enable
000046  f7fffffe          BL       rt_schedule
00004a  2000              MOVS     r0,#0                 ;1232
00004c  bdf8              POP      {r3-r7,pc}
;;;1237   RTM_EXPORT(rt_event_control);
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      ||.constdata||+0x108
                  |L1.84|
000054  6576656e          DCB      "event != RT_NULL",0
000058  7420213d
00005c  2052545f
000060  4e554c4c
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L1.104|
000068  28257329          DCB      "(%s) assert failed at %s:%d \n",0
00006c  20617373
000070  65727420
000074  6661696c
000078  65642061
00007c  74202573
000080  3a256420
000084  0a00    
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.rt_event_create||, CODE, READONLY, ALIGN=2

                  rt_event_create PROC
;;;939     */
;;;940    rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
000000  b5f8              PUSH     {r3-r7,lr}
;;;941    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;942        rt_event_t event;
;;;943    
;;;944        RT_DEBUG_NOT_IN_INTERRUPT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4607              MOV      r7,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  2400              MOVS     r4,#0
000012  b180              CBZ      r0,|L2.54|
000014  4910              LDR      r1,|L2.88|
000016  a011              ADR      r0,|L2.92|
000018  f7fffffe          BL       rt_kprintf
00001c  f88d4000          STRB     r4,[sp,#0]
000020  f44f736c          MOV      r3,#0x3b0
000024  4a0c              LDR      r2,|L2.88|
000026  a116              ADR      r1,|L2.128|
000028  a016              ADR      r0,|L2.132|
00002a  f7fffffe          BL       rt_kprintf
                  |L2.46|
00002e  f89d0000          LDRB     r0,[sp,#0]
000032  2800              CMP      r0,#0
000034  d0fb              BEQ      |L2.46|
                  |L2.54|
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       rt_hw_interrupt_enable
;;;945    
;;;946        /* allocate object */
;;;947        event = (rt_event_t)rt_object_allocate(RT_Object_Class_Event, name);
00003c  4631              MOV      r1,r6
00003e  2003              MOVS     r0,#3
000040  f7fffffe          BL       rt_object_allocate
;;;948        if (event == RT_NULL)
000044  2800              CMP      r0,#0
000046  d005              BEQ      |L2.84|
;;;949            return event;
;;;950    
;;;951        /* set parent */
;;;952        event->parent.parent.flag = flag;
000048  7245              STRB     r5,[r0,#9]
00004a  f1000114          ADD      r1,r0,#0x14
00004e  6181              STR      r1,[r0,#0x18]
;;;953    
;;;954        /* init ipc object */
;;;955        rt_ipc_object_init(&(event->parent));
;;;956    
;;;957        /* init event */
;;;958        event->set = 0;
000050  61c4              STR      r4,[r0,#0x1c]
000052  6141              STR      r1,[r0,#0x14]
                  |L2.84|
;;;959    
;;;960        return event;
;;;961    }
000054  bdf8              POP      {r3-r7,pc}
;;;962    RTM_EXPORT(rt_event_create);
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      ||.constdata||+0xcc
                  |L2.92|
00005c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000060  74696f6e
000064  5b25735d
000068  20736861
00006c  6c6c206e
000070  6f742075
000074  73656420
000078  696e2049
00007c  53520a00
                  |L2.128|
000080  3000              DCB      "0",0
000082  00                DCB      0
000083  00                DCB      0
                  |L2.132|
000084  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000088  20617373
00008c  65727420
000090  6661696c
000094  65642061
000098  74202573
00009c  3a256420
0000a0  0a00    
0000a2  00                DCB      0
0000a3  00                DCB      0

                          AREA ||i.rt_event_delete||, CODE, READONLY, ALIGN=2

                  rt_event_delete PROC
;;;970     */
;;;971    rt_err_t rt_event_delete(rt_event_t event)
000000  b5f8              PUSH     {r3-r7,lr}
;;;972    {
000002  0004              MOVS     r4,r0
000004  f04f0500          MOV      r5,#0
000008  d10c              BNE      |L3.36|
;;;973        /* parameter check */
;;;974        RT_ASSERT(event != RT_NULL);
00000a  f88d5000          STRB     r5,[sp,#0]
00000e  f24033ce          MOV      r3,#0x3ce
000012  4a16              LDR      r2,|L3.108|
000014  a116              ADR      r1,|L3.112|
000016  a01b              ADR      r0,|L3.132|
000018  f7fffffe          BL       rt_kprintf
                  |L3.28|
00001c  f89d1000          LDRB     r1,[sp,#0]
000020  2900              CMP      r1,#0
000022  d0fb              BEQ      |L3.28|
                  |L3.36|
;;;975    
;;;976        RT_DEBUG_NOT_IN_INTERRUPT;
000024  f7fffffe          BL       rt_hw_interrupt_disable
000028  4606              MOV      r6,r0
00002a  f7fffffe          BL       rt_interrupt_get_nest
00002e  b180              CBZ      r0,|L3.82|
000030  490e              LDR      r1,|L3.108|
000032  a01c              ADR      r0,|L3.164|
000034  f7fffffe          BL       rt_kprintf
000038  f88d5000          STRB     r5,[sp,#0]
00003c  f44f7374          MOV      r3,#0x3d0
000040  4a0a              LDR      r2,|L3.108|
000042  a121              ADR      r1,|L3.200|
000044  a00f              ADR      r0,|L3.132|
000046  f7fffffe          BL       rt_kprintf
                  |L3.74|
00004a  f89d1000          LDRB     r1,[sp,#0]
00004e  2900              CMP      r1,#0
000050  d0fb              BEQ      |L3.74|
                  |L3.82|
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       rt_hw_interrupt_enable
;;;977    
;;;978        /* resume all suspended thread */
;;;979        rt_ipc_list_resume_all(&(event->parent.suspend_thread));
000058  f1040014          ADD      r0,r4,#0x14
00005c  f7fffffe          BL       rt_ipc_list_resume_all
;;;980    
;;;981        /* delete event object */
;;;982        rt_object_delete(&(event->parent.parent));
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       rt_object_delete
;;;983    
;;;984        return RT_EOK;
000066  2000              MOVS     r0,#0
;;;985    }
000068  bdf8              POP      {r3-r7,pc}
;;;986    RTM_EXPORT(rt_event_delete);
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      ||.constdata||+0xdc
                  |L3.112|
000070  6576656e          DCB      "event != RT_NULL",0
000074  7420213d
000078  2052545f
00007c  4e554c4c
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0
                  |L3.132|
000084  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000088  20617373
00008c  65727420
000090  6661696c
000094  65642061
000098  74202573
00009c  3a256420
0000a0  0a00    
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L3.164|
0000a4  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0000a8  74696f6e
0000ac  5b25735d
0000b0  20736861
0000b4  6c6c206e
0000b8  6f742075
0000bc  73656420
0000c0  696e2049
0000c4  53520a00
                  |L3.200|
0000c8  3000              DCB      "0",0
0000ca  00                DCB      0
0000cb  00                DCB      0

                          AREA ||i.rt_event_detach||, CODE, READONLY, ALIGN=2

                  rt_event_detach PROC
;;;915     */
;;;916    rt_err_t rt_event_detach(rt_event_t event)
000000  b538              PUSH     {r3-r5,lr}
;;;917    {
000002  0004              MOVS     r4,r0
000004  d10c              BNE      |L4.32|
;;;918        /* parameter check */
;;;919        RT_ASSERT(event != RT_NULL);
000006  f88d0000          STRB     r0,[sp,#0]
00000a  f2403397          MOV      r3,#0x397
00000e  4a09              LDR      r2,|L4.52|
000010  a109              ADR      r1,|L4.56|
000012  a00e              ADR      r0,|L4.76|
000014  f7fffffe          BL       rt_kprintf
                  |L4.24|
000018  f89d1000          LDRB     r1,[sp,#0]
00001c  2900              CMP      r1,#0
00001e  d0fb              BEQ      |L4.24|
                  |L4.32|
;;;920    
;;;921        /* resume all suspended thread */
;;;922        rt_ipc_list_resume_all(&(event->parent.suspend_thread));
000020  f1040014          ADD      r0,r4,#0x14
000024  f7fffffe          BL       rt_ipc_list_resume_all
;;;923    
;;;924        /* detach event object */
;;;925        rt_object_detach(&(event->parent.parent));
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       rt_object_detach
;;;926    
;;;927        return RT_EOK;
00002e  2000              MOVS     r0,#0
;;;928    }
000030  bd38              POP      {r3-r5,pc}
;;;929    RTM_EXPORT(rt_event_detach);
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      ||.constdata||+0xbc
                  |L4.56|
000038  6576656e          DCB      "event != RT_NULL",0
00003c  7420213d
000040  2052545f
000044  4e554c4c
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0
                  |L4.76|
00004c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000050  20617373
000054  65727420
000058  6661696c
00005c  65642061
000060  74202573
000064  3a256420
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.rt_event_init||, CODE, READONLY, ALIGN=2

                  rt_event_init PROC
;;;888     */
;;;889    rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
000000  b5f8              PUSH     {r3-r7,lr}
;;;890    {
000002  4616              MOV      r6,r2
000004  460f              MOV      r7,r1
000006  0004              MOVS     r4,r0
000008  f04f0500          MOV      r5,#0
00000c  d10c              BNE      |L5.40|
;;;891        RT_ASSERT(event != RT_NULL);
00000e  f88d5000          STRB     r5,[sp,#0]
000012  f240337b          MOV      r3,#0x37b
000016  4a0b              LDR      r2,|L5.68|
000018  a10b              ADR      r1,|L5.72|
00001a  a010              ADR      r0,|L5.92|
00001c  f7fffffe          BL       rt_kprintf
                  |L5.32|
000020  f89d0000          LDRB     r0,[sp,#0]
000024  2800              CMP      r0,#0
000026  d0fb              BEQ      |L5.32|
                  |L5.40|
;;;892    
;;;893        /* init object */
;;;894        rt_object_init(&(event->parent.parent), RT_Object_Class_Event, name);
000028  463a              MOV      r2,r7
00002a  2103              MOVS     r1,#3
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       rt_object_init
;;;895    
;;;896        /* set parent flag */
;;;897        event->parent.parent.flag = flag;
000032  7266              STRB     r6,[r4,#9]
000034  f1040014          ADD      r0,r4,#0x14
000038  61a0              STR      r0,[r4,#0x18]
;;;898    
;;;899        /* init ipc object */
;;;900        rt_ipc_object_init(&(event->parent));
;;;901    
;;;902        /* init event */
;;;903        event->set = 0;
;;;904    
;;;905        return RT_EOK;
00003a  61e5              STR      r5,[r4,#0x1c]
00003c  6160              STR      r0,[r4,#0x14]
00003e  2000              MOVS     r0,#0
;;;906    }
000040  bdf8              POP      {r3-r7,pc}
;;;907    RTM_EXPORT(rt_event_init);
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      ||.constdata||+0xae
                  |L5.72|
000048  6576656e          DCB      "event != RT_NULL",0
00004c  7420213d
000050  2052545f
000054  4e554c4c
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L5.92|
00005c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000060  20617373
000064  65727420
000068  6661696c
00006c  65642061
000070  74202573
000074  3a256420
000078  0a00    
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.rt_event_recv||, CODE, READONLY, ALIGN=2

                  rt_event_recv PROC
;;;1092    */
;;;1093   rt_err_t rt_event_recv(rt_event_t   event,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1094                          rt_uint32_t  set,
;;;1095                          rt_uint8_t   option,
;;;1096                          rt_int32_t   timeout,
;;;1097                          rt_uint32_t *recved)
;;;1098   {
000004  b081              SUB      sp,sp,#4
000006  4617              MOV      r7,r2
000008  460e              MOV      r6,r1
00000a  4605              MOV      r5,r0
;;;1099       struct rt_thread *thread;
;;;1100       register rt_ubase_t level;
;;;1101       register rt_base_t status;
;;;1102   
;;;1103       RT_DEBUG_IN_THREAD_CONTEXT;
00000c  f8dda038          LDR      r10,[sp,#0x38]
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  4683              MOV      r11,r0
000016  f7fffffe          BL       rt_thread_self
00001a  f240444f          MOV      r4,#0x44f
00001e  f04f0800          MOV      r8,#0
000022  b978              CBNZ     r0,|L6.68|
000024  4954              LDR      r1,|L6.376|
000026  a055              ADR      r0,|L6.380|
000028  f7fffffe          BL       rt_kprintf
00002c  f88d8000          STRB     r8,[sp,#0]
000030  4623              MOV      r3,r4
000032  4a51              LDR      r2,|L6.376|
000034  a15f              ADR      r1,|L6.436|
000036  a060              ADR      r0,|L6.440|
000038  f7fffffe          BL       rt_kprintf
                  |L6.60|
00003c  f89d0000          LDRB     r0,[sp,#0]
000040  2800              CMP      r0,#0
000042  d0fb              BEQ      |L6.60|
                  |L6.68|
000044  f7fffffe          BL       rt_hw_interrupt_disable
000048  4681              MOV      r9,r0
00004a  f7fffffe          BL       rt_interrupt_get_nest
00004e  b178              CBZ      r0,|L6.112|
000050  4949              LDR      r1,|L6.376|
000052  a061              ADR      r0,|L6.472|
000054  f7fffffe          BL       rt_kprintf
000058  f88d8000          STRB     r8,[sp,#0]
00005c  4623              MOV      r3,r4
00005e  4a46              LDR      r2,|L6.376|
000060  a154              ADR      r1,|L6.436|
000062  a055              ADR      r0,|L6.440|
000064  f7fffffe          BL       rt_kprintf
                  |L6.104|
000068  f89d0000          LDRB     r0,[sp,#0]
00006c  2800              CMP      r0,#0
00006e  d0fb              BEQ      |L6.104|
                  |L6.112|
000070  4648              MOV      r0,r9
000072  f7fffffe          BL       rt_hw_interrupt_enable
000076  4658              MOV      r0,r11
000078  f7fffffe          BL       rt_hw_interrupt_enable
;;;1104   
;;;1105       /* parameter check */
;;;1106       RT_ASSERT(event != RT_NULL);
00007c  b965              CBNZ     r5,|L6.152|
00007e  f88d8000          STRB     r8,[sp,#0]
000082  f2404352          MOV      r3,#0x452
000086  4a3c              LDR      r2,|L6.376|
000088  a15c              ADR      r1,|L6.508|
00008a  a04b              ADR      r0,|L6.440|
00008c  f7fffffe          BL       rt_kprintf
                  |L6.144|
000090  f89d0000          LDRB     r0,[sp,#0]
000094  2800              CMP      r0,#0
000096  d0fb              BEQ      |L6.144|
                  |L6.152|
;;;1107       if (set == 0)
;;;1108           return -RT_ERROR;
000098  f04f30ff          MOV      r0,#0xffffffff
00009c  2e00              CMP      r6,#0                 ;1107
00009e  d059              BEQ      |L6.340|
;;;1109   
;;;1110       /* init status */
;;;1111       status = -RT_ERROR;
0000a0  4681              MOV      r9,r0
;;;1112       /* get current thread */
;;;1113       thread = rt_thread_self();
0000a2  f7fffffe          BL       rt_thread_self
0000a6  4604              MOV      r4,r0
;;;1114       /* reset thread error */
;;;1115       thread->error = RT_EOK;
;;;1116   
;;;1117       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(event->parent.parent)));
0000a8  f8c08030          STR      r8,[r0,#0x30]
0000ac  4858              LDR      r0,|L6.528|
0000ae  6801              LDR      r1,[r0,#0]  ; rt_object_trytake_hook
0000b0  b109              CBZ      r1,|L6.182|
0000b2  4628              MOV      r0,r5
0000b4  4788              BLX      r1
                  |L6.182|
;;;1118   
;;;1119       /* disable interrupt */
;;;1120       level = rt_hw_interrupt_disable();
0000b6  f7fffffe          BL       rt_hw_interrupt_disable
0000ba  4683              MOV      r11,r0
;;;1121   
;;;1122       /* check event set */
;;;1123       if (option & RT_EVENT_FLAG_AND)
0000bc  07f8              LSLS     r0,r7,#31
0000be  d004              BEQ      |L6.202|
;;;1124       {
;;;1125           if ((event->set & set) == set)
0000c0  69e8              LDR      r0,[r5,#0x1c]
0000c2  ea360000          BICS     r0,r6,r0
0000c6  d049              BEQ      |L6.348|
0000c8  e015              B        |L6.246|
                  |L6.202|
;;;1126               status = RT_EOK;
;;;1127       }
;;;1128       else if (option & RT_EVENT_FLAG_OR)
0000ca  07b8              LSLS     r0,r7,#30
0000cc  d503              BPL      |L6.214|
;;;1129       {
;;;1130           if (event->set & set)
0000ce  69e8              LDR      r0,[r5,#0x1c]
0000d0  4230              TST      r0,r6
0000d2  d143              BNE      |L6.348|
0000d4  e00f              B        |L6.246|
                  |L6.214|
;;;1131               status = RT_EOK;
;;;1132       }
;;;1133       else
;;;1134       {
;;;1135           /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */
;;;1136           RT_ASSERT(0);
0000d6  f88d8000          STRB     r8,[sp,#0]
0000da  f44f638e          MOV      r3,#0x470
0000de  4a26              LDR      r2,|L6.376|
0000e0  a134              ADR      r1,|L6.436|
0000e2  a035              ADR      r0,|L6.440|
0000e4  f7fffffe          BL       rt_kprintf
                  |L6.232|
0000e8  f89d0000          LDRB     r0,[sp,#0]
0000ec  2800              CMP      r0,#0
0000ee  d0fb              BEQ      |L6.232|
;;;1137       }
;;;1138   
;;;1139       if (status == RT_EOK)
0000f0  f1b90f00          CMP      r9,#0
0000f4  d032              BEQ      |L6.348|
                  |L6.246|
;;;1140       {
;;;1141           /* set received event */
;;;1142           *recved = (event->set & set);
;;;1143   
;;;1144           /* received event */
;;;1145           if (option & RT_EVENT_FLAG_CLEAR)
;;;1146               event->set &= ~set;
;;;1147       }
;;;1148       else if (timeout == 0)
0000f6  9804              LDR      r0,[sp,#0x10]
0000f8  b378              CBZ      r0,|L6.346|
;;;1149       {
;;;1150           /* no waiting */
;;;1151           thread->error = -RT_ETIMEOUT;
;;;1152       }
;;;1153       else
;;;1154       {
;;;1155           /* fill thread event info */
;;;1156           thread->event_set  = set;
;;;1157           thread->event_info = option;
0000fa  63e6              STR      r6,[r4,#0x3c]
0000fc  f8847040          STRB     r7,[r4,#0x40]
;;;1158   
;;;1159           /* put thread to suspended thread list */
;;;1160           rt_ipc_list_suspend(&(event->parent.suspend_thread),
000100  7a6a              LDRB     r2,[r5,#9]
000102  4621              MOV      r1,r4
000104  f1050014          ADD      r0,r5,#0x14
000108  f7fffffe          BL       rt_ipc_list_suspend
;;;1161                               thread,
;;;1162                               event->parent.parent.flag);
;;;1163   
;;;1164           /* if there is a waiting timeout, active thread timer */
;;;1165           if (timeout > 0)
00010c  9804              LDR      r0,[sp,#0x10]
00010e  2800              CMP      r0,#0
000110  dd09              BLE      |L6.294|
;;;1166           {
;;;1167               /* reset the timeout of thread timer and start it */
;;;1168               rt_timer_control(&(thread->thread_timer),
000112  f104004c          ADD      r0,r4,#0x4c
000116  aa04              ADD      r2,sp,#0x10
000118  2100              MOVS     r1,#0
00011a  4606              MOV      r6,r0
00011c  f7fffffe          BL       rt_timer_control
000120  4630              MOV      r0,r6
;;;1169                                RT_TIMER_CTRL_SET_TIME,
;;;1170                                &timeout);
;;;1171               rt_timer_start(&(thread->thread_timer));
000122  f7fffffe          BL       rt_timer_start
                  |L6.294|
;;;1172           }
;;;1173   
;;;1174           /* enable interrupt */
;;;1175           rt_hw_interrupt_enable(level);
000126  4658              MOV      r0,r11
000128  f7fffffe          BL       rt_hw_interrupt_enable
;;;1176   
;;;1177           /* do a schedule */
;;;1178           rt_schedule();
00012c  f7fffffe          BL       rt_schedule
;;;1179   
;;;1180           if (thread->error != RT_EOK)
000130  6b20              LDR      r0,[r4,#0x30]
000132  2800              CMP      r0,#0
000134  d10e              BNE      |L6.340|
;;;1181           {
;;;1182               /* return error */
;;;1183               return thread->error;
;;;1184           }
;;;1185   
;;;1186           /* received an event, disable interrupt to protect */
;;;1187           level = rt_hw_interrupt_disable();
000136  f7fffffe          BL       rt_hw_interrupt_disable
;;;1188   
;;;1189           /* set received event */
;;;1190           *recved = thread->event_set;
00013a  6be1              LDR      r1,[r4,#0x3c]
00013c  4683              MOV      r11,r0                ;1187
00013e  f8ca1000          STR      r1,[r10,#0]
                  |L6.322|
;;;1191       }
;;;1192   
;;;1193       /* enable interrupt */
;;;1194       rt_hw_interrupt_enable(level);
000142  4658              MOV      r0,r11
000144  f7fffffe          BL       rt_hw_interrupt_enable
;;;1195   
;;;1196       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(event->parent.parent)));
000148  4832              LDR      r0,|L6.532|
00014a  6801              LDR      r1,[r0,#0]  ; rt_object_take_hook
00014c  b109              CBZ      r1,|L6.338|
00014e  4628              MOV      r0,r5
000150  4788              BLX      r1
                  |L6.338|
;;;1197   
;;;1198       return thread->error;
000152  6b20              LDR      r0,[r4,#0x30]
                  |L6.340|
;;;1199   }
000154  b005              ADD      sp,sp,#0x14
000156  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.346|
00015a  e009              B        |L6.368|
                  |L6.348|
00015c  69e8              LDR      r0,[r5,#0x1c]         ;1142
00015e  4030              ANDS     r0,r0,r6              ;1142
000160  f8ca0000          STR      r0,[r10,#0]           ;1145
000164  0778              LSLS     r0,r7,#29             ;1145
000166  d5ec              BPL      |L6.322|
000168  69e8              LDR      r0,[r5,#0x1c]         ;1146
00016a  43b0              BICS     r0,r0,r6              ;1146
00016c  61e8              STR      r0,[r5,#0x1c]         ;1146
00016e  e7e8              B        |L6.322|
                  |L6.368|
000170  f06f0001          MVN      r0,#1                 ;1151
000174  6320              STR      r0,[r4,#0x30]         ;1151
000176  e7e4              B        |L6.322|
;;;1200   RTM_EXPORT(rt_event_recv);
                          ENDP

                  |L6.376|
                          DCD      ||.constdata||+0xfa
                  |L6.380|
00017c  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
000180  74696f6e
000184  5b25735d
000188  20736861
00018c  6c6c206e
000190  6f742062
000194  65207573
000198  65642062
00019c  65666f72
0001a0  65207363
0001a4  68656475
0001a8  6c657220
0001ac  73746172
0001b0  740a    
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L6.436|
0001b4  3000              DCB      "0",0
0001b6  00                DCB      0
0001b7  00                DCB      0
                  |L6.440|
0001b8  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0001bc  20617373
0001c0  65727420
0001c4  6661696c
0001c8  65642061
0001cc  74202573
0001d0  3a256420
0001d4  0a00    
0001d6  00                DCB      0
0001d7  00                DCB      0
                  |L6.472|
0001d8  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0001dc  74696f6e
0001e0  5b25735d
0001e4  20736861
0001e8  6c6c206e
0001ec  6f742075
0001f0  73656420
0001f4  696e2049
0001f8  53520a00
                  |L6.508|
0001fc  6576656e          DCB      "event != RT_NULL",0
000200  7420213d
000204  2052545f
000208  4e554c4c
00020c  00      
00020d  00                DCB      0
00020e  00                DCB      0
00020f  00                DCB      0
                  |L6.528|
                          DCD      rt_object_trytake_hook
                  |L6.532|
                          DCD      rt_object_take_hook

                          AREA ||i.rt_event_send||, CODE, READONLY, ALIGN=2

                  rt_event_send PROC
;;;997     */
;;;998    rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;999    {
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d10c              BNE      |L7.36|
;;;1000       struct rt_list_node *n;
;;;1001       struct rt_thread *thread;
;;;1002       register rt_ubase_t level;
;;;1003       register rt_base_t status;
;;;1004       rt_bool_t need_schedule;
;;;1005   
;;;1006       /* parameter check */
;;;1007       RT_ASSERT(event != RT_NULL);
00000a  f88d0000          STRB     r0,[sp,#0]
00000e  f24033ef          MOV      r3,#0x3ef
000012  4a28              LDR      r2,|L7.180|
000014  a128              ADR      r1,|L7.184|
000016  a02d              ADR      r0,|L7.204|
000018  f7fffffe          BL       rt_kprintf
                  |L7.28|
00001c  f89d0000          LDRB     r0,[sp,#0]
000020  2800              CMP      r0,#0
000022  d0fb              BEQ      |L7.28|
                  |L7.36|
;;;1008       if (set == 0)
;;;1009           return -RT_ERROR;
000024  f04f37ff          MOV      r7,#0xffffffff
000028  b195              CBZ      r5,|L7.80|
;;;1010   
;;;1011       need_schedule = RT_FALSE;
;;;1012       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(event->parent.parent)));
00002a  4830              LDR      r0,|L7.236|
00002c  2600              MOVS     r6,#0                 ;1011
00002e  6801              LDR      r1,[r0,#0]  ; rt_object_put_hook
000030  b109              CBZ      r1,|L7.54|
000032  4620              MOV      r0,r4
000034  4788              BLX      r1
                  |L7.54|
;;;1013   
;;;1014       /* disable interrupt */
;;;1015       level = rt_hw_interrupt_disable();
000036  f7fffffe          BL       rt_hw_interrupt_disable
00003a  4681              MOV      r9,r0
;;;1016   
;;;1017       /* set event */
;;;1018       event->set |= set;
00003c  69e0              LDR      r0,[r4,#0x1c]
00003e  4328              ORRS     r0,r0,r5
;;;1019   
;;;1020       if (!rt_list_isempty(&event->parent.suspend_thread))
000040  61e0              STR      r0,[r4,#0x1c]
000042  f1040014          ADD      r0,r4,#0x14
000046  4680              MOV      r8,r0
000048  f7fffffe          BL       rt_list_isempty
00004c  b118              CBZ      r0,|L7.86|
00004e  e028              B        |L7.162|
                  |L7.80|
000050  4638              MOV      r0,r7                 ;1009
                  |L7.82|
;;;1021       {
;;;1022           /* search thread list to resume thread */
;;;1023           n = event->parent.suspend_thread.next;
;;;1024           while (n != &(event->parent.suspend_thread))
;;;1025           {
;;;1026               /* get thread */
;;;1027               thread = rt_list_entry(n, struct rt_thread, tlist);
;;;1028   
;;;1029               status = -RT_ERROR;
;;;1030               if (thread->event_info & RT_EVENT_FLAG_AND)
;;;1031               {
;;;1032                   if ((thread->event_set & event->set) == thread->event_set)
;;;1033                   {
;;;1034                       /* received an AND event */
;;;1035                       status = RT_EOK;
;;;1036                   }
;;;1037               }
;;;1038               else if (thread->event_info & RT_EVENT_FLAG_OR)
;;;1039               {
;;;1040                   if (thread->event_set & event->set)
;;;1041                   {
;;;1042                       /* save recieved event set */
;;;1043                       thread->event_set = thread->event_set & event->set;
;;;1044   
;;;1045                       /* received an OR event */
;;;1046                       status = RT_EOK;
;;;1047                   }
;;;1048               }
;;;1049   
;;;1050               /* move node to the next */
;;;1051               n = n->next;
;;;1052   
;;;1053               /* condition is satisfied, resume thread */
;;;1054               if (status == RT_EOK)
;;;1055               {
;;;1056                   /* clear event */
;;;1057                   if (thread->event_info & RT_EVENT_FLAG_CLEAR)
;;;1058                       event->set &= ~thread->event_set;
;;;1059   
;;;1060                   /* resume thread, and thread list breaks out */
;;;1061                   rt_thread_resume(thread);
;;;1062   
;;;1063                   /* need do a scheduling */
;;;1064                   need_schedule = RT_TRUE;
;;;1065               }
;;;1066           }
;;;1067       }
;;;1068   
;;;1069       /* enable interrupt */
;;;1070       rt_hw_interrupt_enable(level);
;;;1071   
;;;1072       /* do a schedule */
;;;1073       if (need_schedule == RT_TRUE)
;;;1074           rt_schedule();
;;;1075   
;;;1076       return RT_EOK;
;;;1077   }
000052  e8bd83f8          POP      {r3-r9,pc}
                  |L7.86|
000056  6965              LDR      r5,[r4,#0x14]         ;1024
000058  e021              B        |L7.158|
                  |L7.90|
00005a  f895202c          LDRB     r2,[r5,#0x2c]         ;1030
00005e  f1a50014          SUB      r0,r5,#0x14           ;1027
000062  4639              MOV      r1,r7                 ;1029
000064  07d3              LSLS     r3,r2,#31             ;1030
000066  d005              BEQ      |L7.116|
000068  6bc2              LDR      r2,[r0,#0x3c]         ;1032
00006a  69e3              LDR      r3,[r4,#0x1c]         ;1032
00006c  439a              BICS     r2,r2,r3              ;1032
00006e  d109              BNE      |L7.132|
                  |L7.112|
000070  2100              MOVS     r1,#0                 ;1035
000072  e007              B        |L7.132|
                  |L7.116|
000074  0792              LSLS     r2,r2,#30             ;1038
000076  d505              BPL      |L7.132|
000078  6bc2              LDR      r2,[r0,#0x3c]         ;1040
00007a  69e3              LDR      r3,[r4,#0x1c]         ;1040
00007c  401a              ANDS     r2,r2,r3              ;1040
00007e  d001              BEQ      |L7.132|
000080  63c2              STR      r2,[r0,#0x3c]         ;1046
000082  e7f5              B        |L7.112|
                  |L7.132|
000084  682d              LDR      r5,[r5,#0]            ;1051
000086  b951              CBNZ     r1,|L7.158|
000088  f8901040          LDRB     r1,[r0,#0x40]         ;1057
00008c  0749              LSLS     r1,r1,#29             ;1057
00008e  d503              BPL      |L7.152|
000090  69e1              LDR      r1,[r4,#0x1c]         ;1058
000092  6bc2              LDR      r2,[r0,#0x3c]         ;1058
000094  4391              BICS     r1,r1,r2              ;1058
000096  61e1              STR      r1,[r4,#0x1c]         ;1058
                  |L7.152|
000098  f7fffffe          BL       rt_thread_resume
00009c  2601              MOVS     r6,#1                 ;1064
                  |L7.158|
00009e  4545              CMP      r5,r8                 ;1024
0000a0  d1db              BNE      |L7.90|
                  |L7.162|
0000a2  4648              MOV      r0,r9                 ;1070
0000a4  f7fffffe          BL       rt_hw_interrupt_enable
0000a8  b10e              CBZ      r6,|L7.174|
0000aa  f7fffffe          BL       rt_schedule
                  |L7.174|
0000ae  2000              MOVS     r0,#0                 ;1076
0000b0  e7cf              B        |L7.82|
;;;1078   RTM_EXPORT(rt_event_send);
                          ENDP

0000b2  0000              DCW      0x0000
                  |L7.180|
                          DCD      ||.constdata||+0xec
                  |L7.184|
0000b8  6576656e          DCB      "event != RT_NULL",0
0000bc  7420213d
0000c0  2052545f
0000c4  4e554c4c
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L7.204|
0000cc  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000d0  20617373
0000d4  65727420
0000d8  6661696c
0000dc  65642061
0000e0  74202573
0000e4  3a256420
0000e8  0a00    
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L7.236|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_ipc_list_resume||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_resume PROC
;;;145     */
;;;146    rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
000000  b510              PUSH     {r4,lr}
;;;147    {
;;;148        struct rt_thread *thread;
;;;149    
;;;150        /* get thread entry */
;;;151        thread = rt_list_entry(list->next, struct rt_thread, tlist);
000002  6800              LDR      r0,[r0,#0]
000004  3814              SUBS     r0,r0,#0x14
;;;152    
;;;153        RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));
;;;154    
;;;155        /* resume it */
;;;156        rt_thread_resume(thread);
000006  f7fffffe          BL       rt_thread_resume
;;;157    
;;;158        return RT_EOK;
00000a  2000              MOVS     r0,#0
;;;159    }
00000c  bd10              POP      {r4,pc}
;;;160    
                          ENDP


                          AREA ||i.rt_ipc_list_resume_all||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_resume_all PROC
;;;168     */
;;;169    rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
000000  b570              PUSH     {r4-r6,lr}
;;;170    {
000002  4605              MOV      r5,r0
;;;171        struct rt_thread *thread;
;;;172        register rt_ubase_t temp;
;;;173    
;;;174        /* wakeup all suspend threads */
;;;175        while (!rt_list_isempty(list))
;;;176        {
;;;177            /* disable interrupt */
;;;178            temp = rt_hw_interrupt_disable();
;;;179    
;;;180            /* get next suspend thread */
;;;181            thread = rt_list_entry(list->next, struct rt_thread, tlist);
;;;182            /* set error code to RT_ERROR */
;;;183            thread->error = -RT_ERROR;
000004  f04f36ff          MOV      r6,#0xffffffff
000008  e00a              B        |L9.32|
                  |L9.10|
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4604              MOV      r4,r0                 ;178
000010  6828              LDR      r0,[r5,#0]
000012  61c6              STR      r6,[r0,#0x1c]
000014  3814              SUBS     r0,r0,#0x14
;;;184    
;;;185            /*
;;;186             * resume thread
;;;187             * In rt_thread_resume function, it will remove current thread from
;;;188             * suspend list
;;;189             */
;;;190            rt_thread_resume(thread);
000016  f7fffffe          BL       rt_thread_resume
;;;191    
;;;192            /* enable interrupt */
;;;193            rt_hw_interrupt_enable(temp);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_hw_interrupt_enable
                  |L9.32|
000020  4628              MOV      r0,r5                 ;175
000022  f7fffffe          BL       rt_list_isempty
000026  2800              CMP      r0,#0                 ;175
000028  d0ef              BEQ      |L9.10|
;;;194        }
;;;195    
;;;196        return RT_EOK;
00002a  2000              MOVS     r0,#0
;;;197    }
00002c  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP


                          AREA ||i.rt_ipc_list_suspend||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_suspend PROC
;;;91      */
;;;92     rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;93                                            struct rt_thread *thread,
;;;94                                            rt_uint8_t        flag)
;;;95     {
000004  4605              MOV      r5,r0
000006  4614              MOV      r4,r2
000008  460e              MOV      r6,r1
;;;96         /* suspend thread */
;;;97         rt_thread_suspend(thread);
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       rt_thread_suspend
;;;98     
;;;99         switch (flag)
;;;100        {
;;;101        case RT_IPC_FLAG_FIFO:
;;;102            rt_list_insert_before(list, &(thread->tlist));
000010  f1060714          ADD      r7,r6,#0x14
000014  b1ac              CBZ      r4,|L10.66|
000016  2c01              CMP      r4,#1                 ;99
000018  d117              BNE      |L10.74|
;;;103            break;
;;;104    
;;;105        case RT_IPC_FLAG_PRIO:
;;;106            {
;;;107                struct rt_list_node *n;
;;;108                struct rt_thread *sthread;
;;;109    
;;;110                /* find a suitable position */
;;;111                for (n = list->next; n != list; n = n->next)
00001a  682c              LDR      r4,[r5,#0]
00001c  e00d              B        |L10.58|
                  |L10.30|
;;;112                {
;;;113                    sthread = rt_list_entry(n, struct rt_thread, tlist);
;;;114    
;;;115                    /* find out */
;;;116                    if (thread->current_priority < sthread->current_priority)
00001e  f8961035          LDRB     r1,[r6,#0x35]
000022  f8942021          LDRB     r2,[r4,#0x21]
000026  f1a40014          SUB      r0,r4,#0x14           ;113
00002a  4291              CMP      r1,r2
00002c  d204              BCS      |L10.56|
00002e  4639              MOV      r1,r7
000030  3014              ADDS     r0,r0,#0x14
;;;117                    {
;;;118                        /* insert this thread before the sthread */
;;;119                        rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
000032  f7fffffe          BL       rt_list_insert_before
;;;120                        break;
000036  e002              B        |L10.62|
                  |L10.56|
000038  6824              LDR      r4,[r4,#0]            ;111
                  |L10.58|
00003a  42ac              CMP      r4,r5                 ;111
00003c  d1ef              BNE      |L10.30|
                  |L10.62|
;;;121                    }
;;;122                }
;;;123    
;;;124                /*
;;;125                 * not found a suitable position,
;;;126                 * append to the end of suspend_thread list
;;;127                 */
;;;128                if (n == list)
00003e  42ac              CMP      r4,r5
000040  d103              BNE      |L10.74|
                  |L10.66|
000042  4639              MOV      r1,r7
;;;129                    rt_list_insert_before(list, &(thread->tlist));
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       rt_list_insert_before
                  |L10.74|
;;;130            }
;;;131            break;
;;;132        }
;;;133    
;;;134        return RT_EOK;
00004a  2000              MOVS     r0,#0
;;;135    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;136    
                          ENDP


                          AREA ||i.rt_list_insert_before||, CODE, READONLY, ALIGN=1

                  rt_list_insert_before PROC
;;;76      */
;;;77     rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
000000  6842              LDR      r2,[r0,#4]
;;;78     {
;;;79         l->prev->next = n;
;;;80         n->prev = l->prev;
000002  6011              STR      r1,[r2,#0]
000004  6842              LDR      r2,[r0,#4]
;;;81     
;;;82         l->prev = n;
000006  604a              STR      r2,[r1,#4]
;;;83         n->next = l;
000008  6041              STR      r1,[r0,#4]
00000a  6008              STR      r0,[r1,#0]
;;;84     }
00000c  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;101     */
;;;102    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  6801              LDR      r1,[r0,#0]
;;;103    {
;;;104        return l->next == l;
000002  4281              CMP      r1,r0
000004  d101              BNE      |L12.10|
000006  2001              MOVS     r0,#1
;;;105    }
000008  4770              BX       lr
                  |L12.10|
00000a  2000              MOVS     r0,#0                 ;104
00000c  4770              BX       lr
;;;106    
                          ENDP


                          AREA ||i.rt_mb_control||, CODE, READONLY, ALIGN=2

                  rt_mb_control PROC
;;;1685    */
;;;1686   rt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1687   {
000002  460e              MOV      r6,r1
000004  0004              MOVS     r4,r0
000006  f04f0500          MOV      r5,#0
00000a  d10c              BNE      |L13.38|
;;;1688       rt_ubase_t level;
;;;1689       RT_ASSERT(mb != RT_NULL);
00000c  f88d5000          STRB     r5,[sp,#0]
000010  f2406399          MOV      r3,#0x699
000014  4a11              LDR      r2,|L13.92|
000016  a112              ADR      r1,|L13.96|
000018  a015              ADR      r0,|L13.112|
00001a  f7fffffe          BL       rt_kprintf
                  |L13.30|
00001e  f89d0000          LDRB     r0,[sp,#0]
000022  2800              CMP      r0,#0
000024  d0fb              BEQ      |L13.30|
                  |L13.38|
;;;1690   
;;;1691       if (cmd == RT_IPC_CMD_RESET)
000026  2e01              CMP      r6,#1
000028  d002              BEQ      |L13.48|
;;;1692       {
;;;1693           /* disable interrupt */
;;;1694           level = rt_hw_interrupt_disable();
;;;1695   
;;;1696           /* resume all waiting thread */
;;;1697           rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
;;;1698           /* also resume all mailbox private suspended thread */
;;;1699           rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
;;;1700   
;;;1701           /* re-init mailbox */
;;;1702           mb->entry      = 0;
;;;1703           mb->in_offset  = 0;
;;;1704           mb->out_offset = 0;
;;;1705   
;;;1706           /* enable interrupt */
;;;1707           rt_hw_interrupt_enable(level);
;;;1708   
;;;1709           rt_schedule();
;;;1710   
;;;1711           return RT_EOK;
;;;1712       }
;;;1713   
;;;1714       return -RT_ERROR;
00002a  f04f30ff          MOV      r0,#0xffffffff
;;;1715   }
00002e  bdf8              POP      {r3-r7,pc}
                  |L13.48|
000030  f7fffffe          BL       rt_hw_interrupt_disable
000034  4606              MOV      r6,r0                 ;1694
000036  f1040014          ADD      r0,r4,#0x14           ;1697
00003a  f7fffffe          BL       rt_ipc_list_resume_all
00003e  f1040028          ADD      r0,r4,#0x28           ;1699
000042  f7fffffe          BL       rt_ipc_list_resume_all
000046  8465              STRH     r5,[r4,#0x22]         ;1702
000048  84a5              STRH     r5,[r4,#0x24]         ;1703
00004a  84e5              STRH     r5,[r4,#0x26]         ;1704
00004c  4630              MOV      r0,r6                 ;1707
00004e  f7fffffe          BL       rt_hw_interrupt_enable
000052  f7fffffe          BL       rt_schedule
000056  2000              MOVS     r0,#0                 ;1711
000058  bdf8              POP      {r3-r7,pc}
;;;1716   RTM_EXPORT(rt_mb_control);
                          ENDP

00005a  0000              DCW      0x0000
                  |L13.92|
                          DCD      ||.constdata||+0x166
                  |L13.96|
000060  6d622021          DCB      "mb != RT_NULL",0
000064  3d205254
000068  5f4e554c
00006c  4c00    
00006e  00                DCB      0
00006f  00                DCB      0
                  |L13.112|
000070  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000074  20617373
000078  65727420
00007c  6661696c
000080  65642061
000084  74202573
000088  3a256420
00008c  0a00    
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.rt_mb_create||, CODE, READONLY, ALIGN=2

                  rt_mb_create PROC
;;;1317    */
;;;1318   rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1319   {
000004  4617              MOV      r7,r2
000006  460e              MOV      r6,r1
000008  4604              MOV      r4,r0
;;;1320       rt_mailbox_t mb;
;;;1321   
;;;1322       RT_DEBUG_NOT_IN_INTERRUPT;
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4680              MOV      r8,r0
000010  f7fffffe          BL       rt_interrupt_get_nest
000014  2500              MOVS     r5,#0
000016  b180              CBZ      r0,|L14.58|
000018  491a              LDR      r1,|L14.132|
00001a  a01b              ADR      r0,|L14.136|
00001c  f7fffffe          BL       rt_kprintf
000020  f88d5000          STRB     r5,[sp,#0]
000024  f240532a          MOV      r3,#0x52a
000028  4a16              LDR      r2,|L14.132|
00002a  a120              ADR      r1,|L14.172|
00002c  a020              ADR      r0,|L14.176|
00002e  f7fffffe          BL       rt_kprintf
                  |L14.50|
000032  f89d0000          LDRB     r0,[sp,#0]
000036  2800              CMP      r0,#0
000038  d0fb              BEQ      |L14.50|
                  |L14.58|
00003a  4640              MOV      r0,r8
00003c  f7fffffe          BL       rt_hw_interrupt_enable
;;;1323   
;;;1324       /* allocate object */
;;;1325       mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
000040  4621              MOV      r1,r4
000042  2004              MOVS     r0,#4
000044  f7fffffe          BL       rt_object_allocate
000048  0004              MOVS     r4,r0
;;;1326       if (mb == RT_NULL)
00004a  d013              BEQ      |L14.116|
;;;1327           return mb;
;;;1328   
;;;1329       /* set parent */
;;;1330       mb->parent.parent.flag = flag;
00004c  7267              STRB     r7,[r4,#9]
00004e  f1040014          ADD      r0,r4,#0x14
000052  61a0              STR      r0,[r4,#0x18]
;;;1331   
;;;1332       /* init ipc object */
;;;1333       rt_ipc_object_init(&(mb->parent));
;;;1334   
;;;1335       /* init mailbox */
;;;1336       mb->size     = size;
000054  6160              STR      r0,[r4,#0x14]
000056  b2b0              UXTH     r0,r6
000058  8420              STRH     r0,[r4,#0x20]
;;;1337       mb->msg_pool = RT_KERNEL_MALLOC(mb->size * sizeof(rt_uint32_t));
00005a  0080              LSLS     r0,r0,#2
00005c  f7fffffe          BL       rt_malloc
;;;1338       if (mb->msg_pool == RT_NULL)
000060  61e0              STR      r0,[r4,#0x1c]
000062  b148              CBZ      r0,|L14.120|
;;;1339       {
;;;1340           /* delete mailbox object */
;;;1341           rt_object_delete(&(mb->parent.parent));
;;;1342   
;;;1343           return RT_NULL;
;;;1344       }
;;;1345       mb->entry      = 0;
000064  8465              STRH     r5,[r4,#0x22]
;;;1346       mb->in_offset  = 0;
000066  84a5              STRH     r5,[r4,#0x24]
;;;1347       mb->out_offset = 0;
000068  84e5              STRH     r5,[r4,#0x26]
;;;1348   
;;;1349       /* init an additional list of sender suspend thread */
;;;1350       rt_list_init(&(mb->suspend_sender_thread));
00006a  f1040028          ADD      r0,r4,#0x28
00006e  62e0              STR      r0,[r4,#0x2c]
;;;1351   
;;;1352       return mb;
000070  62a0              STR      r0,[r4,#0x28]
000072  4620              MOV      r0,r4
                  |L14.116|
;;;1353   }
000074  e8bd83f8          POP      {r3-r9,pc}
                  |L14.120|
000078  4620              MOV      r0,r4                 ;1341
00007a  f7fffffe          BL       rt_object_delete
00007e  2000              MOVS     r0,#0                 ;1343
000080  e7f8              B        |L14.116|
;;;1354   RTM_EXPORT(rt_mb_create);
                          ENDP

000082  0000              DCW      0x0000
                  |L14.132|
                          DCD      ||.constdata||+0x131
                  |L14.136|
000088  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00008c  74696f6e
000090  5b25735d
000094  20736861
000098  6c6c206e
00009c  6f742075
0000a0  73656420
0000a4  696e2049
0000a8  53520a00
                  |L14.172|
0000ac  3000              DCB      "0",0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L14.176|
0000b0  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000b4  20617373
0000b8  65727420
0000bc  6661696c
0000c0  65642061
0000c4  74202573
0000c8  3a256420
0000cc  0a00    
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||i.rt_mb_delete||, CODE, READONLY, ALIGN=2

                  rt_mb_delete PROC
;;;1362    */
;;;1363   rt_err_t rt_mb_delete(rt_mailbox_t mb)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1364   {
000002  4604              MOV      r4,r0
;;;1365       RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4606              MOV      r6,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2500              MOVS     r5,#0
000010  b180              CBZ      r0,|L15.52|
000012  4919              LDR      r1,|L15.120|
000014  a019              ADR      r0,|L15.124|
000016  f7fffffe          BL       rt_kprintf
00001a  f88d5000          STRB     r5,[sp,#0]
00001e  f2405355          MOV      r3,#0x555
000022  4a15              LDR      r2,|L15.120|
000024  a11e              ADR      r1,|L15.160|
000026  a01f              ADR      r0,|L15.164|
000028  f7fffffe          BL       rt_kprintf
                  |L15.44|
00002c  f89d0000          LDRB     r0,[sp,#0]
000030  2800              CMP      r0,#0
000032  d0fb              BEQ      |L15.44|
                  |L15.52|
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       rt_hw_interrupt_enable
;;;1366   
;;;1367       /* parameter check */
;;;1368       RT_ASSERT(mb != RT_NULL);
00003a  b964              CBNZ     r4,|L15.86|
00003c  f88d5000          STRB     r5,[sp,#0]
000040  f44f63ab          MOV      r3,#0x558
000044  4a0c              LDR      r2,|L15.120|
000046  a11f              ADR      r1,|L15.196|
000048  a016              ADR      r0,|L15.164|
00004a  f7fffffe          BL       rt_kprintf
                  |L15.78|
00004e  f89d0000          LDRB     r0,[sp,#0]
000052  2800              CMP      r0,#0
000054  d0fb              BEQ      |L15.78|
                  |L15.86|
;;;1369   
;;;1370       /* resume all suspended thread */
;;;1371       rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
000056  f1040014          ADD      r0,r4,#0x14
00005a  f7fffffe          BL       rt_ipc_list_resume_all
;;;1372   
;;;1373       /* also resume all mailbox private suspended thread */
;;;1374       rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
00005e  f1040028          ADD      r0,r4,#0x28
000062  f7fffffe          BL       rt_ipc_list_resume_all
;;;1375   
;;;1376   #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;1377       /* the mb object belongs to an application module */
;;;1378       if (mb->parent.parent.flag & RT_OBJECT_FLAG_MODULE)
;;;1379           rt_module_free(mb->parent.parent.module_id, mb->msg_pool);
;;;1380       else
;;;1381   #endif
;;;1382   
;;;1383       /* free mailbox pool */
;;;1384       RT_KERNEL_FREE(mb->msg_pool);
000066  69e0              LDR      r0,[r4,#0x1c]
000068  f7fffffe          BL       rt_free
;;;1385   
;;;1386       /* delete mailbox object */
;;;1387       rt_object_delete(&(mb->parent.parent));
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       rt_object_delete
;;;1388   
;;;1389       return RT_EOK;
000072  2000              MOVS     r0,#0
;;;1390   }
000074  bdf8              POP      {r3-r7,pc}
;;;1391   RTM_EXPORT(rt_mb_delete);
                          ENDP

000076  0000              DCW      0x0000
                  |L15.120|
                          DCD      ||.constdata||+0x13e
                  |L15.124|
00007c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000080  74696f6e
000084  5b25735d
000088  20736861
00008c  6c6c206e
000090  6f742075
000094  73656420
000098  696e2049
00009c  53520a00
                  |L15.160|
0000a0  3000              DCB      "0",0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L15.164|
0000a4  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000a8  20617373
0000ac  65727420
0000b0  6661696c
0000b4  65642061
0000b8  74202573
0000bc  3a256420
0000c0  0a00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L15.196|
0000c4  6d622021          DCB      "mb != RT_NULL",0
0000c8  3d205254
0000cc  5f4e554c
0000d0  4c00    
0000d2  00                DCB      0
0000d3  00                DCB      0

                          AREA ||i.rt_mb_detach||, CODE, READONLY, ALIGN=2

                  rt_mb_detach PROC
;;;1290    */
;;;1291   rt_err_t rt_mb_detach(rt_mailbox_t mb)
000000  b538              PUSH     {r3-r5,lr}
;;;1292   {
000002  0004              MOVS     r4,r0
000004  d10c              BNE      |L16.32|
;;;1293       /* parameter check */
;;;1294       RT_ASSERT(mb != RT_NULL);
000006  f88d0000          STRB     r0,[sp,#0]
00000a  f240530e          MOV      r3,#0x50e
00000e  4a0b              LDR      r2,|L16.60|
000010  a10b              ADR      r1,|L16.64|
000012  a00f              ADR      r0,|L16.80|
000014  f7fffffe          BL       rt_kprintf
                  |L16.24|
000018  f89d1000          LDRB     r1,[sp,#0]
00001c  2900              CMP      r1,#0
00001e  d0fb              BEQ      |L16.24|
                  |L16.32|
;;;1295   
;;;1296       /* resume all suspended thread */
;;;1297       rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
000020  f1040014          ADD      r0,r4,#0x14
000024  f7fffffe          BL       rt_ipc_list_resume_all
;;;1298       /* also resume all mailbox private suspended thread */
;;;1299       rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
000028  f1040028          ADD      r0,r4,#0x28
00002c  f7fffffe          BL       rt_ipc_list_resume_all
;;;1300   
;;;1301       /* detach mailbox object */
;;;1302       rt_object_detach(&(mb->parent.parent));
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       rt_object_detach
;;;1303   
;;;1304       return RT_EOK;
000036  2000              MOVS     r0,#0
;;;1305   }
000038  bd38              POP      {r3-r5,pc}
;;;1306   RTM_EXPORT(rt_mb_detach);
                          ENDP

00003a  0000              DCW      0x0000
                  |L16.60|
                          DCD      ||.constdata||+0x124
                  |L16.64|
000040  6d622021          DCB      "mb != RT_NULL",0
000044  3d205254
000048  5f4e554c
00004c  4c00    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L16.80|
000050  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000054  20617373
000058  65727420
00005c  6661696c
000060  65642061
000064  74202573
000068  3a256420
00006c  0a00    
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.rt_mb_init||, CODE, READONLY, ALIGN=2

                  rt_mb_init PROC
;;;1252    */
;;;1253   rt_err_t rt_mb_init(rt_mailbox_t mb,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1254                       const char  *name,
;;;1255                       void        *msgpool,
;;;1256                       rt_size_t    size,
;;;1257                       rt_uint8_t   flag)
;;;1258   {
000004  461e              MOV      r6,r3
000006  f8dd8020          LDR      r8,[sp,#0x20]
00000a  4617              MOV      r7,r2
00000c  4689              MOV      r9,r1
00000e  0004              MOVS     r4,r0
000010  f04f0500          MOV      r5,#0
000014  d10c              BNE      |L17.48|
;;;1259       RT_ASSERT(mb != RT_NULL);
000016  f88d5000          STRB     r5,[sp,#0]
00001a  f24043eb          MOV      r3,#0x4eb
00001e  4a0f              LDR      r2,|L17.92|
000020  a10f              ADR      r1,|L17.96|
000022  a013              ADR      r0,|L17.112|
000024  f7fffffe          BL       rt_kprintf
                  |L17.40|
000028  f89d0000          LDRB     r0,[sp,#0]
00002c  2800              CMP      r0,#0
00002e  d0fb              BEQ      |L17.40|
                  |L17.48|
;;;1260   
;;;1261       /* init object */
;;;1262       rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
000030  464a              MOV      r2,r9
000032  2104              MOVS     r1,#4
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       rt_object_init
;;;1263   
;;;1264       /* set parent flag */
;;;1265       mb->parent.parent.flag = flag;
00003a  f8848009          STRB     r8,[r4,#9]
00003e  f1040014          ADD      r0,r4,#0x14
000042  61a0              STR      r0,[r4,#0x18]
;;;1266   
;;;1267       /* init ipc object */
;;;1268       rt_ipc_object_init(&(mb->parent));
;;;1269   
;;;1270       /* init mailbox */
;;;1271       mb->msg_pool   = msgpool;
;;;1272       mb->size       = size;
000044  61e7              STR      r7,[r4,#0x1c]
000046  6160              STR      r0,[r4,#0x14]
000048  8426              STRH     r6,[r4,#0x20]
;;;1273       mb->entry      = 0;
00004a  8465              STRH     r5,[r4,#0x22]
;;;1274       mb->in_offset  = 0;
00004c  84a5              STRH     r5,[r4,#0x24]
;;;1275       mb->out_offset = 0;
00004e  84e5              STRH     r5,[r4,#0x26]
000050  3428              ADDS     r4,r4,#0x28
;;;1276   
;;;1277       /* init an additional list of sender suspend thread */
;;;1278       rt_list_init(&(mb->suspend_sender_thread));
;;;1279   
;;;1280       return RT_EOK;
000052  2000              MOVS     r0,#0
000054  6064              STR      r4,[r4,#4]
000056  6024              STR      r4,[r4,#0]
;;;1281   }
000058  e8bd83f8          POP      {r3-r9,pc}
;;;1282   RTM_EXPORT(rt_mb_init);
                          ENDP

                  |L17.92|
                          DCD      ||.constdata||+0x119
                  |L17.96|
000060  6d622021          DCB      "mb != RT_NULL",0
000064  3d205254
000068  5f4e554c
00006c  4c00    
00006e  00                DCB      0
00006f  00                DCB      0
                  |L17.112|
000070  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000074  20617373
000078  65727420
00007c  6661696c
000080  65642061
000084  74202573
000088  3a256420
00008c  0a00    
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.rt_mb_recv||, CODE, READONLY, ALIGN=2

                  rt_mb_recv PROC
;;;1550    */
;;;1551   rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1552   {
000004  b082              SUB      sp,sp,#8
000006  468b              MOV      r11,r1
000008  0004              MOVS     r4,r0
00000a  f04f0700          MOV      r7,#0
00000e  d10c              BNE      |L18.42|
;;;1553       struct rt_thread *thread;
;;;1554       register rt_ubase_t temp;
;;;1555       rt_uint32_t tick_delta;
;;;1556   
;;;1557       /* parameter check */
;;;1558       RT_ASSERT(mb != RT_NULL);
000010  f88d7000          STRB     r7,[sp,#0]
000014  f2406316          MOV      r3,#0x616
000018  4a5e              LDR      r2,|L18.404|
00001a  a15f              ADR      r1,|L18.408|
00001c  a062              ADR      r0,|L18.424|
00001e  f7fffffe          BL       rt_kprintf
                  |L18.34|
000022  f89d0000          LDRB     r0,[sp,#0]
000026  2800              CMP      r0,#0
000028  d0fb              BEQ      |L18.34|
                  |L18.42|
;;;1559   
;;;1560       /* initialize delta tick */
;;;1561       tick_delta = 0;
00002a  2600              MOVS     r6,#0
;;;1562       /* get current thread */
;;;1563       thread = rt_thread_self();
00002c  f7fffffe          BL       rt_thread_self
000030  4605              MOV      r5,r0
;;;1564   
;;;1565       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
000032  4865              LDR      r0,|L18.456|
000034  6801              LDR      r1,[r0,#0]  ; rt_object_trytake_hook
000036  b109              CBZ      r1,|L18.60|
000038  4620              MOV      r0,r4
00003a  4788              BLX      r1
                  |L18.60|
;;;1566   
;;;1567       /* disable interrupt */
;;;1568       temp = rt_hw_interrupt_disable();
00003c  f7fffffe          BL       rt_hw_interrupt_disable
000040  4680              MOV      r8,r0
;;;1569   
;;;1570       /* for non-blocking call */
;;;1571       if (mb->entry == 0 && timeout == 0)
000042  8c60              LDRH     r0,[r4,#0x22]
000044  9904              LDR      r1,[sp,#0x10]
;;;1572       {
;;;1573           rt_hw_interrupt_enable(temp);
;;;1574   
;;;1575           return -RT_ETIMEOUT;
000046  f06f0a01          MVN      r10,#1
00004a  4308              ORRS     r0,r0,r1              ;1571
00004c  d171              BNE      |L18.306|
00004e  4640              MOV      r0,r8                 ;1573
000050  f7fffffe          BL       rt_hw_interrupt_enable
000054  4650              MOV      r0,r10
                  |L18.86|
;;;1576       }
;;;1577   
;;;1578       /* mailbox is empty */
;;;1579       while (mb->entry == 0)
;;;1580       {
;;;1581           /* reset error number in thread */
;;;1582           thread->error = RT_EOK;
;;;1583   
;;;1584           /* no waiting, return timeout */
;;;1585           if (timeout == 0)
;;;1586           {
;;;1587               /* enable interrupt */
;;;1588               rt_hw_interrupt_enable(temp);
;;;1589   
;;;1590               thread->error = -RT_ETIMEOUT;
;;;1591   
;;;1592               return -RT_ETIMEOUT;
;;;1593           }
;;;1594   
;;;1595           RT_DEBUG_IN_THREAD_CONTEXT;
;;;1596           /* suspend current thread */
;;;1597           rt_ipc_list_suspend(&(mb->parent.suspend_thread),
;;;1598                               thread,
;;;1599                               mb->parent.parent.flag);
;;;1600   
;;;1601           /* has waiting time, start thread timer */
;;;1602           if (timeout > 0)
;;;1603           {
;;;1604               /* get the start tick of timer */
;;;1605               tick_delta = rt_tick_get();
;;;1606   
;;;1607               RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
;;;1608                                           thread->name));
;;;1609   
;;;1610               /* reset the timeout of thread timer and start it */
;;;1611               rt_timer_control(&(thread->thread_timer),
;;;1612                                RT_TIMER_CTRL_SET_TIME,
;;;1613                                &timeout);
;;;1614               rt_timer_start(&(thread->thread_timer));
;;;1615           }
;;;1616   
;;;1617           /* enable interrupt */
;;;1618           rt_hw_interrupt_enable(temp);
;;;1619   
;;;1620           /* re-schedule */
;;;1621           rt_schedule();
;;;1622   
;;;1623           /* resume from suspend state */
;;;1624           if (thread->error != RT_EOK)
;;;1625           {
;;;1626               /* return error */
;;;1627               return thread->error;
;;;1628           }
;;;1629   
;;;1630           /* disable interrupt */
;;;1631           temp = rt_hw_interrupt_disable();
;;;1632   
;;;1633           /* if it's not waiting forever and then re-calculate timeout tick */
;;;1634           if (timeout > 0)
;;;1635           {
;;;1636               tick_delta = rt_tick_get() - tick_delta;
;;;1637               timeout -= tick_delta;
;;;1638               if (timeout < 0)
;;;1639                   timeout = 0;
;;;1640           }
;;;1641       }
;;;1642   
;;;1643       /* fill ptr */
;;;1644       *value = mb->msg_pool[mb->out_offset];
;;;1645   
;;;1646       /* increase output offset */
;;;1647       ++ mb->out_offset;
;;;1648       if (mb->out_offset >= mb->size)
;;;1649           mb->out_offset = 0;
;;;1650       /* decrease message entry */
;;;1651       mb->entry --;
;;;1652   
;;;1653       /* resume suspended thread */
;;;1654       if (!rt_list_isempty(&(mb->suspend_sender_thread)))
;;;1655       {
;;;1656           rt_ipc_list_resume(&(mb->suspend_sender_thread));
;;;1657   
;;;1658           /* enable interrupt */
;;;1659           rt_hw_interrupt_enable(temp);
;;;1660   
;;;1661           RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
;;;1662   
;;;1663           rt_schedule();
;;;1664   
;;;1665           return RT_EOK;
;;;1666       }
;;;1667   
;;;1668       /* enable interrupt */
;;;1669       rt_hw_interrupt_enable(temp);
;;;1670   
;;;1671       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
;;;1672   
;;;1673       return RT_EOK;
;;;1674   }
000056  b005              ADD      sp,sp,#0x14
000058  e8bd8ff0          POP      {r4-r11,pc}
                  |L18.92|
00005c  632f              STR      r7,[r5,#0x30]         ;1585
00005e  9804              LDR      r0,[sp,#0x10]         ;1585
000060  b130              CBZ      r0,|L18.112|
000062  f7fffffe          BL       rt_hw_interrupt_disable
000066  9000              STR      r0,[sp,#0]            ;1595
000068  f7fffffe          BL       rt_thread_self
00006c  b138              CBZ      r0,|L18.126|
00006e  e017              B        |L18.160|
                  |L18.112|
000070  4640              MOV      r0,r8                 ;1588
000072  f7fffffe          BL       rt_hw_interrupt_enable
000076  4650              MOV      r0,r10                ;1590
000078  f8c5a030          STR      r10,[r5,#0x30]        ;1592
00007c  e7eb              B        |L18.86|
                  |L18.126|
00007e  4945              LDR      r1,|L18.404|
000080  a052              ADR      r0,|L18.460|
000082  f7fffffe          BL       rt_kprintf
000086  f88d7004          STRB     r7,[sp,#4]            ;1595
00008a  f240633b          MOV      r3,#0x63b             ;1595
00008e  4a41              LDR      r2,|L18.404|
000090  a15c              ADR      r1,|L18.516|
000092  a045              ADR      r0,|L18.424|
000094  f7fffffe          BL       rt_kprintf
                  |L18.152|
000098  f89d0004          LDRB     r0,[sp,#4]            ;1595
00009c  2800              CMP      r0,#0                 ;1595
00009e  d0fb              BEQ      |L18.152|
                  |L18.160|
0000a0  f7fffffe          BL       rt_hw_interrupt_disable
0000a4  4681              MOV      r9,r0                 ;1595
0000a6  f7fffffe          BL       rt_interrupt_get_nest
0000aa  b180              CBZ      r0,|L18.206|
0000ac  4939              LDR      r1,|L18.404|
0000ae  a056              ADR      r0,|L18.520|
0000b0  f7fffffe          BL       rt_kprintf
0000b4  f88d7004          STRB     r7,[sp,#4]            ;1595
0000b8  f240633b          MOV      r3,#0x63b             ;1595
0000bc  4a35              LDR      r2,|L18.404|
0000be  a151              ADR      r1,|L18.516|
0000c0  a039              ADR      r0,|L18.424|
0000c2  f7fffffe          BL       rt_kprintf
                  |L18.198|
0000c6  f89d0004          LDRB     r0,[sp,#4]            ;1595
0000ca  2800              CMP      r0,#0                 ;1595
0000cc  d0fb              BEQ      |L18.198|
                  |L18.206|
0000ce  4648              MOV      r0,r9                 ;1595
0000d0  f7fffffe          BL       rt_hw_interrupt_enable
0000d4  9800              LDR      r0,[sp,#0]            ;1595
0000d6  f7fffffe          BL       rt_hw_interrupt_enable
0000da  7a62              LDRB     r2,[r4,#9]            ;1597
0000dc  4629              MOV      r1,r5                 ;1597
0000de  f1040014          ADD      r0,r4,#0x14           ;1597
0000e2  f7fffffe          BL       rt_ipc_list_suspend
0000e6  9804              LDR      r0,[sp,#0x10]         ;1602
0000e8  2800              CMP      r0,#0                 ;1602
0000ea  dd0c              BLE      |L18.262|
0000ec  f7fffffe          BL       rt_tick_get
0000f0  4606              MOV      r6,r0                 ;1605
0000f2  f105004c          ADD      r0,r5,#0x4c           ;1611
0000f6  aa04              ADD      r2,sp,#0x10           ;1611
0000f8  2100              MOVS     r1,#0                 ;1611
0000fa  4681              MOV      r9,r0                 ;1611
0000fc  f7fffffe          BL       rt_timer_control
000100  4648              MOV      r0,r9                 ;1611
000102  f7fffffe          BL       rt_timer_start
                  |L18.262|
000106  4640              MOV      r0,r8                 ;1618
000108  f7fffffe          BL       rt_hw_interrupt_enable
00010c  f7fffffe          BL       rt_schedule
000110  6b28              LDR      r0,[r5,#0x30]         ;1624
000112  2800              CMP      r0,#0                 ;1624
000114  d19f              BNE      |L18.86|
000116  f7fffffe          BL       rt_hw_interrupt_disable
00011a  4680              MOV      r8,r0                 ;1631
00011c  9804              LDR      r0,[sp,#0x10]         ;1634
00011e  2800              CMP      r0,#0                 ;1634
000120  dd07              BLE      |L18.306|
000122  f7fffffe          BL       rt_tick_get
000126  1b86              SUBS     r6,r0,r6              ;1636
000128  9804              LDR      r0,[sp,#0x10]         ;1637
00012a  1b80              SUBS     r0,r0,r6              ;1637
00012c  9004              STR      r0,[sp,#0x10]         ;1638
00012e  d500              BPL      |L18.306|
000130  9704              STR      r7,[sp,#0x10]         ;1639
                  |L18.306|
000132  8c60              LDRH     r0,[r4,#0x22]         ;1579
000134  2800              CMP      r0,#0                 ;1579
000136  d091              BEQ      |L18.92|
000138  8ce1              LDRH     r1,[r4,#0x26]         ;1644
00013a  69e0              LDR      r0,[r4,#0x1c]         ;1644
00013c  f8501021          LDR      r1,[r0,r1,LSL #2]     ;1644
000140  f8cb1000          STR      r1,[r11,#0]           ;1647
000144  8ce0              LDRH     r0,[r4,#0x26]         ;1647
000146  1c40              ADDS     r0,r0,#1              ;1647
000148  b280              UXTH     r0,r0                 ;1647
00014a  84e0              STRH     r0,[r4,#0x26]         ;1647
00014c  8c21              LDRH     r1,[r4,#0x20]         ;1648
00014e  4288              CMP      r0,r1                 ;1648
000150  d300              BCC      |L18.340|
000152  84e7              STRH     r7,[r4,#0x26]         ;1649
                  |L18.340|
000154  8c60              LDRH     r0,[r4,#0x22]         ;1651
000156  1e40              SUBS     r0,r0,#1              ;1651
000158  8460              STRH     r0,[r4,#0x22]         ;1651
00015a  f1040028          ADD      r0,r4,#0x28           ;1654
00015e  4606              MOV      r6,r0                 ;1654
000160  f7fffffe          BL       rt_list_isempty
000164  4d31              LDR      r5,|L18.556|
000166  b140              CBZ      r0,|L18.378|
000168  4640              MOV      r0,r8                 ;1669
00016a  f7fffffe          BL       rt_hw_interrupt_enable
00016e  6829              LDR      r1,[r5,#0]            ;1671  ; rt_object_take_hook
000170  b109              CBZ      r1,|L18.374|
000172  4620              MOV      r0,r4                 ;1671
000174  4788              BLX      r1                    ;1671
                  |L18.374|
000176  2000              MOVS     r0,#0                 ;1673
000178  e76d              B        |L18.86|
                  |L18.378|
00017a  4630              MOV      r0,r6
00017c  f7fffffe          BL       rt_ipc_list_resume
000180  4640              MOV      r0,r8                 ;1659
000182  f7fffffe          BL       rt_hw_interrupt_enable
000186  6829              LDR      r1,[r5,#0]            ;1661  ; rt_object_take_hook
000188  b109              CBZ      r1,|L18.398|
00018a  4620              MOV      r0,r4                 ;1661
00018c  4788              BLX      r1                    ;1661
                  |L18.398|
00018e  f7fffffe          BL       rt_schedule
000192  e7f0              B        |L18.374|
;;;1675   RTM_EXPORT(rt_mb_recv);
                          ENDP

                  |L18.404|
                          DCD      ||.constdata||+0x15b
                  |L18.408|
000198  6d622021          DCB      "mb != RT_NULL",0
00019c  3d205254
0001a0  5f4e554c
0001a4  4c00    
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L18.424|
0001a8  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0001ac  20617373
0001b0  65727420
0001b4  6661696c
0001b8  65642061
0001bc  74202573
0001c0  3a256420
0001c4  0a00    
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L18.456|
                          DCD      rt_object_trytake_hook
                  |L18.460|
0001cc  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
0001d0  74696f6e
0001d4  5b25735d
0001d8  20736861
0001dc  6c6c206e
0001e0  6f742062
0001e4  65207573
0001e8  65642062
0001ec  65666f72
0001f0  65207363
0001f4  68656475
0001f8  6c657220
0001fc  73746172
000200  740a    
000202  00                DCB      0
000203  00                DCB      0
                  |L18.516|
000204  3000              DCB      "0",0
000206  00                DCB      0
000207  00                DCB      0
                  |L18.520|
000208  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00020c  74696f6e
000210  5b25735d
000214  20736861
000218  6c6c206e
00021c  6f742075
000220  73656420
000224  696e2049
000228  53520a00
                  |L18.556|
                          DCD      rt_object_take_hook

                          AREA ||i.rt_mb_send||, CODE, READONLY, ALIGN=1

                  rt_mb_send PROC
;;;1534    */
;;;1535   rt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value)
000000  2200              MOVS     r2,#0
;;;1536   {
;;;1537       return rt_mb_send_wait(mb, value, 0);
000002  f7ffbffe          B.W      rt_mb_send_wait
;;;1538   }
;;;1539   RTM_EXPORT(rt_mb_send);
                          ENDP


                          AREA ||i.rt_mb_send_wait||, CODE, READONLY, ALIGN=2

                  rt_mb_send_wait PROC
;;;1403    */
;;;1404   rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1405                            rt_uint32_t  value,
;;;1406                            rt_int32_t   timeout)
;;;1407   {
000004  b082              SUB      sp,sp,#8
000006  468b              MOV      r11,r1
000008  0004              MOVS     r4,r0
00000a  f04f0700          MOV      r7,#0
00000e  d10c              BNE      |L20.42|
;;;1408       struct rt_thread *thread;
;;;1409       register rt_ubase_t temp;
;;;1410       rt_uint32_t tick_delta;
;;;1411   
;;;1412       /* parameter check */
;;;1413       RT_ASSERT(mb != RT_NULL);
000010  f88d7000          STRB     r7,[sp,#0]
000014  f2405385          MOV      r3,#0x585
000018  4a57              LDR      r2,|L20.376|
00001a  a158              ADR      r1,|L20.380|
00001c  a05b              ADR      r0,|L20.396|
00001e  f7fffffe          BL       rt_kprintf
                  |L20.34|
000022  f89d0000          LDRB     r0,[sp,#0]
000026  2800              CMP      r0,#0
000028  d0fb              BEQ      |L20.34|
                  |L20.42|
;;;1414   
;;;1415       /* initialize delta tick */
;;;1416       tick_delta = 0;
00002a  2600              MOVS     r6,#0
;;;1417       /* get current thread */
;;;1418       thread = rt_thread_self();
00002c  f7fffffe          BL       rt_thread_self
000030  4605              MOV      r5,r0
;;;1419   
;;;1420       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
000032  485e              LDR      r0,|L20.428|
000034  6801              LDR      r1,[r0,#0]  ; rt_object_put_hook
000036  b109              CBZ      r1,|L20.60|
000038  4620              MOV      r0,r4
00003a  4788              BLX      r1
                  |L20.60|
;;;1421   
;;;1422       /* disable interrupt */
;;;1423       temp = rt_hw_interrupt_disable();
00003c  f7fffffe          BL       rt_hw_interrupt_disable
000040  4680              MOV      r8,r0
;;;1424   
;;;1425       /* for non-blocking call */
;;;1426       if (mb->entry == mb->size && timeout == 0)
000042  8c60              LDRH     r0,[r4,#0x22]
000044  8c21              LDRH     r1,[r4,#0x20]
;;;1427       {
;;;1428           rt_hw_interrupt_enable(temp);
;;;1429   
;;;1430           return -RT_EFULL;
000046  f06f0a02          MVN      r10,#2
00004a  4288              CMP      r0,r1                 ;1426
00004c  d16d              BNE      |L20.298|
00004e  9804              LDR      r0,[sp,#0x10]         ;1426
000050  b150              CBZ      r0,|L20.104|
000052  e06a              B        |L20.298|
                  |L20.84|
;;;1431       }
;;;1432   
;;;1433       /* mailbox is full */
;;;1434       while (mb->entry == mb->size)
;;;1435       {
;;;1436           /* reset error number in thread */
;;;1437           thread->error = RT_EOK;
;;;1438   
;;;1439           /* no waiting, return timeout */
;;;1440           if (timeout == 0)
000054  632f              STR      r7,[r5,#0x30]
000056  9804              LDR      r0,[sp,#0x10]
000058  b130              CBZ      r0,|L20.104|
;;;1441           {
;;;1442               /* enable interrupt */
;;;1443               rt_hw_interrupt_enable(temp);
;;;1444   
;;;1445               return -RT_EFULL;
;;;1446           }
;;;1447   
;;;1448           RT_DEBUG_IN_THREAD_CONTEXT;
00005a  f7fffffe          BL       rt_hw_interrupt_disable
00005e  9000              STR      r0,[sp,#0]
000060  f7fffffe          BL       rt_thread_self
000064  b138              CBZ      r0,|L20.118|
000066  e017              B        |L20.152|
                  |L20.104|
000068  4640              MOV      r0,r8                 ;1443
00006a  f7fffffe          BL       rt_hw_interrupt_enable
00006e  4650              MOV      r0,r10                ;1445
                  |L20.112|
;;;1449           /* suspend current thread */
;;;1450           rt_ipc_list_suspend(&(mb->suspend_sender_thread),
;;;1451                               thread,
;;;1452                               mb->parent.parent.flag);
;;;1453   
;;;1454           /* has waiting time, start thread timer */
;;;1455           if (timeout > 0)
;;;1456           {
;;;1457               /* get the start tick of timer */
;;;1458               tick_delta = rt_tick_get();
;;;1459   
;;;1460               RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
;;;1461                                           thread->name));
;;;1462   
;;;1463               /* reset the timeout of thread timer and start it */
;;;1464               rt_timer_control(&(thread->thread_timer),
;;;1465                                RT_TIMER_CTRL_SET_TIME,
;;;1466                                &timeout);
;;;1467               rt_timer_start(&(thread->thread_timer));
;;;1468           }
;;;1469   
;;;1470           /* enable interrupt */
;;;1471           rt_hw_interrupt_enable(temp);
;;;1472   
;;;1473           /* re-schedule */
;;;1474           rt_schedule();
;;;1475   
;;;1476           /* resume from suspend state */
;;;1477           if (thread->error != RT_EOK)
;;;1478           {
;;;1479               /* return error */
;;;1480               return thread->error;
;;;1481           }
;;;1482   
;;;1483           /* disable interrupt */
;;;1484           temp = rt_hw_interrupt_disable();
;;;1485   
;;;1486           /* if it's not waiting forever and then re-calculate timeout tick */
;;;1487           if (timeout > 0)
;;;1488           {
;;;1489               tick_delta = rt_tick_get() - tick_delta;
;;;1490               timeout -= tick_delta;
;;;1491               if (timeout < 0)
;;;1492                   timeout = 0;
;;;1493           }
;;;1494       }
;;;1495   
;;;1496       /* set ptr */
;;;1497       mb->msg_pool[mb->in_offset] = value;
;;;1498       /* increase input offset */
;;;1499       ++ mb->in_offset;
;;;1500       if (mb->in_offset >= mb->size)
;;;1501           mb->in_offset = 0;
;;;1502       /* increase message entry */
;;;1503       mb->entry ++;
;;;1504   
;;;1505       /* resume suspended thread */
;;;1506       if (!rt_list_isempty(&mb->parent.suspend_thread))
;;;1507       {
;;;1508           rt_ipc_list_resume(&(mb->parent.suspend_thread));
;;;1509   
;;;1510           /* enable interrupt */
;;;1511           rt_hw_interrupt_enable(temp);
;;;1512   
;;;1513           rt_schedule();
;;;1514   
;;;1515           return RT_EOK;
;;;1516       }
;;;1517   
;;;1518       /* enable interrupt */
;;;1519       rt_hw_interrupt_enable(temp);
;;;1520   
;;;1521       return RT_EOK;
;;;1522   }
000070  b005              ADD      sp,sp,#0x14
000072  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.118|
000076  4940              LDR      r1,|L20.376|
000078  a04d              ADR      r0,|L20.432|
00007a  f7fffffe          BL       rt_kprintf
00007e  f88d7004          STRB     r7,[sp,#4]            ;1448
000082  f44f63b5          MOV      r3,#0x5a8             ;1448
000086  4a3c              LDR      r2,|L20.376|
000088  a157              ADR      r1,|L20.488|
00008a  a040              ADR      r0,|L20.396|
00008c  f7fffffe          BL       rt_kprintf
                  |L20.144|
000090  f89d0004          LDRB     r0,[sp,#4]            ;1448
000094  2800              CMP      r0,#0                 ;1448
000096  d0fb              BEQ      |L20.144|
                  |L20.152|
000098  f7fffffe          BL       rt_hw_interrupt_disable
00009c  4681              MOV      r9,r0                 ;1448
00009e  f7fffffe          BL       rt_interrupt_get_nest
0000a2  b180              CBZ      r0,|L20.198|
0000a4  4934              LDR      r1,|L20.376|
0000a6  a051              ADR      r0,|L20.492|
0000a8  f7fffffe          BL       rt_kprintf
0000ac  f88d7004          STRB     r7,[sp,#4]            ;1448
0000b0  f44f63b5          MOV      r3,#0x5a8             ;1448
0000b4  4a30              LDR      r2,|L20.376|
0000b6  a14c              ADR      r1,|L20.488|
0000b8  a034              ADR      r0,|L20.396|
0000ba  f7fffffe          BL       rt_kprintf
                  |L20.190|
0000be  f89d0004          LDRB     r0,[sp,#4]            ;1448
0000c2  2800              CMP      r0,#0                 ;1448
0000c4  d0fb              BEQ      |L20.190|
                  |L20.198|
0000c6  4648              MOV      r0,r9                 ;1448
0000c8  f7fffffe          BL       rt_hw_interrupt_enable
0000cc  9800              LDR      r0,[sp,#0]            ;1448
0000ce  f7fffffe          BL       rt_hw_interrupt_enable
0000d2  7a62              LDRB     r2,[r4,#9]            ;1450
0000d4  4629              MOV      r1,r5                 ;1450
0000d6  f1040028          ADD      r0,r4,#0x28           ;1450
0000da  f7fffffe          BL       rt_ipc_list_suspend
0000de  9804              LDR      r0,[sp,#0x10]         ;1455
0000e0  2800              CMP      r0,#0                 ;1455
0000e2  dd0c              BLE      |L20.254|
0000e4  f7fffffe          BL       rt_tick_get
0000e8  4606              MOV      r6,r0                 ;1458
0000ea  f105004c          ADD      r0,r5,#0x4c           ;1464
0000ee  aa04              ADD      r2,sp,#0x10           ;1464
0000f0  2100              MOVS     r1,#0                 ;1464
0000f2  4681              MOV      r9,r0                 ;1464
0000f4  f7fffffe          BL       rt_timer_control
0000f8  4648              MOV      r0,r9                 ;1464
0000fa  f7fffffe          BL       rt_timer_start
                  |L20.254|
0000fe  4640              MOV      r0,r8                 ;1471
000100  f7fffffe          BL       rt_hw_interrupt_enable
000104  f7fffffe          BL       rt_schedule
000108  6b28              LDR      r0,[r5,#0x30]         ;1477
00010a  2800              CMP      r0,#0                 ;1477
00010c  d1b0              BNE      |L20.112|
00010e  f7fffffe          BL       rt_hw_interrupt_disable
000112  4680              MOV      r8,r0                 ;1484
000114  9804              LDR      r0,[sp,#0x10]         ;1487
000116  2800              CMP      r0,#0                 ;1487
000118  dd07              BLE      |L20.298|
00011a  f7fffffe          BL       rt_tick_get
00011e  1b86              SUBS     r6,r0,r6              ;1489
000120  9804              LDR      r0,[sp,#0x10]         ;1490
000122  1b80              SUBS     r0,r0,r6              ;1490
000124  9004              STR      r0,[sp,#0x10]         ;1491
000126  d500              BPL      |L20.298|
000128  9704              STR      r7,[sp,#0x10]         ;1492
                  |L20.298|
00012a  8c60              LDRH     r0,[r4,#0x22]         ;1434
00012c  8c21              LDRH     r1,[r4,#0x20]         ;1434
00012e  4288              CMP      r0,r1                 ;1434
000130  d090              BEQ      |L20.84|
000132  8ca2              LDRH     r2,[r4,#0x24]         ;1497
000134  69e1              LDR      r1,[r4,#0x1c]         ;1497
000136  f841b022          STR      r11,[r1,r2,LSL #2]    ;1497
00013a  8ca0              LDRH     r0,[r4,#0x24]         ;1499
00013c  1c40              ADDS     r0,r0,#1              ;1499
00013e  b280              UXTH     r0,r0                 ;1499
000140  84a0              STRH     r0,[r4,#0x24]         ;1499
000142  8c21              LDRH     r1,[r4,#0x20]         ;1500
000144  4288              CMP      r0,r1                 ;1500
000146  d300              BCC      |L20.330|
000148  84a7              STRH     r7,[r4,#0x24]         ;1501
                  |L20.330|
00014a  8c60              LDRH     r0,[r4,#0x22]         ;1503
00014c  1c40              ADDS     r0,r0,#1              ;1503
00014e  8460              STRH     r0,[r4,#0x22]         ;1503
000150  f1040014          ADD      r0,r4,#0x14           ;1506
000154  4604              MOV      r4,r0                 ;1506
000156  f7fffffe          BL       rt_list_isempty
00015a  b120              CBZ      r0,|L20.358|
00015c  4640              MOV      r0,r8                 ;1519
00015e  f7fffffe          BL       rt_hw_interrupt_enable
                  |L20.354|
000162  2000              MOVS     r0,#0                 ;1521
000164  e784              B        |L20.112|
                  |L20.358|
000166  4620              MOV      r0,r4
000168  f7fffffe          BL       rt_ipc_list_resume
00016c  4640              MOV      r0,r8                 ;1511
00016e  f7fffffe          BL       rt_hw_interrupt_enable
000172  f7fffffe          BL       rt_schedule
000176  e7f4              B        |L20.354|
;;;1523   RTM_EXPORT(rt_mb_send_wait);
                          ENDP

                  |L20.376|
                          DCD      ||.constdata||+0x14b
                  |L20.380|
00017c  6d622021          DCB      "mb != RT_NULL",0
000180  3d205254
000184  5f4e554c
000188  4c00    
00018a  00                DCB      0
00018b  00                DCB      0
                  |L20.396|
00018c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000190  20617373
000194  65727420
000198  6661696c
00019c  65642061
0001a0  74202573
0001a4  3a256420
0001a8  0a00    
0001aa  00                DCB      0
0001ab  00                DCB      0
                  |L20.428|
                          DCD      rt_object_put_hook
                  |L20.432|
0001b0  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
0001b4  74696f6e
0001b8  5b25735d
0001bc  20736861
0001c0  6c6c206e
0001c4  6f742062
0001c8  65207573
0001cc  65642062
0001d0  65666f72
0001d4  65207363
0001d8  68656475
0001dc  6c657220
0001e0  73746172
0001e4  740a    
0001e6  00                DCB      0
0001e7  00                DCB      0
                  |L20.488|
0001e8  3000              DCB      "0",0
0001ea  00                DCB      0
0001eb  00                DCB      0
                  |L20.492|
0001ec  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0001f0  74696f6e
0001f4  5b25735d
0001f8  20736861
0001fc  6c6c206e
000200  6f742075
000204  73656420
000208  696e2049
00020c  53520a00

                          AREA ||i.rt_mq_control||, CODE, READONLY, ALIGN=2

                  rt_mq_control PROC
;;;2233    */
;;;2234   rt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2235   {
000002  460e              MOV      r6,r1
000004  0004              MOVS     r4,r0
000006  f04f0500          MOV      r5,#0
00000a  d10c              BNE      |L21.38|
;;;2236       rt_ubase_t level;
;;;2237       struct rt_mq_message *msg;
;;;2238   
;;;2239       RT_ASSERT(mq != RT_NULL);
00000c  f88d5000          STRB     r5,[sp,#0]
000010  f64003bf          MOV      r3,#0x8bf
000014  4a14              LDR      r2,|L21.104|
000016  a115              ADR      r1,|L21.108|
000018  a018              ADR      r0,|L21.124|
00001a  f7fffffe          BL       rt_kprintf
                  |L21.30|
00001e  f89d0000          LDRB     r0,[sp,#0]
000022  2800              CMP      r0,#0
000024  d0fb              BEQ      |L21.30|
                  |L21.38|
;;;2240   
;;;2241       if (cmd == RT_IPC_CMD_RESET)
000026  2e01              CMP      r6,#1
000028  d002              BEQ      |L21.48|
;;;2242       {
;;;2243           /* disable interrupt */
;;;2244           level = rt_hw_interrupt_disable();
;;;2245   
;;;2246           /* resume all waiting thread */
;;;2247           rt_ipc_list_resume_all(&mq->parent.suspend_thread);
;;;2248   
;;;2249           /* release all message in the queue */
;;;2250           while (mq->msg_queue_head != RT_NULL)
;;;2251           {
;;;2252               /* get message from queue */
;;;2253               msg = (struct rt_mq_message *)mq->msg_queue_head;
;;;2254   
;;;2255               /* move message queue head */
;;;2256               mq->msg_queue_head = msg->next;
;;;2257               /* reach queue tail, set to NULL */
;;;2258               if (mq->msg_queue_tail == msg)
;;;2259                   mq->msg_queue_tail = RT_NULL;
;;;2260   
;;;2261               /* put message to free list */
;;;2262               msg->next = (struct rt_mq_message *)mq->msg_queue_free;
;;;2263               mq->msg_queue_free = msg;
;;;2264           }
;;;2265   
;;;2266           /* clean entry */
;;;2267           mq->entry = 0;
;;;2268   
;;;2269           /* enable interrupt */
;;;2270           rt_hw_interrupt_enable(level);
;;;2271   
;;;2272           rt_schedule();
;;;2273   
;;;2274           return RT_EOK;
;;;2275       }
;;;2276   
;;;2277       return -RT_ERROR;
00002a  f04f30ff          MOV      r0,#0xffffffff
;;;2278   }
00002e  bdf8              POP      {r3-r7,pc}
                  |L21.48|
000030  f7fffffe          BL       rt_hw_interrupt_disable
000034  4606              MOV      r6,r0                 ;2244
000036  f1040014          ADD      r0,r4,#0x14           ;2247
00003a  f7fffffe          BL       rt_ipc_list_resume_all
00003e  e008              B        |L21.82|
                  |L21.64|
000040  6801              LDR      r1,[r0,#0]            ;2256
000042  62a1              STR      r1,[r4,#0x28]         ;2258
000044  6ae1              LDR      r1,[r4,#0x2c]         ;2258
000046  4281              CMP      r1,r0                 ;2258
000048  d100              BNE      |L21.76|
00004a  62e5              STR      r5,[r4,#0x2c]         ;2259
                  |L21.76|
00004c  6b21              LDR      r1,[r4,#0x30]         ;2262
00004e  6001              STR      r1,[r0,#0]            ;2263
000050  6320              STR      r0,[r4,#0x30]         ;2263
                  |L21.82|
000052  6aa0              LDR      r0,[r4,#0x28]         ;2250
000054  2800              CMP      r0,#0                 ;2250
000056  d1f3              BNE      |L21.64|
000058  84a5              STRH     r5,[r4,#0x24]         ;2267
00005a  4630              MOV      r0,r6                 ;2270
00005c  f7fffffe          BL       rt_hw_interrupt_enable
000060  f7fffffe          BL       rt_schedule
000064  2000              MOVS     r0,#0                 ;2274
000066  bdf8              POP      {r3-r7,pc}
;;;2279   RTM_EXPORT(rt_mq_control);
                          ENDP

                  |L21.104|
                          DCD      ||.constdata||+0x1c9
                  |L21.108|
00006c  6d712021          DCB      "mq != RT_NULL",0
000070  3d205254
000074  5f4e554c
000078  4c00    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L21.124|
00007c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000080  20617373
000084  65727420
000088  6661696c
00008c  65642061
000090  74202573
000094  3a256420
000098  0a00    
00009a  00                DCB      0
00009b  00                DCB      0

                          AREA ||i.rt_mq_create||, CODE, READONLY, ALIGN=2

                  rt_mq_create PROC
;;;1820    */
;;;1821   rt_mq_t rt_mq_create(const char *name,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1822                        rt_size_t   msg_size,
;;;1823                        rt_size_t   max_msgs,
;;;1824                        rt_uint8_t  flag)
;;;1825   {
000004  461f              MOV      r7,r3
000006  4690              MOV      r8,r2
000008  460e              MOV      r6,r1
00000a  4604              MOV      r4,r0
;;;1826       struct rt_messagequeue *mq;
;;;1827       struct rt_mq_message *head;
;;;1828       register rt_base_t temp;
;;;1829   
;;;1830       RT_DEBUG_NOT_IN_INTERRUPT;
00000c  f7fffffe          BL       rt_hw_interrupt_disable
000010  4681              MOV      r9,r0
000012  f7fffffe          BL       rt_interrupt_get_nest
000016  2500              MOVS     r5,#0
000018  b180              CBZ      r0,|L22.60|
00001a  4923              LDR      r1,|L22.168|
00001c  a023              ADR      r0,|L22.172|
00001e  f7fffffe          BL       rt_kprintf
000022  f88d5000          STRB     r5,[sp,#0]
000026  f2407326          MOV      r3,#0x726
00002a  4a1f              LDR      r2,|L22.168|
00002c  a128              ADR      r1,|L22.208|
00002e  a029              ADR      r0,|L22.212|
000030  f7fffffe          BL       rt_kprintf
                  |L22.52|
000034  f89d0000          LDRB     r0,[sp,#0]
000038  2800              CMP      r0,#0
00003a  d0fb              BEQ      |L22.52|
                  |L22.60|
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       rt_hw_interrupt_enable
;;;1831   
;;;1832       /* allocate object */
;;;1833       mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
000042  4621              MOV      r1,r4
000044  2005              MOVS     r0,#5
000046  f7fffffe          BL       rt_object_allocate
00004a  0004              MOVS     r4,r0
;;;1834       if (mq == RT_NULL)
00004c  d01b              BEQ      |L22.134|
;;;1835           return mq;
;;;1836   
;;;1837       /* set parent */
;;;1838       mq->parent.parent.flag = flag;
00004e  7267              STRB     r7,[r4,#9]
000050  f1040014          ADD      r0,r4,#0x14
000054  61a0              STR      r0,[r4,#0x18]
;;;1839   
;;;1840       /* init ipc object */
;;;1841       rt_ipc_object_init(&(mq->parent));
;;;1842   
;;;1843       /* init message queue */
;;;1844   
;;;1845       /* get correct message size */
;;;1846       mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
000056  6160              STR      r0,[r4,#0x14]
000058  1df0              ADDS     r0,r6,#7
00005a  f64f71f8          MOV      r1,#0xfff8
00005e  4008              ANDS     r0,r0,r1
000060  8420              STRH     r0,[r4,#0x20]
;;;1847       mq->max_msgs = max_msgs;
000062  fa1ff188          UXTH     r1,r8
000066  1d00              ADDS     r0,r0,#4
000068  8461              STRH     r1,[r4,#0x22]
;;;1848   
;;;1849       /* allocate message pool */
;;;1850       mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message))* mq->max_msgs);
00006a  4348              MULS     r0,r1,r0
00006c  f7fffffe          BL       rt_malloc
;;;1851       if (mq->msg_pool == RT_NULL)
000070  61e0              STR      r0,[r4,#0x1c]
000072  b120              CBZ      r0,|L22.126|
;;;1852       {
;;;1853           rt_mq_delete(mq);
;;;1854   
;;;1855           return RT_NULL;
;;;1856       }
;;;1857   
;;;1858       /* init message list */
;;;1859       mq->msg_queue_head = RT_NULL;
;;;1860       mq->msg_queue_tail = RT_NULL;
000074  62a5              STR      r5,[r4,#0x28]
;;;1861   
;;;1862       /* init message empty list */
;;;1863       mq->msg_queue_free = RT_NULL;
000076  62e5              STR      r5,[r4,#0x2c]
;;;1864       for (temp = 0; temp < mq->max_msgs; temp ++)
000078  2000              MOVS     r0,#0
00007a  6325              STR      r5,[r4,#0x30]
00007c  e00e              B        |L22.156|
                  |L22.126|
00007e  4620              MOV      r0,r4                 ;1853
000080  f7fffffe          BL       rt_mq_delete
000084  2000              MOVS     r0,#0                 ;1855
                  |L22.134|
;;;1865       {
;;;1866           head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
;;;1867                  temp * (mq->msg_size + sizeof(struct rt_mq_message)));
;;;1868           head->next = mq->msg_queue_free;
;;;1869           mq->msg_queue_free = head;
;;;1870       }
;;;1871   
;;;1872       /* the initial entry is zero */
;;;1873       mq->entry = 0;
;;;1874   
;;;1875       return mq;
;;;1876   }
000086  e8bd83f8          POP      {r3-r9,pc}
                  |L22.138|
00008a  8c21              LDRH     r1,[r4,#0x20]         ;1866
00008c  69e2              LDR      r2,[r4,#0x1c]         ;1866
00008e  1d09              ADDS     r1,r1,#4              ;1866
000090  fb002101          MLA      r1,r0,r1,r2           ;1866
000094  6b22              LDR      r2,[r4,#0x30]         ;1868
000096  600a              STR      r2,[r1,#0]            ;1869
000098  1c40              ADDS     r0,r0,#1              ;1869
00009a  6321              STR      r1,[r4,#0x30]         ;1869
                  |L22.156|
00009c  8c61              LDRH     r1,[r4,#0x22]         ;1864
00009e  4281              CMP      r1,r0                 ;1864
0000a0  dcf3              BGT      |L22.138|
0000a2  84a5              STRH     r5,[r4,#0x24]         ;1873
0000a4  4620              MOV      r0,r4                 ;1875
0000a6  e7ee              B        |L22.134|
;;;1877   RTM_EXPORT(rt_mq_create);
                          ENDP

                  |L22.168|
                          DCD      ||.constdata||+0x18c
                  |L22.172|
0000ac  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0000b0  74696f6e
0000b4  5b25735d
0000b8  20736861
0000bc  6c6c206e
0000c0  6f742075
0000c4  73656420
0000c8  696e2049
0000cc  53520a00
                  |L22.208|
0000d0  3000              DCB      "0",0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L22.212|
0000d4  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000d8  20617373
0000dc  65727420
0000e0  6661696c
0000e4  65642061
0000e8  74202573
0000ec  3a256420
0000f0  0a00    
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||i.rt_mq_delete||, CODE, READONLY, ALIGN=2

                  rt_mq_delete PROC
;;;1885    */
;;;1886   rt_err_t rt_mq_delete(rt_mq_t mq)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1887   {
000002  4604              MOV      r4,r0
;;;1888       RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4606              MOV      r6,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2500              MOVS     r5,#0
000010  b180              CBZ      r0,|L23.52|
000012  4917              LDR      r1,|L23.112|
000014  a017              ADR      r0,|L23.116|
000016  f7fffffe          BL       rt_kprintf
00001a  f88d5000          STRB     r5,[sp,#0]
00001e  f44f63ec          MOV      r3,#0x760
000022  4a13              LDR      r2,|L23.112|
000024  a11c              ADR      r1,|L23.152|
000026  a01d              ADR      r0,|L23.156|
000028  f7fffffe          BL       rt_kprintf
                  |L23.44|
00002c  f89d1000          LDRB     r1,[sp,#0]
000030  2900              CMP      r1,#0
000032  d0fb              BEQ      |L23.44|
                  |L23.52|
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       rt_hw_interrupt_enable
;;;1889   
;;;1890       /* parameter check */
;;;1891       RT_ASSERT(mq != RT_NULL);
00003a  b964              CBNZ     r4,|L23.86|
00003c  f88d5000          STRB     r5,[sp,#0]
000040  f2407363          MOV      r3,#0x763
000044  4a0a              LDR      r2,|L23.112|
000046  a11d              ADR      r1,|L23.188|
000048  a014              ADR      r0,|L23.156|
00004a  f7fffffe          BL       rt_kprintf
                  |L23.78|
00004e  f89d1000          LDRB     r1,[sp,#0]
000052  2900              CMP      r1,#0
000054  d0fb              BEQ      |L23.78|
                  |L23.86|
;;;1892   
;;;1893       /* resume all suspended thread */
;;;1894       rt_ipc_list_resume_all(&(mq->parent.suspend_thread));
000056  f1040014          ADD      r0,r4,#0x14
00005a  f7fffffe          BL       rt_ipc_list_resume_all
;;;1895   
;;;1896   #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;1897       /* the mq object belongs to an application module */
;;;1898       if (mq->parent.parent.flag & RT_OBJECT_FLAG_MODULE)
;;;1899           rt_module_free(mq->parent.parent.module_id, mq->msg_pool);
;;;1900       else
;;;1901   #endif
;;;1902   
;;;1903       /* free message queue pool */
;;;1904       RT_KERNEL_FREE(mq->msg_pool);
00005e  69e0              LDR      r0,[r4,#0x1c]
000060  f7fffffe          BL       rt_free
;;;1905   
;;;1906       /* delete message queue object */
;;;1907       rt_object_delete(&(mq->parent.parent));
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       rt_object_delete
;;;1908   
;;;1909       return RT_EOK;
00006a  2000              MOVS     r0,#0
;;;1910   }
00006c  bdf8              POP      {r3-r7,pc}
;;;1911   RTM_EXPORT(rt_mq_delete);
                          ENDP

00006e  0000              DCW      0x0000
                  |L23.112|
                          DCD      ||.constdata||+0x199
                  |L23.116|
000074  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000078  74696f6e
00007c  5b25735d
000080  20736861
000084  6c6c206e
000088  6f742075
00008c  73656420
000090  696e2049
000094  53520a00
                  |L23.152|
000098  3000              DCB      "0",0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L23.156|
00009c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000a0  20617373
0000a4  65727420
0000a8  6661696c
0000ac  65642061
0000b0  74202573
0000b4  3a256420
0000b8  0a00    
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L23.188|
0000bc  6d712021          DCB      "mq != RT_NULL",0
0000c0  3d205254
0000c4  5f4e554c
0000c8  4c00    
0000ca  00                DCB      0
0000cb  00                DCB      0

                          AREA ||i.rt_mq_detach||, CODE, READONLY, ALIGN=2

                  rt_mq_detach PROC
;;;1794    */
;;;1795   rt_err_t rt_mq_detach(rt_mq_t mq)
000000  b538              PUSH     {r3-r5,lr}
;;;1796   {
000002  0004              MOVS     r4,r0
000004  d10c              BNE      |L24.32|
;;;1797       /* parameter check */
;;;1798       RT_ASSERT(mq != RT_NULL);
000006  f88d0000          STRB     r0,[sp,#0]
00000a  f2407306          MOV      r3,#0x706
00000e  4a09              LDR      r2,|L24.52|
000010  a109              ADR      r1,|L24.56|
000012  a00d              ADR      r0,|L24.72|
000014  f7fffffe          BL       rt_kprintf
                  |L24.24|
000018  f89d1000          LDRB     r1,[sp,#0]
00001c  2900              CMP      r1,#0
00001e  d0fb              BEQ      |L24.24|
                  |L24.32|
;;;1799   
;;;1800       /* resume all suspended thread */
;;;1801       rt_ipc_list_resume_all(&mq->parent.suspend_thread);
000020  f1040014          ADD      r0,r4,#0x14
000024  f7fffffe          BL       rt_ipc_list_resume_all
;;;1802   
;;;1803       /* detach message queue object */
;;;1804       rt_object_detach(&(mq->parent.parent));
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       rt_object_detach
;;;1805   
;;;1806       return RT_EOK;
00002e  2000              MOVS     r0,#0
;;;1807   }
000030  bd38              POP      {r3-r5,pc}
;;;1808   RTM_EXPORT(rt_mq_detach);
                          ENDP

000032  0000              DCW      0x0000
                  |L24.52|
                          DCD      ||.constdata||+0x17f
                  |L24.56|
000038  6d712021          DCB      "mq != RT_NULL",0
00003c  3d205254
000040  5f4e554c
000044  4c00    
000046  00                DCB      0
000047  00                DCB      0
                  |L24.72|
000048  28257329          DCB      "(%s) assert failed at %s:%d \n",0
00004c  20617373
000050  65727420
000054  6661696c
000058  65642061
00005c  74202573
000060  3a256420
000064  0a00    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.rt_mq_init||, CODE, READONLY, ALIGN=2

                  rt_mq_init PROC
;;;1737    */
;;;1738   rt_err_t rt_mq_init(rt_mq_t     mq,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1739                       const char *name,
;;;1740                       void       *msgpool,
;;;1741                       rt_size_t   msg_size,
;;;1742                       rt_size_t   pool_size,
;;;1743                       rt_uint8_t  flag)
;;;1744   {
000004  461e              MOV      r6,r3
000006  e9dd980a          LDRD     r9,r8,[sp,#0x28]
00000a  4617              MOV      r7,r2
00000c  468a              MOV      r10,r1
00000e  0004              MOVS     r4,r0
000010  f04f0500          MOV      r5,#0
000014  d10c              BNE      |L25.48|
;;;1745       struct rt_mq_message *head;
;;;1746       register rt_base_t temp;
;;;1747   
;;;1748       /* parameter check */
;;;1749       RT_ASSERT(mq != RT_NULL);
000016  f88d5000          STRB     r5,[sp,#0]
00001a  f24063d5          MOV      r3,#0x6d5
00001e  4a19              LDR      r2,|L25.132|
000020  a119              ADR      r1,|L25.136|
000022  a01d              ADR      r0,|L25.152|
000024  f7fffffe          BL       rt_kprintf
                  |L25.40|
000028  f89d0000          LDRB     r0,[sp,#0]
00002c  2800              CMP      r0,#0
00002e  d0fb              BEQ      |L25.40|
                  |L25.48|
;;;1750   
;;;1751       /* init object */
;;;1752       rt_object_init(&(mq->parent.parent), RT_Object_Class_MessageQueue, name);
000030  4652              MOV      r2,r10
000032  2105              MOVS     r1,#5
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       rt_object_init
;;;1753   
;;;1754       /* set parent flag */
;;;1755       mq->parent.parent.flag = flag;
00003a  f8848009          STRB     r8,[r4,#9]
00003e  f1040014          ADD      r0,r4,#0x14
000042  61a0              STR      r0,[r4,#0x18]
;;;1756   
;;;1757       /* init ipc object */
;;;1758       rt_ipc_object_init(&(mq->parent));
;;;1759   
;;;1760       /* set messasge pool */
;;;1761       mq->msg_pool = msgpool;
;;;1762   
;;;1763       /* get correct message size */
;;;1764       mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
000044  61e7              STR      r7,[r4,#0x1c]
000046  6160              STR      r0,[r4,#0x14]
000048  f64f70f8          MOV      r0,#0xfff8
00004c  1df6              ADDS     r6,r6,#7
00004e  4006              ANDS     r6,r6,r0
000050  8426              STRH     r6,[r4,#0x20]
000052  1d36              ADDS     r6,r6,#4
;;;1765       mq->max_msgs = pool_size / (mq->msg_size + sizeof(struct rt_mq_message));
000054  fbb9f0f6          UDIV     r0,r9,r6
000058  8460              STRH     r0,[r4,#0x22]
;;;1766   
;;;1767       /* init message list */
;;;1768       mq->msg_queue_head = RT_NULL;
;;;1769       mq->msg_queue_tail = RT_NULL;
00005a  62a5              STR      r5,[r4,#0x28]
;;;1770   
;;;1771       /* init message empty list */
;;;1772       mq->msg_queue_free = RT_NULL;
00005c  62e5              STR      r5,[r4,#0x2c]
;;;1773       for (temp = 0; temp < mq->max_msgs; temp ++)
00005e  2000              MOVS     r0,#0
000060  6325              STR      r5,[r4,#0x30]
000062  e008              B        |L25.118|
                  |L25.100|
;;;1774       {
;;;1775           head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
000064  8c21              LDRH     r1,[r4,#0x20]
000066  69e2              LDR      r2,[r4,#0x1c]
000068  1d09              ADDS     r1,r1,#4
00006a  fb002101          MLA      r1,r0,r1,r2
;;;1776               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
;;;1777           head->next = mq->msg_queue_free;
00006e  6b22              LDR      r2,[r4,#0x30]
;;;1778           mq->msg_queue_free = head;
000070  600a              STR      r2,[r1,#0]
000072  1c40              ADDS     r0,r0,#1
000074  6321              STR      r1,[r4,#0x30]
                  |L25.118|
000076  8c61              LDRH     r1,[r4,#0x22]         ;1773
000078  4281              CMP      r1,r0                 ;1773
00007a  dcf3              BGT      |L25.100|
;;;1779       }
;;;1780   
;;;1781       /* the initial entry is zero */
;;;1782       mq->entry = 0;
00007c  84a5              STRH     r5,[r4,#0x24]
;;;1783   
;;;1784       return RT_EOK;
00007e  2000              MOVS     r0,#0
;;;1785   }
000080  e8bd8ff8          POP      {r3-r11,pc}
;;;1786   RTM_EXPORT(rt_mq_init);
                          ENDP

                  |L25.132|
                          DCD      ||.constdata||+0x174
                  |L25.136|
000088  6d712021          DCB      "mq != RT_NULL",0
00008c  3d205254
000090  5f4e554c
000094  4c00    
000096  00                DCB      0
000097  00                DCB      0
                  |L25.152|
000098  28257329          DCB      "(%s) assert failed at %s:%d \n",0
00009c  20617373
0000a0  65727420
0000a4  6661696c
0000a8  65642061
0000ac  74202573
0000b0  3a256420
0000b4  0a00    
0000b6  00                DCB      0
0000b7  00                DCB      0

                          AREA ||i.rt_mq_recv||, CODE, READONLY, ALIGN=2

                  rt_mq_recv PROC
;;;2094    */
;;;2095   rt_err_t rt_mq_recv(rt_mq_t    mq,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2096                       void      *buffer,
;;;2097                       rt_size_t  size,
;;;2098                       rt_int32_t timeout)
;;;2099   {
000004  b083              SUB      sp,sp,#0xc
000006  4690              MOV      r8,r2
000008  0004              MOVS     r4,r0
00000a  f04f0700          MOV      r7,#0
00000e  d10c              BNE      |L26.42|
;;;2100       struct rt_thread *thread;
;;;2101       register rt_ubase_t temp;
;;;2102       struct rt_mq_message *msg;
;;;2103       rt_uint32_t tick_delta;
;;;2104   
;;;2105       RT_ASSERT(mq != RT_NULL);
000010  f88d7000          STRB     r7,[sp,#0]
000014  f6400339          MOV      r3,#0x839
000018  4a69              LDR      r2,|L26.448|
00001a  a16a              ADR      r1,|L26.452|
00001c  a06d              ADR      r0,|L26.468|
00001e  f7fffffe          BL       rt_kprintf
                  |L26.34|
000022  f89d0000          LDRB     r0,[sp,#0]
000026  2800              CMP      r0,#0
000028  d0fb              BEQ      |L26.34|
                  |L26.42|
;;;2106       RT_ASSERT(buffer != RT_NULL);
00002a  9804              LDR      r0,[sp,#0x10]
00002c  b960              CBNZ     r0,|L26.72|
00002e  f88d7000          STRB     r7,[sp,#0]
000032  f640033a          MOV      r3,#0x83a
000036  4a62              LDR      r2,|L26.448|
000038  a16e              ADR      r1,|L26.500|
00003a  a066              ADR      r0,|L26.468|
00003c  f7fffffe          BL       rt_kprintf
                  |L26.64|
000040  f89d0000          LDRB     r0,[sp,#0]
000044  2800              CMP      r0,#0
000046  d0fb              BEQ      |L26.64|
                  |L26.72|
;;;2107       RT_ASSERT(size != 0);
000048  f1b80f00          CMP      r8,#0
00004c  d10c              BNE      |L26.104|
00004e  f88d7000          STRB     r7,[sp,#0]
000052  f640033b          MOV      r3,#0x83b
000056  4a5a              LDR      r2,|L26.448|
000058  a16b              ADR      r1,|L26.520|
00005a  a05e              ADR      r0,|L26.468|
00005c  f7fffffe          BL       rt_kprintf
                  |L26.96|
000060  f89d0000          LDRB     r0,[sp,#0]
000064  2800              CMP      r0,#0
000066  d0fb              BEQ      |L26.96|
                  |L26.104|
;;;2108   
;;;2109       /* initialize delta tick */
;;;2110       tick_delta = 0;
000068  2600              MOVS     r6,#0
;;;2111       /* get current thread */
;;;2112       thread = rt_thread_self();
00006a  f7fffffe          BL       rt_thread_self
00006e  4605              MOV      r5,r0
;;;2113       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
000070  4868              LDR      r0,|L26.532|
000072  6801              LDR      r1,[r0,#0]  ; rt_object_trytake_hook
000074  b109              CBZ      r1,|L26.122|
000076  4620              MOV      r0,r4
000078  4788              BLX      r1
                  |L26.122|
;;;2114   
;;;2115       /* disable interrupt */
;;;2116       temp = rt_hw_interrupt_disable();
00007a  f7fffffe          BL       rt_hw_interrupt_disable
00007e  4681              MOV      r9,r0
;;;2117   
;;;2118       /* for non-blocking call */
;;;2119       if (mq->entry == 0 && timeout == 0)
000080  8ca0              LDRH     r0,[r4,#0x24]
000082  9906              LDR      r1,[sp,#0x18]
;;;2120       {
;;;2121           rt_hw_interrupt_enable(temp);
;;;2122   
;;;2123           return -RT_ETIMEOUT;
000084  f06f0b01          MVN      r11,#1
000088  4308              ORRS     r0,r0,r1              ;2119
00008a  d169              BNE      |L26.352|
00008c  4648              MOV      r0,r9                 ;2121
00008e  f7fffffe          BL       rt_hw_interrupt_enable
000092  4658              MOV      r0,r11
                  |L26.148|
;;;2124       }
;;;2125   
;;;2126       /* message queue is empty */
;;;2127       while (mq->entry == 0)
;;;2128       {
;;;2129           RT_DEBUG_IN_THREAD_CONTEXT;
;;;2130   
;;;2131           /* reset error number in thread */
;;;2132           thread->error = RT_EOK;
;;;2133   
;;;2134           /* no waiting, return timeout */
;;;2135           if (timeout == 0)
;;;2136           {
;;;2137               /* enable interrupt */
;;;2138               rt_hw_interrupt_enable(temp);
;;;2139   
;;;2140               thread->error = -RT_ETIMEOUT;
;;;2141   
;;;2142               return -RT_ETIMEOUT;
;;;2143           }
;;;2144   
;;;2145           /* suspend current thread */
;;;2146           rt_ipc_list_suspend(&(mq->parent.suspend_thread),
;;;2147                               thread,
;;;2148                               mq->parent.parent.flag);
;;;2149   
;;;2150           /* has waiting time, start thread timer */
;;;2151           if (timeout > 0)
;;;2152           {
;;;2153               /* get the start tick of timer */
;;;2154               tick_delta = rt_tick_get();
;;;2155   
;;;2156               RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
;;;2157                                           thread->name));
;;;2158   
;;;2159               /* reset the timeout of thread timer and start it */
;;;2160               rt_timer_control(&(thread->thread_timer),
;;;2161                                RT_TIMER_CTRL_SET_TIME,
;;;2162                                &timeout);
;;;2163               rt_timer_start(&(thread->thread_timer));
;;;2164           }
;;;2165   
;;;2166           /* enable interrupt */
;;;2167           rt_hw_interrupt_enable(temp);
;;;2168   
;;;2169           /* re-schedule */
;;;2170           rt_schedule();
;;;2171   
;;;2172           /* recv message */
;;;2173           if (thread->error != RT_EOK)
;;;2174           {
;;;2175               /* return error */
;;;2176               return thread->error;
;;;2177           }
;;;2178   
;;;2179           /* disable interrupt */
;;;2180           temp = rt_hw_interrupt_disable();
;;;2181   
;;;2182           /* if it's not waiting forever and then re-calculate timeout tick */
;;;2183           if (timeout > 0)
;;;2184           {
;;;2185               tick_delta = rt_tick_get() - tick_delta;
;;;2186               timeout -= tick_delta;
;;;2187               if (timeout < 0)
;;;2188                   timeout = 0;
;;;2189           }
;;;2190       }
;;;2191   
;;;2192       /* get message from queue */
;;;2193       msg = (struct rt_mq_message *)mq->msg_queue_head;
;;;2194   
;;;2195       /* move message queue head */
;;;2196       mq->msg_queue_head = msg->next;
;;;2197       /* reach queue tail, set to NULL */
;;;2198       if (mq->msg_queue_tail == msg)
;;;2199           mq->msg_queue_tail = RT_NULL;
;;;2200   
;;;2201       /* decrease message entry */
;;;2202       mq->entry --;
;;;2203   
;;;2204       /* enable interrupt */
;;;2205       rt_hw_interrupt_enable(temp);
;;;2206   
;;;2207       /* copy message */
;;;2208       rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
;;;2209   
;;;2210       /* disable interrupt */
;;;2211       temp = rt_hw_interrupt_disable();
;;;2212       /* put message to free list */
;;;2213       msg->next = (struct rt_mq_message *)mq->msg_queue_free;
;;;2214       mq->msg_queue_free = msg;
;;;2215       /* enable interrupt */
;;;2216       rt_hw_interrupt_enable(temp);
;;;2217   
;;;2218       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
;;;2219   
;;;2220       return RT_EOK;
;;;2221   }
000094  b007              ADD      sp,sp,#0x1c
000096  e8bd8ff0          POP      {r4-r11,pc}
                  |L26.154|
00009a  f7fffffe          BL       rt_hw_interrupt_disable
00009e  9000              STR      r0,[sp,#0]            ;2129
0000a0  f7fffffe          BL       rt_thread_self
0000a4  b980              CBNZ     r0,|L26.200|
0000a6  4946              LDR      r1,|L26.448|
0000a8  a05b              ADR      r0,|L26.536|
0000aa  f7fffffe          BL       rt_kprintf
0000ae  f88d7004          STRB     r7,[sp,#4]            ;2129
0000b2  f6400351          MOV      r3,#0x851             ;2129
0000b6  4a42              LDR      r2,|L26.448|
0000b8  a155              ADR      r1,|L26.528|
0000ba  a046              ADR      r0,|L26.468|
0000bc  f7fffffe          BL       rt_kprintf
                  |L26.192|
0000c0  f89d0004          LDRB     r0,[sp,#4]            ;2129
0000c4  2800              CMP      r0,#0                 ;2129
0000c6  d0fb              BEQ      |L26.192|
                  |L26.200|
0000c8  f7fffffe          BL       rt_hw_interrupt_disable
0000cc  4682              MOV      r10,r0                ;2129
0000ce  f7fffffe          BL       rt_interrupt_get_nest
0000d2  b180              CBZ      r0,|L26.246|
0000d4  493a              LDR      r1,|L26.448|
0000d6  a05e              ADR      r0,|L26.592|
0000d8  f7fffffe          BL       rt_kprintf
0000dc  f88d7004          STRB     r7,[sp,#4]            ;2129
0000e0  f6400351          MOV      r3,#0x851             ;2129
0000e4  4a36              LDR      r2,|L26.448|
0000e6  a14a              ADR      r1,|L26.528|
0000e8  a03a              ADR      r0,|L26.468|
0000ea  f7fffffe          BL       rt_kprintf
                  |L26.238|
0000ee  f89d0004          LDRB     r0,[sp,#4]            ;2129
0000f2  2800              CMP      r0,#0                 ;2129
0000f4  d0fb              BEQ      |L26.238|
                  |L26.246|
0000f6  4650              MOV      r0,r10                ;2129
0000f8  f7fffffe          BL       rt_hw_interrupt_enable
0000fc  9800              LDR      r0,[sp,#0]            ;2129
0000fe  f7fffffe          BL       rt_hw_interrupt_enable
000102  632f              STR      r7,[r5,#0x30]         ;2135
000104  9806              LDR      r0,[sp,#0x18]         ;2135
000106  b3e8              CBZ      r0,|L26.388|
000108  7a62              LDRB     r2,[r4,#9]            ;2146
00010a  4629              MOV      r1,r5                 ;2146
00010c  f1040014          ADD      r0,r4,#0x14           ;2146
000110  f7fffffe          BL       rt_ipc_list_suspend
000114  9806              LDR      r0,[sp,#0x18]         ;2151
000116  2800              CMP      r0,#0                 ;2151
000118  dd0c              BLE      |L26.308|
00011a  f7fffffe          BL       rt_tick_get
00011e  4606              MOV      r6,r0                 ;2154
000120  f105004c          ADD      r0,r5,#0x4c           ;2160
000124  aa06              ADD      r2,sp,#0x18           ;2160
000126  2100              MOVS     r1,#0                 ;2160
000128  4682              MOV      r10,r0                ;2160
00012a  f7fffffe          BL       rt_timer_control
00012e  4650              MOV      r0,r10                ;2160
000130  f7fffffe          BL       rt_timer_start
                  |L26.308|
000134  4648              MOV      r0,r9                 ;2167
000136  f7fffffe          BL       rt_hw_interrupt_enable
00013a  f7fffffe          BL       rt_schedule
00013e  6b28              LDR      r0,[r5,#0x30]         ;2173
000140  2800              CMP      r0,#0                 ;2173
000142  d1a7              BNE      |L26.148|
000144  f7fffffe          BL       rt_hw_interrupt_disable
000148  4681              MOV      r9,r0                 ;2180
00014a  9806              LDR      r0,[sp,#0x18]         ;2183
00014c  2800              CMP      r0,#0                 ;2183
00014e  dd07              BLE      |L26.352|
000150  f7fffffe          BL       rt_tick_get
000154  1b86              SUBS     r6,r0,r6              ;2185
000156  9806              LDR      r0,[sp,#0x18]         ;2186
000158  1b80              SUBS     r0,r0,r6              ;2186
00015a  9006              STR      r0,[sp,#0x18]         ;2187
00015c  d500              BPL      |L26.352|
00015e  9706              STR      r7,[sp,#0x18]         ;2188
                  |L26.352|
000160  8ca0              LDRH     r0,[r4,#0x24]         ;2127
000162  2800              CMP      r0,#0                 ;2127
000164  d099              BEQ      |L26.154|
000166  6aa5              LDR      r5,[r4,#0x28]         ;2196
000168  6828              LDR      r0,[r5,#0]            ;2196
00016a  62a0              STR      r0,[r4,#0x28]         ;2198
00016c  6ae0              LDR      r0,[r4,#0x2c]         ;2198
00016e  42a8              CMP      r0,r5                 ;2198
000170  d100              BNE      |L26.372|
000172  62e7              STR      r7,[r4,#0x2c]         ;2199
                  |L26.372|
000174  8ca0              LDRH     r0,[r4,#0x24]         ;2202
000176  1e40              SUBS     r0,r0,#1              ;2202
000178  84a0              STRH     r0,[r4,#0x24]         ;2202
00017a  4648              MOV      r0,r9                 ;2205
00017c  f7fffffe          BL       rt_hw_interrupt_enable
000180  8c22              LDRH     r2,[r4,#0x20]         ;2208
000182  e000              B        |L26.390|
                  |L26.388|
000184  e015              B        |L26.434|
                  |L26.390|
000186  4640              MOV      r0,r8                 ;2208
000188  4542              CMP      r2,r8                 ;2208
00018a  d300              BCC      |L26.398|
00018c  4602              MOV      r2,r0                 ;2208
                  |L26.398|
00018e  1d29              ADDS     r1,r5,#4              ;2208
000190  9804              LDR      r0,[sp,#0x10]         ;2208
000192  f7fffffe          BL       rt_memcpy
000196  f7fffffe          BL       rt_hw_interrupt_disable
00019a  6b21              LDR      r1,[r4,#0x30]         ;2213
00019c  6029              STR      r1,[r5,#0]            ;2214
00019e  6325              STR      r5,[r4,#0x30]         ;2216
0001a0  f7fffffe          BL       rt_hw_interrupt_enable
0001a4  4833              LDR      r0,|L26.628|
0001a6  6801              LDR      r1,[r0,#0]            ;2218  ; rt_object_take_hook
0001a8  b109              CBZ      r1,|L26.430|
0001aa  4620              MOV      r0,r4                 ;2218
0001ac  4788              BLX      r1                    ;2218
                  |L26.430|
0001ae  2000              MOVS     r0,#0                 ;2220
0001b0  e770              B        |L26.148|
                  |L26.434|
0001b2  4648              MOV      r0,r9                 ;2138
0001b4  f7fffffe          BL       rt_hw_interrupt_enable
0001b8  4658              MOV      r0,r11                ;2140
0001ba  f8c5b030          STR      r11,[r5,#0x30]        ;2140
0001be  e769              B        |L26.148|
;;;2222   RTM_EXPORT(rt_mq_recv);
                          ENDP

                  |L26.448|
                          DCD      ||.constdata||+0x1be
                  |L26.452|
0001c4  6d712021          DCB      "mq != RT_NULL",0
0001c8  3d205254
0001cc  5f4e554c
0001d0  4c00    
0001d2  00                DCB      0
0001d3  00                DCB      0
                  |L26.468|
0001d4  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0001d8  20617373
0001dc  65727420
0001e0  6661696c
0001e4  65642061
0001e8  74202573
0001ec  3a256420
0001f0  0a00    
0001f2  00                DCB      0
0001f3  00                DCB      0
                  |L26.500|
0001f4  62756666          DCB      "buffer != RT_NULL",0
0001f8  65722021
0001fc  3d205254
000200  5f4e554c
000204  4c00    
000206  00                DCB      0
000207  00                DCB      0
                  |L26.520|
000208  73697a65          DCB      "size != "
00020c  20213d20
                  |L26.528|
000210  3000              DCB      "0",0
000212  00                DCB      0
000213  00                DCB      0
                  |L26.532|
                          DCD      rt_object_trytake_hook
                  |L26.536|
000218  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
00021c  74696f6e
000220  5b25735d
000224  20736861
000228  6c6c206e
00022c  6f742062
000230  65207573
000234  65642062
000238  65666f72
00023c  65207363
000240  68656475
000244  6c657220
000248  73746172
00024c  740a    
00024e  00                DCB      0
00024f  00                DCB      0
                  |L26.592|
000250  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000254  74696f6e
000258  5b25735d
00025c  20736861
000260  6c6c206e
000264  6f742075
000268  73656420
00026c  696e2049
000270  53520a00
                  |L26.628|
                          DCD      rt_object_take_hook

                          AREA ||i.rt_mq_send||, CODE, READONLY, ALIGN=2

                  rt_mq_send PROC
;;;1923    */
;;;1924   rt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1925   {
000004  4617              MOV      r7,r2
000006  4688              MOV      r8,r1
000008  0004              MOVS     r4,r0
00000a  f04f0600          MOV      r6,#0
00000e  d10c              BNE      |L27.42|
;;;1926       register rt_ubase_t temp;
;;;1927       struct rt_mq_message *msg;
;;;1928   
;;;1929       RT_ASSERT(mq != RT_NULL);
000010  f88d6000          STRB     r6,[sp,#0]
000014  f2407389          MOV      r3,#0x789
000018  4a33              LDR      r2,|L27.232|
00001a  a134              ADR      r1,|L27.236|
00001c  a037              ADR      r0,|L27.252|
00001e  f7fffffe          BL       rt_kprintf
                  |L27.34|
000022  f89d0000          LDRB     r0,[sp,#0]
000026  2800              CMP      r0,#0
000028  d0fb              BEQ      |L27.34|
                  |L27.42|
;;;1930       RT_ASSERT(buffer != RT_NULL);
00002a  f1b80f00          CMP      r8,#0
00002e  d10c              BNE      |L27.74|
000030  f88d6000          STRB     r6,[sp,#0]
000034  f240738a          MOV      r3,#0x78a
000038  4a2b              LDR      r2,|L27.232|
00003a  a138              ADR      r1,|L27.284|
00003c  a02f              ADR      r0,|L27.252|
00003e  f7fffffe          BL       rt_kprintf
                  |L27.66|
000042  f89d0000          LDRB     r0,[sp,#0]
000046  2800              CMP      r0,#0
000048  d0fb              BEQ      |L27.66|
                  |L27.74|
;;;1931       RT_ASSERT(size != 0);
00004a  b967              CBNZ     r7,|L27.102|
00004c  f88d6000          STRB     r6,[sp,#0]
000050  f240738b          MOV      r3,#0x78b
000054  4a24              LDR      r2,|L27.232|
000056  a136              ADR      r1,|L27.304|
000058  a028              ADR      r0,|L27.252|
00005a  f7fffffe          BL       rt_kprintf
                  |L27.94|
00005e  f89d0000          LDRB     r0,[sp,#0]
000062  2800              CMP      r0,#0
000064  d0fb              BEQ      |L27.94|
                  |L27.102|
;;;1932   
;;;1933       /* greater than one message size */
;;;1934       if (size > mq->msg_size)
000066  8c20              LDRH     r0,[r4,#0x20]
000068  42b8              CMP      r0,r7
00006a  d203              BCS      |L27.116|
;;;1935           return -RT_ERROR;
00006c  f04f30ff          MOV      r0,#0xffffffff
                  |L27.112|
;;;1936   
;;;1937       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
;;;1938   
;;;1939       /* disable interrupt */
;;;1940       temp = rt_hw_interrupt_disable();
;;;1941   
;;;1942       /* get a free list, there must be an empty item */
;;;1943       msg = (struct rt_mq_message*)mq->msg_queue_free;
;;;1944       /* message queue is full */
;;;1945       if (msg == RT_NULL)
;;;1946       {
;;;1947           /* enable interrupt */
;;;1948           rt_hw_interrupt_enable(temp);
;;;1949   
;;;1950           return -RT_EFULL;
;;;1951       }
;;;1952       /* move free list pointer */
;;;1953       mq->msg_queue_free = msg->next;
;;;1954   
;;;1955       /* enable interrupt */
;;;1956       rt_hw_interrupt_enable(temp);
;;;1957   
;;;1958       /* the msg is the new tailer of list, the next shall be NULL */
;;;1959       msg->next = RT_NULL;
;;;1960       /* copy buffer */
;;;1961       rt_memcpy(msg + 1, buffer, size);
;;;1962   
;;;1963       /* disable interrupt */
;;;1964       temp = rt_hw_interrupt_disable();
;;;1965       /* link msg to message queue */
;;;1966       if (mq->msg_queue_tail != RT_NULL)
;;;1967       {
;;;1968           /* if the tail exists, */
;;;1969           ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
;;;1970       }
;;;1971   
;;;1972       /* set new tail */
;;;1973       mq->msg_queue_tail = msg;
;;;1974       /* if the head is empty, set head */
;;;1975       if (mq->msg_queue_head == RT_NULL)
;;;1976           mq->msg_queue_head = msg;
;;;1977   
;;;1978       /* increase message entry */
;;;1979       mq->entry ++;
;;;1980   
;;;1981       /* resume suspended thread */
;;;1982       if (!rt_list_isempty(&mq->parent.suspend_thread))
;;;1983       {
;;;1984           rt_ipc_list_resume(&(mq->parent.suspend_thread));
;;;1985   
;;;1986           /* enable interrupt */
;;;1987           rt_hw_interrupt_enable(temp);
;;;1988   
;;;1989           rt_schedule();
;;;1990   
;;;1991           return RT_EOK;
;;;1992       }
;;;1993   
;;;1994       /* enable interrupt */
;;;1995       rt_hw_interrupt_enable(temp);
;;;1996   
;;;1997       return RT_EOK;
;;;1998   }
000070  e8bd83f8          POP      {r3-r9,pc}
                  |L27.116|
000074  4831              LDR      r0,|L27.316|
000076  6801              LDR      r1,[r0,#0]            ;1937  ; rt_object_put_hook
000078  b109              CBZ      r1,|L27.126|
00007a  4620              MOV      r0,r4                 ;1937
00007c  4788              BLX      r1                    ;1937
                  |L27.126|
00007e  f7fffffe          BL       rt_hw_interrupt_disable
000082  6b25              LDR      r5,[r4,#0x30]         ;1945
000084  b19d              CBZ      r5,|L27.174|
000086  6829              LDR      r1,[r5,#0]            ;1953
000088  6321              STR      r1,[r4,#0x30]         ;1956
00008a  f7fffffe          BL       rt_hw_interrupt_enable
00008e  463a              MOV      r2,r7                 ;1961
000090  4641              MOV      r1,r8                 ;1961
000092  1d28              ADDS     r0,r5,#4              ;1961
000094  602e              STR      r6,[r5,#0]            ;1961
000096  f7fffffe          BL       rt_memcpy
00009a  f7fffffe          BL       rt_hw_interrupt_disable
00009e  4606              MOV      r6,r0                 ;1964
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;1966
0000a2  b100              CBZ      r0,|L27.166|
0000a4  6005              STR      r5,[r0,#0]            ;1969
                  |L27.166|
0000a6  62e5              STR      r5,[r4,#0x2c]         ;1975
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;1975
0000aa  b128              CBZ      r0,|L27.184|
0000ac  e005              B        |L27.186|
                  |L27.174|
0000ae  f7fffffe          BL       rt_hw_interrupt_enable
0000b2  f06f0002          MVN      r0,#2                 ;1950
0000b6  e7db              B        |L27.112|
                  |L27.184|
0000b8  62a5              STR      r5,[r4,#0x28]         ;1976
                  |L27.186|
0000ba  8ca0              LDRH     r0,[r4,#0x24]         ;1979
0000bc  1c40              ADDS     r0,r0,#1              ;1979
0000be  84a0              STRH     r0,[r4,#0x24]         ;1979
0000c0  f1040014          ADD      r0,r4,#0x14           ;1982
0000c4  4604              MOV      r4,r0                 ;1982
0000c6  f7fffffe          BL       rt_list_isempty
0000ca  b120              CBZ      r0,|L27.214|
0000cc  4630              MOV      r0,r6                 ;1995
0000ce  f7fffffe          BL       rt_hw_interrupt_enable
                  |L27.210|
0000d2  2000              MOVS     r0,#0                 ;1997
0000d4  e7cc              B        |L27.112|
                  |L27.214|
0000d6  4620              MOV      r0,r4
0000d8  f7fffffe          BL       rt_ipc_list_resume
0000dc  4630              MOV      r0,r6                 ;1987
0000de  f7fffffe          BL       rt_hw_interrupt_enable
0000e2  f7fffffe          BL       rt_schedule
0000e6  e7f4              B        |L27.210|
;;;1999   RTM_EXPORT(rt_mq_send);
                          ENDP

                  |L27.232|
                          DCD      ||.constdata||+0x1a6
                  |L27.236|
0000ec  6d712021          DCB      "mq != RT_NULL",0
0000f0  3d205254
0000f4  5f4e554c
0000f8  4c00    
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L27.252|
0000fc  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000100  20617373
000104  65727420
000108  6661696c
00010c  65642061
000110  74202573
000114  3a256420
000118  0a00    
00011a  00                DCB      0
00011b  00                DCB      0
                  |L27.284|
00011c  62756666          DCB      "buffer != RT_NULL",0
000120  65722021
000124  3d205254
000128  5f4e554c
00012c  4c00    
00012e  00                DCB      0
00012f  00                DCB      0
                  |L27.304|
000130  73697a65          DCB      "size != 0",0
000134  20213d20
000138  3000    
00013a  00                DCB      0
00013b  00                DCB      0
                  |L27.316|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_mq_urgent||, CODE, READONLY, ALIGN=2

                  rt_mq_urgent PROC
;;;2011    */
;;;2012   rt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2013   {
000002  4616              MOV      r6,r2
000004  460f              MOV      r7,r1
000006  0004              MOVS     r4,r0
000008  f04f0500          MOV      r5,#0
00000c  d10c              BNE      |L28.40|
;;;2014       register rt_ubase_t temp;
;;;2015       struct rt_mq_message *msg;
;;;2016   
;;;2017       RT_ASSERT(mq != RT_NULL);
00000e  f88d5000          STRB     r5,[sp,#0]
000012  f24073e1          MOV      r3,#0x7e1
000016  4a31              LDR      r2,|L28.220|
000018  a131              ADR      r1,|L28.224|
00001a  a035              ADR      r0,|L28.240|
00001c  f7fffffe          BL       rt_kprintf
                  |L28.32|
000020  f89d0000          LDRB     r0,[sp,#0]
000024  2800              CMP      r0,#0
000026  d0fb              BEQ      |L28.32|
                  |L28.40|
;;;2018       RT_ASSERT(buffer != RT_NULL);
000028  b967              CBNZ     r7,|L28.68|
00002a  f88d5000          STRB     r5,[sp,#0]
00002e  f24073e2          MOV      r3,#0x7e2
000032  4a2a              LDR      r2,|L28.220|
000034  a136              ADR      r1,|L28.272|
000036  a02e              ADR      r0,|L28.240|
000038  f7fffffe          BL       rt_kprintf
                  |L28.60|
00003c  f89d0000          LDRB     r0,[sp,#0]
000040  2800              CMP      r0,#0
000042  d0fb              BEQ      |L28.60|
                  |L28.68|
;;;2019       RT_ASSERT(size != 0);
000044  b966              CBNZ     r6,|L28.96|
000046  f88d5000          STRB     r5,[sp,#0]
00004a  f24073e3          MOV      r3,#0x7e3
00004e  4a23              LDR      r2,|L28.220|
000050  a134              ADR      r1,|L28.292|
000052  a027              ADR      r0,|L28.240|
000054  f7fffffe          BL       rt_kprintf
                  |L28.88|
000058  f89d0000          LDRB     r0,[sp,#0]
00005c  2800              CMP      r0,#0
00005e  d0fb              BEQ      |L28.88|
                  |L28.96|
;;;2020   
;;;2021       /* greater than one message size */
;;;2022       if (size > mq->msg_size)
000060  8c20              LDRH     r0,[r4,#0x20]
000062  42b0              CMP      r0,r6
000064  d202              BCS      |L28.108|
;;;2023           return -RT_ERROR;
000066  f04f30ff          MOV      r0,#0xffffffff
;;;2024   
;;;2025       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
;;;2026   
;;;2027       /* disable interrupt */
;;;2028       temp = rt_hw_interrupt_disable();
;;;2029   
;;;2030       /* get a free list, there must be an empty item */
;;;2031       msg = (struct rt_mq_message *)mq->msg_queue_free;
;;;2032       /* message queue is full */
;;;2033       if (msg == RT_NULL)
;;;2034       {
;;;2035           /* enable interrupt */
;;;2036           rt_hw_interrupt_enable(temp);
;;;2037   
;;;2038           return -RT_EFULL;
;;;2039       }
;;;2040       /* move free list pointer */
;;;2041       mq->msg_queue_free = msg->next;
;;;2042   
;;;2043       /* enable interrupt */
;;;2044       rt_hw_interrupt_enable(temp);
;;;2045   
;;;2046       /* copy buffer */
;;;2047       rt_memcpy(msg + 1, buffer, size);
;;;2048   
;;;2049       /* disable interrupt */
;;;2050       temp = rt_hw_interrupt_disable();
;;;2051   
;;;2052       /* link msg to the beginning of message queue */
;;;2053       msg->next = mq->msg_queue_head;
;;;2054       mq->msg_queue_head = msg;
;;;2055   
;;;2056       /* if there is no tail */
;;;2057       if (mq->msg_queue_tail == RT_NULL)
;;;2058           mq->msg_queue_tail = msg;
;;;2059   
;;;2060       /* increase message entry */
;;;2061       mq->entry ++;
;;;2062   
;;;2063       /* resume suspended thread */
;;;2064       if (!rt_list_isempty(&mq->parent.suspend_thread))
;;;2065       {
;;;2066           rt_ipc_list_resume(&(mq->parent.suspend_thread));
;;;2067   
;;;2068           /* enable interrupt */
;;;2069           rt_hw_interrupt_enable(temp);
;;;2070   
;;;2071           rt_schedule();
;;;2072   
;;;2073           return RT_EOK;
;;;2074       }
;;;2075   
;;;2076       /* enable interrupt */
;;;2077       rt_hw_interrupt_enable(temp);
;;;2078   
;;;2079       return RT_EOK;
;;;2080   }
00006a  bdf8              POP      {r3-r7,pc}
                  |L28.108|
00006c  4830              LDR      r0,|L28.304|
00006e  6801              LDR      r1,[r0,#0]            ;2025  ; rt_object_put_hook
000070  b109              CBZ      r1,|L28.118|
000072  4620              MOV      r0,r4                 ;2025
000074  4788              BLX      r1                    ;2025
                  |L28.118|
000076  f7fffffe          BL       rt_hw_interrupt_disable
00007a  6b25              LDR      r5,[r4,#0x30]         ;2033
00007c  b18d              CBZ      r5,|L28.162|
00007e  6829              LDR      r1,[r5,#0]            ;2041
000080  6321              STR      r1,[r4,#0x30]         ;2044
000082  f7fffffe          BL       rt_hw_interrupt_enable
000086  4632              MOV      r2,r6                 ;2047
000088  4639              MOV      r1,r7                 ;2047
00008a  1d28              ADDS     r0,r5,#4              ;2047
00008c  f7fffffe          BL       rt_memcpy
000090  f7fffffe          BL       rt_hw_interrupt_disable
000094  4606              MOV      r6,r0                 ;2050
000096  6aa0              LDR      r0,[r4,#0x28]         ;2053
000098  6028              STR      r0,[r5,#0]            ;2054
00009a  62a5              STR      r5,[r4,#0x28]         ;2057
00009c  6ae0              LDR      r0,[r4,#0x2c]         ;2057
00009e  b128              CBZ      r0,|L28.172|
0000a0  e005              B        |L28.174|
                  |L28.162|
0000a2  f7fffffe          BL       rt_hw_interrupt_enable
0000a6  f06f0002          MVN      r0,#2                 ;2038
0000aa  bdf8              POP      {r3-r7,pc}
                  |L28.172|
0000ac  62e5              STR      r5,[r4,#0x2c]         ;2058
                  |L28.174|
0000ae  8ca0              LDRH     r0,[r4,#0x24]         ;2061
0000b0  1c40              ADDS     r0,r0,#1              ;2061
0000b2  84a0              STRH     r0,[r4,#0x24]         ;2061
0000b4  f1040014          ADD      r0,r4,#0x14           ;2064
0000b8  4604              MOV      r4,r0                 ;2064
0000ba  f7fffffe          BL       rt_list_isempty
0000be  b120              CBZ      r0,|L28.202|
0000c0  4630              MOV      r0,r6                 ;2077
0000c2  f7fffffe          BL       rt_hw_interrupt_enable
                  |L28.198|
0000c6  2000              MOVS     r0,#0                 ;2079
0000c8  bdf8              POP      {r3-r7,pc}
                  |L28.202|
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       rt_ipc_list_resume
0000d0  4630              MOV      r0,r6                 ;2069
0000d2  f7fffffe          BL       rt_hw_interrupt_enable
0000d6  f7fffffe          BL       rt_schedule
0000da  e7f4              B        |L28.198|
;;;2081   RTM_EXPORT(rt_mq_urgent);
                          ENDP

                  |L28.220|
                          DCD      ||.constdata||+0x1b1
                  |L28.224|
0000e0  6d712021          DCB      "mq != RT_NULL",0
0000e4  3d205254
0000e8  5f4e554c
0000ec  4c00    
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L28.240|
0000f0  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000f4  20617373
0000f8  65727420
0000fc  6661696c
000100  65642061
000104  74202573
000108  3a256420
00010c  0a00    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L28.272|
000110  62756666          DCB      "buffer != RT_NULL",0
000114  65722021
000118  3d205254
00011c  5f4e554c
000120  4c00    
000122  00                DCB      0
000123  00                DCB      0
                  |L28.292|
000124  73697a65          DCB      "size != 0",0
000128  20213d20
00012c  3000    
00012e  00                DCB      0
00012f  00                DCB      0
                  |L28.304|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_mutex_control||, CODE, READONLY, ALIGN=1

                  rt_mutex_control PROC
;;;870     */
;;;871    rt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg)
000000  f04f30ff          MOV      r0,#0xffffffff
;;;872    {
;;;873        return -RT_ERROR;
;;;874    }
000004  4770              BX       lr
;;;875    RTM_EXPORT(rt_mutex_control);
                          ENDP


                          AREA ||i.rt_mutex_create||, CODE, READONLY, ALIGN=2

                  rt_mutex_create PROC
;;;580     */
;;;581    rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
000000  b5f8              PUSH     {r3-r7,lr}
;;;582    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;583        struct rt_mutex *mutex;
;;;584    
;;;585        RT_DEBUG_NOT_IN_INTERRUPT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4607              MOV      r7,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  2400              MOVS     r4,#0
000012  b180              CBZ      r0,|L30.54|
000014  4912              LDR      r1,|L30.96|
000016  a013              ADR      r0,|L30.100|
000018  f7fffffe          BL       rt_kprintf
00001c  f88d4000          STRB     r4,[sp,#0]
000020  f2402349          MOV      r3,#0x249
000024  4a0e              LDR      r2,|L30.96|
000026  a118              ADR      r1,|L30.136|
000028  a018              ADR      r0,|L30.140|
00002a  f7fffffe          BL       rt_kprintf
                  |L30.46|
00002e  f89d0000          LDRB     r0,[sp,#0]
000032  2800              CMP      r0,#0
000034  d0fb              BEQ      |L30.46|
                  |L30.54|
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       rt_hw_interrupt_enable
;;;586    
;;;587        /* allocate object */
;;;588        mutex = (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name);
00003c  4631              MOV      r1,r6
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       rt_object_allocate
;;;589        if (mutex == RT_NULL)
000044  2800              CMP      r0,#0
000046  d00a              BEQ      |L30.94|
000048  f1000114          ADD      r1,r0,#0x14
00004c  6181              STR      r1,[r0,#0x18]
;;;590            return mutex;
;;;591    
;;;592        /* init ipc object */
;;;593        rt_ipc_object_init(&(mutex->parent));
;;;594    
;;;595        mutex->value              = 1;
00004e  6141              STR      r1,[r0,#0x14]
000050  2101              MOVS     r1,#1
000052  8381              STRH     r1,[r0,#0x1c]
;;;596        mutex->owner              = RT_NULL;
;;;597        mutex->original_priority  = 0xFF;
000054  21ff              MOVS     r1,#0xff
000056  6204              STR      r4,[r0,#0x20]
000058  7781              STRB     r1,[r0,#0x1e]
;;;598        mutex->hold               = 0;
00005a  77c4              STRB     r4,[r0,#0x1f]
;;;599    
;;;600        /* set flag */
;;;601        mutex->parent.parent.flag = flag;
00005c  7245              STRB     r5,[r0,#9]
                  |L30.94|
;;;602    
;;;603        return mutex;
;;;604    }
00005e  bdf8              POP      {r3-r7,pc}
;;;605    RTM_EXPORT(rt_mutex_create);
                          ENDP

                  |L30.96|
                          DCD      ||.constdata||+0x6f
                  |L30.100|
000064  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000068  74696f6e
00006c  5b25735d
000070  20736861
000074  6c6c206e
000078  6f742075
00007c  73656420
000080  696e2049
000084  53520a00
                  |L30.136|
000088  3000              DCB      "0",0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L30.140|
00008c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000090  20617373
000094  65727420
000098  6661696c
00009c  65642061
0000a0  74202573
0000a4  3a256420
0000a8  0a00    
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.rt_mutex_delete||, CODE, READONLY, ALIGN=2

                  rt_mutex_delete PROC
;;;615     */
;;;616    rt_err_t rt_mutex_delete(rt_mutex_t mutex)
000000  b5f8              PUSH     {r3-r7,lr}
;;;617    {
000002  4604              MOV      r4,r0
;;;618        RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4606              MOV      r6,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2500              MOVS     r5,#0
000010  b180              CBZ      r0,|L31.52|
000012  4915              LDR      r1,|L31.104|
000014  a015              ADR      r0,|L31.108|
000016  f7fffffe          BL       rt_kprintf
00001a  f88d5000          STRB     r5,[sp,#0]
00001e  f240236a          MOV      r3,#0x26a
000022  4a11              LDR      r2,|L31.104|
000024  a11a              ADR      r1,|L31.144|
000026  a01b              ADR      r0,|L31.148|
000028  f7fffffe          BL       rt_kprintf
                  |L31.44|
00002c  f89d1000          LDRB     r1,[sp,#0]
000030  2900              CMP      r1,#0
000032  d0fb              BEQ      |L31.44|
                  |L31.52|
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       rt_hw_interrupt_enable
;;;619    
;;;620        RT_ASSERT(mutex != RT_NULL);
00003a  b964              CBNZ     r4,|L31.86|
00003c  f88d5000          STRB     r5,[sp,#0]
000040  f44f731b          MOV      r3,#0x26c
000044  4a08              LDR      r2,|L31.104|
000046  a11b              ADR      r1,|L31.180|
000048  a012              ADR      r0,|L31.148|
00004a  f7fffffe          BL       rt_kprintf
                  |L31.78|
00004e  f89d1000          LDRB     r1,[sp,#0]
000052  2900              CMP      r1,#0
000054  d0fb              BEQ      |L31.78|
                  |L31.86|
;;;621    
;;;622        /* wakeup all suspend threads */
;;;623        rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
000056  f1040014          ADD      r0,r4,#0x14
00005a  f7fffffe          BL       rt_ipc_list_resume_all
;;;624    
;;;625        /* delete semaphore object */
;;;626        rt_object_delete(&(mutex->parent.parent));
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       rt_object_delete
;;;627    
;;;628        return RT_EOK;
000064  2000              MOVS     r0,#0
;;;629    }
000066  bdf8              POP      {r3-r7,pc}
;;;630    RTM_EXPORT(rt_mutex_delete);
                          ENDP

                  |L31.104|
                          DCD      ||.constdata||+0x7f
                  |L31.108|
00006c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000070  74696f6e
000074  5b25735d
000078  20736861
00007c  6c6c206e
000080  6f742075
000084  73656420
000088  696e2049
00008c  53520a00
                  |L31.144|
000090  3000              DCB      "0",0
000092  00                DCB      0
000093  00                DCB      0
                  |L31.148|
000094  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000098  20617373
00009c  65727420
0000a0  6661696c
0000a4  65642061
0000a8  74202573
0000ac  3a256420
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L31.180|
0000b4  6d757465          DCB      "mutex != RT_NULL",0
0000b8  7820213d
0000bc  2052545f
0000c0  4e554c4c
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0

                          AREA ||i.rt_mutex_detach||, CODE, READONLY, ALIGN=2

                  rt_mutex_detach PROC
;;;555     */
;;;556    rt_err_t rt_mutex_detach(rt_mutex_t mutex)
000000  b538              PUSH     {r3-r5,lr}
;;;557    {
000002  0004              MOVS     r4,r0
000004  d10c              BNE      |L32.32|
;;;558        RT_ASSERT(mutex != RT_NULL);
000006  f88d0000          STRB     r0,[sp,#0]
00000a  f240232e          MOV      r3,#0x22e
00000e  4a09              LDR      r2,|L32.52|
000010  a109              ADR      r1,|L32.56|
000012  a00e              ADR      r0,|L32.76|
000014  f7fffffe          BL       rt_kprintf
                  |L32.24|
000018  f89d1000          LDRB     r1,[sp,#0]
00001c  2900              CMP      r1,#0
00001e  d0fb              BEQ      |L32.24|
                  |L32.32|
;;;559    
;;;560        /* wakeup all suspend threads */
;;;561        rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
000020  f1040014          ADD      r0,r4,#0x14
000024  f7fffffe          BL       rt_ipc_list_resume_all
;;;562    
;;;563        /* detach semaphore object */
;;;564        rt_object_detach(&(mutex->parent.parent));
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       rt_object_detach
;;;565    
;;;566        return RT_EOK;
00002e  2000              MOVS     r0,#0
;;;567    }
000030  bd38              POP      {r3-r5,pc}
;;;568    RTM_EXPORT(rt_mutex_detach);
                          ENDP

000032  0000              DCW      0x0000
                  |L32.52|
                          DCD      ||.constdata||+0x5f
                  |L32.56|
000038  6d757465          DCB      "mutex != RT_NULL",0
00003c  7820213d
000040  2052545f
000044  4e554c4c
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0
                  |L32.76|
00004c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000050  20617373
000054  65727420
000058  6661696c
00005c  65642061
000060  74202573
000064  3a256420
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.rt_mutex_init||, CODE, READONLY, ALIGN=2

                  rt_mutex_init PROC
;;;524     */
;;;525    rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
000000  b5f8              PUSH     {r3-r7,lr}
;;;526    {
000002  4616              MOV      r6,r2
000004  460f              MOV      r7,r1
000006  0004              MOVS     r4,r0
000008  f04f0500          MOV      r5,#0
00000c  d10c              BNE      |L33.40|
;;;527        RT_ASSERT(mutex != RT_NULL);
00000e  f88d5000          STRB     r5,[sp,#0]
000012  f240230f          MOV      r3,#0x20f
000016  4a0d              LDR      r2,|L33.76|
000018  a10d              ADR      r1,|L33.80|
00001a  a012              ADR      r0,|L33.100|
00001c  f7fffffe          BL       rt_kprintf
                  |L33.32|
000020  f89d0000          LDRB     r0,[sp,#0]
000024  2800              CMP      r0,#0
000026  d0fb              BEQ      |L33.32|
                  |L33.40|
;;;528    
;;;529        /* init object */
;;;530        rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
000028  463a              MOV      r2,r7
00002a  2102              MOVS     r1,#2
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       rt_object_init
000032  f1040014          ADD      r0,r4,#0x14
000036  61a0              STR      r0,[r4,#0x18]
;;;531    
;;;532        /* init ipc object */
;;;533        rt_ipc_object_init(&(mutex->parent));
;;;534    
;;;535        mutex->value = 1;
000038  6160              STR      r0,[r4,#0x14]
00003a  2001              MOVS     r0,#1
00003c  83a0              STRH     r0,[r4,#0x1c]
;;;536        mutex->owner = RT_NULL;
;;;537        mutex->original_priority = 0xFF;
00003e  20ff              MOVS     r0,#0xff
000040  6225              STR      r5,[r4,#0x20]
000042  77a0              STRB     r0,[r4,#0x1e]
;;;538        mutex->hold  = 0;
000044  77e5              STRB     r5,[r4,#0x1f]
;;;539    
;;;540        /* set flag */
;;;541        mutex->parent.parent.flag = flag;
000046  7266              STRB     r6,[r4,#9]
;;;542    
;;;543        return RT_EOK;
000048  2000              MOVS     r0,#0
;;;544    }
00004a  bdf8              POP      {r3-r7,pc}
;;;545    RTM_EXPORT(rt_mutex_init);
                          ENDP

                  |L33.76|
                          DCD      ||.constdata||+0x51
                  |L33.80|
000050  6d757465          DCB      "mutex != RT_NULL",0
000054  7820213d
000058  2052545f
00005c  4e554c4c
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L33.100|
000064  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000068  20617373
00006c  65727420
000070  6661696c
000074  65642061
000078  74202573
00007c  3a256420
000080  0a00    
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.rt_mutex_release||, CODE, READONLY, ALIGN=2

                  rt_mutex_release PROC
;;;771     */
;;;772    rt_err_t rt_mutex_release(rt_mutex_t mutex)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;773    {
000004  4604              MOV      r4,r0
;;;774        register rt_base_t temp;
;;;775        struct rt_thread *thread;
;;;776        rt_bool_t need_schedule;
;;;777    
;;;778        need_schedule = RT_FALSE;
000006  2500              MOVS     r5,#0
;;;779    
;;;780        /* only thread could release mutex because we need test the ownership */
;;;781        RT_DEBUG_IN_THREAD_CONTEXT;
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4681              MOV      r9,r0
00000e  f7fffffe          BL       rt_thread_self
000012  f240370d          MOV      r7,#0x30d
000016  2600              MOVS     r6,#0
000018  b978              CBNZ     r0,|L34.58|
00001a  493a              LDR      r1,|L34.260|
00001c  a03a              ADR      r0,|L34.264|
00001e  f7fffffe          BL       rt_kprintf
000022  f88d6000          STRB     r6,[sp,#0]
000026  463b              MOV      r3,r7
000028  4a36              LDR      r2,|L34.260|
00002a  a145              ADR      r1,|L34.320|
00002c  a045              ADR      r0,|L34.324|
00002e  f7fffffe          BL       rt_kprintf
                  |L34.50|
000032  f89d0000          LDRB     r0,[sp,#0]
000036  2800              CMP      r0,#0
000038  d0fb              BEQ      |L34.50|
                  |L34.58|
00003a  f7fffffe          BL       rt_hw_interrupt_disable
00003e  4680              MOV      r8,r0
000040  f7fffffe          BL       rt_interrupt_get_nest
000044  b178              CBZ      r0,|L34.102|
000046  492f              LDR      r1,|L34.260|
000048  a046              ADR      r0,|L34.356|
00004a  f7fffffe          BL       rt_kprintf
00004e  f88d6000          STRB     r6,[sp,#0]
000052  463b              MOV      r3,r7
000054  4a2b              LDR      r2,|L34.260|
000056  a13a              ADR      r1,|L34.320|
000058  a03a              ADR      r0,|L34.324|
00005a  f7fffffe          BL       rt_kprintf
                  |L34.94|
00005e  f89d0000          LDRB     r0,[sp,#0]
000062  2800              CMP      r0,#0
000064  d0fb              BEQ      |L34.94|
                  |L34.102|
000066  4640              MOV      r0,r8
000068  f7fffffe          BL       rt_hw_interrupt_enable
00006c  4648              MOV      r0,r9
00006e  f7fffffe          BL       rt_hw_interrupt_enable
;;;782    
;;;783        /* get current thread */
;;;784        thread = rt_thread_self();
000072  f7fffffe          BL       rt_thread_self
000076  4607              MOV      r7,r0
;;;785    
;;;786        /* disable interrupt */
;;;787        temp = rt_hw_interrupt_disable();
000078  f7fffffe          BL       rt_hw_interrupt_disable
00007c  4680              MOV      r8,r0
;;;788    
;;;789        RT_DEBUG_LOG(RT_DEBUG_IPC,
;;;790                     ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
;;;791                      thread->name, mutex->value, mutex->hold));
;;;792    
;;;793        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
00007e  4842              LDR      r0,|L34.392|
000080  6801              LDR      r1,[r0,#0]  ; rt_object_put_hook
000082  b109              CBZ      r1,|L34.136|
000084  4620              MOV      r0,r4
000086  4788              BLX      r1
                  |L34.136|
;;;794    
;;;795        /* mutex only can be released by owner */
;;;796        if (thread != mutex->owner)
000088  6a20              LDR      r0,[r4,#0x20]
00008a  42b8              CMP      r0,r7
00008c  d008              BEQ      |L34.160|
;;;797        {
;;;798            thread->error = -RT_ERROR;
00008e  f04f34ff          MOV      r4,#0xffffffff
;;;799    
;;;800            /* enable interrupt */
;;;801            rt_hw_interrupt_enable(temp);
000092  4640              MOV      r0,r8
000094  633c              STR      r4,[r7,#0x30]
000096  f7fffffe          BL       rt_hw_interrupt_enable
;;;802    
;;;803            return -RT_ERROR;
00009a  4620              MOV      r0,r4
                  |L34.156|
;;;804        }
;;;805    
;;;806        /* decrease hold */
;;;807        mutex->hold --;
;;;808        /* if no hold */
;;;809        if (mutex->hold == 0)
;;;810        {
;;;811            /* change the owner thread to original priority */
;;;812            if (mutex->original_priority != mutex->owner->current_priority)
;;;813            {
;;;814                rt_thread_control(mutex->owner,
;;;815                                  RT_THREAD_CTRL_CHANGE_PRIORITY,
;;;816                                  &(mutex->original_priority));
;;;817            }
;;;818    
;;;819            /* wakeup suspended thread */
;;;820            if (!rt_list_isempty(&mutex->parent.suspend_thread))
;;;821            {
;;;822                /* get suspended thread */
;;;823                thread = rt_list_entry(mutex->parent.suspend_thread.next,
;;;824                                       struct rt_thread,
;;;825                                       tlist);
;;;826    
;;;827                RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
;;;828                                            thread->name));
;;;829    
;;;830                /* set new owner and priority */
;;;831                mutex->owner             = thread;
;;;832                mutex->original_priority = thread->current_priority;
;;;833                mutex->hold ++;
;;;834    
;;;835                /* resume thread */
;;;836                rt_ipc_list_resume(&(mutex->parent.suspend_thread));
;;;837    
;;;838                need_schedule = RT_TRUE;
;;;839            }
;;;840            else
;;;841            {
;;;842                /* increase value */
;;;843                mutex->value ++;
;;;844    
;;;845                /* clear owner */
;;;846                mutex->owner             = RT_NULL;
;;;847                mutex->original_priority = 0xff;
;;;848            }
;;;849        }
;;;850    
;;;851        /* enable interrupt */
;;;852        rt_hw_interrupt_enable(temp);
;;;853    
;;;854        /* perform a schedule */
;;;855        if (need_schedule == RT_TRUE)
;;;856            rt_schedule();
;;;857    
;;;858        return RT_EOK;
;;;859    }
00009c  e8bd83f8          POP      {r3-r9,pc}
                  |L34.160|
0000a0  7fe1              LDRB     r1,[r4,#0x1f]         ;807
0000a2  1e49              SUBS     r1,r1,#1              ;807
0000a4  f01101ff          ANDS     r1,r1,#0xff           ;807
0000a8  77e1              STRB     r1,[r4,#0x1f]         ;807
0000aa  d115              BNE      |L34.216|
0000ac  7fa1              LDRB     r1,[r4,#0x1e]         ;812
0000ae  f8902035          LDRB     r2,[r0,#0x35]         ;812
0000b2  4291              CMP      r1,r2                 ;812
0000b4  d004              BEQ      |L34.192|
0000b6  f104021e          ADD      r2,r4,#0x1e           ;814
0000ba  2102              MOVS     r1,#2                 ;814
0000bc  f7fffffe          BL       rt_thread_control
                  |L34.192|
0000c0  f1040014          ADD      r0,r4,#0x14           ;820
0000c4  4607              MOV      r7,r0                 ;820
0000c6  f7fffffe          BL       rt_list_isempty
0000ca  b168              CBZ      r0,|L34.232|
0000cc  8ba0              LDRH     r0,[r4,#0x1c]         ;843
0000ce  1c40              ADDS     r0,r0,#1              ;843
0000d0  83a0              STRH     r0,[r4,#0x1c]         ;843
0000d2  20ff              MOVS     r0,#0xff              ;847
0000d4  6226              STR      r6,[r4,#0x20]         ;847
0000d6  77a0              STRB     r0,[r4,#0x1e]         ;847
                  |L34.216|
0000d8  4640              MOV      r0,r8                 ;852
0000da  f7fffffe          BL       rt_hw_interrupt_enable
0000de  b10d              CBZ      r5,|L34.228|
0000e0  f7fffffe          BL       rt_schedule
                  |L34.228|
0000e4  2000              MOVS     r0,#0                 ;858
0000e6  e7d9              B        |L34.156|
                  |L34.232|
0000e8  6960              LDR      r0,[r4,#0x14]         ;823
0000ea  3814              SUBS     r0,r0,#0x14           ;823
0000ec  6220              STR      r0,[r4,#0x20]         ;832
0000ee  f8900035          LDRB     r0,[r0,#0x35]         ;832
0000f2  77a0              STRB     r0,[r4,#0x1e]         ;832
0000f4  7fe0              LDRB     r0,[r4,#0x1f]         ;833
0000f6  1c40              ADDS     r0,r0,#1              ;833
0000f8  77e0              STRB     r0,[r4,#0x1f]         ;833
0000fa  4638              MOV      r0,r7                 ;833
0000fc  f7fffffe          BL       rt_ipc_list_resume
000100  2501              MOVS     r5,#1                 ;838
000102  e7e9              B        |L34.216|
;;;860    RTM_EXPORT(rt_mutex_release);
                          ENDP

                  |L34.260|
                          DCD      ||.constdata||+0x9d
                  |L34.264|
000108  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
00010c  74696f6e
000110  5b25735d
000114  20736861
000118  6c6c206e
00011c  6f742062
000120  65207573
000124  65642062
000128  65666f72
00012c  65207363
000130  68656475
000134  6c657220
000138  73746172
00013c  740a    
00013e  00                DCB      0
00013f  00                DCB      0
                  |L34.320|
000140  3000              DCB      "0",0
000142  00                DCB      0
000143  00                DCB      0
                  |L34.324|
000144  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000148  20617373
00014c  65727420
000150  6661696c
000154  65642061
000158  74202573
00015c  3a256420
000160  0a00    
000162  00                DCB      0
000163  00                DCB      0
                  |L34.356|
000164  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000168  74696f6e
00016c  5b25735d
000170  20736861
000174  6c6c206e
000178  6f742075
00017c  73656420
000180  696e2049
000184  53520a00
                  |L34.392|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_mutex_take||, CODE, READONLY, ALIGN=2

                  rt_mutex_take PROC
;;;641     */
;;;642    rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;643    {
000004  b082              SUB      sp,sp,#8
000006  4604              MOV      r4,r0
;;;644        register rt_base_t temp;
;;;645        struct rt_thread *thread;
;;;646    
;;;647        /* this function must not be used in interrupt even if time = 0 */
;;;648        RT_DEBUG_IN_THREAD_CONTEXT;
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4680              MOV      r8,r0
00000e  f7fffffe          BL       rt_thread_self
000012  f44f7522          MOV      r5,#0x288
000016  2600              MOVS     r6,#0
000018  b978              CBNZ     r0,|L35.58|
00001a  494b              LDR      r1,|L35.328|
00001c  a04b              ADR      r0,|L35.332|
00001e  f7fffffe          BL       rt_kprintf
000022  f88d6000          STRB     r6,[sp,#0]
000026  462b              MOV      r3,r5
000028  4a47              LDR      r2,|L35.328|
00002a  a156              ADR      r1,|L35.388|
00002c  a056              ADR      r0,|L35.392|
00002e  f7fffffe          BL       rt_kprintf
                  |L35.50|
000032  f89d0000          LDRB     r0,[sp,#0]
000036  2800              CMP      r0,#0
000038  d0fb              BEQ      |L35.50|
                  |L35.58|
00003a  f7fffffe          BL       rt_hw_interrupt_disable
00003e  4607              MOV      r7,r0
000040  f7fffffe          BL       rt_interrupt_get_nest
000044  b178              CBZ      r0,|L35.102|
000046  4940              LDR      r1,|L35.328|
000048  a057              ADR      r0,|L35.424|
00004a  f7fffffe          BL       rt_kprintf
00004e  f88d6000          STRB     r6,[sp,#0]
000052  462b              MOV      r3,r5
000054  4a3c              LDR      r2,|L35.328|
000056  a14b              ADR      r1,|L35.388|
000058  a04b              ADR      r0,|L35.392|
00005a  f7fffffe          BL       rt_kprintf
                  |L35.94|
00005e  f89d0000          LDRB     r0,[sp,#0]
000062  2800              CMP      r0,#0
000064  d0fb              BEQ      |L35.94|
                  |L35.102|
000066  4638              MOV      r0,r7
000068  f7fffffe          BL       rt_hw_interrupt_enable
00006c  4640              MOV      r0,r8
00006e  f7fffffe          BL       rt_hw_interrupt_enable
;;;649    
;;;650        RT_ASSERT(mutex != RT_NULL);
000072  b964              CBNZ     r4,|L35.142|
000074  f88d6000          STRB     r6,[sp,#0]
000078  f240238a          MOV      r3,#0x28a
00007c  4a32              LDR      r2,|L35.328|
00007e  a153              ADR      r1,|L35.460|
000080  a041              ADR      r0,|L35.392|
000082  f7fffffe          BL       rt_kprintf
                  |L35.134|
000086  f89d0000          LDRB     r0,[sp,#0]
00008a  2800              CMP      r0,#0
00008c  d0fb              BEQ      |L35.134|
                  |L35.142|
;;;651    
;;;652        /* disable interrupt */
;;;653        temp = rt_hw_interrupt_disable();
00008e  f7fffffe          BL       rt_hw_interrupt_disable
000092  4607              MOV      r7,r0
;;;654    
;;;655        /* get current thread */
;;;656        thread = rt_thread_self();
000094  f7fffffe          BL       rt_thread_self
000098  4605              MOV      r5,r0
;;;657    
;;;658        RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
00009a  4851              LDR      r0,|L35.480|
00009c  6801              LDR      r1,[r0,#0]  ; rt_object_trytake_hook
00009e  b109              CBZ      r1,|L35.164|
0000a0  4620              MOV      r0,r4
0000a2  4788              BLX      r1
                  |L35.164|
;;;659    
;;;660        RT_DEBUG_LOG(RT_DEBUG_IPC,
;;;661                     ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
;;;662                      thread->name, mutex->value, mutex->hold));
;;;663    
;;;664        /* reset thread error */
;;;665        thread->error = RT_EOK;
;;;666    
;;;667        if (mutex->owner == thread)
0000a4  632e              STR      r6,[r5,#0x30]
0000a6  6a20              LDR      r0,[r4,#0x20]
0000a8  42a8              CMP      r0,r5
0000aa  d103              BNE      |L35.180|
                  |L35.172|
;;;668        {
;;;669            /* it's the same thread */
;;;670            mutex->hold ++;
0000ac  7fe0              LDRB     r0,[r4,#0x1f]
0000ae  1c40              ADDS     r0,r0,#1
0000b0  77e0              STRB     r0,[r4,#0x1f]
0000b2  e033              B        |L35.284|
                  |L35.180|
;;;671        }
;;;672        else
;;;673        {
;;;674            /* The value of mutex is 1 in initial status. Therefore, if the
;;;675             * value is great than 0, it indicates the mutex is avaible.
;;;676             */
;;;677            if (mutex->value > 0)
0000b4  8ba1              LDRH     r1,[r4,#0x1c]
0000b6  b131              CBZ      r1,|L35.198|
0000b8  1e49              SUBS     r1,r1,#1
;;;678            {
;;;679                /* mutex is available */
;;;680                mutex->value --;
0000ba  83a1              STRH     r1,[r4,#0x1c]
;;;681    
;;;682                /* set mutex owner and original priority */
;;;683                mutex->owner             = thread;
;;;684                mutex->original_priority = thread->current_priority;
0000bc  6225              STR      r5,[r4,#0x20]
0000be  f8950035          LDRB     r0,[r5,#0x35]
0000c2  77a0              STRB     r0,[r4,#0x1e]
;;;685                mutex->hold ++;
0000c4  e7f2              B        |L35.172|
                  |L35.198|
;;;686            }
;;;687            else
;;;688            {
;;;689                /* no waiting, return with timeout */
;;;690                if (time == 0)
0000c6  9903              LDR      r1,[sp,#0xc]
0000c8  b3a1              CBZ      r1,|L35.308|
;;;691                {
;;;692                    /* set error as timeout */
;;;693                    thread->error = -RT_ETIMEOUT;
;;;694    
;;;695                    /* enable interrupt */
;;;696                    rt_hw_interrupt_enable(temp);
;;;697    
;;;698                    return -RT_ETIMEOUT;
;;;699                }
;;;700                else
;;;701                {
;;;702                    /* mutex is unavailable, push to suspend list */
;;;703                    RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
;;;704                                                thread->name));
;;;705    
;;;706                    /* change the owner thread priority of mutex */
;;;707                    if (thread->current_priority < mutex->owner->current_priority)
0000ca  f8951035          LDRB     r1,[r5,#0x35]
0000ce  f8902035          LDRB     r2,[r0,#0x35]
0000d2  4291              CMP      r1,r2
0000d4  d204              BCS      |L35.224|
;;;708                    {
;;;709                        /* change the owner thread priority */
;;;710                        rt_thread_control(mutex->owner,
0000d6  f1050235          ADD      r2,r5,#0x35
0000da  2102              MOVS     r1,#2
0000dc  f7fffffe          BL       rt_thread_control
                  |L35.224|
;;;711                                          RT_THREAD_CTRL_CHANGE_PRIORITY,
;;;712                                          &thread->current_priority);
;;;713                    }
;;;714    
;;;715                    /* suspend current thread */
;;;716                    rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
0000e0  7a62              LDRB     r2,[r4,#9]
0000e2  4629              MOV      r1,r5
0000e4  f1040014          ADD      r0,r4,#0x14
0000e8  f7fffffe          BL       rt_ipc_list_suspend
;;;717                                        thread,
;;;718                                        mutex->parent.parent.flag);
;;;719    
;;;720                    /* has waiting time, start thread timer */
;;;721                    if (time > 0)
0000ec  9803              LDR      r0,[sp,#0xc]
0000ee  2800              CMP      r0,#0
0000f0  dd09              BLE      |L35.262|
;;;722                    {
;;;723                        RT_DEBUG_LOG(RT_DEBUG_IPC,
;;;724                                     ("mutex_take: start the timer of thread:%s\n",
;;;725                                      thread->name));
;;;726    
;;;727                        /* reset the timeout of thread timer and start it */
;;;728                        rt_timer_control(&(thread->thread_timer),
0000f2  f105004c          ADD      r0,r5,#0x4c
0000f6  aa03              ADD      r2,sp,#0xc
0000f8  2100              MOVS     r1,#0
0000fa  4606              MOV      r6,r0
0000fc  f7fffffe          BL       rt_timer_control
000100  4630              MOV      r0,r6
;;;729                                         RT_TIMER_CTRL_SET_TIME,
;;;730                                         &time);
;;;731                        rt_timer_start(&(thread->thread_timer));
000102  f7fffffe          BL       rt_timer_start
                  |L35.262|
;;;732                    }
;;;733    
;;;734                    /* enable interrupt */
;;;735                    rt_hw_interrupt_enable(temp);
000106  4638              MOV      r0,r7
000108  f7fffffe          BL       rt_hw_interrupt_enable
;;;736    
;;;737                    /* do schedule */
;;;738                    rt_schedule();
00010c  f7fffffe          BL       rt_schedule
;;;739    
;;;740                    if (thread->error != RT_EOK)
000110  6b28              LDR      r0,[r5,#0x30]
000112  2800              CMP      r0,#0
000114  d10b              BNE      |L35.302|
;;;741                    {
;;;742                        /* return error */
;;;743                        return thread->error;
;;;744                    }
;;;745                    else
;;;746                    {
;;;747                        /* the mutex is taken successfully. */
;;;748                        /* disable interrupt */
;;;749                        temp = rt_hw_interrupt_disable();
000116  f7fffffe          BL       rt_hw_interrupt_disable
00011a  4607              MOV      r7,r0
                  |L35.284|
;;;750                    }
;;;751                }
;;;752            }
;;;753        }
;;;754    
;;;755        /* enable interrupt */
;;;756        rt_hw_interrupt_enable(temp);
00011c  4638              MOV      r0,r7
00011e  f7fffffe          BL       rt_hw_interrupt_enable
;;;757    
;;;758        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
000122  4830              LDR      r0,|L35.484|
000124  6801              LDR      r1,[r0,#0]  ; rt_object_take_hook
000126  b109              CBZ      r1,|L35.300|
000128  4620              MOV      r0,r4
00012a  4788              BLX      r1
                  |L35.300|
;;;759    
;;;760        return RT_EOK;
00012c  2000              MOVS     r0,#0
                  |L35.302|
;;;761    }
00012e  b004              ADD      sp,sp,#0x10
000130  e8bd81f0          POP      {r4-r8,pc}
                  |L35.308|
000134  e7ff              B        |L35.310|
                  |L35.310|
000136  f06f0401          MVN      r4,#1                 ;693
00013a  4638              MOV      r0,r7                 ;696
00013c  632c              STR      r4,[r5,#0x30]         ;696
00013e  f7fffffe          BL       rt_hw_interrupt_enable
000142  4620              MOV      r0,r4                 ;698
000144  e7f3              B        |L35.302|
;;;762    RTM_EXPORT(rt_mutex_take);
                          ENDP

000146  0000              DCW      0x0000
                  |L35.328|
                          DCD      ||.constdata||+0x8f
                  |L35.332|
00014c  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
000150  74696f6e
000154  5b25735d
000158  20736861
00015c  6c6c206e
000160  6f742062
000164  65207573
000168  65642062
00016c  65666f72
000170  65207363
000174  68656475
000178  6c657220
00017c  73746172
000180  740a    
000182  00                DCB      0
000183  00                DCB      0
                  |L35.388|
000184  3000              DCB      "0",0
000186  00                DCB      0
000187  00                DCB      0
                  |L35.392|
000188  28257329          DCB      "(%s) assert failed at %s:%d \n",0
00018c  20617373
000190  65727420
000194  6661696c
000198  65642061
00019c  74202573
0001a0  3a256420
0001a4  0a00    
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L35.424|
0001a8  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0001ac  74696f6e
0001b0  5b25735d
0001b4  20736861
0001b8  6c6c206e
0001bc  6f742075
0001c0  73656420
0001c4  696e2049
0001c8  53520a00
                  |L35.460|
0001cc  6d757465          DCB      "mutex != RT_NULL",0
0001d0  7820213d
0001d4  2052545f
0001d8  4e554c4c
0001dc  00      
0001dd  00                DCB      0
0001de  00                DCB      0
0001df  00                DCB      0
                  |L35.480|
                          DCD      rt_object_trytake_hook
                  |L35.484|
                          DCD      rt_object_take_hook

                          AREA ||i.rt_sem_control||, CODE, READONLY, ALIGN=2

                  rt_sem_control PROC
;;;480     */
;;;481    rt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;482    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d10c              BNE      |L36.36|
;;;483        rt_ubase_t level;
;;;484        RT_ASSERT(sem != RT_NULL);
00000a  f88d0000          STRB     r0,[sp,#0]
00000e  f44f73f2          MOV      r3,#0x1e4
000012  4a0e              LDR      r2,|L36.76|
000014  a10e              ADR      r1,|L36.80|
000016  a012              ADR      r0,|L36.96|
000018  f7fffffe          BL       rt_kprintf
                  |L36.28|
00001c  f89d3000          LDRB     r3,[sp,#0]
000020  2b00              CMP      r3,#0
000022  d0fb              BEQ      |L36.28|
                  |L36.36|
;;;485    
;;;486        if (cmd == RT_IPC_CMD_RESET)
000024  2e01              CMP      r6,#1
000026  d002              BEQ      |L36.46|
;;;487        {
;;;488            rt_uint32_t value;
;;;489    
;;;490            /* get value */
;;;491            value = (rt_uint32_t)arg;
;;;492            /* disable interrupt */
;;;493            level = rt_hw_interrupt_disable();
;;;494    
;;;495            /* resume all waiting thread */
;;;496            rt_ipc_list_resume_all(&sem->parent.suspend_thread);
;;;497    
;;;498            /* set new value */
;;;499            sem->value = (rt_uint16_t)value;
;;;500    
;;;501            /* enable interrupt */
;;;502            rt_hw_interrupt_enable(level);
;;;503    
;;;504            rt_schedule();
;;;505    
;;;506            return RT_EOK;
;;;507        }
;;;508    
;;;509        return -RT_ERROR;
000028  f04f30ff          MOV      r0,#0xffffffff
;;;510    }
00002c  bdf8              POP      {r3-r7,pc}
                  |L36.46|
00002e  f7fffffe          BL       rt_hw_interrupt_disable
000032  4606              MOV      r6,r0                 ;493
000034  f1040014          ADD      r0,r4,#0x14           ;496
000038  f7fffffe          BL       rt_ipc_list_resume_all
00003c  83a5              STRH     r5,[r4,#0x1c]         ;499
00003e  4630              MOV      r0,r6                 ;502
000040  f7fffffe          BL       rt_hw_interrupt_enable
000044  f7fffffe          BL       rt_schedule
000048  2000              MOVS     r0,#0                 ;506
00004a  bdf8              POP      {r3-r7,pc}
;;;511    RTM_EXPORT(rt_sem_control);
                          ENDP

                  |L36.76|
                          DCD      ||.constdata||+0x42
                  |L36.80|
000050  73656d20          DCB      "sem != RT_NULL",0
000054  213d2052
000058  545f4e55
00005c  4c4c00  
00005f  00                DCB      0
                  |L36.96|
000060  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000064  20617373
000068  65727420
00006c  6661696c
000070  65642061
000074  74202573
000078  3a256420
00007c  0a00    
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.rt_sem_create||, CODE, READONLY, ALIGN=2

                  rt_sem_create PROC
;;;268     */
;;;269    rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
000000  b5f8              PUSH     {r3-r7,lr}
;;;270    {
000002  4615              MOV      r5,r2
000004  460c              MOV      r4,r1
000006  4606              MOV      r6,r0
;;;271        rt_sem_t sem;
;;;272    
;;;273        RT_DEBUG_NOT_IN_INTERRUPT;
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4607              MOV      r7,r0
00000e  f7fffffe          BL       rt_interrupt_get_nest
000012  b188              CBZ      r0,|L37.56|
000014  4910              LDR      r1,|L37.88|
000016  a011              ADR      r0,|L37.92|
000018  f7fffffe          BL       rt_kprintf
00001c  2000              MOVS     r0,#0
00001e  f88d0000          STRB     r0,[sp,#0]
000022  f2401311          MOV      r3,#0x111
000026  4a0c              LDR      r2,|L37.88|
000028  a115              ADR      r1,|L37.128|
00002a  a016              ADR      r0,|L37.132|
00002c  f7fffffe          BL       rt_kprintf
                  |L37.48|
000030  f89d0000          LDRB     r0,[sp,#0]
000034  2800              CMP      r0,#0
000036  d0fb              BEQ      |L37.48|
                  |L37.56|
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       rt_hw_interrupt_enable
;;;274    
;;;275        /* allocate object */
;;;276        sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
00003e  4631              MOV      r1,r6
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       rt_object_allocate
;;;277        if (sem == RT_NULL)
000046  2800              CMP      r0,#0
000048  d005              BEQ      |L37.86|
00004a  f1000114          ADD      r1,r0,#0x14
00004e  6181              STR      r1,[r0,#0x18]
;;;278            return sem;
;;;279    
;;;280        /* init ipc object */
;;;281        rt_ipc_object_init(&(sem->parent));
;;;282    
;;;283        /* set init value */
;;;284        sem->value = value;
000050  6141              STR      r1,[r0,#0x14]
000052  8384              STRH     r4,[r0,#0x1c]
;;;285    
;;;286        /* set parent */
;;;287        sem->parent.parent.flag = flag;
000054  7245              STRB     r5,[r0,#9]
                  |L37.86|
;;;288    
;;;289        return sem;
;;;290    }
000056  bdf8              POP      {r3-r7,pc}
;;;291    RTM_EXPORT(rt_sem_create);
                          ENDP

                  |L37.88|
                          DCD      ||.constdata||+0x1a
                  |L37.92|
00005c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000060  74696f6e
000064  5b25735d
000068  20736861
00006c  6c6c206e
000070  6f742075
000074  73656420
000078  696e2049
00007c  53520a00
                  |L37.128|
000080  3000              DCB      "0",0
000082  00                DCB      0
000083  00                DCB      0
                  |L37.132|
000084  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000088  20617373
00008c  65727420
000090  6661696c
000094  65642061
000098  74202573
00009c  3a256420
0000a0  0a00    
0000a2  00                DCB      0
0000a3  00                DCB      0

                          AREA ||i.rt_sem_delete||, CODE, READONLY, ALIGN=2

                  rt_sem_delete PROC
;;;301     */
;;;302    rt_err_t rt_sem_delete(rt_sem_t sem)
000000  b5f8              PUSH     {r3-r7,lr}
;;;303    {
000002  4604              MOV      r4,r0
;;;304        RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4606              MOV      r6,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2500              MOVS     r5,#0
000010  b180              CBZ      r0,|L38.52|
000012  4915              LDR      r1,|L38.104|
000014  a015              ADR      r0,|L38.108|
000016  f7fffffe          BL       rt_kprintf
00001a  f88d5000          STRB     r5,[sp,#0]
00001e  f44f7398          MOV      r3,#0x130
000022  4a11              LDR      r2,|L38.104|
000024  a11a              ADR      r1,|L38.144|
000026  a01b              ADR      r0,|L38.148|
000028  f7fffffe          BL       rt_kprintf
                  |L38.44|
00002c  f89d1000          LDRB     r1,[sp,#0]
000030  2900              CMP      r1,#0
000032  d0fb              BEQ      |L38.44|
                  |L38.52|
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       rt_hw_interrupt_enable
;;;305    
;;;306        RT_ASSERT(sem != RT_NULL);
00003a  b964              CBNZ     r4,|L38.86|
00003c  f88d5000          STRB     r5,[sp,#0]
000040  f44f7399          MOV      r3,#0x132
000044  4a08              LDR      r2,|L38.104|
000046  a11b              ADR      r1,|L38.180|
000048  a012              ADR      r0,|L38.148|
00004a  f7fffffe          BL       rt_kprintf
                  |L38.78|
00004e  f89d1000          LDRB     r1,[sp,#0]
000052  2900              CMP      r1,#0
000054  d0fb              BEQ      |L38.78|
                  |L38.86|
;;;307    
;;;308        /* wakeup all suspend threads */
;;;309        rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
000056  f1040014          ADD      r0,r4,#0x14
00005a  f7fffffe          BL       rt_ipc_list_resume_all
;;;310    
;;;311        /* delete semaphore object */
;;;312        rt_object_delete(&(sem->parent.parent));
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       rt_object_delete
;;;313    
;;;314        return RT_EOK;
000064  2000              MOVS     r0,#0
;;;315    }
000066  bdf8              POP      {r3-r7,pc}
;;;316    RTM_EXPORT(rt_sem_delete);
                          ENDP

                  |L38.104|
                          DCD      ||.constdata||+0x28
                  |L38.108|
00006c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000070  74696f6e
000074  5b25735d
000078  20736861
00007c  6c6c206e
000080  6f742075
000084  73656420
000088  696e2049
00008c  53520a00
                  |L38.144|
000090  3000              DCB      "0",0
000092  00                DCB      0
000093  00                DCB      0
                  |L38.148|
000094  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000098  20617373
00009c  65727420
0000a0  6661696c
0000a4  65642061
0000a8  74202573
0000ac  3a256420
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L38.180|
0000b4  73656d20          DCB      "sem != RT_NULL",0
0000b8  213d2052
0000bc  545f4e55
0000c0  4c4c00  
0000c3  00                DCB      0

                          AREA ||i.rt_sem_detach||, CODE, READONLY, ALIGN=2

                  rt_sem_detach PROC
;;;242     */
;;;243    rt_err_t rt_sem_detach(rt_sem_t sem)
000000  b538              PUSH     {r3-r5,lr}
;;;244    {
000002  0004              MOVS     r4,r0
000004  d10b              BNE      |L39.30|
;;;245        RT_ASSERT(sem != RT_NULL);
000006  f88d0000          STRB     r0,[sp,#0]
00000a  23f5              MOVS     r3,#0xf5
00000c  4a08              LDR      r2,|L39.48|
00000e  a109              ADR      r1,|L39.52|
000010  a00c              ADR      r0,|L39.68|
000012  f7fffffe          BL       rt_kprintf
                  |L39.22|
000016  f89d1000          LDRB     r1,[sp,#0]
00001a  2900              CMP      r1,#0
00001c  d0fb              BEQ      |L39.22|
                  |L39.30|
;;;246    
;;;247        /* wakeup all suspend threads */
;;;248        rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
00001e  f1040014          ADD      r0,r4,#0x14
000022  f7fffffe          BL       rt_ipc_list_resume_all
;;;249    
;;;250        /* detach semaphore object */
;;;251        rt_object_detach(&(sem->parent.parent));
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       rt_object_detach
;;;252    
;;;253        return RT_EOK;
00002c  2000              MOVS     r0,#0
;;;254    }
00002e  bd38              POP      {r3-r5,pc}
;;;255    RTM_EXPORT(rt_sem_detach);
                          ENDP

                  |L39.48|
                          DCD      ||.constdata||+0xc
                  |L39.52|
000034  73656d20          DCB      "sem != RT_NULL",0
000038  213d2052
00003c  545f4e55
000040  4c4c00  
000043  00                DCB      0
                  |L39.68|
000044  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000048  20617373
00004c  65727420
000050  6661696c
000054  65642061
000058  74202573
00005c  3a256420
000060  0a00    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.rt_sem_init||, CODE, READONLY, ALIGN=2

                  rt_sem_init PROC
;;;210     */
;;;211    rt_err_t rt_sem_init(rt_sem_t    sem,
000000  b5f8              PUSH     {r3-r7,lr}
;;;212                         const char *name,
;;;213                         rt_uint32_t value,
;;;214                         rt_uint8_t  flag)
;;;215    {
000002  461e              MOV      r6,r3
000004  4615              MOV      r5,r2
000006  460f              MOV      r7,r1
000008  0004              MOVS     r4,r0
00000a  d10b              BNE      |L40.36|
;;;216        RT_ASSERT(sem != RT_NULL);
00000c  f88d0000          STRB     r0,[sp,#0]
000010  23d8              MOVS     r3,#0xd8
000012  4a0b              LDR      r2,|L40.64|
000014  a10b              ADR      r1,|L40.68|
000016  a00f              ADR      r0,|L40.84|
000018  f7fffffe          BL       rt_kprintf
                  |L40.28|
00001c  f89d0000          LDRB     r0,[sp,#0]
000020  2800              CMP      r0,#0
000022  d0fb              BEQ      |L40.28|
                  |L40.36|
;;;217    
;;;218        /* init object */
;;;219        rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
000024  463a              MOV      r2,r7
000026  2101              MOVS     r1,#1
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       rt_object_init
00002e  f1040014          ADD      r0,r4,#0x14
000032  61a0              STR      r0,[r4,#0x18]
;;;220    
;;;221        /* init ipc object */
;;;222        rt_ipc_object_init(&(sem->parent));
;;;223    
;;;224        /* set init value */
;;;225        sem->value = value;
000034  6160              STR      r0,[r4,#0x14]
000036  83a5              STRH     r5,[r4,#0x1c]
;;;226    
;;;227        /* set parent */
;;;228        sem->parent.parent.flag = flag;
000038  7266              STRB     r6,[r4,#9]
;;;229    
;;;230        return RT_EOK;
00003a  2000              MOVS     r0,#0
;;;231    }
00003c  bdf8              POP      {r3-r7,pc}
;;;232    RTM_EXPORT(rt_sem_init);
                          ENDP

00003e  0000              DCW      0x0000
                  |L40.64|
                          DCD      ||.constdata||
                  |L40.68|
000044  73656d20          DCB      "sem != RT_NULL",0
000048  213d2052
00004c  545f4e55
000050  4c4c00  
000053  00                DCB      0
                  |L40.84|
000054  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000058  20617373
00005c  65727420
000060  6661696c
000064  65642061
000068  74202573
00006c  3a256420
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.rt_sem_release||, CODE, READONLY, ALIGN=2

                  rt_sem_release PROC
;;;434     */
;;;435    rt_err_t rt_sem_release(rt_sem_t sem)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;436    {
000004  4604              MOV      r4,r0
;;;437        register rt_base_t temp;
;;;438        register rt_bool_t need_schedule;
;;;439    
;;;440        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
000006  4810              LDR      r0,|L41.72|
000008  6801              LDR      r1,[r0,#0]            ;436  ; rt_object_put_hook
00000a  b109              CBZ      r1,|L41.16|
00000c  4620              MOV      r0,r4
00000e  4788              BLX      r1
                  |L41.16|
;;;441    
;;;442        need_schedule = RT_FALSE;
000010  2500              MOVS     r5,#0
;;;443    
;;;444        /* disable interrupt */
;;;445        temp = rt_hw_interrupt_disable();
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4606              MOV      r6,r0
;;;446    
;;;447        RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
;;;448                                    rt_thread_self()->name,
;;;449                                    ((struct rt_object *)sem)->name,
;;;450                                    sem->value));
;;;451    
;;;452        if (!rt_list_isempty(&sem->parent.suspend_thread))
000018  f1040014          ADD      r0,r4,#0x14
00001c  4607              MOV      r7,r0
00001e  f7fffffe          BL       rt_list_isempty
000022  b158              CBZ      r0,|L41.60|
;;;453        {
;;;454            /* resume the suspended thread */
;;;455            rt_ipc_list_resume(&(sem->parent.suspend_thread));
;;;456            need_schedule = RT_TRUE;
;;;457        }
;;;458        else
;;;459            sem->value ++; /* increase value */
000024  8ba0              LDRH     r0,[r4,#0x1c]
000026  1c40              ADDS     r0,r0,#1
000028  83a0              STRH     r0,[r4,#0x1c]
                  |L41.42|
;;;460    
;;;461        /* enable interrupt */
;;;462        rt_hw_interrupt_enable(temp);
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       rt_hw_interrupt_enable
;;;463    
;;;464        /* resume a thread, re-schedule */
;;;465        if (need_schedule == RT_TRUE)
000030  b10d              CBZ      r5,|L41.54|
;;;466            rt_schedule();
000032  f7fffffe          BL       rt_schedule
                  |L41.54|
;;;467    
;;;468        return RT_EOK;
000036  2000              MOVS     r0,#0
;;;469    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L41.60|
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       rt_ipc_list_resume
000042  2501              MOVS     r5,#1                 ;456
000044  e7f1              B        |L41.42|
;;;470    RTM_EXPORT(rt_sem_release);
                          ENDP

000046  0000              DCW      0x0000
                  |L41.72|
                          DCD      rt_object_put_hook

                          AREA ||i.rt_sem_take||, CODE, READONLY, ALIGN=2

                  rt_sem_take PROC
;;;327     */
;;;328    rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
000000  e92d43f3          PUSH     {r0,r1,r4-r9,lr}
;;;329    {
000004  b081              SUB      sp,sp,#4
000006  0004              MOVS     r4,r0
000008  f04f0600          MOV      r6,#0
00000c  d10c              BNE      |L42.40|
;;;330        register rt_base_t temp;
;;;331        struct rt_thread *thread;
;;;332    
;;;333        RT_ASSERT(sem != RT_NULL);
00000e  f88d6000          STRB     r6,[sp,#0]
000012  f240134d          MOV      r3,#0x14d
000016  4a3e              LDR      r2,|L42.272|
000018  a13e              ADR      r1,|L42.276|
00001a  a042              ADR      r0,|L42.292|
00001c  f7fffffe          BL       rt_kprintf
                  |L42.32|
000020  f89d0000          LDRB     r0,[sp,#0]
000024  2800              CMP      r0,#0
000026  d0fb              BEQ      |L42.32|
                  |L42.40|
;;;334    
;;;335        RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
000028  4846              LDR      r0,|L42.324|
00002a  6801              LDR      r1,[r0,#0]  ; rt_object_trytake_hook
00002c  b109              CBZ      r1,|L42.50|
00002e  4620              MOV      r0,r4
000030  4788              BLX      r1
                  |L42.50|
;;;336    
;;;337        /* disable interrupt */
;;;338        temp = rt_hw_interrupt_disable();
000032  f7fffffe          BL       rt_hw_interrupt_disable
000036  4605              MOV      r5,r0
;;;339    
;;;340        RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
;;;341                                    rt_thread_self()->name,
;;;342                                    ((struct rt_object *)sem)->name,
;;;343                                    sem->value));
;;;344    
;;;345        if (sem->value > 0)
000038  8ba0              LDRH     r0,[r4,#0x1c]
00003a  b128              CBZ      r0,|L42.72|
00003c  1e40              SUBS     r0,r0,#1
;;;346        {
;;;347            /* semaphore is available */
;;;348            sem->value --;
00003e  83a0              STRH     r0,[r4,#0x1c]
;;;349    
;;;350            /* enable interrupt */
;;;351            rt_hw_interrupt_enable(temp);
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       rt_hw_interrupt_enable
000046  e05c              B        |L42.258|
                  |L42.72|
;;;352        }
;;;353        else
;;;354        {
;;;355            /* no waiting, return with timeout */
;;;356            if (time == 0)
000048  9802              LDR      r0,[sp,#8]
00004a  b140              CBZ      r0,|L42.94|
;;;357            {
;;;358                rt_hw_interrupt_enable(temp);
;;;359    
;;;360                return -RT_ETIMEOUT;
;;;361            }
;;;362            else
;;;363            {
;;;364                /* current context checking */
;;;365                RT_DEBUG_IN_THREAD_CONTEXT;
00004c  f7fffffe          BL       rt_hw_interrupt_disable
000050  4681              MOV      r9,r0
000052  f7fffffe          BL       rt_thread_self
000056  f240176d          MOV      r7,#0x16d
00005a  b138              CBZ      r0,|L42.108|
00005c  e016              B        |L42.140|
                  |L42.94|
00005e  4628              MOV      r0,r5                 ;358
000060  f7fffffe          BL       rt_hw_interrupt_enable
000064  f06f0001          MVN      r0,#1                 ;360
                  |L42.104|
;;;366    
;;;367                /* semaphore is unavailable, push to suspend list */
;;;368                /* get current thread */
;;;369                thread = rt_thread_self();
;;;370    
;;;371                /* reset thread error number */
;;;372                thread->error = RT_EOK;
;;;373    
;;;374                RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
;;;375                                            thread->name));
;;;376    
;;;377                /* suspend thread */
;;;378                rt_ipc_list_suspend(&(sem->parent.suspend_thread),
;;;379                                    thread,
;;;380                                    sem->parent.parent.flag);
;;;381    
;;;382                /* has waiting time, start thread timer */
;;;383                if (time > 0)
;;;384                {
;;;385                    RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
;;;386                                                thread->name));
;;;387    
;;;388                    /* reset the timeout of thread timer and start it */
;;;389                    rt_timer_control(&(thread->thread_timer),
;;;390                                     RT_TIMER_CTRL_SET_TIME,
;;;391                                     &time);
;;;392                    rt_timer_start(&(thread->thread_timer));
;;;393                }
;;;394    
;;;395                /* enable interrupt */
;;;396                rt_hw_interrupt_enable(temp);
;;;397    
;;;398                /* do schedule */
;;;399                rt_schedule();
;;;400    
;;;401                if (thread->error != RT_EOK)
;;;402                {
;;;403                    return thread->error;
;;;404                }
;;;405            }
;;;406        }
;;;407    
;;;408        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
;;;409    
;;;410        return RT_EOK;
;;;411    }
000068  e8bd83fe          POP      {r1-r9,pc}
                  |L42.108|
00006c  4928              LDR      r1,|L42.272|
00006e  a036              ADR      r0,|L42.328|
000070  f7fffffe          BL       rt_kprintf
000074  f88d6000          STRB     r6,[sp,#0]            ;365
000078  463b              MOV      r3,r7                 ;365
00007a  4a25              LDR      r2,|L42.272|
00007c  a140              ADR      r1,|L42.384|
00007e  a029              ADR      r0,|L42.292|
000080  f7fffffe          BL       rt_kprintf
                  |L42.132|
000084  f89d0000          LDRB     r0,[sp,#0]            ;365
000088  2800              CMP      r0,#0                 ;365
00008a  d0fb              BEQ      |L42.132|
                  |L42.140|
00008c  f7fffffe          BL       rt_hw_interrupt_disable
000090  4680              MOV      r8,r0                 ;365
000092  f7fffffe          BL       rt_interrupt_get_nest
000096  b178              CBZ      r0,|L42.184|
000098  491d              LDR      r1,|L42.272|
00009a  a03a              ADR      r0,|L42.388|
00009c  f7fffffe          BL       rt_kprintf
0000a0  f88d6000          STRB     r6,[sp,#0]            ;365
0000a4  463b              MOV      r3,r7                 ;365
0000a6  4a1a              LDR      r2,|L42.272|
0000a8  a135              ADR      r1,|L42.384|
0000aa  a01e              ADR      r0,|L42.292|
0000ac  f7fffffe          BL       rt_kprintf
                  |L42.176|
0000b0  f89d0000          LDRB     r0,[sp,#0]            ;365
0000b4  2800              CMP      r0,#0                 ;365
0000b6  d0fb              BEQ      |L42.176|
                  |L42.184|
0000b8  4640              MOV      r0,r8                 ;365
0000ba  f7fffffe          BL       rt_hw_interrupt_enable
0000be  4648              MOV      r0,r9                 ;365
0000c0  f7fffffe          BL       rt_hw_interrupt_enable
0000c4  f7fffffe          BL       rt_thread_self
0000c8  6306              STR      r6,[r0,#0x30]         ;378
0000ca  4607              MOV      r7,r0                 ;369
0000cc  4601              MOV      r1,r0                 ;378
0000ce  7a62              LDRB     r2,[r4,#9]            ;378
0000d0  f1040014          ADD      r0,r4,#0x14           ;378
0000d4  f7fffffe          BL       rt_ipc_list_suspend
0000d8  9802              LDR      r0,[sp,#8]            ;383
0000da  2800              CMP      r0,#0                 ;383
0000dc  dd09              BLE      |L42.242|
0000de  f107004c          ADD      r0,r7,#0x4c           ;389
0000e2  aa02              ADD      r2,sp,#8              ;389
0000e4  2100              MOVS     r1,#0                 ;389
0000e6  4606              MOV      r6,r0                 ;389
0000e8  f7fffffe          BL       rt_timer_control
0000ec  4630              MOV      r0,r6                 ;389
0000ee  f7fffffe          BL       rt_timer_start
                  |L42.242|
0000f2  4628              MOV      r0,r5                 ;396
0000f4  f7fffffe          BL       rt_hw_interrupt_enable
0000f8  f7fffffe          BL       rt_schedule
0000fc  6b38              LDR      r0,[r7,#0x30]         ;401
0000fe  2800              CMP      r0,#0                 ;401
000100  d1b2              BNE      |L42.104|
                  |L42.258|
000102  4829              LDR      r0,|L42.424|
000104  6801              LDR      r1,[r0,#0]            ;408  ; rt_object_take_hook
000106  b109              CBZ      r1,|L42.268|
000108  4620              MOV      r0,r4                 ;408
00010a  4788              BLX      r1                    ;408
                  |L42.268|
00010c  2000              MOVS     r0,#0                 ;410
00010e  e7ab              B        |L42.104|
;;;412    RTM_EXPORT(rt_sem_take);
                          ENDP

                  |L42.272|
                          DCD      ||.constdata||+0x36
                  |L42.276|
000114  73656d20          DCB      "sem != RT_NULL",0
000118  213d2052
00011c  545f4e55
000120  4c4c00  
000123  00                DCB      0
                  |L42.292|
000124  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000128  20617373
00012c  65727420
000130  6661696c
000134  65642061
000138  74202573
00013c  3a256420
000140  0a00    
000142  00                DCB      0
000143  00                DCB      0
                  |L42.324|
                          DCD      rt_object_trytake_hook
                  |L42.328|
000148  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
00014c  74696f6e
000150  5b25735d
000154  20736861
000158  6c6c206e
00015c  6f742062
000160  65207573
000164  65642062
000168  65666f72
00016c  65207363
000170  68656475
000174  6c657220
000178  73746172
00017c  740a    
00017e  00                DCB      0
00017f  00                DCB      0
                  |L42.384|
000180  3000              DCB      "0",0
000182  00                DCB      0
000183  00                DCB      0
                  |L42.388|
000184  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000188  74696f6e
00018c  5b25735d
000190  20736861
000194  6c6c206e
000198  6f742075
00019c  73656420
0001a0  696e2049
0001a4  53520a00
                  |L42.424|
                          DCD      rt_object_take_hook

                          AREA ||i.rt_sem_trytake||, CODE, READONLY, ALIGN=1

                  rt_sem_trytake PROC
;;;420     */
;;;421    rt_err_t rt_sem_trytake(rt_sem_t sem)
000000  2100              MOVS     r1,#0
;;;422    {
;;;423        return rt_sem_take(sem, 0);
000002  f7ffbffe          B.W      rt_sem_take
;;;424    }
;;;425    RTM_EXPORT(rt_sem_trytake);
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f73          DCB      0x72,0x74,0x5f,0x73
000004  656d5f69          DCB      0x65,0x6d,0x5f,0x69
000008  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.126|
00000c  72745f73          DCB      0x72,0x74,0x5f,0x73
000010  656d5f64          DCB      0x65,0x6d,0x5f,0x64
000014  65746163          DCB      0x65,0x74,0x61,0x63
000018  6800              DCB      0x68,0x00
                  |symbol_number.127|
00001a  7274              DCB      0x72,0x74
00001c  5f73656d          DCB      0x5f,0x73,0x65,0x6d
000020  5f637265          DCB      0x5f,0x63,0x72,0x65
000024  61746500          DCB      0x61,0x74,0x65,0x00
                  |symbol_number.128|
000028  72745f73          DCB      0x72,0x74,0x5f,0x73
00002c  656d5f64          DCB      0x65,0x6d,0x5f,0x64
000030  656c6574          DCB      0x65,0x6c,0x65,0x74
000034  6500              DCB      0x65,0x00
                  |symbol_number.129|
000036  7274              DCB      0x72,0x74
000038  5f73656d          DCB      0x5f,0x73,0x65,0x6d
00003c  5f74616b          DCB      0x5f,0x74,0x61,0x6b
000040  6500              DCB      0x65,0x00
                  |symbol_number.130|
000042  7274              DCB      0x72,0x74
000044  5f73656d          DCB      0x5f,0x73,0x65,0x6d
000048  5f636f6e          DCB      0x5f,0x63,0x6f,0x6e
00004c  74726f6c          DCB      0x74,0x72,0x6f,0x6c
000050  00                DCB      0x00
                  |symbol_number.131|
000051  72745f            DCB      0x72,0x74,0x5f
000054  6d757465          DCB      0x6d,0x75,0x74,0x65
000058  785f696e          DCB      0x78,0x5f,0x69,0x6e
00005c  697400            DCB      0x69,0x74,0x00
                  |symbol_number.132|
00005f  72                DCB      0x72
000060  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000064  7465785f          DCB      0x74,0x65,0x78,0x5f
000068  64657461          DCB      0x64,0x65,0x74,0x61
00006c  636800            DCB      0x63,0x68,0x00
                  |symbol_number.133|
00006f  72                DCB      0x72
000070  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000074  7465785f          DCB      0x74,0x65,0x78,0x5f
000078  63726561          DCB      0x63,0x72,0x65,0x61
00007c  746500            DCB      0x74,0x65,0x00
                  |symbol_number.134|
00007f  72                DCB      0x72
000080  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000084  7465785f          DCB      0x74,0x65,0x78,0x5f
000088  64656c65          DCB      0x64,0x65,0x6c,0x65
00008c  746500            DCB      0x74,0x65,0x00
                  |symbol_number.135|
00008f  72                DCB      0x72
000090  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000094  7465785f          DCB      0x74,0x65,0x78,0x5f
000098  74616b65          DCB      0x74,0x61,0x6b,0x65
00009c  00                DCB      0x00
                  |symbol_number.136|
00009d  72745f            DCB      0x72,0x74,0x5f
0000a0  6d757465          DCB      0x6d,0x75,0x74,0x65
0000a4  785f7265          DCB      0x78,0x5f,0x72,0x65
0000a8  6c656173          DCB      0x6c,0x65,0x61,0x73
0000ac  6500              DCB      0x65,0x00
                  |symbol_number.137|
0000ae  7274              DCB      0x72,0x74
0000b0  5f657665          DCB      0x5f,0x65,0x76,0x65
0000b4  6e745f69          DCB      0x6e,0x74,0x5f,0x69
0000b8  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.138|
0000bc  72745f65          DCB      0x72,0x74,0x5f,0x65
0000c0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000c4  5f646574          DCB      0x5f,0x64,0x65,0x74
0000c8  61636800          DCB      0x61,0x63,0x68,0x00
                  |symbol_number.139|
0000cc  72745f65          DCB      0x72,0x74,0x5f,0x65
0000d0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000d4  5f637265          DCB      0x5f,0x63,0x72,0x65
0000d8  61746500          DCB      0x61,0x74,0x65,0x00
                  |symbol_number.140|
0000dc  72745f65          DCB      0x72,0x74,0x5f,0x65
0000e0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000e4  5f64656c          DCB      0x5f,0x64,0x65,0x6c
0000e8  65746500          DCB      0x65,0x74,0x65,0x00
                  |symbol_number.141|
0000ec  72745f65          DCB      0x72,0x74,0x5f,0x65
0000f0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000f4  5f73656e          DCB      0x5f,0x73,0x65,0x6e
0000f8  6400              DCB      0x64,0x00
                  |symbol_number.142|
0000fa  7274              DCB      0x72,0x74
0000fc  5f657665          DCB      0x5f,0x65,0x76,0x65
000100  6e745f72          DCB      0x6e,0x74,0x5f,0x72
000104  65637600          DCB      0x65,0x63,0x76,0x00
                  |symbol_number.143|
000108  72745f65          DCB      0x72,0x74,0x5f,0x65
00010c  76656e74          DCB      0x76,0x65,0x6e,0x74
000110  5f636f6e          DCB      0x5f,0x63,0x6f,0x6e
000114  74726f6c          DCB      0x74,0x72,0x6f,0x6c
000118  00                DCB      0x00
                  |symbol_number.144|
000119  72745f            DCB      0x72,0x74,0x5f
00011c  6d625f69          DCB      0x6d,0x62,0x5f,0x69
000120  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.145|
000124  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000128  625f6465          DCB      0x62,0x5f,0x64,0x65
00012c  74616368          DCB      0x74,0x61,0x63,0x68
000130  00                DCB      0x00
                  |symbol_number.146|
000131  72745f            DCB      0x72,0x74,0x5f
000134  6d625f63          DCB      0x6d,0x62,0x5f,0x63
000138  72656174          DCB      0x72,0x65,0x61,0x74
00013c  6500              DCB      0x65,0x00
                  |symbol_number.147|
00013e  7274              DCB      0x72,0x74
000140  5f6d625f          DCB      0x5f,0x6d,0x62,0x5f
000144  64656c65          DCB      0x64,0x65,0x6c,0x65
000148  746500            DCB      0x74,0x65,0x00
                  |symbol_number.148|
00014b  72                DCB      0x72
00014c  745f6d62          DCB      0x74,0x5f,0x6d,0x62
000150  5f73656e          DCB      0x5f,0x73,0x65,0x6e
000154  645f7761          DCB      0x64,0x5f,0x77,0x61
000158  697400            DCB      0x69,0x74,0x00
                  |symbol_number.149|
00015b  72                DCB      0x72
00015c  745f6d62          DCB      0x74,0x5f,0x6d,0x62
000160  5f726563          DCB      0x5f,0x72,0x65,0x63
000164  7600              DCB      0x76,0x00
                  |symbol_number.150|
000166  7274              DCB      0x72,0x74
000168  5f6d625f          DCB      0x5f,0x6d,0x62,0x5f
00016c  636f6e74          DCB      0x63,0x6f,0x6e,0x74
000170  726f6c00          DCB      0x72,0x6f,0x6c,0x00
                  |symbol_number.151|
000174  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000178  715f696e          DCB      0x71,0x5f,0x69,0x6e
00017c  697400            DCB      0x69,0x74,0x00
                  |symbol_number.152|
00017f  72                DCB      0x72
000180  745f6d71          DCB      0x74,0x5f,0x6d,0x71
000184  5f646574          DCB      0x5f,0x64,0x65,0x74
000188  61636800          DCB      0x61,0x63,0x68,0x00
                  |symbol_number.153|
00018c  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000190  715f6372          DCB      0x71,0x5f,0x63,0x72
000194  65617465          DCB      0x65,0x61,0x74,0x65
000198  00                DCB      0x00
                  |symbol_number.154|
000199  72745f            DCB      0x72,0x74,0x5f
00019c  6d715f64          DCB      0x6d,0x71,0x5f,0x64
0001a0  656c6574          DCB      0x65,0x6c,0x65,0x74
0001a4  6500              DCB      0x65,0x00
                  |symbol_number.155|
0001a6  7274              DCB      0x72,0x74
0001a8  5f6d715f          DCB      0x5f,0x6d,0x71,0x5f
0001ac  73656e64          DCB      0x73,0x65,0x6e,0x64
0001b0  00                DCB      0x00
                  |symbol_number.156|
0001b1  72745f            DCB      0x72,0x74,0x5f
0001b4  6d715f75          DCB      0x6d,0x71,0x5f,0x75
0001b8  7267656e          DCB      0x72,0x67,0x65,0x6e
0001bc  7400              DCB      0x74,0x00
                  |symbol_number.157|
0001be  7274              DCB      0x72,0x74
0001c0  5f6d715f          DCB      0x5f,0x6d,0x71,0x5f
0001c4  72656376          DCB      0x72,0x65,0x63,0x76
0001c8  00                DCB      0x00
                  |symbol_number.158|
0001c9  72745f            DCB      0x72,0x74,0x5f
0001cc  6d715f63          DCB      0x6d,0x71,0x5f,0x63
0001d0  6f6e7472          DCB      0x6f,0x6e,0x74,0x72
0001d4  6f6c00            DCB      0x6f,0x6c,0x00
