; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_pwr.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_pwr.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_pwr.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_pwr.c]
                          THUMB

                          AREA ||i.PWR_BackupAccessCmd||, CODE, READONLY, ALIGN=2

                  PWR_BackupAccessCmd PROC
;;;134      */
;;;135    void PWR_BackupAccessCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;136    {
000002  0004              MOVS     r4,r0
000004  d005              BEQ      |L1.18|
;;;137      /* Check the parameters */
;;;138      assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d003              BEQ      |L1.18|
00000a  218a              MOVS     r1,#0x8a
00000c  4802              LDR      r0,|L1.24|
00000e  f7fffffe          BL       assert_failed
                  |L1.18|
;;;139      
;;;140      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
000012  4802              LDR      r0,|L1.28|
000014  6204              STR      r4,[r0,#0x20]
;;;141    }
000016  bd10              POP      {r4,pc}
;;;142    
                          ENDP

                  |L1.24|
                          DCD      ||.conststring||
                  |L1.28|
                          DCD      0x420e0000

                          AREA ||i.PWR_BackupRegulatorCmd||, CODE, READONLY, ALIGN=2

                  PWR_BackupRegulatorCmd PROC
;;;297      */
;;;298    void PWR_BackupRegulatorCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;299    {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L2.20|
;;;300      /* Check the parameters */
;;;301      assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L2.20|
00000a  f240112d          MOV      r1,#0x12d
00000e  4803              LDR      r0,|L2.28|
000010  f7fffffe          BL       assert_failed
                  |L2.20|
;;;302    
;;;303      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
000014  4802              LDR      r0,|L2.32|
000016  f8c040a4          STR      r4,[r0,#0xa4]
;;;304    }
00001a  bd10              POP      {r4,pc}
;;;305    
                          ENDP

                  |L2.28|
                          DCD      ||.conststring||
                  |L2.32|
                          DCD      0x420e0000

                          AREA ||i.PWR_ClearFlag||, CODE, READONLY, ALIGN=2

                  PWR_ClearFlag PROC
;;;631      */
;;;632    void PWR_ClearFlag(uint32_t PWR_FLAG)
000000  b510              PUSH     {r4,lr}
;;;633    {
000002  4604              MOV      r4,r0
;;;634      /* Check the parameters */
;;;635      assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
000004  2801              CMP      r0,#1
000006  d006              BEQ      |L3.22|
000008  2c02              CMP      r4,#2
00000a  d004              BEQ      |L3.22|
00000c  f240217b          MOV      r1,#0x27b
000010  4804              LDR      r0,|L3.36|
000012  f7fffffe          BL       assert_failed
                  |L3.22|
;;;636             
;;;637      PWR->CR |=  PWR_FLAG << 2;
000016  4804              LDR      r0,|L3.40|
000018  6801              LDR      r1,[r0,#0]
00001a  ea410184          ORR      r1,r1,r4,LSL #2
00001e  6001              STR      r1,[r0,#0]
;;;638    }
000020  bd10              POP      {r4,pc}
;;;639    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      ||.conststring||
                  |L3.40|
                          DCD      0x40007000

                          AREA ||i.PWR_DeInit||, CODE, READONLY, ALIGN=1

                  PWR_DeInit PROC
;;;119      */
;;;120    void PWR_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;121    {
;;;122      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  070c              LSLS     r4,r1,#28
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;123      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;124    }
;;;125    
                          ENDP


                          AREA ||i.PWR_EnterSTANDBYMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTANDBYMode PROC
;;;547      */
;;;548    void PWR_EnterSTANDBYMode(void)
000000  4807              LDR      r0,|L5.32|
;;;549    {
;;;550      /* Clear Wakeup flag */
;;;551      PWR->CR |= PWR_CR_CWUF;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;552      
;;;553      /* Select STANDBY mode */
;;;554      PWR->CR |= PWR_CR_PDDS;
00000a  6801              LDR      r1,[r0,#0]
00000c  f0410102          ORR      r1,r1,#2
000010  6001              STR      r1,[r0,#0]
;;;555      
;;;556      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;557      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000012  4804              LDR      r0,|L5.36|
000014  6801              LDR      r1,[r0,#0]
000016  f0410104          ORR      r1,r1,#4
00001a  6001              STR      r1,[r0,#0]
;;;558      
;;;559    /* This option is used to ensure that store operations are completed */
;;;560    #if defined ( __CC_ARM   )
;;;561      __force_stores();
;;;562    #endif
;;;563      /* Request Wait For Interrupt */
;;;564      __WFI();
00001c  bf30              WFI      
;;;565    }
00001e  4770              BX       lr
;;;566    
                          ENDP

                  |L5.32|
                          DCD      0x40007000
                  |L5.36|
                          DCD      0xe000ed10

                          AREA ||i.PWR_EnterSTOPMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTOPMode PROC
;;;499      */
;;;500    void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
000000  b570              PUSH     {r4-r6,lr}
;;;501    {
000002  460c              MOV      r4,r1
000004  0005              MOVS     r5,r0
000006  d006              BEQ      |L6.22|
;;;502      uint32_t tmpreg = 0;
;;;503      
;;;504      /* Check the parameters */
;;;505      assert_param(IS_PWR_REGULATOR(PWR_Regulator));
000008  2d01              CMP      r5,#1
00000a  d004              BEQ      |L6.22|
00000c  f24011f9          MOV      r1,#0x1f9
000010  4810              LDR      r0,|L6.84|
000012  f7fffffe          BL       assert_failed
                  |L6.22|
;;;506      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
000016  2c01              CMP      r4,#1
000018  d006              BEQ      |L6.40|
00001a  2c02              CMP      r4,#2
00001c  d004              BEQ      |L6.40|
00001e  f44f71fd          MOV      r1,#0x1fa
000022  480c              LDR      r0,|L6.84|
000024  f7fffffe          BL       assert_failed
                  |L6.40|
;;;507      
;;;508      /* Select the regulator state in STOP mode ---------------------------------*/
;;;509      tmpreg = PWR->CR;
000028  490b              LDR      r1,|L6.88|
00002a  6808              LDR      r0,[r1,#0]
;;;510      /* Clear PDDS and LPDSR bits */
;;;511      tmpreg &= CR_DS_MASK;
00002c  f0200003          BIC      r0,r0,#3
;;;512      
;;;513      /* Set LPDSR bit according to PWR_Regulator value */
;;;514      tmpreg |= PWR_Regulator;
000030  4328              ORRS     r0,r0,r5
;;;515      
;;;516      /* Store the new value */
;;;517      PWR->CR = tmpreg;
000032  6008              STR      r0,[r1,#0]
;;;518      
;;;519      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;520      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000034  4809              LDR      r0,|L6.92|
000036  6801              LDR      r1,[r0,#0]
000038  f0410104          ORR      r1,r1,#4
00003c  6001              STR      r1,[r0,#0]
;;;521      
;;;522      /* Select STOP mode entry --------------------------------------------------*/
;;;523      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
00003e  2c01              CMP      r4,#1
000040  d005              BEQ      |L6.78|
;;;524      {   
;;;525        /* Request Wait For Interrupt */
;;;526        __WFI();
;;;527      }
;;;528      else
;;;529      {
;;;530        /* Request Wait For Event */
;;;531        __WFE();
000042  bf20              WFE      
                  |L6.68|
;;;532      }
;;;533      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;534      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
000044  6801              LDR      r1,[r0,#0]
000046  f0210104          BIC      r1,r1,#4
00004a  6001              STR      r1,[r0,#0]
;;;535    }
00004c  bd70              POP      {r4-r6,pc}
                  |L6.78|
00004e  bf30              WFI                            ;526
000050  e7f8              B        |L6.68|
;;;536    
                          ENDP

000052  0000              DCW      0x0000
                  |L6.84|
                          DCD      ||.conststring||
                  |L6.88|
                          DCD      0x40007000
                  |L6.92|
                          DCD      0xe000ed10

                          AREA ||i.PWR_FlashPowerDownCmd||, CODE, READONLY, ALIGN=2

                  PWR_FlashPowerDownCmd PROC
;;;359      */
;;;360    void PWR_FlashPowerDownCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;361    {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L7.20|
;;;362      /* Check the parameters */
;;;363      assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L7.20|
00000a  f240116b          MOV      r1,#0x16b
00000e  4803              LDR      r0,|L7.28|
000010  f7fffffe          BL       assert_failed
                  |L7.20|
;;;364    
;;;365      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
000014  4802              LDR      r0,|L7.32|
000016  6244              STR      r4,[r0,#0x24]
;;;366    }
000018  bd10              POP      {r4,pc}
;;;367    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      ||.conststring||
                  |L7.32|
                          DCD      0x420e0000

                          AREA ||i.PWR_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  PWR_GetFlagStatus PROC
;;;604      */
;;;605    FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;606    {
;;;607      FlagStatus bitstatus = RESET;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;606
;;;608      
;;;609      /* Check the parameters */
;;;610      assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
000006  2801              CMP      r0,#1
000008  d00d              BEQ      |L8.38|
00000a  2c02              CMP      r4,#2
00000c  d00b              BEQ      |L8.38|
00000e  2c04              CMP      r4,#4
000010  d009              BEQ      |L8.38|
000012  2c08              CMP      r4,#8
000014  d007              BEQ      |L8.38|
000016  f5b44f80          CMP      r4,#0x4000
00001a  d004              BEQ      |L8.38|
00001c  f2402162          MOV      r1,#0x262
000020  4804              LDR      r0,|L8.52|
000022  f7fffffe          BL       assert_failed
                  |L8.38|
;;;611      
;;;612      if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
000026  4804              LDR      r0,|L8.56|
000028  6840              LDR      r0,[r0,#4]
00002a  4220              TST      r0,r4
00002c  d000              BEQ      |L8.48|
;;;613      {
;;;614        bitstatus = SET;
00002e  2501              MOVS     r5,#1
                  |L8.48|
;;;615      }
;;;616      else
;;;617      {
;;;618        bitstatus = RESET;
;;;619      }
;;;620      /* Return the flag status */
;;;621      return bitstatus;
000030  4628              MOV      r0,r5
;;;622    }
000032  bd70              POP      {r4-r6,pc}
;;;623    
                          ENDP

                  |L8.52|
                          DCD      ||.conststring||
                  |L8.56|
                          DCD      0x40007000

                          AREA ||i.PWR_MainRegulatorModeConfig||, CODE, READONLY, ALIGN=2

                  PWR_MainRegulatorModeConfig PROC
;;;317      */
;;;318    void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
000000  b510              PUSH     {r4,lr}
;;;319    {
;;;320      /* Check the parameters */
;;;321      assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));
;;;322    
;;;323      if (PWR_Regulator_Voltage == PWR_Regulator_Voltage_Scale2)
;;;324      {
;;;325        PWR->CR &= ~PWR_Regulator_Voltage_Scale1;
000002  4c09              LDR      r4,|L9.40|
000004  f5b04f80          CMP      r0,#0x4000            ;321
000008  d005              BEQ      |L9.22|
00000a  b148              CBZ      r0,|L9.32|
00000c  f2401141          MOV      r1,#0x141             ;321
000010  4806              LDR      r0,|L9.44|
000012  f7fffffe          BL       assert_failed
                  |L9.22|
;;;326      }
;;;327      else
;;;328      {    
;;;329        PWR->CR |= PWR_Regulator_Voltage_Scale1;
000016  6820              LDR      r0,[r4,#0]
000018  f4404080          ORR      r0,r0,#0x4000
                  |L9.28|
00001c  6020              STR      r0,[r4,#0]            ;325
;;;330      }
;;;331    }
00001e  bd10              POP      {r4,pc}
                  |L9.32|
000020  6820              LDR      r0,[r4,#0]            ;325
000022  f4204080          BIC      r0,r0,#0x4000         ;325
000026  e7f9              B        |L9.28|
;;;332    
                          ENDP

                  |L9.40|
                          DCD      0x40007000
                  |L9.44|
                          DCD      ||.conststring||

                          AREA ||i.PWR_PVDCmd||, CODE, READONLY, ALIGN=2

                  PWR_PVDCmd PROC
;;;205      */
;;;206    void PWR_PVDCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;207    {
000002  0004              MOVS     r4,r0
000004  d005              BEQ      |L10.18|
;;;208      /* Check the parameters */
;;;209      assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d003              BEQ      |L10.18|
00000a  21d1              MOVS     r1,#0xd1
00000c  4802              LDR      r0,|L10.24|
00000e  f7fffffe          BL       assert_failed
                  |L10.18|
;;;210      
;;;211      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
000012  4802              LDR      r0,|L10.28|
000014  6104              STR      r4,[r0,#0x10]
;;;212    }
000016  bd10              POP      {r4,pc}
;;;213    
                          ENDP

                  |L10.24|
                          DCD      ||.conststring||
                  |L10.28|
                          DCD      0x420e0000

                          AREA ||i.PWR_PVDLevelConfig||, CODE, READONLY, ALIGN=2

                  PWR_PVDLevelConfig PROC
;;;180      */
;;;181    void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
000000  b510              PUSH     {r4,lr}
;;;182    {
000002  0004              MOVS     r4,r0
000004  d011              BEQ      |L11.42|
;;;183      uint32_t tmpreg = 0;
;;;184      
;;;185      /* Check the parameters */
;;;186      assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
000006  2c20              CMP      r4,#0x20
000008  d00f              BEQ      |L11.42|
00000a  2c40              CMP      r4,#0x40
00000c  d00d              BEQ      |L11.42|
00000e  2c60              CMP      r4,#0x60
000010  d00b              BEQ      |L11.42|
000012  2c80              CMP      r4,#0x80
000014  d009              BEQ      |L11.42|
000016  2ca0              CMP      r4,#0xa0
000018  d007              BEQ      |L11.42|
00001a  2cc0              CMP      r4,#0xc0
00001c  d005              BEQ      |L11.42|
00001e  2ce0              CMP      r4,#0xe0
000020  d003              BEQ      |L11.42|
000022  21ba              MOVS     r1,#0xba
000024  4804              LDR      r0,|L11.56|
000026  f7fffffe          BL       assert_failed
                  |L11.42|
;;;187      
;;;188      tmpreg = PWR->CR;
00002a  4904              LDR      r1,|L11.60|
00002c  6808              LDR      r0,[r1,#0]
;;;189      
;;;190      /* Clear PLS[7:5] bits */
;;;191      tmpreg &= CR_PLS_MASK;
00002e  f02000e0          BIC      r0,r0,#0xe0
;;;192      
;;;193      /* Set PLS[7:5] bits according to PWR_PVDLevel value */
;;;194      tmpreg |= PWR_PVDLevel;
000032  4320              ORRS     r0,r0,r4
;;;195      
;;;196      /* Store the new value */
;;;197      PWR->CR = tmpreg;
000034  6008              STR      r0,[r1,#0]
;;;198    }
000036  bd10              POP      {r4,pc}
;;;199    
                          ENDP

                  |L11.56|
                          DCD      ||.conststring||
                  |L11.60|
                          DCD      0x40007000

                          AREA ||i.PWR_WakeUpPinCmd||, CODE, READONLY, ALIGN=2

                  PWR_WakeUpPinCmd PROC
;;;239      */
;;;240    void PWR_WakeUpPinCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;241    {
000002  0004              MOVS     r4,r0
000004  d005              BEQ      |L12.18|
;;;242      /* Check the parameters */  
;;;243      assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d003              BEQ      |L12.18|
00000a  21f3              MOVS     r1,#0xf3
00000c  4803              LDR      r0,|L12.28|
00000e  f7fffffe          BL       assert_failed
                  |L12.18|
;;;244    
;;;245      *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
000012  4803              LDR      r0,|L12.32|
000014  f8c040a0          STR      r4,[r0,#0xa0]
;;;246    }
000018  bd10              POP      {r4,pc}
;;;247    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      ||.conststring||
                  |L12.32|
                          DCD      0x420e0000

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_pwr.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f707772
00004a  2e6300  

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_pwr.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____REVSH|
#line 128
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
