; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_adc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_adc.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c]
                          THUMB

                          AREA ||i.ADC_AnalogWatchdogCmd||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogCmd PROC
;;;449      */
;;;450    void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
000000  b570              PUSH     {r4-r6,lr}
;;;451    {
000002  4605              MOV      r5,r0
;;;452      uint32_t tmpreg = 0;
;;;453      /* Check the parameters */
;;;454      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4816              LDR      r0,|L1.96|
000006  460c              MOV      r4,r1                 ;451
000008  4285              CMP      r5,r0
00000a  d00a              BEQ      |L1.34|
00000c  4815              LDR      r0,|L1.100|
00000e  4285              CMP      r5,r0
000010  d007              BEQ      |L1.34|
000012  4815              LDR      r0,|L1.104|
000014  4285              CMP      r5,r0
000016  d004              BEQ      |L1.34|
000018  f44f71e3          MOV      r1,#0x1c6
00001c  4813              LDR      r0,|L1.108|
00001e  f7fffffe          BL       assert_failed
                  |L1.34|
;;;455      assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
000022  4813              LDR      r0,|L1.112|
000024  4284              CMP      r4,r0
000026  d014              BEQ      |L1.82|
000028  4812              LDR      r0,|L1.116|
00002a  4284              CMP      r4,r0
00002c  d011              BEQ      |L1.82|
00002e  4812              LDR      r0,|L1.120|
000030  4284              CMP      r4,r0
000032  d00e              BEQ      |L1.82|
000034  f5b40f00          CMP      r4,#0x800000
000038  d00b              BEQ      |L1.82|
00003a  f5b40f80          CMP      r4,#0x400000
00003e  d008              BEQ      |L1.82|
000040  f5b40f40          CMP      r4,#0xc00000
000044  d005              BEQ      |L1.82|
000046  b124              CBZ      r4,|L1.82|
000048  f24011c7          MOV      r1,#0x1c7
00004c  4807              LDR      r0,|L1.108|
00004e  f7fffffe          BL       assert_failed
                  |L1.82|
;;;456      
;;;457      /* Get the old register value */
;;;458      tmpreg = ADCx->CR1;
000052  6868              LDR      r0,[r5,#4]
;;;459      
;;;460      /* Clear AWDEN, JAWDEN and AWDSGL bits */
;;;461      tmpreg &= CR1_AWDMode_RESET;
000054  4908              LDR      r1,|L1.120|
000056  43c9              MVNS     r1,r1
000058  4008              ANDS     r0,r0,r1
;;;462      
;;;463      /* Set the analog watchdog enable mode */
;;;464      tmpreg |= ADC_AnalogWatchdog;
00005a  4320              ORRS     r0,r0,r4
;;;465      
;;;466      /* Store the new register value */
;;;467      ADCx->CR1 = tmpreg;
00005c  6068              STR      r0,[r5,#4]
;;;468    }
00005e  bd70              POP      {r4-r6,pc}
;;;469    
                          ENDP

                  |L1.96|
                          DCD      0x40012000
                  |L1.100|
                          DCD      0x40012100
                  |L1.104|
                          DCD      0x40012200
                  |L1.108|
                          DCD      ||.conststring||
                  |L1.112|
                          DCD      0x00800200
                  |L1.116|
                          DCD      0x00400200
                  |L1.120|
                          DCD      0x00c00200

                          AREA ||i.ADC_AnalogWatchdogSingleChannelConfig||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;519      */
;;;520    void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;521    {
000002  4605              MOV      r5,r0
;;;522      uint32_t tmpreg = 0;
;;;523      /* Check the parameters */
;;;524      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  481f              LDR      r0,|L2.132|
000006  460c              MOV      r4,r1                 ;521
000008  4285              CMP      r5,r0
00000a  d00a              BEQ      |L2.34|
00000c  481e              LDR      r0,|L2.136|
00000e  4285              CMP      r5,r0
000010  d007              BEQ      |L2.34|
000012  481e              LDR      r0,|L2.140|
000014  4285              CMP      r5,r0
000016  d004              BEQ      |L2.34|
000018  f44f7103          MOV      r1,#0x20c
00001c  481c              LDR      r0,|L2.144|
00001e  f7fffffe          BL       assert_failed
                  |L2.34|
;;;525      assert_param(IS_ADC_CHANNEL(ADC_Channel));
000022  b344              CBZ      r4,|L2.118|
000024  2c01              CMP      r4,#1
000026  d026              BEQ      |L2.118|
000028  2c02              CMP      r4,#2
00002a  d024              BEQ      |L2.118|
00002c  2c03              CMP      r4,#3
00002e  d022              BEQ      |L2.118|
000030  2c04              CMP      r4,#4
000032  d020              BEQ      |L2.118|
000034  2c05              CMP      r4,#5
000036  d01e              BEQ      |L2.118|
000038  2c06              CMP      r4,#6
00003a  d01c              BEQ      |L2.118|
00003c  2c07              CMP      r4,#7
00003e  d01a              BEQ      |L2.118|
000040  2c08              CMP      r4,#8
000042  d018              BEQ      |L2.118|
000044  2c09              CMP      r4,#9
000046  d016              BEQ      |L2.118|
000048  2c0a              CMP      r4,#0xa
00004a  d014              BEQ      |L2.118|
00004c  2c0b              CMP      r4,#0xb
00004e  d012              BEQ      |L2.118|
000050  2c0c              CMP      r4,#0xc
000052  d010              BEQ      |L2.118|
000054  2c0d              CMP      r4,#0xd
000056  d00e              BEQ      |L2.118|
000058  2c0e              CMP      r4,#0xe
00005a  d00c              BEQ      |L2.118|
00005c  2c0f              CMP      r4,#0xf
00005e  d00a              BEQ      |L2.118|
000060  2c10              CMP      r4,#0x10
000062  d008              BEQ      |L2.118|
000064  2c11              CMP      r4,#0x11
000066  d006              BEQ      |L2.118|
000068  2c12              CMP      r4,#0x12
00006a  d004              BEQ      |L2.118|
00006c  f240210d          MOV      r1,#0x20d
000070  4807              LDR      r0,|L2.144|
000072  f7fffffe          BL       assert_failed
                  |L2.118|
;;;526      
;;;527      /* Get the old register value */
;;;528      tmpreg = ADCx->CR1;
000076  6868              LDR      r0,[r5,#4]
;;;529      
;;;530      /* Clear the Analog watchdog channel select bits */
;;;531      tmpreg &= CR1_AWDCH_RESET;
000078  f020001f          BIC      r0,r0,#0x1f
;;;532      
;;;533      /* Set the Analog watchdog channel */
;;;534      tmpreg |= ADC_Channel;
00007c  4320              ORRS     r0,r0,r4
;;;535      
;;;536      /* Store the new register value */
;;;537      ADCx->CR1 = tmpreg;
00007e  6068              STR      r0,[r5,#4]
;;;538    }
000080  bd70              POP      {r4-r6,pc}
;;;539    /**
                          ENDP

000082  0000              DCW      0x0000
                  |L2.132|
                          DCD      0x40012000
                  |L2.136|
                          DCD      0x40012100
                  |L2.140|
                          DCD      0x40012200
                  |L2.144|
                          DCD      ||.conststring||

                          AREA ||i.ADC_AnalogWatchdogThresholdsConfig||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;478      */
;;;479    void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;480                                            uint16_t LowThreshold)
;;;481    {
000004  4604              MOV      r4,r0
;;;482      /* Check the parameters */
;;;483      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  4812              LDR      r0,|L3.80|
000008  4615              MOV      r5,r2                 ;481
00000a  460e              MOV      r6,r1                 ;481
00000c  4284              CMP      r4,r0
00000e  d00a              BEQ      |L3.38|
000010  4810              LDR      r0,|L3.84|
000012  4284              CMP      r4,r0
000014  d007              BEQ      |L3.38|
000016  4810              LDR      r0,|L3.88|
000018  4284              CMP      r4,r0
00001a  d004              BEQ      |L3.38|
00001c  f24011e3          MOV      r1,#0x1e3
000020  480e              LDR      r0,|L3.92|
000022  f7fffffe          BL       assert_failed
                  |L3.38|
;;;484      assert_param(IS_ADC_THRESHOLD(HighThreshold));
000026  f44f5780          MOV      r7,#0x1000
00002a  42be              CMP      r6,r7
00002c  d304              BCC      |L3.56|
00002e  f44f71f2          MOV      r1,#0x1e4
000032  480a              LDR      r0,|L3.92|
000034  f7fffffe          BL       assert_failed
                  |L3.56|
;;;485      assert_param(IS_ADC_THRESHOLD(LowThreshold));
000038  42bd              CMP      r5,r7
00003a  d304              BCC      |L3.70|
00003c  f24011e5          MOV      r1,#0x1e5
000040  4806              LDR      r0,|L3.92|
000042  f7fffffe          BL       assert_failed
                  |L3.70|
;;;486      
;;;487      /* Set the ADCx high threshold */
;;;488      ADCx->HTR = HighThreshold;
000046  6266              STR      r6,[r4,#0x24]
;;;489      
;;;490      /* Set the ADCx low threshold */
;;;491      ADCx->LTR = LowThreshold;
000048  62a5              STR      r5,[r4,#0x28]
;;;492    }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;493    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      0x40012000
                  |L3.84|
                          DCD      0x40012100
                  |L3.88|
                          DCD      0x40012200
                  |L3.92|
                          DCD      ||.conststring||

                          AREA ||i.ADC_AutoInjectedConvCmd||, CODE, READONLY, ALIGN=2

                  ADC_AutoInjectedConvCmd PROC
;;;1418     */
;;;1419   void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1420   {
000002  4604              MOV      r4,r0
;;;1421     /* Check the parameters */
;;;1422     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480f              LDR      r0,|L4.68|
000006  460d              MOV      r5,r1                 ;1420
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L4.34|
00000c  480e              LDR      r0,|L4.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L4.34|
000012  480e              LDR      r0,|L4.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L4.34|
000018  f240518e          MOV      r1,#0x58e
00001c  480c              LDR      r0,|L4.80|
00001e  f7fffffe          BL       assert_failed
                  |L4.34|
;;;1423     assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L4.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L4.50|
000028  f240518f          MOV      r1,#0x58f
00002c  4808              LDR      r0,|L4.80|
00002e  f7fffffe          BL       assert_failed
                  |L4.50|
;;;1424     if (NewState != DISABLE)
;;;1425     {
;;;1426       /* Enable the selected ADC automatic injected group conversion */
;;;1427       ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
000032  6860              LDR      r0,[r4,#4]
000034  f4406080          ORR      r0,r0,#0x400
000038  e002              B        |L4.64|
                  |L4.58|
;;;1428     }
;;;1429     else
;;;1430     {
;;;1431       /* Disable the selected ADC automatic injected group conversion */
;;;1432       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
00003a  6860              LDR      r0,[r4,#4]
00003c  f4206080          BIC      r0,r0,#0x400
                  |L4.64|
000040  6060              STR      r0,[r4,#4]            ;1427
;;;1433     }
;;;1434   }
000042  bd70              POP      {r4-r6,pc}
;;;1435   
                          ENDP

                  |L4.68|
                          DCD      0x40012000
                  |L4.72|
                          DCD      0x40012100
                  |L4.76|
                          DCD      0x40012200
                  |L4.80|
                          DCD      ||.conststring||

                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=2

                  ADC_ClearFlag PROC
;;;1652     */
;;;1653   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1654   {
000002  4604              MOV      r4,r0
;;;1655     /* Check the parameters */
;;;1656     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480c              LDR      r0,|L5.56|
000006  460d              MOV      r5,r1                 ;1654
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L5.34|
00000c  480b              LDR      r0,|L5.60|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L5.34|
000012  480b              LDR      r0,|L5.64|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L5.34|
000018  f44f61cf          MOV      r1,#0x678
00001c  4809              LDR      r0,|L5.68|
00001e  f7fffffe          BL       assert_failed
                  |L5.34|
;;;1657     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
000022  09a8              LSRS     r0,r5,#6
000024  d100              BNE      |L5.40|
000026  b925              CBNZ     r5,|L5.50|
                  |L5.40|
000028  f2406179          MOV      r1,#0x679
00002c  4805              LDR      r0,|L5.68|
00002e  f7fffffe          BL       assert_failed
                  |L5.50|
;;;1658   
;;;1659     /* Clear the selected ADC flags */
;;;1660     ADCx->SR = ~(uint32_t)ADC_FLAG;
000032  43e8              MVNS     r0,r5
000034  6020              STR      r0,[r4,#0]
;;;1661   }
000036  bd70              POP      {r4-r6,pc}
;;;1662   
                          ENDP

                  |L5.56|
                          DCD      0x40012000
                  |L5.60|
                          DCD      0x40012100
                  |L5.64|
                          DCD      0x40012200
                  |L5.68|
                          DCD      ||.conststring||

                          AREA ||i.ADC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  ADC_ClearITPendingBit PROC
;;;1714     */
;;;1715   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1716   {
000002  4605              MOV      r5,r0
;;;1717     uint8_t itmask = 0;
;;;1718     /* Check the parameters */
;;;1719     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4813              LDR      r0,|L6.84|
000006  460c              MOV      r4,r1                 ;1716
000008  4285              CMP      r5,r0
00000a  d00a              BEQ      |L6.34|
00000c  4812              LDR      r0,|L6.88|
00000e  4285              CMP      r5,r0
000010  d007              BEQ      |L6.34|
000012  4812              LDR      r0,|L6.92|
000014  4285              CMP      r5,r0
000016  d004              BEQ      |L6.34|
000018  f24061b7          MOV      r1,#0x6b7
00001c  4810              LDR      r0,|L6.96|
00001e  f7fffffe          BL       assert_failed
                  |L6.34|
;;;1720     assert_param(IS_ADC_IT(ADC_IT)); 
000022  f5a47000          SUB      r0,r4,#0x200
000026  3805              SUBS     r0,#5
000028  d00f              BEQ      |L6.74|
00002a  f5b47f83          CMP      r4,#0x106
00002e  d00c              BEQ      |L6.74|
000030  f5a46080          SUB      r0,r4,#0x400
000034  3807              SUBS     r0,#7
000036  d008              BEQ      |L6.74|
000038  f5a45000          SUB      r0,r4,#0x2000
00003c  381a              SUBS     r0,r0,#0x1a
00003e  d004              BEQ      |L6.74|
000040  f44f61d7          MOV      r1,#0x6b8
000044  4806              LDR      r0,|L6.96|
000046  f7fffffe          BL       assert_failed
                  |L6.74|
;;;1721     /* Get the ADC IT index */
;;;1722     itmask = (uint8_t)(ADC_IT >> 8);
;;;1723     /* Clear the selected ADC interrupt pending bits */
;;;1724     ADCx->SR = ~(uint32_t)itmask;
00004a  ea6f2014          MVN      r0,r4,LSR #8
00004e  6028              STR      r0,[r5,#0]
;;;1725   }                    
000050  bd70              POP      {r4-r6,pc}
;;;1726   /**
                          ENDP

000052  0000              DCW      0x0000
                  |L6.84|
                          DCD      0x40012000
                  |L6.88|
                          DCD      0x40012100
                  |L6.92|
                          DCD      0x40012200
                  |L6.96|
                          DCD      ||.conststring||

                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=2

                  ADC_Cmd PROC
;;;391      */
;;;392    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;393    {
000002  4604              MOV      r4,r0
;;;394      /* Check the parameters */
;;;395      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480f              LDR      r0,|L7.68|
000006  460d              MOV      r5,r1                 ;393
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L7.34|
00000c  480e              LDR      r0,|L7.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L7.34|
000012  480e              LDR      r0,|L7.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L7.34|
000018  f240118b          MOV      r1,#0x18b
00001c  480c              LDR      r0,|L7.80|
00001e  f7fffffe          BL       assert_failed
                  |L7.34|
;;;396      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L7.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L7.50|
000028  f44f71c6          MOV      r1,#0x18c
00002c  4808              LDR      r0,|L7.80|
00002e  f7fffffe          BL       assert_failed
                  |L7.50|
;;;397      if (NewState != DISABLE)
;;;398      {
;;;399        /* Set the ADON bit to wake up the ADC from power down mode */
;;;400        ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
000032  68a0              LDR      r0,[r4,#8]
000034  f0400001          ORR      r0,r0,#1
000038  e002              B        |L7.64|
                  |L7.58|
;;;401      }
;;;402      else
;;;403      {
;;;404        /* Disable the selected ADC peripheral */
;;;405        ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
00003a  68a0              LDR      r0,[r4,#8]
00003c  f0200001          BIC      r0,r0,#1
                  |L7.64|
000040  60a0              STR      r0,[r4,#8]            ;400
;;;406      }
;;;407    }
000042  bd70              POP      {r4-r6,pc}
;;;408    /**
                          ENDP

                  |L7.68|
                          DCD      0x40012000
                  |L7.72|
                          DCD      0x40012100
                  |L7.76|
                          DCD      0x40012200
                  |L7.80|
                          DCD      ||.conststring||

                          AREA ||i.ADC_CommonInit||, CODE, READONLY, ALIGN=2

                  ADC_CommonInit PROC
;;;333      */
;;;334    void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
000000  b510              PUSH     {r4,lr}
;;;335    {
000002  6801              LDR      r1,[r0,#0]
000004  4604              MOV      r4,r0
000006  b1e1              CBZ      r1,|L8.66|
;;;336      uint32_t tmpreg1 = 0;
;;;337      /* Check the parameters */
;;;338      assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
000008  2901              CMP      r1,#1
00000a  d01a              BEQ      |L8.66|
00000c  2902              CMP      r1,#2
00000e  d018              BEQ      |L8.66|
000010  2905              CMP      r1,#5
000012  d016              BEQ      |L8.66|
000014  2906              CMP      r1,#6
000016  d014              BEQ      |L8.66|
000018  2907              CMP      r1,#7
00001a  d012              BEQ      |L8.66|
00001c  2909              CMP      r1,#9
00001e  d010              BEQ      |L8.66|
000020  2911              CMP      r1,#0x11
000022  d00e              BEQ      |L8.66|
000024  2912              CMP      r1,#0x12
000026  d00c              BEQ      |L8.66|
000028  2915              CMP      r1,#0x15
00002a  d00a              BEQ      |L8.66|
00002c  2916              CMP      r1,#0x16
00002e  d008              BEQ      |L8.66|
000030  2917              CMP      r1,#0x17
000032  d006              BEQ      |L8.66|
000034  2919              CMP      r1,#0x19
000036  d004              BEQ      |L8.66|
000038  f44f71a9          MOV      r1,#0x152
00003c  4833              LDR      r0,|L8.268|
00003e  f7fffffe          BL       assert_failed
                  |L8.66|
;;;339      assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
000042  6860              LDR      r0,[r4,#4]
000044  b168              CBZ      r0,|L8.98|
000046  f5b03f80          CMP      r0,#0x10000
00004a  d00a              BEQ      |L8.98|
00004c  f5b03f00          CMP      r0,#0x20000
000050  d007              BEQ      |L8.98|
000052  f5b03f40          CMP      r0,#0x30000
000056  d004              BEQ      |L8.98|
000058  f2401153          MOV      r1,#0x153
00005c  482b              LDR      r0,|L8.268|
00005e  f7fffffe          BL       assert_failed
                  |L8.98|
;;;340      assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
000062  68a0              LDR      r0,[r4,#8]
000064  b168              CBZ      r0,|L8.130|
000066  f5b04f80          CMP      r0,#0x4000
00006a  d00a              BEQ      |L8.130|
00006c  f5b04f00          CMP      r0,#0x8000
000070  d007              BEQ      |L8.130|
000072  f5b04f40          CMP      r0,#0xc000
000076  d004              BEQ      |L8.130|
000078  f44f71aa          MOV      r1,#0x154
00007c  4823              LDR      r0,|L8.268|
00007e  f7fffffe          BL       assert_failed
                  |L8.130|
;;;341      assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
000082  68e1              LDR      r1,[r4,#0xc]
000084  b389              CBZ      r1,|L8.234|
000086  f5b17f80          CMP      r1,#0x100
00008a  d02e              BEQ      |L8.234|
00008c  f5b17f00          CMP      r1,#0x200
000090  d02b              BEQ      |L8.234|
000092  f5b17f40          CMP      r1,#0x300
000096  d028              BEQ      |L8.234|
000098  f5b16f80          CMP      r1,#0x400
00009c  d025              BEQ      |L8.234|
00009e  f5b16fa0          CMP      r1,#0x500
0000a2  d022              BEQ      |L8.234|
0000a4  f5b16fc0          CMP      r1,#0x600
0000a8  d01f              BEQ      |L8.234|
0000aa  f5b16fe0          CMP      r1,#0x700
0000ae  d01c              BEQ      |L8.234|
0000b0  f5b16f00          CMP      r1,#0x800
0000b4  d019              BEQ      |L8.234|
0000b6  f5b16f10          CMP      r1,#0x900
0000ba  d016              BEQ      |L8.234|
0000bc  f5b16f20          CMP      r1,#0xa00
0000c0  d013              BEQ      |L8.234|
0000c2  f5b16f30          CMP      r1,#0xb00
0000c6  d010              BEQ      |L8.234|
0000c8  f5b16f40          CMP      r1,#0xc00
0000cc  d00d              BEQ      |L8.234|
0000ce  f5b16f50          CMP      r1,#0xd00
0000d2  d00a              BEQ      |L8.234|
0000d4  f5b16f60          CMP      r1,#0xe00
0000d8  d007              BEQ      |L8.234|
0000da  f5b16f70          CMP      r1,#0xf00
0000de  d004              BEQ      |L8.234|
0000e0  f2401155          MOV      r1,#0x155
0000e4  4809              LDR      r0,|L8.268|
0000e6  f7fffffe          BL       assert_failed
                  |L8.234|
;;;342      /*---------------------------- ADC CCR Configuration -----------------*/
;;;343      /* Get the ADC CCR value */
;;;344      tmpreg1 = ADC->CCR;
0000ea  4a09              LDR      r2,|L8.272|
0000ec  f8d20304          LDR      r0,[r2,#0x304]
;;;345      
;;;346      /* Clear MULTI, DELAY, DMA and ADCPRE bits */
;;;347      tmpreg1 &= CR_CLEAR_MASK;
0000f0  4908              LDR      r1,|L8.276|
0000f2  4008              ANDS     r0,r0,r1
0000f4  e9d41300          LDRD     r1,r3,[r4,#0]
;;;348      
;;;349      /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,
;;;350         and DMA access mode for multimode */
;;;351      /* Set MULTI bits according to ADC_Mode value */
;;;352      /* Set ADCPRE bits according to ADC_Prescaler value */
;;;353      /* Set DMA bits according to ADC_DMAAccessMode value */
;;;354      /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
;;;355      tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
0000f8  4319              ORRS     r1,r1,r3
0000fa  e9d43402          LDRD     r3,r4,[r4,#8]
0000fe  4323              ORRS     r3,r3,r4
000100  4319              ORRS     r1,r1,r3
000102  4301              ORRS     r1,r1,r0
;;;356                            ADC_CommonInitStruct->ADC_Prescaler | 
;;;357                            ADC_CommonInitStruct->ADC_DMAAccessMode | 
;;;358                            ADC_CommonInitStruct->ADC_TwoSamplingDelay);
;;;359                            
;;;360      /* Write to ADC CCR */
;;;361      ADC->CCR = tmpreg1;
000104  f8c21304          STR      r1,[r2,#0x304]
;;;362    }
000108  bd10              POP      {r4,pc}
;;;363    
                          ENDP

00010a  0000              DCW      0x0000
                  |L8.268|
                          DCD      ||.conststring||
                  |L8.272|
                          DCD      0x40012000
                  |L8.276|
                          DCD      0xfffc30e0

                          AREA ||i.ADC_CommonStructInit||, CODE, READONLY, ALIGN=1

                  ADC_CommonStructInit PROC
;;;369      */
;;;370    void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
000000  2100              MOVS     r1,#0
;;;371    {
;;;372      /* Initialize the ADC_Mode member */
;;;373      ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
;;;374    
;;;375      /* initialize the ADC_Prescaler member */
;;;376      ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
000002  6001              STR      r1,[r0,#0]
;;;377    
;;;378      /* Initialize the ADC_DMAAccessMode member */
;;;379      ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
000004  6041              STR      r1,[r0,#4]
;;;380    
;;;381      /* Initialize the ADC_TwoSamplingDelay member */
;;;382      ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;383    }
00000a  4770              BX       lr
;;;384    
                          ENDP


                          AREA ||i.ADC_ContinuousModeCmd||, CODE, READONLY, ALIGN=2

                  ADC_ContinuousModeCmd PROC
;;;896      */
;;;897    void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;898    {
000002  4604              MOV      r4,r0
;;;899      /* Check the parameters */
;;;900      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480f              LDR      r0,|L10.68|
000006  460d              MOV      r5,r1                 ;898
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L10.34|
00000c  480e              LDR      r0,|L10.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L10.34|
000012  480e              LDR      r0,|L10.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L10.34|
000018  f44f7161          MOV      r1,#0x384
00001c  480c              LDR      r0,|L10.80|
00001e  f7fffffe          BL       assert_failed
                  |L10.34|
;;;901      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L10.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L10.50|
000028  f2403185          MOV      r1,#0x385
00002c  4808              LDR      r0,|L10.80|
00002e  f7fffffe          BL       assert_failed
                  |L10.50|
;;;902      
;;;903      if (NewState != DISABLE)
;;;904      {
;;;905        /* Enable the selected ADC continuous conversion mode */
;;;906        ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
000032  68a0              LDR      r0,[r4,#8]
000034  f0400002          ORR      r0,r0,#2
000038  e002              B        |L10.64|
                  |L10.58|
;;;907      }
;;;908      else
;;;909      {
;;;910        /* Disable the selected ADC continuous conversion mode */
;;;911        ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
00003a  68a0              LDR      r0,[r4,#8]
00003c  f0200002          BIC      r0,r0,#2
                  |L10.64|
000040  60a0              STR      r0,[r4,#8]            ;906
;;;912      }
;;;913    }
000042  bd70              POP      {r4-r6,pc}
;;;914    
                          ENDP

                  |L10.68|
                          DCD      0x40012000
                  |L10.72|
                          DCD      0x40012100
                  |L10.76|
                          DCD      0x40012200
                  |L10.80|
                          DCD      ||.conststring||

                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=2

                  ADC_DMACmd PROC
;;;1047     */
;;;1048   void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1049   {
000002  4604              MOV      r4,r0
;;;1050     /* Check the parameters */
;;;1051     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480f              LDR      r0,|L11.68|
000006  460d              MOV      r5,r1                 ;1049
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L11.34|
00000c  480e              LDR      r0,|L11.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L11.34|
000012  480e              LDR      r0,|L11.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L11.34|
000018  f240411b          MOV      r1,#0x41b
00001c  480c              LDR      r0,|L11.80|
00001e  f7fffffe          BL       assert_failed
                  |L11.34|
;;;1052     assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L11.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L11.50|
000028  f240411c          MOV      r1,#0x41c
00002c  4808              LDR      r0,|L11.80|
00002e  f7fffffe          BL       assert_failed
                  |L11.50|
;;;1053     if (NewState != DISABLE)
;;;1054     {
;;;1055       /* Enable the selected ADC DMA request */
;;;1056       ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
000032  68a0              LDR      r0,[r4,#8]
000034  f4407080          ORR      r0,r0,#0x100
000038  e002              B        |L11.64|
                  |L11.58|
;;;1057     }
;;;1058     else
;;;1059     {
;;;1060       /* Disable the selected ADC DMA request */
;;;1061       ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
00003a  68a0              LDR      r0,[r4,#8]
00003c  f4207080          BIC      r0,r0,#0x100
                  |L11.64|
000040  60a0              STR      r0,[r4,#8]            ;1056
;;;1062     }
;;;1063   }
000042  bd70              POP      {r4-r6,pc}
;;;1064   
                          ENDP

                  |L11.68|
                          DCD      0x40012000
                  |L11.72|
                          DCD      0x40012100
                  |L11.76|
                          DCD      0x40012200
                  |L11.80|
                          DCD      ||.conststring||

                          AREA ||i.ADC_DMARequestAfterLastTransferCmd||, CODE, READONLY, ALIGN=2

                  ADC_DMARequestAfterLastTransferCmd PROC
;;;1071     */
;;;1072   void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1073   {
000002  4604              MOV      r4,r0
;;;1074     /* Check the parameters */
;;;1075     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480f              LDR      r0,|L12.68|
000006  460d              MOV      r5,r1                 ;1073
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L12.34|
00000c  480e              LDR      r0,|L12.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L12.34|
000012  480e              LDR      r0,|L12.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L12.34|
000018  f2404133          MOV      r1,#0x433
00001c  480c              LDR      r0,|L12.80|
00001e  f7fffffe          BL       assert_failed
                  |L12.34|
;;;1076     assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L12.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L12.50|
000028  f2404134          MOV      r1,#0x434
00002c  4808              LDR      r0,|L12.80|
00002e  f7fffffe          BL       assert_failed
                  |L12.50|
;;;1077     if (NewState != DISABLE)
;;;1078     {
;;;1079       /* Enable the selected ADC DMA request after last transfer */
;;;1080       ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
000032  68a0              LDR      r0,[r4,#8]
000034  f4407000          ORR      r0,r0,#0x200
000038  e002              B        |L12.64|
                  |L12.58|
;;;1081     }
;;;1082     else
;;;1083     {
;;;1084       /* Disable the selected ADC DMA request after last transfer */
;;;1085       ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
00003a  68a0              LDR      r0,[r4,#8]
00003c  f4207000          BIC      r0,r0,#0x200
                  |L12.64|
000040  60a0              STR      r0,[r4,#8]            ;1080
;;;1086     }
;;;1087   }
000042  bd70              POP      {r4-r6,pc}
;;;1088   
                          ENDP

                  |L12.68|
                          DCD      0x40012000
                  |L12.72|
                          DCD      0x40012100
                  |L12.76|
                          DCD      0x40012200
                  |L12.80|
                          DCD      ||.conststring||

                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=1

                  ADC_DeInit PROC
;;;205      */
;;;206    void ADC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;207    {
;;;208      /* Enable all ADCs reset state */
;;;209      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
000002  2101              MOVS     r1,#1
000004  020c              LSLS     r4,r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;210      
;;;211      /* Release all ADCs from reset state */
;;;212      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
;;;213    }
;;;214    
                          ENDP


                          AREA ||i.ADC_DiscModeChannelCountConfig||, CODE, READONLY, ALIGN=2

                  ADC_DiscModeChannelCountConfig PROC
;;;922      */
;;;923    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;924    {
000002  4604              MOV      r4,r0
;;;925      uint32_t tmpreg1 = 0;
;;;926      uint32_t tmpreg2 = 0;
;;;927      
;;;928      /* Check the parameters */
;;;929      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480f              LDR      r0,|L14.68|
000006  460d              MOV      r5,r1                 ;924
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L14.34|
00000c  480e              LDR      r0,|L14.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L14.34|
000012  480e              LDR      r0,|L14.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L14.34|
000018  f24031a1          MOV      r1,#0x3a1
00001c  480c              LDR      r0,|L14.80|
00001e  f7fffffe          BL       assert_failed
                  |L14.34|
;;;930      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
000022  1e68              SUBS     r0,r5,#1
000024  2807              CMP      r0,#7
000026  d904              BLS      |L14.50|
000028  f24031a2          MOV      r1,#0x3a2
00002c  4808              LDR      r0,|L14.80|
00002e  f7fffffe          BL       assert_failed
                  |L14.50|
;;;931      
;;;932      /* Get the old register value */
;;;933      tmpreg1 = ADCx->CR1;
000032  6860              LDR      r0,[r4,#4]
;;;934      
;;;935      /* Clear the old discontinuous mode channel count */
;;;936      tmpreg1 &= CR1_DISCNUM_RESET;
000034  1e6d              SUBS     r5,r5,#1
000036  f4204060          BIC      r0,r0,#0xe000
;;;937      
;;;938      /* Set the discontinuous mode channel count */
;;;939      tmpreg2 = Number - 1;
;;;940      tmpreg1 |= tmpreg2 << 13;
00003a  ea403045          ORR      r0,r0,r5,LSL #13
;;;941      
;;;942      /* Store the new register value */
;;;943      ADCx->CR1 = tmpreg1;
00003e  6060              STR      r0,[r4,#4]
;;;944    }
000040  bd70              POP      {r4-r6,pc}
;;;945    
                          ENDP

000042  0000              DCW      0x0000
                  |L14.68|
                          DCD      0x40012000
                  |L14.72|
                          DCD      0x40012100
                  |L14.76|
                          DCD      0x40012200
                  |L14.80|
                          DCD      ||.conststring||

                          AREA ||i.ADC_DiscModeCmd||, CODE, READONLY, ALIGN=2

                  ADC_DiscModeCmd PROC
;;;954      */
;;;955    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;956    {
000002  4604              MOV      r4,r0
;;;957      /* Check the parameters */
;;;958      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480f              LDR      r0,|L15.68|
000006  460d              MOV      r5,r1                 ;956
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L15.34|
00000c  480e              LDR      r0,|L15.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L15.34|
000012  480e              LDR      r0,|L15.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L15.34|
000018  f24031be          MOV      r1,#0x3be
00001c  480c              LDR      r0,|L15.80|
00001e  f7fffffe          BL       assert_failed
                  |L15.34|
;;;959      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L15.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L15.50|
000028  f24031bf          MOV      r1,#0x3bf
00002c  4808              LDR      r0,|L15.80|
00002e  f7fffffe          BL       assert_failed
                  |L15.50|
;;;960      
;;;961      if (NewState != DISABLE)
;;;962      {
;;;963        /* Enable the selected ADC regular discontinuous mode */
;;;964        ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
000032  6860              LDR      r0,[r4,#4]
000034  f4406000          ORR      r0,r0,#0x800
000038  e002              B        |L15.64|
                  |L15.58|
;;;965      }
;;;966      else
;;;967      {
;;;968        /* Disable the selected ADC regular discontinuous mode */
;;;969        ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
00003a  6860              LDR      r0,[r4,#4]
00003c  f4206000          BIC      r0,r0,#0x800
                  |L15.64|
000040  6060              STR      r0,[r4,#4]            ;964
;;;970      }
;;;971    }
000042  bd70              POP      {r4-r6,pc}
;;;972    
                          ENDP

                  |L15.68|
                          DCD      0x40012000
                  |L15.72|
                          DCD      0x40012100
                  |L15.76|
                          DCD      0x40012200
                  |L15.80|
                          DCD      ||.conststring||

                          AREA ||i.ADC_EOCOnEachRegularChannelCmd||, CODE, READONLY, ALIGN=2

                  ADC_EOCOnEachRegularChannelCmd PROC
;;;871      */
;;;872    void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;873    {
000002  4604              MOV      r4,r0
;;;874      /* Check the parameters */
;;;875      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480f              LDR      r0,|L16.68|
000006  460d              MOV      r5,r1                 ;873
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L16.34|
00000c  480e              LDR      r0,|L16.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L16.34|
000012  480e              LDR      r0,|L16.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L16.34|
000018  f240316b          MOV      r1,#0x36b
00001c  480c              LDR      r0,|L16.80|
00001e  f7fffffe          BL       assert_failed
                  |L16.34|
;;;876      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L16.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L16.50|
000028  f44f715b          MOV      r1,#0x36c
00002c  4808              LDR      r0,|L16.80|
00002e  f7fffffe          BL       assert_failed
                  |L16.50|
;;;877      
;;;878      if (NewState != DISABLE)
;;;879      {
;;;880        /* Enable the selected ADC EOC rising on each regular channel conversion */
;;;881        ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
000032  68a0              LDR      r0,[r4,#8]
000034  f4406080          ORR      r0,r0,#0x400
000038  e002              B        |L16.64|
                  |L16.58|
;;;882      }
;;;883      else
;;;884      {
;;;885        /* Disable the selected ADC EOC rising on each regular channel conversion */
;;;886        ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
00003a  68a0              LDR      r0,[r4,#8]
00003c  f4206080          BIC      r0,r0,#0x400
                  |L16.64|
000040  60a0              STR      r0,[r4,#8]            ;881
;;;887      }
;;;888    }
000042  bd70              POP      {r4-r6,pc}
;;;889    
                          ENDP

                  |L16.68|
                          DCD      0x40012000
                  |L16.72|
                          DCD      0x40012100
                  |L16.76|
                          DCD      0x40012200
                  |L16.80|
                          DCD      ||.conststring||

                          AREA ||i.ADC_ExternalTrigInjectedConvConfig||, CODE, READONLY, ALIGN=2

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;1321     */
;;;1322   void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
000000  b570              PUSH     {r4-r6,lr}
;;;1323   {
000002  4605              MOV      r5,r0
;;;1324     uint32_t tmpreg = 0;
;;;1325     /* Check the parameters */
;;;1326     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4823              LDR      r0,|L17.148|
000006  460c              MOV      r4,r1                 ;1323
000008  4285              CMP      r5,r0
00000a  d00a              BEQ      |L17.34|
00000c  4822              LDR      r0,|L17.152|
00000e  4285              CMP      r5,r0
000010  d007              BEQ      |L17.34|
000012  4822              LDR      r0,|L17.156|
000014  4285              CMP      r5,r0
000016  d004              BEQ      |L17.34|
000018  f240512e          MOV      r1,#0x52e
00001c  4820              LDR      r0,|L17.160|
00001e  f7fffffe          BL       assert_failed
                  |L17.34|
;;;1327     assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
000022  b38c              CBZ      r4,|L17.136|
000024  f5b43f80          CMP      r4,#0x10000
000028  d02e              BEQ      |L17.136|
00002a  f5b43f00          CMP      r4,#0x20000
00002e  d02b              BEQ      |L17.136|
000030  f5b43f40          CMP      r4,#0x30000
000034  d028              BEQ      |L17.136|
000036  f5b42f80          CMP      r4,#0x40000
00003a  d025              BEQ      |L17.136|
00003c  f5b42fa0          CMP      r4,#0x50000
000040  d022              BEQ      |L17.136|
000042  f5b42fc0          CMP      r4,#0x60000
000046  d01f              BEQ      |L17.136|
000048  f5b42fe0          CMP      r4,#0x70000
00004c  d01c              BEQ      |L17.136|
00004e  f5b42f00          CMP      r4,#0x80000
000052  d019              BEQ      |L17.136|
000054  f5b42f10          CMP      r4,#0x90000
000058  d016              BEQ      |L17.136|
00005a  f5b42f20          CMP      r4,#0xa0000
00005e  d013              BEQ      |L17.136|
000060  f5b42f30          CMP      r4,#0xb0000
000064  d010              BEQ      |L17.136|
000066  f5b42f40          CMP      r4,#0xc0000
00006a  d00d              BEQ      |L17.136|
00006c  f5b42f50          CMP      r4,#0xd0000
000070  d00a              BEQ      |L17.136|
000072  f5b42f60          CMP      r4,#0xe0000
000076  d007              BEQ      |L17.136|
000078  f5b42f70          CMP      r4,#0xf0000
00007c  d004              BEQ      |L17.136|
00007e  f240512f          MOV      r1,#0x52f
000082  4807              LDR      r0,|L17.160|
000084  f7fffffe          BL       assert_failed
                  |L17.136|
;;;1328     
;;;1329     /* Get the old register value */
;;;1330     tmpreg = ADCx->CR2;
000088  68a8              LDR      r0,[r5,#8]
;;;1331     
;;;1332     /* Clear the old external event selection for injected group */
;;;1333     tmpreg &= CR2_JEXTSEL_RESET;
00008a  f4202070          BIC      r0,r0,#0xf0000
;;;1334     
;;;1335     /* Set the external event selection for injected group */
;;;1336     tmpreg |= ADC_ExternalTrigInjecConv;
00008e  4320              ORRS     r0,r0,r4
;;;1337     
;;;1338     /* Store the new register value */
;;;1339     ADCx->CR2 = tmpreg;
000090  60a8              STR      r0,[r5,#8]
;;;1340   }
000092  bd70              POP      {r4-r6,pc}
;;;1341   
                          ENDP

                  |L17.148|
                          DCD      0x40012000
                  |L17.152|
                          DCD      0x40012100
                  |L17.156|
                          DCD      0x40012200
                  |L17.160|
                          DCD      ||.conststring||

                          AREA ||i.ADC_ExternalTrigInjectedConvEdgeConfig||, CODE, READONLY, ALIGN=2

                  ADC_ExternalTrigInjectedConvEdgeConfig PROC
;;;1355     */
;;;1356   void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
000000  b570              PUSH     {r4-r6,lr}
;;;1357   {
000002  4604              MOV      r4,r0
;;;1358     uint32_t tmpreg = 0;
;;;1359     /* Check the parameters */
;;;1360     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4811              LDR      r0,|L18.76|
000006  460d              MOV      r5,r1                 ;1357
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L18.34|
00000c  4810              LDR      r0,|L18.80|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L18.34|
000012  4810              LDR      r0,|L18.84|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L18.34|
000018  f44f61aa          MOV      r1,#0x550
00001c  480e              LDR      r0,|L18.88|
00001e  f7fffffe          BL       assert_failed
                  |L18.34|
;;;1361     assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
000022  b16d              CBZ      r5,|L18.64|
000024  f5b51f80          CMP      r5,#0x100000
000028  d00a              BEQ      |L18.64|
00002a  f5b51f00          CMP      r5,#0x200000
00002e  d007              BEQ      |L18.64|
000030  f5b51f40          CMP      r5,#0x300000
000034  d004              BEQ      |L18.64|
000036  f2405151          MOV      r1,#0x551
00003a  4807              LDR      r0,|L18.88|
00003c  f7fffffe          BL       assert_failed
                  |L18.64|
;;;1362     /* Get the old register value */
;;;1363     tmpreg = ADCx->CR2;
000040  68a0              LDR      r0,[r4,#8]
;;;1364     /* Clear the old external trigger edge for injected group */
;;;1365     tmpreg &= CR2_JEXTEN_RESET;
000042  f4201040          BIC      r0,r0,#0x300000
;;;1366     /* Set the new external trigger edge for injected group */
;;;1367     tmpreg |= ADC_ExternalTrigInjecConvEdge;
000046  4328              ORRS     r0,r0,r5
;;;1368     /* Store the new register value */
;;;1369     ADCx->CR2 = tmpreg;
000048  60a0              STR      r0,[r4,#8]
;;;1370   }
00004a  bd70              POP      {r4-r6,pc}
;;;1371   
                          ENDP

                  |L18.76|
                          DCD      0x40012000
                  |L18.80|
                          DCD      0x40012100
                  |L18.84|
                          DCD      0x40012200
                  |L18.88|
                          DCD      ||.conststring||

                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetConversionValue PROC
;;;977      */
;;;978    uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;979    {
000002  4604              MOV      r4,r0
;;;980      /* Check the parameters */
;;;981      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4808              LDR      r0,|L19.40|
000006  4284              CMP      r4,r0
000008  d00a              BEQ      |L19.32|
00000a  4808              LDR      r0,|L19.44|
00000c  4284              CMP      r4,r0
00000e  d007              BEQ      |L19.32|
000010  4807              LDR      r0,|L19.48|
000012  4284              CMP      r4,r0
000014  d004              BEQ      |L19.32|
000016  f24031d5          MOV      r1,#0x3d5
00001a  4806              LDR      r0,|L19.52|
00001c  f7fffffe          BL       assert_failed
                  |L19.32|
;;;982      
;;;983      /* Return the selected ADC conversion value */
;;;984      return (uint16_t) ADCx->DR;
000020  6ce0              LDR      r0,[r4,#0x4c]
000022  b280              UXTH     r0,r0
;;;985    }
000024  bd10              POP      {r4,pc}
;;;986    
                          ENDP

000026  0000              DCW      0x0000
                  |L19.40|
                          DCD      0x40012000
                  |L19.44|
                          DCD      0x40012100
                  |L19.48|
                          DCD      0x40012200
                  |L19.52|
                          DCD      ||.conststring||

                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetFlagStatus PROC
;;;1617     */
;;;1618   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1619   {
000002  4605              MOV      r5,r0
;;;1620     FlagStatus bitstatus = RESET;
;;;1621     /* Check the parameters */
;;;1622     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4813              LDR      r0,|L20.84|
000006  2600              MOVS     r6,#0                 ;1620
000008  460c              MOV      r4,r1                 ;1619
00000a  4285              CMP      r5,r0
00000c  d00a              BEQ      |L20.36|
00000e  4812              LDR      r0,|L20.88|
000010  4285              CMP      r5,r0
000012  d007              BEQ      |L20.36|
000014  4811              LDR      r0,|L20.92|
000016  4285              CMP      r5,r0
000018  d004              BEQ      |L20.36|
00001a  f2406156          MOV      r1,#0x656
00001e  4810              LDR      r0,|L20.96|
000020  f7fffffe          BL       assert_failed
                  |L20.36|
;;;1623     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
000024  2c01              CMP      r4,#1
000026  d00e              BEQ      |L20.70|
000028  2c02              CMP      r4,#2
00002a  d00c              BEQ      |L20.70|
00002c  2c04              CMP      r4,#4
00002e  d00a              BEQ      |L20.70|
000030  2c08              CMP      r4,#8
000032  d008              BEQ      |L20.70|
000034  2c10              CMP      r4,#0x10
000036  d006              BEQ      |L20.70|
000038  2c20              CMP      r4,#0x20
00003a  d004              BEQ      |L20.70|
00003c  f2406157          MOV      r1,#0x657
000040  4807              LDR      r0,|L20.96|
000042  f7fffffe          BL       assert_failed
                  |L20.70|
;;;1624   
;;;1625     /* Check the status of the specified ADC flag */
;;;1626     if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
000046  6828              LDR      r0,[r5,#0]
000048  4220              TST      r0,r4
00004a  d000              BEQ      |L20.78|
;;;1627     {
;;;1628       /* ADC_FLAG is set */
;;;1629       bitstatus = SET;
00004c  2601              MOVS     r6,#1
                  |L20.78|
;;;1630     }
;;;1631     else
;;;1632     {
;;;1633       /* ADC_FLAG is reset */
;;;1634       bitstatus = RESET;
;;;1635     }
;;;1636     /* Return the ADC_FLAG status */
;;;1637     return  bitstatus;
00004e  4630              MOV      r0,r6
;;;1638   }
000050  bd70              POP      {r4-r6,pc}
;;;1639   
                          ENDP

000052  0000              DCW      0x0000
                  |L20.84|
                          DCD      0x40012000
                  |L20.88|
                          DCD      0x40012100
                  |L20.92|
                          DCD      0x40012200
                  |L20.96|
                          DCD      ||.conststring||

                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetITStatus PROC
;;;1673     */
;;;1674   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1675   {
000002  4605              MOV      r5,r0
;;;1676     ITStatus bitstatus = RESET;
;;;1677     uint32_t itmask = 0, enablestatus = 0;
;;;1678   
;;;1679     /* Check the parameters */
;;;1680     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4817              LDR      r0,|L21.100|
000006  2600              MOVS     r6,#0                 ;1676
000008  460c              MOV      r4,r1                 ;1675
00000a  4285              CMP      r5,r0
00000c  d00a              BEQ      |L21.36|
00000e  4816              LDR      r0,|L21.104|
000010  4285              CMP      r5,r0
000012  d007              BEQ      |L21.36|
000014  4815              LDR      r0,|L21.108|
000016  4285              CMP      r5,r0
000018  d004              BEQ      |L21.36|
00001a  f44f61d2          MOV      r1,#0x690
00001e  4814              LDR      r0,|L21.112|
000020  f7fffffe          BL       assert_failed
                  |L21.36|
;;;1681     assert_param(IS_ADC_IT(ADC_IT));
000024  f5a47000          SUB      r0,r4,#0x200
000028  3805              SUBS     r0,#5
00002a  d00f              BEQ      |L21.76|
00002c  f5b47f83          CMP      r4,#0x106
000030  d00c              BEQ      |L21.76|
000032  f5a46080          SUB      r0,r4,#0x400
000036  3807              SUBS     r0,#7
000038  d008              BEQ      |L21.76|
00003a  f5a45000          SUB      r0,r4,#0x2000
00003e  381a              SUBS     r0,r0,#0x1a
000040  d004              BEQ      |L21.76|
000042  f2406191          MOV      r1,#0x691
000046  480a              LDR      r0,|L21.112|
000048  f7fffffe          BL       assert_failed
                  |L21.76|
;;;1682   
;;;1683     /* Get the ADC IT index */
;;;1684     itmask = ADC_IT >> 8;
;;;1685   
;;;1686     /* Get the ADC_IT enable bit status */
;;;1687     enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
00004c  6869              LDR      r1,[r5,#4]
00004e  2201              MOVS     r2,#1
000050  40a2              LSLS     r2,r2,r4
000052  4011              ANDS     r1,r1,r2
;;;1688   
;;;1689     /* Check the status of the specified ADC interrupt */
;;;1690     if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
000054  682a              LDR      r2,[r5,#0]
000056  ea122f14          TST      r2,r4,LSR #8
00005a  d001              BEQ      |L21.96|
00005c  b101              CBZ      r1,|L21.96|
;;;1691     {
;;;1692       /* ADC_IT is set */
;;;1693       bitstatus = SET;
00005e  2601              MOVS     r6,#1
                  |L21.96|
;;;1694     }
;;;1695     else
;;;1696     {
;;;1697       /* ADC_IT is reset */
;;;1698       bitstatus = RESET;
;;;1699     }
;;;1700     /* Return the ADC_IT status */
;;;1701     return  bitstatus;
000060  4630              MOV      r0,r6
;;;1702   }
000062  bd70              POP      {r4-r6,pc}
;;;1703   
                          ENDP

                  |L21.100|
                          DCD      0x40012000
                  |L21.104|
                          DCD      0x40012100
                  |L21.108|
                          DCD      0x40012200
                  |L21.112|
                          DCD      ||.conststring||

                          AREA ||i.ADC_GetInjectedConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetInjectedConversionValue PROC
;;;1472     */
;;;1473   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
000000  b538              PUSH     {r3-r5,lr}
;;;1474   {
000002  4605              MOV      r5,r0
;;;1475     __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
;;;1476     
;;;1477     /* Check the parameters */
;;;1478     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  9000              STR      r0,[sp,#0]
000008  4810              LDR      r0,|L22.76|
00000a  460c              MOV      r4,r1                 ;1474
00000c  4285              CMP      r5,r0
00000e  d00a              BEQ      |L22.38|
000010  480f              LDR      r0,|L22.80|
000012  4285              CMP      r5,r0
000014  d007              BEQ      |L22.38|
000016  480f              LDR      r0,|L22.84|
000018  4285              CMP      r5,r0
00001a  d004              BEQ      |L22.38|
00001c  f24051c6          MOV      r1,#0x5c6
000020  480d              LDR      r0,|L22.88|
000022  f7fffffe          BL       assert_failed
                  |L22.38|
;;;1479     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
000026  2c14              CMP      r4,#0x14
000028  d00a              BEQ      |L22.64|
00002a  2c18              CMP      r4,#0x18
00002c  d008              BEQ      |L22.64|
00002e  2c1c              CMP      r4,#0x1c
000030  d006              BEQ      |L22.64|
000032  2c20              CMP      r4,#0x20
000034  d004              BEQ      |L22.64|
000036  f24051c7          MOV      r1,#0x5c7
00003a  4807              LDR      r0,|L22.88|
00003c  f7fffffe          BL       assert_failed
                  |L22.64|
;;;1480   
;;;1481     tmp = (uint32_t)ADCx;
;;;1482     tmp += ADC_InjectedChannel + JDR_OFFSET;
000040  1928              ADDS     r0,r5,r4
000042  3028              ADDS     r0,r0,#0x28
;;;1483     
;;;1484     /* Returns the selected injected channel conversion data value */
;;;1485     return (uint16_t) (*(__IO uint32_t*)  tmp); 
000044  9000              STR      r0,[sp,#0]
000046  6800              LDR      r0,[r0,#0]
000048  b280              UXTH     r0,r0
;;;1486   }
00004a  bd38              POP      {r3-r5,pc}
;;;1487   /**
                          ENDP

                  |L22.76|
                          DCD      0x40012000
                  |L22.80|
                          DCD      0x40012100
                  |L22.84|
                          DCD      0x40012200
                  |L22.88|
                          DCD      ||.conststring||

                          AREA ||i.ADC_GetMultiModeConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetMultiModeConversionValue PROC
;;;998      */
;;;999    uint32_t ADC_GetMultiModeConversionValue(void)
000000  4801              LDR      r0,|L23.8|
;;;1000   {
;;;1001     /* Return the multi mode conversion value */
;;;1002     return (*(__IO uint32_t *) CDR_ADDRESS);
000002  f8d00308          LDR      r0,[r0,#0x308]
;;;1003   }
000006  4770              BX       lr
;;;1004   /**
                          ENDP

                  |L23.8|
                          DCD      0x40012000

                          AREA ||i.ADC_GetSoftwareStartConvStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetSoftwareStartConvStatus PROC
;;;841      */
;;;842    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
000000  b570              PUSH     {r4-r6,lr}
;;;843    {
000002  4604              MOV      r4,r0
;;;844      FlagStatus bitstatus = RESET;
;;;845      /* Check the parameters */
;;;846      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480a              LDR      r0,|L24.48|
000006  2500              MOVS     r5,#0                 ;844
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L24.34|
00000c  4809              LDR      r0,|L24.52|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L24.34|
000012  4809              LDR      r0,|L24.56|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L24.34|
000018  f240314e          MOV      r1,#0x34e
00001c  4807              LDR      r0,|L24.60|
00001e  f7fffffe          BL       assert_failed
                  |L24.34|
;;;847      
;;;848      /* Check the status of SWSTART bit */
;;;849      if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
000022  68a0              LDR      r0,[r4,#8]
000024  0240              LSLS     r0,r0,#9
000026  d500              BPL      |L24.42|
;;;850      {
;;;851        /* SWSTART bit is set */
;;;852        bitstatus = SET;
000028  2501              MOVS     r5,#1
                  |L24.42|
;;;853      }
;;;854      else
;;;855      {
;;;856        /* SWSTART bit is reset */
;;;857        bitstatus = RESET;
;;;858      }
;;;859      
;;;860      /* Return the SWSTART bit status */
;;;861      return  bitstatus;
00002a  4628              MOV      r0,r5
;;;862    }
00002c  bd70              POP      {r4-r6,pc}
;;;863    
                          ENDP

00002e  0000              DCW      0x0000
                  |L24.48|
                          DCD      0x40012000
                  |L24.52|
                          DCD      0x40012100
                  |L24.56|
                          DCD      0x40012200
                  |L24.60|
                          DCD      ||.conststring||

                          AREA ||i.ADC_GetSoftwareStartInjectedConvCmdStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;1389     */
;;;1390   FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
000000  b570              PUSH     {r4-r6,lr}
;;;1391   {
000002  4604              MOV      r4,r0
;;;1392     FlagStatus bitstatus = RESET;
;;;1393     /* Check the parameters */
;;;1394     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480a              LDR      r0,|L25.48|
000006  2500              MOVS     r5,#0                 ;1392
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L25.34|
00000c  4809              LDR      r0,|L25.52|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L25.34|
000012  4809              LDR      r0,|L25.56|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L25.34|
000018  f2405172          MOV      r1,#0x572
00001c  4807              LDR      r0,|L25.60|
00001e  f7fffffe          BL       assert_failed
                  |L25.34|
;;;1395     
;;;1396     /* Check the status of JSWSTART bit */
;;;1397     if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
000022  68a0              LDR      r0,[r4,#8]
000024  0240              LSLS     r0,r0,#9
000026  d500              BPL      |L25.42|
;;;1398     {
;;;1399       /* JSWSTART bit is set */
;;;1400       bitstatus = SET;
000028  2501              MOVS     r5,#1
                  |L25.42|
;;;1401     }
;;;1402     else
;;;1403     {
;;;1404       /* JSWSTART bit is reset */
;;;1405       bitstatus = RESET;
;;;1406     }
;;;1407     /* Return the JSWSTART bit status */
;;;1408     return  bitstatus;
00002a  4628              MOV      r0,r5
;;;1409   }
00002c  bd70              POP      {r4-r6,pc}
;;;1410   
                          ENDP

00002e  0000              DCW      0x0000
                  |L25.48|
                          DCD      0x40012000
                  |L25.52|
                          DCD      0x40012100
                  |L25.56|
                          DCD      0x40012200
                  |L25.60|
                          DCD      ||.conststring||

                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=2

                  ADC_ITConfig PROC
;;;1580     */
;;;1581   void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
000000  b570              PUSH     {r4-r6,lr}
;;;1582   {
000002  4604              MOV      r4,r0
;;;1583     uint32_t itmask = 0;
;;;1584     /* Check the parameters */
;;;1585     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  481a              LDR      r0,|L26.112|
000006  4616              MOV      r6,r2                 ;1582
000008  460d              MOV      r5,r1                 ;1582
00000a  4284              CMP      r4,r0
00000c  d00a              BEQ      |L26.36|
00000e  4819              LDR      r0,|L26.116|
000010  4284              CMP      r4,r0
000012  d007              BEQ      |L26.36|
000014  4818              LDR      r0,|L26.120|
000016  4284              CMP      r4,r0
000018  d004              BEQ      |L26.36|
00001a  f2406131          MOV      r1,#0x631
00001e  4817              LDR      r0,|L26.124|
000020  f7fffffe          BL       assert_failed
                  |L26.36|
;;;1586     assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b136              CBZ      r6,|L26.52|
000026  2e01              CMP      r6,#1
000028  d004              BEQ      |L26.52|
00002a  f2406132          MOV      r1,#0x632
00002e  4813              LDR      r0,|L26.124|
000030  f7fffffe          BL       assert_failed
                  |L26.52|
;;;1587     assert_param(IS_ADC_IT(ADC_IT)); 
000034  f5a57000          SUB      r0,r5,#0x200
000038  3805              SUBS     r0,#5
00003a  d00f              BEQ      |L26.92|
00003c  f5b57f83          CMP      r5,#0x106
000040  d00c              BEQ      |L26.92|
000042  f5a56080          SUB      r0,r5,#0x400
000046  3807              SUBS     r0,#7
000048  d008              BEQ      |L26.92|
00004a  f5a55000          SUB      r0,r5,#0x2000
00004e  381a              SUBS     r0,r0,#0x1a
000050  d004              BEQ      |L26.92|
000052  f2406133          MOV      r1,#0x633
000056  4809              LDR      r0,|L26.124|
000058  f7fffffe          BL       assert_failed
                  |L26.92|
;;;1588   
;;;1589     /* Get the ADC IT index */
;;;1590     itmask = (uint8_t)ADC_IT;
;;;1591     itmask = (uint32_t)0x01 << itmask;    
00005c  2001              MOVS     r0,#1
;;;1592   
;;;1593     if (NewState != DISABLE)
;;;1594     {
;;;1595       /* Enable the selected ADC interrupts */
;;;1596       ADCx->CR1 |= itmask;
;;;1597     }
;;;1598     else
;;;1599     {
;;;1600       /* Disable the selected ADC interrupts */
;;;1601       ADCx->CR1 &= (~(uint32_t)itmask);
00005e  6861              LDR      r1,[r4,#4]
000060  40a8              LSLS     r0,r0,r5              ;1591
000062  b10e              CBZ      r6,|L26.104|
000064  4301              ORRS     r1,r1,r0              ;1596
000066  e000              B        |L26.106|
                  |L26.104|
000068  4381              BICS     r1,r1,r0
                  |L26.106|
00006a  6061              STR      r1,[r4,#4]            ;1596
;;;1602     }
;;;1603   }
00006c  bd70              POP      {r4-r6,pc}
;;;1604   
                          ENDP

00006e  0000              DCW      0x0000
                  |L26.112|
                          DCD      0x40012000
                  |L26.116|
                          DCD      0x40012100
                  |L26.120|
                          DCD      0x40012200
                  |L26.124|
                          DCD      ||.conststring||

                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;227      */
;;;228    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;229    {
000004  4605              MOV      r5,r0
;;;230      uint32_t tmpreg1 = 0;
;;;231      uint8_t tmpreg2 = 0;
;;;232      /* Check the parameters */
;;;233      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  4850              LDR      r0,|L27.328|
000008  460c              MOV      r4,r1                 ;229
00000a  4285              CMP      r5,r0
00000c  d009              BEQ      |L27.34|
00000e  484f              LDR      r0,|L27.332|
000010  4285              CMP      r5,r0
000012  d006              BEQ      |L27.34|
000014  484e              LDR      r0,|L27.336|
000016  4285              CMP      r5,r0
000018  d003              BEQ      |L27.34|
00001a  21e9              MOVS     r1,#0xe9
00001c  484d              LDR      r0,|L27.340|
00001e  f7fffffe          BL       assert_failed
                  |L27.34|
;;;234      assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
000022  f04f7680          MOV      r6,#0x1000000
000026  6820              LDR      r0,[r4,#0]
000028  0077              LSLS     r7,r6,#1
00002a  f04f7840          MOV      r8,#0x3000000
00002e  b148              CBZ      r0,|L27.68|
000030  42b0              CMP      r0,r6
000032  d007              BEQ      |L27.68|
000034  42b8              CMP      r0,r7
000036  d005              BEQ      |L27.68|
000038  4540              CMP      r0,r8
00003a  d003              BEQ      |L27.68|
00003c  21ea              MOVS     r1,#0xea
00003e  4845              LDR      r0,|L27.340|
000040  f7fffffe          BL       assert_failed
                  |L27.68|
;;;235      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
000044  7920              LDRB     r0,[r4,#4]
000046  b128              CBZ      r0,|L27.84|
000048  2801              CMP      r0,#1
00004a  d003              BEQ      |L27.84|
00004c  21eb              MOVS     r1,#0xeb
00004e  4841              LDR      r0,|L27.340|
000050  f7fffffe          BL       assert_failed
                  |L27.84|
;;;236      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
000054  7960              LDRB     r0,[r4,#5]
000056  b128              CBZ      r0,|L27.100|
000058  2801              CMP      r0,#1
00005a  d003              BEQ      |L27.100|
00005c  21ec              MOVS     r1,#0xec
00005e  483d              LDR      r0,|L27.340|
000060  f7fffffe          BL       assert_failed
                  |L27.100|
;;;237      assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
000064  68a0              LDR      r0,[r4,#8]
000066  b160              CBZ      r0,|L27.130|
000068  f1b05f80          CMP      r0,#0x10000000
00006c  d009              BEQ      |L27.130|
00006e  f1b05f00          CMP      r0,#0x20000000
000072  d006              BEQ      |L27.130|
000074  f1b05f40          CMP      r0,#0x30000000
000078  d003              BEQ      |L27.130|
00007a  21ed              MOVS     r1,#0xed
00007c  4835              LDR      r0,|L27.340|
00007e  f7fffffe          BL       assert_failed
                  |L27.130|
;;;238      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
000082  68e0              LDR      r0,[r4,#0xc]
000084  b368              CBZ      r0,|L27.226|
000086  42b0              CMP      r0,r6
000088  d02b              BEQ      |L27.226|
00008a  42b8              CMP      r0,r7
00008c  d029              BEQ      |L27.226|
00008e  4540              CMP      r0,r8
000090  d027              BEQ      |L27.226|
000092  f1b06f80          CMP      r0,#0x4000000
000096  d024              BEQ      |L27.226|
000098  f1b06fa0          CMP      r0,#0x5000000
00009c  d021              BEQ      |L27.226|
00009e  f1b06fc0          CMP      r0,#0x6000000
0000a2  d01e              BEQ      |L27.226|
0000a4  f1b06fe0          CMP      r0,#0x7000000
0000a8  d01b              BEQ      |L27.226|
0000aa  f1b06f00          CMP      r0,#0x8000000
0000ae  d018              BEQ      |L27.226|
0000b0  f1b06f10          CMP      r0,#0x9000000
0000b4  d015              BEQ      |L27.226|
0000b6  f1b06f20          CMP      r0,#0xa000000
0000ba  d012              BEQ      |L27.226|
0000bc  f1b06f30          CMP      r0,#0xb000000
0000c0  d00f              BEQ      |L27.226|
0000c2  f1b06f40          CMP      r0,#0xc000000
0000c6  d00c              BEQ      |L27.226|
0000c8  f1b06f50          CMP      r0,#0xd000000
0000cc  d009              BEQ      |L27.226|
0000ce  f1b06f60          CMP      r0,#0xe000000
0000d2  d006              BEQ      |L27.226|
0000d4  f1b06f70          CMP      r0,#0xf000000
0000d8  d003              BEQ      |L27.226|
0000da  21ee              MOVS     r1,#0xee
0000dc  481d              LDR      r0,|L27.340|
0000de  f7fffffe          BL       assert_failed
                  |L27.226|
;;;239      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
0000e2  6920              LDR      r0,[r4,#0x10]
0000e4  b130              CBZ      r0,|L27.244|
0000e6  f5b06f00          CMP      r0,#0x800
0000ea  d003              BEQ      |L27.244|
0000ec  21ef              MOVS     r1,#0xef
0000ee  4819              LDR      r0,|L27.340|
0000f0  f7fffffe          BL       assert_failed
                  |L27.244|
;;;240      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
0000f4  7d20              LDRB     r0,[r4,#0x14]
0000f6  1e40              SUBS     r0,r0,#1
0000f8  280f              CMP      r0,#0xf
0000fa  d903              BLS      |L27.260|
0000fc  21f0              MOVS     r1,#0xf0
0000fe  4815              LDR      r0,|L27.340|
000100  f7fffffe          BL       assert_failed
                  |L27.260|
;;;241      
;;;242      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;243      /* Get the ADCx CR1 value */
;;;244      tmpreg1 = ADCx->CR1;
000104  6868              LDR      r0,[r5,#4]
;;;245      
;;;246      /* Clear RES and SCAN bits */
;;;247      tmpreg1 &= CR1_CLEAR_MASK;
000106  4914              LDR      r1,|L27.344|
;;;248      
;;;249      /* Configure ADCx: scan conversion mode and resolution */
;;;250      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;251      /* Set RES bit according to ADC_Resolution value */ 
;;;252      tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
000108  7922              LDRB     r2,[r4,#4]
00010a  4008              ANDS     r0,r0,r1              ;247
00010c  6821              LDR      r1,[r4,#0]
00010e  ea402002          ORR      r0,r0,r2,LSL #8
000112  4301              ORRS     r1,r1,r0
;;;253                                       ADC_InitStruct->ADC_Resolution);
;;;254      /* Write to ADCx CR1 */
;;;255      ADCx->CR1 = tmpreg1;
000114  6069              STR      r1,[r5,#4]
;;;256      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;257      /* Get the ADCx CR2 value */
;;;258      tmpreg1 = ADCx->CR2;
000116  68a8              LDR      r0,[r5,#8]
;;;259      
;;;260      /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
;;;261      tmpreg1 &= CR2_CLEAR_MASK;
000118  4910              LDR      r1,|L27.348|
;;;262      
;;;263      /* Configure ADCx: external trigger event and edge, data alignment and 
;;;264         continuous conversion mode */
;;;265      /* Set ALIGN bit according to ADC_DataAlign value */
;;;266      /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
;;;267      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;268      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;269      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
00011a  7963              LDRB     r3,[r4,#5]
00011c  4008              ANDS     r0,r0,r1              ;261
00011e  e9d42103          LDRD     r2,r1,[r4,#0xc]       ;261
000122  4311              ORRS     r1,r1,r2
000124  68a2              LDR      r2,[r4,#8]
000126  ea420243          ORR      r2,r2,r3,LSL #1
00012a  4311              ORRS     r1,r1,r2
00012c  4301              ORRS     r1,r1,r0
;;;270                            ADC_InitStruct->ADC_ExternalTrigConv | 
;;;271                            ADC_InitStruct->ADC_ExternalTrigConvEdge | \
;;;272                            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;273                            
;;;274      /* Write to ADCx CR2 */
;;;275      ADCx->CR2 = tmpreg1;
00012e  60a9              STR      r1,[r5,#8]
;;;276      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;277      /* Get the ADCx SQR1 value */
;;;278      tmpreg1 = ADCx->SQR1;
000130  6ae8              LDR      r0,[r5,#0x2c]
;;;279      
;;;280      /* Clear L bits */
;;;281      tmpreg1 &= SQR1_L_RESET;
;;;282      
;;;283      /* Configure ADCx: regular channel sequence length */
;;;284      /* Set L bits according to ADC_NbrOfConversion value */
;;;285      tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
000132  7d21              LDRB     r1,[r4,#0x14]
000134  f4200070          BIC      r0,r0,#0xf00000       ;281
000138  1e49              SUBS     r1,r1,#1
00013a  b2c9              UXTB     r1,r1
;;;286      tmpreg1 |= ((uint32_t)tmpreg2 << 20);
00013c  ea405001          ORR      r0,r0,r1,LSL #20
;;;287      
;;;288      /* Write to ADCx SQR1 */
;;;289      ADCx->SQR1 = tmpreg1;
000140  62e8              STR      r0,[r5,#0x2c]
;;;290    }
000142  e8bd81f0          POP      {r4-r8,pc}
;;;291    
                          ENDP

000146  0000              DCW      0x0000
                  |L27.328|
                          DCD      0x40012000
                  |L27.332|
                          DCD      0x40012100
                  |L27.336|
                          DCD      0x40012200
                  |L27.340|
                          DCD      ||.conststring||
                  |L27.344|
                          DCD      0xfcfffeff
                  |L27.348|
                          DCD      0xc0fff7fd

                          AREA ||i.ADC_InjectedChannelConfig||, CODE, READONLY, ALIGN=2

                  ADC_InjectedChannelConfig PROC
;;;1185     */
;;;1186   void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1187   {
000004  4606              MOV      r6,r0
;;;1188     uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
;;;1189     /* Check the parameters */
;;;1190     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  483e              LDR      r0,|L28.256|
000008  461d              MOV      r5,r3                 ;1187
00000a  4617              MOV      r7,r2                 ;1187
00000c  460c              MOV      r4,r1                 ;1187
00000e  4286              CMP      r6,r0
000010  d00a              BEQ      |L28.40|
000012  483c              LDR      r0,|L28.260|
000014  4286              CMP      r6,r0
000016  d007              BEQ      |L28.40|
000018  483b              LDR      r0,|L28.264|
00001a  4286              CMP      r6,r0
00001c  d004              BEQ      |L28.40|
00001e  f24041a6          MOV      r1,#0x4a6
000022  483a              LDR      r0,|L28.268|
000024  f7fffffe          BL       assert_failed
                  |L28.40|
;;;1191     assert_param(IS_ADC_CHANNEL(ADC_Channel));
000028  b344              CBZ      r4,|L28.124|
00002a  2c01              CMP      r4,#1
00002c  d026              BEQ      |L28.124|
00002e  2c02              CMP      r4,#2
000030  d024              BEQ      |L28.124|
000032  2c03              CMP      r4,#3
000034  d022              BEQ      |L28.124|
000036  2c04              CMP      r4,#4
000038  d020              BEQ      |L28.124|
00003a  2c05              CMP      r4,#5
00003c  d01e              BEQ      |L28.124|
00003e  2c06              CMP      r4,#6
000040  d01c              BEQ      |L28.124|
000042  2c07              CMP      r4,#7
000044  d01a              BEQ      |L28.124|
000046  2c08              CMP      r4,#8
000048  d018              BEQ      |L28.124|
00004a  2c09              CMP      r4,#9
00004c  d016              BEQ      |L28.124|
00004e  2c0a              CMP      r4,#0xa
000050  d014              BEQ      |L28.124|
000052  2c0b              CMP      r4,#0xb
000054  d012              BEQ      |L28.124|
000056  2c0c              CMP      r4,#0xc
000058  d010              BEQ      |L28.124|
00005a  2c0d              CMP      r4,#0xd
00005c  d00e              BEQ      |L28.124|
00005e  2c0e              CMP      r4,#0xe
000060  d00c              BEQ      |L28.124|
000062  2c0f              CMP      r4,#0xf
000064  d00a              BEQ      |L28.124|
000066  2c10              CMP      r4,#0x10
000068  d008              BEQ      |L28.124|
00006a  2c11              CMP      r4,#0x11
00006c  d006              BEQ      |L28.124|
00006e  2c12              CMP      r4,#0x12
000070  d004              BEQ      |L28.124|
000072  f24041a7          MOV      r1,#0x4a7
000076  4825              LDR      r0,|L28.268|
000078  f7fffffe          BL       assert_failed
                  |L28.124|
;;;1192     assert_param(IS_ADC_INJECTED_RANK(Rank));
00007c  1e78              SUBS     r0,r7,#1
00007e  2803              CMP      r0,#3
000080  d904              BLS      |L28.140|
000082  f44f6195          MOV      r1,#0x4a8
000086  4821              LDR      r0,|L28.268|
000088  f7fffffe          BL       assert_failed
                  |L28.140|
;;;1193     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
00008c  b195              CBZ      r5,|L28.180|
00008e  2d01              CMP      r5,#1
000090  d010              BEQ      |L28.180|
000092  2d02              CMP      r5,#2
000094  d00e              BEQ      |L28.180|
000096  2d03              CMP      r5,#3
000098  d00c              BEQ      |L28.180|
00009a  2d04              CMP      r5,#4
00009c  d00a              BEQ      |L28.180|
00009e  2d05              CMP      r5,#5
0000a0  d008              BEQ      |L28.180|
0000a2  2d06              CMP      r5,#6
0000a4  d006              BEQ      |L28.180|
0000a6  2d07              CMP      r5,#7
0000a8  d004              BEQ      |L28.180|
0000aa  f24041a9          MOV      r1,#0x4a9
0000ae  4817              LDR      r0,|L28.268|
0000b0  f7fffffe          BL       assert_failed
                  |L28.180|
0000b4  2207              MOVS     r2,#7                 ;1187
;;;1194     /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;1195     if (ADC_Channel > ADC_Channel_9)
0000b6  2c09              CMP      r4,#9
0000b8  d90a              BLS      |L28.208|
;;;1196     {
;;;1197       /* Get the old register value */
;;;1198       tmpreg1 = ADCx->SMPR1;
0000ba  68f1              LDR      r1,[r6,#0xc]
;;;1199       /* Calculate the mask to clear */
;;;1200       tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
0000bc  f1a4000a          SUB      r0,r4,#0xa
0000c0  eb000040          ADD      r0,r0,r0,LSL #1
0000c4  4082              LSLS     r2,r2,r0
;;;1201       /* Clear the old sample time */
;;;1202       tmpreg1 &= ~tmpreg2;
0000c6  4391              BICS     r1,r1,r2
;;;1203       /* Calculate the mask to set */
;;;1204       tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
0000c8  4085              LSLS     r5,r5,r0
;;;1205       /* Set the new sample time */
;;;1206       tmpreg1 |= tmpreg2;
0000ca  4329              ORRS     r1,r1,r5
;;;1207       /* Store the new register value */
;;;1208       ADCx->SMPR1 = tmpreg1;
0000cc  60f1              STR      r1,[r6,#0xc]
0000ce  e007              B        |L28.224|
                  |L28.208|
;;;1209     }
;;;1210     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1211     {
;;;1212       /* Get the old register value */
;;;1213       tmpreg1 = ADCx->SMPR2;
0000d0  6931              LDR      r1,[r6,#0x10]
;;;1214       /* Calculate the mask to clear */
;;;1215       tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
0000d2  eb040044          ADD      r0,r4,r4,LSL #1
0000d6  4082              LSLS     r2,r2,r0
;;;1216       /* Clear the old sample time */
;;;1217       tmpreg1 &= ~tmpreg2;
0000d8  4391              BICS     r1,r1,r2
;;;1218       /* Calculate the mask to set */
;;;1219       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
0000da  4085              LSLS     r5,r5,r0
;;;1220       /* Set the new sample time */
;;;1221       tmpreg1 |= tmpreg2;
0000dc  4329              ORRS     r1,r1,r5
;;;1222       /* Store the new register value */
;;;1223       ADCx->SMPR2 = tmpreg1;
0000de  6131              STR      r1,[r6,#0x10]
                  |L28.224|
;;;1224     }
;;;1225     /* Rank configuration */
;;;1226     /* Get the old register value */
;;;1227     tmpreg1 = ADCx->JSQR;
0000e0  6bb0              LDR      r0,[r6,#0x38]
;;;1228     /* Get JL value: Number = JL+1 */
;;;1229     tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
;;;1230     /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;1231     tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
0000e2  221f              MOVS     r2,#0x1f
0000e4  f3c05101          UBFX     r1,r0,#20,#2          ;1229
0000e8  1a79              SUBS     r1,r7,r1
0000ea  1c89              ADDS     r1,r1,#2
0000ec  eb010181          ADD      r1,r1,r1,LSL #2
0000f0  408a              LSLS     r2,r2,r1
;;;1232     /* Clear the old JSQx bits for the selected rank */
;;;1233     tmpreg1 &= ~tmpreg2;
0000f2  4390              BICS     r0,r0,r2
;;;1234     /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;1235     tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
0000f4  408c              LSLS     r4,r4,r1
;;;1236     /* Set the JSQx bits for the selected rank */
;;;1237     tmpreg1 |= tmpreg2;
0000f6  4320              ORRS     r0,r0,r4
;;;1238     /* Store the new register value */
;;;1239     ADCx->JSQR = tmpreg1;
0000f8  63b0              STR      r0,[r6,#0x38]
;;;1240   }
0000fa  e8bd81f0          POP      {r4-r8,pc}
;;;1241   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L28.256|
                          DCD      0x40012000
                  |L28.260|
                          DCD      0x40012100
                  |L28.264|
                          DCD      0x40012200
                  |L28.268|
                          DCD      ||.conststring||

                          AREA ||i.ADC_InjectedDiscModeCmd||, CODE, READONLY, ALIGN=2

                  ADC_InjectedDiscModeCmd PROC
;;;1444     */
;;;1445   void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1446   {
000002  4604              MOV      r4,r0
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480f              LDR      r0,|L29.68|
000006  460d              MOV      r5,r1                 ;1446
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L29.34|
00000c  480e              LDR      r0,|L29.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L29.34|
000012  480e              LDR      r0,|L29.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L29.34|
000018  f44f61b5          MOV      r1,#0x5a8
00001c  480c              LDR      r0,|L29.80|
00001e  f7fffffe          BL       assert_failed
                  |L29.34|
;;;1449     assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L29.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L29.50|
000028  f24051a9          MOV      r1,#0x5a9
00002c  4808              LDR      r0,|L29.80|
00002e  f7fffffe          BL       assert_failed
                  |L29.50|
;;;1450     if (NewState != DISABLE)
;;;1451     {
;;;1452       /* Enable the selected ADC injected discontinuous mode */
;;;1453       ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
000032  6860              LDR      r0,[r4,#4]
000034  f4405080          ORR      r0,r0,#0x1000
000038  e002              B        |L29.64|
                  |L29.58|
;;;1454     }
;;;1455     else
;;;1456     {
;;;1457       /* Disable the selected ADC injected discontinuous mode */
;;;1458       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
00003a  6860              LDR      r0,[r4,#4]
00003c  f4205080          BIC      r0,r0,#0x1000
                  |L29.64|
000040  6060              STR      r0,[r4,#4]            ;1453
;;;1459     }
;;;1460   }
000042  bd70              POP      {r4-r6,pc}
;;;1461   
                          ENDP

                  |L29.68|
                          DCD      0x40012000
                  |L29.72|
                          DCD      0x40012100
                  |L29.76|
                          DCD      0x40012200
                  |L29.80|
                          DCD      ||.conststring||

                          AREA ||i.ADC_InjectedSequencerLengthConfig||, CODE, READONLY, ALIGN=2

                  ADC_InjectedSequencerLengthConfig PROC
;;;1248     */
;;;1249   void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1250   {
000002  4604              MOV      r4,r0
;;;1251     uint32_t tmpreg1 = 0;
;;;1252     uint32_t tmpreg2 = 0;
;;;1253     /* Check the parameters */
;;;1254     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  480f              LDR      r0,|L30.68|
000006  460d              MOV      r5,r1                 ;1250
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L30.34|
00000c  480e              LDR      r0,|L30.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L30.34|
000012  480e              LDR      r0,|L30.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L30.34|
000018  f24041e6          MOV      r1,#0x4e6
00001c  480c              LDR      r0,|L30.80|
00001e  f7fffffe          BL       assert_failed
                  |L30.34|
;;;1255     assert_param(IS_ADC_INJECTED_LENGTH(Length));
000022  1e68              SUBS     r0,r5,#1
000024  2803              CMP      r0,#3
000026  d904              BLS      |L30.50|
000028  f24041e7          MOV      r1,#0x4e7
00002c  4808              LDR      r0,|L30.80|
00002e  f7fffffe          BL       assert_failed
                  |L30.50|
;;;1256     
;;;1257     /* Get the old register value */
;;;1258     tmpreg1 = ADCx->JSQR;
000032  6ba0              LDR      r0,[r4,#0x38]
;;;1259     
;;;1260     /* Clear the old injected sequence length JL bits */
;;;1261     tmpreg1 &= JSQR_JL_RESET;
000034  1e6d              SUBS     r5,r5,#1
000036  f4201040          BIC      r0,r0,#0x300000
;;;1262     
;;;1263     /* Set the injected sequence length JL bits */
;;;1264     tmpreg2 = Length - 1; 
;;;1265     tmpreg1 |= tmpreg2 << 20;
00003a  ea405005          ORR      r0,r0,r5,LSL #20
;;;1266     
;;;1267     /* Store the new register value */
;;;1268     ADCx->JSQR = tmpreg1;
00003e  63a0              STR      r0,[r4,#0x38]
;;;1269   }
000040  bd70              POP      {r4-r6,pc}
;;;1270   
                          ENDP

000042  0000              DCW      0x0000
                  |L30.68|
                          DCD      0x40012000
                  |L30.72|
                          DCD      0x40012100
                  |L30.76|
                          DCD      0x40012200
                  |L30.80|
                          DCD      ||.conststring||

                          AREA ||i.ADC_MultiModeDMARequestAfterLastTransferCmd||, CODE, READONLY, ALIGN=2

                  ADC_MultiModeDMARequestAfterLastTransferCmd PROC
;;;1098     */
;;;1099   void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1100   {
;;;1101     /* Check the parameters */
;;;1102     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1103     if (NewState != DISABLE)
;;;1104     {
;;;1105       /* Enable the selected ADC DMA request after last transfer */
;;;1106       ADC->CCR |= (uint32_t)ADC_CCR_DDS;
000002  4c0a              LDR      r4,|L31.44|
000004  b158              CBZ      r0,|L31.30|
000006  2801              CMP      r0,#1                 ;1102
000008  d004              BEQ      |L31.20|
00000a  f240414e          MOV      r1,#0x44e             ;1102
00000e  4808              LDR      r0,|L31.48|
000010  f7fffffe          BL       assert_failed
                  |L31.20|
000014  f8d40304          LDR      r0,[r4,#0x304]
000018  f4405000          ORR      r0,r0,#0x2000
00001c  e003              B        |L31.38|
                  |L31.30|
;;;1107     }
;;;1108     else
;;;1109     {
;;;1110       /* Disable the selected ADC DMA request after last transfer */
;;;1111       ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
00001e  f8d40304          LDR      r0,[r4,#0x304]
000022  f4205000          BIC      r0,r0,#0x2000
                  |L31.38|
000026  f8c40304          STR      r0,[r4,#0x304]        ;1106
;;;1112     }
;;;1113   }
00002a  bd10              POP      {r4,pc}
;;;1114   /**
                          ENDP

                  |L31.44|
                          DCD      0x40012000
                  |L31.48|
                          DCD      ||.conststring||

                          AREA ||i.ADC_RegularChannelConfig||, CODE, READONLY, ALIGN=2

                  ADC_RegularChannelConfig PROC
;;;707      */
;;;708    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;709    {
000004  4605              MOV      r5,r0
;;;710      uint32_t tmpreg1 = 0, tmpreg2 = 0;
;;;711      /* Check the parameters */
;;;712      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  4849              LDR      r0,|L32.300|
000008  461e              MOV      r6,r3                 ;709
00000a  4617              MOV      r7,r2                 ;709
00000c  460c              MOV      r4,r1                 ;709
00000e  4285              CMP      r5,r0
000010  d00a              BEQ      |L32.40|
000012  4847              LDR      r0,|L32.304|
000014  4285              CMP      r5,r0
000016  d007              BEQ      |L32.40|
000018  4846              LDR      r0,|L32.308|
00001a  4285              CMP      r5,r0
00001c  d004              BEQ      |L32.40|
00001e  f44f7132          MOV      r1,#0x2c8
000022  4845              LDR      r0,|L32.312|
000024  f7fffffe          BL       assert_failed
                  |L32.40|
;;;713      assert_param(IS_ADC_CHANNEL(ADC_Channel));
000028  b344              CBZ      r4,|L32.124|
00002a  2c01              CMP      r4,#1
00002c  d026              BEQ      |L32.124|
00002e  2c02              CMP      r4,#2
000030  d024              BEQ      |L32.124|
000032  2c03              CMP      r4,#3
000034  d022              BEQ      |L32.124|
000036  2c04              CMP      r4,#4
000038  d020              BEQ      |L32.124|
00003a  2c05              CMP      r4,#5
00003c  d01e              BEQ      |L32.124|
00003e  2c06              CMP      r4,#6
000040  d01c              BEQ      |L32.124|
000042  2c07              CMP      r4,#7
000044  d01a              BEQ      |L32.124|
000046  2c08              CMP      r4,#8
000048  d018              BEQ      |L32.124|
00004a  2c09              CMP      r4,#9
00004c  d016              BEQ      |L32.124|
00004e  2c0a              CMP      r4,#0xa
000050  d014              BEQ      |L32.124|
000052  2c0b              CMP      r4,#0xb
000054  d012              BEQ      |L32.124|
000056  2c0c              CMP      r4,#0xc
000058  d010              BEQ      |L32.124|
00005a  2c0d              CMP      r4,#0xd
00005c  d00e              BEQ      |L32.124|
00005e  2c0e              CMP      r4,#0xe
000060  d00c              BEQ      |L32.124|
000062  2c0f              CMP      r4,#0xf
000064  d00a              BEQ      |L32.124|
000066  2c10              CMP      r4,#0x10
000068  d008              BEQ      |L32.124|
00006a  2c11              CMP      r4,#0x11
00006c  d006              BEQ      |L32.124|
00006e  2c12              CMP      r4,#0x12
000070  d004              BEQ      |L32.124|
000072  f24021c9          MOV      r1,#0x2c9
000076  4830              LDR      r0,|L32.312|
000078  f7fffffe          BL       assert_failed
                  |L32.124|
;;;714      assert_param(IS_ADC_REGULAR_RANK(Rank));
00007c  f1a70801          SUB      r8,r7,#1
000080  f1b80f0f          CMP      r8,#0xf
000084  d904              BLS      |L32.144|
000086  f24021ca          MOV      r1,#0x2ca
00008a  482b              LDR      r0,|L32.312|
00008c  f7fffffe          BL       assert_failed
                  |L32.144|
;;;715      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
000090  b196              CBZ      r6,|L32.184|
000092  2e01              CMP      r6,#1
000094  d010              BEQ      |L32.184|
000096  2e02              CMP      r6,#2
000098  d00e              BEQ      |L32.184|
00009a  2e03              CMP      r6,#3
00009c  d00c              BEQ      |L32.184|
00009e  2e04              CMP      r6,#4
0000a0  d00a              BEQ      |L32.184|
0000a2  2e05              CMP      r6,#5
0000a4  d008              BEQ      |L32.184|
0000a6  2e06              CMP      r6,#6
0000a8  d006              BEQ      |L32.184|
0000aa  2e07              CMP      r6,#7
0000ac  d004              BEQ      |L32.184|
0000ae  f24021cb          MOV      r1,#0x2cb
0000b2  4821              LDR      r0,|L32.312|
0000b4  f7fffffe          BL       assert_failed
                  |L32.184|
0000b8  2207              MOVS     r2,#7                 ;709
;;;716      
;;;717      /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;718      if (ADC_Channel > ADC_Channel_9)
0000ba  2c09              CMP      r4,#9
0000bc  d90a              BLS      |L32.212|
;;;719      {
;;;720        /* Get the old register value */
;;;721        tmpreg1 = ADCx->SMPR1;
0000be  68e9              LDR      r1,[r5,#0xc]
;;;722        
;;;723        /* Calculate the mask to clear */
;;;724        tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
0000c0  f1a4000a          SUB      r0,r4,#0xa
0000c4  eb000040          ADD      r0,r0,r0,LSL #1
0000c8  4082              LSLS     r2,r2,r0
;;;725        
;;;726        /* Clear the old sample time */
;;;727        tmpreg1 &= ~tmpreg2;
0000ca  4391              BICS     r1,r1,r2
;;;728        
;;;729        /* Calculate the mask to set */
;;;730        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
0000cc  4086              LSLS     r6,r6,r0
;;;731        
;;;732        /* Set the new sample time */
;;;733        tmpreg1 |= tmpreg2;
0000ce  4331              ORRS     r1,r1,r6
;;;734        
;;;735        /* Store the new register value */
;;;736        ADCx->SMPR1 = tmpreg1;
0000d0  60e9              STR      r1,[r5,#0xc]
0000d2  e007              B        |L32.228|
                  |L32.212|
;;;737      }
;;;738      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;739      {
;;;740        /* Get the old register value */
;;;741        tmpreg1 = ADCx->SMPR2;
0000d4  6929              LDR      r1,[r5,#0x10]
;;;742        
;;;743        /* Calculate the mask to clear */
;;;744        tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
0000d6  eb040044          ADD      r0,r4,r4,LSL #1
0000da  4082              LSLS     r2,r2,r0
;;;745        
;;;746        /* Clear the old sample time */
;;;747        tmpreg1 &= ~tmpreg2;
0000dc  4391              BICS     r1,r1,r2
;;;748        
;;;749        /* Calculate the mask to set */
;;;750        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
0000de  4086              LSLS     r6,r6,r0
;;;751        
;;;752        /* Set the new sample time */
;;;753        tmpreg1 |= tmpreg2;
0000e0  4331              ORRS     r1,r1,r6
;;;754        
;;;755        /* Store the new register value */
;;;756        ADCx->SMPR2 = tmpreg1;
0000e2  6129              STR      r1,[r5,#0x10]
                  |L32.228|
;;;757      }
;;;758      /* For Rank 1 to 6 */
;;;759      if (Rank < 7)
;;;760      {
;;;761        /* Get the old register value */
;;;762        tmpreg1 = ADCx->SQR3;
;;;763        
;;;764        /* Calculate the mask to clear */
;;;765        tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
0000e4  211f              MOVS     r1,#0x1f
0000e6  2f07              CMP      r7,#7                 ;759
0000e8  d209              BCS      |L32.254|
0000ea  6b6a              LDR      r2,[r5,#0x34]         ;762
0000ec  eb080088          ADD      r0,r8,r8,LSL #2
0000f0  4081              LSLS     r1,r1,r0
;;;766        
;;;767        /* Clear the old SQx bits for the selected rank */
;;;768        tmpreg1 &= ~tmpreg2;
0000f2  438a              BICS     r2,r2,r1
;;;769        
;;;770        /* Calculate the mask to set */
;;;771        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
0000f4  4084              LSLS     r4,r4,r0
;;;772        
;;;773        /* Set the SQx bits for the selected rank */
;;;774        tmpreg1 |= tmpreg2;
0000f6  4322              ORRS     r2,r2,r4
;;;775        
;;;776        /* Store the new register value */
;;;777        ADCx->SQR3 = tmpreg1;
0000f8  636a              STR      r2,[r5,#0x34]
                  |L32.250|
;;;778      }
;;;779      /* For Rank 7 to 12 */
;;;780      else if (Rank < 13)
;;;781      {
;;;782        /* Get the old register value */
;;;783        tmpreg1 = ADCx->SQR2;
;;;784        
;;;785        /* Calculate the mask to clear */
;;;786        tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
;;;787        
;;;788        /* Clear the old SQx bits for the selected rank */
;;;789        tmpreg1 &= ~tmpreg2;
;;;790        
;;;791        /* Calculate the mask to set */
;;;792        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
;;;793        
;;;794        /* Set the SQx bits for the selected rank */
;;;795        tmpreg1 |= tmpreg2;
;;;796        
;;;797        /* Store the new register value */
;;;798        ADCx->SQR2 = tmpreg1;
;;;799      }
;;;800      /* For Rank 13 to 16 */
;;;801      else
;;;802      {
;;;803        /* Get the old register value */
;;;804        tmpreg1 = ADCx->SQR1;
;;;805        
;;;806        /* Calculate the mask to clear */
;;;807        tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
;;;808        
;;;809        /* Clear the old SQx bits for the selected rank */
;;;810        tmpreg1 &= ~tmpreg2;
;;;811        
;;;812        /* Calculate the mask to set */
;;;813        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
;;;814        
;;;815        /* Set the SQx bits for the selected rank */
;;;816        tmpreg1 |= tmpreg2;
;;;817        
;;;818        /* Store the new register value */
;;;819        ADCx->SQR1 = tmpreg1;
;;;820      }
;;;821    }
0000fa  e8bd81f0          POP      {r4-r8,pc}
                  |L32.254|
0000fe  2f0d              CMP      r7,#0xd               ;780
000100  d209              BCS      |L32.278|
000102  6b2a              LDR      r2,[r5,#0x30]         ;783
000104  1fff              SUBS     r7,r7,#7              ;783
000106  eb070087          ADD      r0,r7,r7,LSL #2       ;786
00010a  4081              LSLS     r1,r1,r0              ;786
00010c  438a              BICS     r2,r2,r1              ;789
00010e  4084              LSLS     r4,r4,r0              ;792
000110  4322              ORRS     r2,r2,r4              ;795
000112  632a              STR      r2,[r5,#0x30]         ;798
000114  e7f1              B        |L32.250|
                  |L32.278|
000116  6aea              LDR      r2,[r5,#0x2c]         ;804
000118  3f0d              SUBS     r7,r7,#0xd            ;804
00011a  eb070087          ADD      r0,r7,r7,LSL #2       ;807
00011e  4081              LSLS     r1,r1,r0              ;807
000120  438a              BICS     r2,r2,r1              ;810
000122  4084              LSLS     r4,r4,r0              ;813
000124  4322              ORRS     r2,r2,r4              ;816
000126  62ea              STR      r2,[r5,#0x2c]         ;819
000128  e7e7              B        |L32.250|
;;;822    
                          ENDP

00012a  0000              DCW      0x0000
                  |L32.300|
                          DCD      0x40012000
                  |L32.304|
                          DCD      0x40012100
                  |L32.308|
                          DCD      0x40012200
                  |L32.312|
                          DCD      ||.conststring||

                          AREA ||i.ADC_SetInjectedOffset||, CODE, READONLY, ALIGN=2

                  ADC_SetInjectedOffset PROC
;;;1283     */
;;;1284   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1285   {
000002  4605              MOV      r5,r0
;;;1286       __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
;;;1287     /* Check the parameters */
;;;1288     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000006  9000              STR      r0,[sp,#0]
000008  4814              LDR      r0,|L33.92|
00000a  4616              MOV      r6,r2                 ;1285
00000c  460c              MOV      r4,r1                 ;1285
00000e  4285              CMP      r5,r0
000010  d00a              BEQ      |L33.40|
000012  4813              LDR      r0,|L33.96|
000014  4285              CMP      r5,r0
000016  d007              BEQ      |L33.40|
000018  4812              LDR      r0,|L33.100|
00001a  4285              CMP      r5,r0
00001c  d004              BEQ      |L33.40|
00001e  f44f61a1          MOV      r1,#0x508
000022  4811              LDR      r0,|L33.104|
000024  f7fffffe          BL       assert_failed
                  |L33.40|
;;;1289     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
000028  2c14              CMP      r4,#0x14
00002a  d00a              BEQ      |L33.66|
00002c  2c18              CMP      r4,#0x18
00002e  d008              BEQ      |L33.66|
000030  2c1c              CMP      r4,#0x1c
000032  d006              BEQ      |L33.66|
000034  2c20              CMP      r4,#0x20
000036  d004              BEQ      |L33.66|
000038  f2405109          MOV      r1,#0x509
00003c  480a              LDR      r0,|L33.104|
00003e  f7fffffe          BL       assert_failed
                  |L33.66|
;;;1290     assert_param(IS_ADC_OFFSET(Offset));
000042  f5b65f80          CMP      r6,#0x1000
000046  d304              BCC      |L33.82|
000048  f240510a          MOV      r1,#0x50a
00004c  4806              LDR      r0,|L33.104|
00004e  f7fffffe          BL       assert_failed
                  |L33.82|
;;;1291     
;;;1292     tmp = (uint32_t)ADCx;
;;;1293     tmp += ADC_InjectedChannel;
000052  1928              ADDS     r0,r5,r4
;;;1294     
;;;1295     /* Set the selected injected channel data offset */
;;;1296    *(__IO uint32_t *) tmp = (uint32_t)Offset;
000054  9000              STR      r0,[sp,#0]
000056  6006              STR      r6,[r0,#0]
;;;1297   }
000058  bdf8              POP      {r3-r7,pc}
;;;1298   
                          ENDP

00005a  0000              DCW      0x0000
                  |L33.92|
                          DCD      0x40012000
                  |L33.96|
                          DCD      0x40012100
                  |L33.100|
                          DCD      0x40012200
                  |L33.104|
                          DCD      ||.conststring||

                          AREA ||i.ADC_SoftwareStartConv||, CODE, READONLY, ALIGN=2

                  ADC_SoftwareStartConv PROC
;;;827      */
;;;828    void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;829    {
000002  4604              MOV      r4,r0
;;;830      /* Check the parameters */
;;;831      assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4809              LDR      r0,|L34.44|
000006  4284              CMP      r4,r0
000008  d00a              BEQ      |L34.32|
00000a  4809              LDR      r0,|L34.48|
00000c  4284              CMP      r4,r0
00000e  d007              BEQ      |L34.32|
000010  4808              LDR      r0,|L34.52|
000012  4284              CMP      r4,r0
000014  d004              BEQ      |L34.32|
000016  f240313f          MOV      r1,#0x33f
00001a  4807              LDR      r0,|L34.56|
00001c  f7fffffe          BL       assert_failed
                  |L34.32|
;;;832      
;;;833      /* Enable the selected ADC conversion for regular group */
;;;834      ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
000020  68a0              LDR      r0,[r4,#8]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  60a0              STR      r0,[r4,#8]
;;;835    }
000028  bd10              POP      {r4,pc}
;;;836    
                          ENDP

00002a  0000              DCW      0x0000
                  |L34.44|
                          DCD      0x40012000
                  |L34.48|
                          DCD      0x40012100
                  |L34.52|
                          DCD      0x40012200
                  |L34.56|
                          DCD      ||.conststring||

                          AREA ||i.ADC_SoftwareStartInjectedConv||, CODE, READONLY, ALIGN=2

                  ADC_SoftwareStartInjectedConv PROC
;;;1376     */
;;;1377   void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;1378   {
000002  4604              MOV      r4,r0
;;;1379     /* Check the parameters */
;;;1380     assert_param(IS_ADC_ALL_PERIPH(ADCx));
000004  4809              LDR      r0,|L35.44|
000006  4284              CMP      r4,r0
000008  d00a              BEQ      |L35.32|
00000a  4809              LDR      r0,|L35.48|
00000c  4284              CMP      r4,r0
00000e  d007              BEQ      |L35.32|
000010  4808              LDR      r0,|L35.52|
000012  4284              CMP      r4,r0
000014  d004              BEQ      |L35.32|
000016  f2405164          MOV      r1,#0x564
00001a  4807              LDR      r0,|L35.56|
00001c  f7fffffe          BL       assert_failed
                  |L35.32|
;;;1381     /* Enable the selected ADC conversion for injected group */
;;;1382     ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
000020  68a0              LDR      r0,[r4,#8]
000022  f4400080          ORR      r0,r0,#0x400000
000026  60a0              STR      r0,[r4,#8]
;;;1383   }
000028  bd10              POP      {r4,pc}
;;;1384   
                          ENDP

00002a  0000              DCW      0x0000
                  |L35.44|
                          DCD      0x40012000
                  |L35.48|
                          DCD      0x40012100
                  |L35.52|
                          DCD      0x40012200
                  |L35.56|
                          DCD      ||.conststring||

                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;302      */
;;;303    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;304    {
;;;305      /* Initialize the ADC_Mode member */
;;;306      ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
;;;307    
;;;308      /* initialize the ADC_ScanConvMode member */
;;;309      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000002  6001              STR      r1,[r0,#0]
000004  7101              STRB     r1,[r0,#4]
;;;310    
;;;311      /* Initialize the ADC_ContinuousConvMode member */
;;;312      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000006  7141              STRB     r1,[r0,#5]
;;;313    
;;;314      /* Initialize the ADC_ExternalTrigConvEdge member */
;;;315      ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
;;;316    
;;;317      /* Initialize the ADC_ExternalTrigConv member */
;;;318      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
000008  6081              STR      r1,[r0,#8]
;;;319    
;;;320      /* Initialize the ADC_DataAlign member */
;;;321      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
00000a  60c1              STR      r1,[r0,#0xc]
;;;322    
;;;323      /* Initialize the ADC_NbrOfConversion member */
;;;324      ADC_InitStruct->ADC_NbrOfConversion = 1;
00000c  6101              STR      r1,[r0,#0x10]
00000e  2101              MOVS     r1,#1
000010  7501              STRB     r1,[r0,#0x14]
;;;325    }
000012  4770              BX       lr
;;;326    
                          ENDP


                          AREA ||i.ADC_TempSensorVrefintCmd||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorVrefintCmd PROC
;;;584      */
;;;585    void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
000000  b510              PUSH     {r4,lr}
;;;586    {
;;;587      /* Check the parameters */
;;;588      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;589      if (NewState != DISABLE)
;;;590      {
;;;591        /* Enable the temperature sensor and Vrefint channel*/
;;;592        ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
000002  4c0a              LDR      r4,|L37.44|
000004  b158              CBZ      r0,|L37.30|
000006  2801              CMP      r0,#1                 ;588
000008  d004              BEQ      |L37.20|
00000a  f44f7113          MOV      r1,#0x24c             ;588
00000e  4808              LDR      r0,|L37.48|
000010  f7fffffe          BL       assert_failed
                  |L37.20|
000014  f8d40304          LDR      r0,[r4,#0x304]
000018  f4400000          ORR      r0,r0,#0x800000
00001c  e003              B        |L37.38|
                  |L37.30|
;;;593      }
;;;594      else
;;;595      {
;;;596        /* Disable the temperature sensor and Vrefint channel*/
;;;597        ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
00001e  f8d40304          LDR      r0,[r4,#0x304]
000022  f4200000          BIC      r0,r0,#0x800000
                  |L37.38|
000026  f8c40304          STR      r0,[r4,#0x304]        ;592
;;;598      }
;;;599    }
00002a  bd10              POP      {r4,pc}
;;;600    
                          ENDP

                  |L37.44|
                          DCD      0x40012000
                  |L37.48|
                          DCD      ||.conststring||

                          AREA ||i.ADC_VBATCmd||, CODE, READONLY, ALIGN=2

                  ADC_VBATCmd PROC
;;;606      */
;;;607    void ADC_VBATCmd(FunctionalState NewState)                             
000000  b510              PUSH     {r4,lr}
;;;608    {
;;;609      /* Check the parameters */
;;;610      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;611      if (NewState != DISABLE)
;;;612      {
;;;613        /* Enable the VBAT channel*/
;;;614        ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
000002  4c0a              LDR      r4,|L38.44|
000004  b158              CBZ      r0,|L38.30|
000006  2801              CMP      r0,#1                 ;610
000008  d004              BEQ      |L38.20|
00000a  f2402162          MOV      r1,#0x262             ;610
00000e  4808              LDR      r0,|L38.48|
000010  f7fffffe          BL       assert_failed
                  |L38.20|
000014  f8d40304          LDR      r0,[r4,#0x304]
000018  f4400080          ORR      r0,r0,#0x400000
00001c  e003              B        |L38.38|
                  |L38.30|
;;;615      }
;;;616      else
;;;617      {
;;;618        /* Disable the VBAT channel*/
;;;619        ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
00001e  f8d40304          LDR      r0,[r4,#0x304]
000022  f4200080          BIC      r0,r0,#0x400000
                  |L38.38|
000026  f8c40304          STR      r0,[r4,#0x304]        ;614
;;;620      }
;;;621    }
00002a  bd10              POP      {r4,pc}
;;;622    
                          ENDP

                  |L38.44|
                          DCD      0x40012000
                  |L38.48|
                          DCD      ||.conststring||

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_adc.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f616463
00004a  2e6300  

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_adc_c_e11a2ea2____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_adc_c_e11a2ea2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_adc_c_e11a2ea2____REVSH|
#line 128
|__asm___15_stm32f4xx_adc_c_e11a2ea2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
