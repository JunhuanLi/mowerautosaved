; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usart.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\usart.crf ..\ext\sys\usart.c]
                          THUMB

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;45     //定义_sys_exit()以避免使用半主机模式    
;;;46     void _sys_exit(int x) 
000000  4770              BX       lr
;;;47     { 
;;;48     	x = x; 
;;;49     } 
;;;50     //重定义fputc函数 
                          ENDP


                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;29     //解决HAL库使用时,某些情况可能报错的bug
;;;30     int _ttywrch(int ch)    
000000  4770              BX       lr
;;;31     {
;;;32         ch=ch;
;;;33     	return ch;
;;;34     }
;;;35     //标准库需要的支持函数                 
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;50     //重定义fputc函数 
;;;51     int fputc(int ch, FILE *f)
000000  4903              LDR      r1,|L3.16|
                  |L3.2|
;;;52     {      
;;;53     	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
000002  680a              LDR      r2,[r1,#0]
000004  0652              LSLS     r2,r2,#25
000006  d5fc              BPL      |L3.2|
;;;54     	USART1->DR = (u8) ch;      
000008  b2c2              UXTB     r2,r0
00000a  604a              STR      r2,[r1,#4]
;;;55     	return ch;
;;;56     }
00000c  4770              BX       lr
;;;57     #endif 
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40011000

                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;105    //bound:波特率 
;;;106    void uart_init(u32 pclk2,u32 bound)
000000  b57c              PUSH     {r2-r6,lr}
;;;107    {  	 
;;;108    	float temp;
;;;109    	u16 mantissa;
;;;110    	u16 fraction;	   
;;;111    	temp=(float)(pclk2*1000000)/(bound*16);//得到USARTDIV@OVER8=0
000002  4a2b              LDR      r2,|L4.176|
000004  4350              MULS     r0,r2,r0
000006  ee000a10          VMOV     s0,r0
00000a  0108              LSLS     r0,r1,#4
;;;112    	mantissa=temp;				 //得到整数部分
;;;113    	fraction=(temp-mantissa)*16; //得到小数部分@OVER8=0 
;;;114        mantissa<<=4;
00000c  f64f72ff          MOV      r2,#0xffff
000010  eef80a40          VCVT.F32.U32 s1,s0                 ;111
000014  ee000a10          VMOV     s0,r0                 ;111
000018  eeb81a40          VCVT.F32.U32 s2,s0                 ;111
00001c  ee800a81          VDIV.F32 s0,s1,s2              ;111
000020  eefc0ac0          VCVT.U32.F32 s1,s0                 ;112
000024  ee100a90          VMOV     r0,s1                 ;112
000028  b280              UXTH     r0,r0                 ;112
00002a  ee000a90          VMOV     s1,r0                 ;113
00002e  ea021000          AND      r0,r2,r0,LSL #4
000032  eef80a60          VCVT.F32.U32 s1,s1                 ;113
000036  ee300a60          VSUB.F32 s0,s0,s1              ;113
00003a  eef30a00          VMOV.F32 s1,#16.00000000       ;113
00003e  ee200a20          VMUL.F32 s0,s0,s1              ;113
000042  eebc0ac0          VCVT.U32.F32 s0,s0                 ;113
000046  ee101a10          VMOV     r1,s0                 ;113
;;;115    	mantissa+=fraction; 
00004a  4408              ADD      r0,r0,r1
00004c  b284              UXTH     r4,r0
;;;116    	RCC->AHB1ENR|=1<<0;   	//使能PORTA口时钟  
00004e  4819              LDR      r0,|L4.180|
000050  6801              LDR      r1,[r0,#0]
000052  f0410101          ORR      r1,r1,#1
000056  6001              STR      r1,[r0,#0]
;;;117    	RCC->APB2ENR|=1<<4;  	//使能串口1时钟 
000058  4816              LDR      r0,|L4.180|
00005a  3014              ADDS     r0,r0,#0x14
00005c  6801              LDR      r1,[r0,#0]
00005e  f0410110          ORR      r1,r1,#0x10
000062  6001              STR      r1,[r0,#0]
;;;118    	GPIO_Set(GPIOA,PIN9|PIN10,GPIO_MODE_AF,GPIO_OTYPE_PP,GPIO_SPEED_50M,GPIO_PUPD_PU);//PA9,PA10,复用功能,上拉输出
000064  2002              MOVS     r0,#2
000066  2101              MOVS     r1,#1
000068  e9cd0100          STRD     r0,r1,[sp,#0]
00006c  4d12              LDR      r5,|L4.184|
00006e  4602              MOV      r2,r0
000070  2300              MOVS     r3,#0
000072  f44f61c0          MOV      r1,#0x600
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       GPIO_Set
;;;119     	GPIO_AF_Set(GPIOA,9,7);	//PA9,AF7
00007c  2207              MOVS     r2,#7
00007e  2109              MOVS     r1,#9
000080  4628              MOV      r0,r5
000082  f7fffffe          BL       GPIO_AF_Set
;;;120    	GPIO_AF_Set(GPIOA,10,7);//PA10,AF7  	   
000086  2207              MOVS     r2,#7
000088  210a              MOVS     r1,#0xa
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       GPIO_AF_Set
;;;121    	//波特率设置
;;;122     	USART1->BRR=mantissa; 	//波特率设置	 
000090  480a              LDR      r0,|L4.188|
000092  6084              STR      r4,[r0,#8]
;;;123    	USART1->CR1&=~(1<<15); 	//设置OVER8=0 
000094  68c1              LDR      r1,[r0,#0xc]
000096  f4214100          BIC      r1,r1,#0x8000
00009a  60c1              STR      r1,[r0,#0xc]
;;;124    	USART1->CR1|=1<<3;  	//串口发送使能 
00009c  68c1              LDR      r1,[r0,#0xc]
00009e  f0410108          ORR      r1,r1,#8
0000a2  60c1              STR      r1,[r0,#0xc]
;;;125    #if EN_USART1_RX		  	//如果使能了接收
;;;126    	//使能接收中断 
;;;127    	USART1->CR1|=1<<2;  	//串口接收使能
;;;128    	USART1->CR1|=1<<5;    	//接收缓冲区非空中断使能	    	
;;;129    	MY_NVIC_Init(3,3,USART1_IRQn,2);//组2，最低优先级 
;;;130    #endif
;;;131    	USART1->CR1|=1<<13;  	//串口使能
0000a4  68c1              LDR      r1,[r0,#0xc]
0000a6  f4415100          ORR      r1,r1,#0x2000
0000aa  60c1              STR      r1,[r0,#0xc]
;;;132    }
0000ac  bd7c              POP      {r2-r6,pc}
;;;133    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L4.176|
                          DCD      0x000f4240
                  |L4.180|
                          DCD      0x40023830
                  |L4.184|
                          DCD      0x40020000
                  |L4.188|
                          DCD      0x40011000

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\ext\\sys\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c__ttywrch____REV16|
#line 388 "..\\ext\\inc\\cmsis_armcc.h"
|__asm___7_usart_c__ttywrch____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c__ttywrch____REVSH|
#line 402
|__asm___7_usart_c__ttywrch____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c__ttywrch____RRX|
#line 587
|__asm___7_usart_c__ttywrch____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
