; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\mempool.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mempool.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\mempool.crf ..\OS\src\mempool.c]
                          THUMB

                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;101     */
;;;102    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  6801              LDR      r1,[r0,#0]
;;;103    {
;;;104        return l->next == l;
000002  4281              CMP      r1,r0
000004  d101              BNE      |L1.10|
000006  2001              MOVS     r0,#1
;;;105    }
000008  4770              BX       lr
                  |L1.10|
00000a  2000              MOVS     r0,#0                 ;104
00000c  4770              BX       lr
;;;106    
                          ENDP


                          AREA ||i.rt_mp_alloc||, CODE, READONLY, ALIGN=2

                  rt_mp_alloc PROC
;;;320     */
;;;321    void *rt_mp_alloc(rt_mp_t mp, rt_int32_t time)
000000  e92d43f3          PUSH     {r0,r1,r4-r9,lr}
;;;322    {
000004  b081              SUB      sp,sp,#4
000006  4604              MOV      r4,r0
;;;323        rt_uint8_t *block_ptr;
;;;324        register rt_base_t level;
;;;325        struct rt_thread *thread;
;;;326        rt_uint32_t before_sleep = 0;
000008  2700              MOVS     r7,#0
;;;327    
;;;328        /* get current thread */
;;;329        thread = rt_thread_self();
00000a  f7fffffe          BL       rt_thread_self
00000e  4605              MOV      r5,r0
;;;330    
;;;331        /* disable interrupt */
;;;332        level = rt_hw_interrupt_disable();
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  4680              MOV      r8,r0
000016  2600              MOVS     r6,#0
;;;333    
;;;334        while (mp->block_free_count == 0)
000018  e05d              B        |L2.214|
                  |L2.26|
;;;335        {
;;;336            /* memory block is unavailable. */
;;;337            if (time == 0)
00001a  9802              LDR      r0,[sp,#8]
00001c  2800              CMP      r0,#0
00001e  d044              BEQ      |L2.170|
;;;338            {
;;;339                /* enable interrupt */
;;;340                rt_hw_interrupt_enable(level);
;;;341    
;;;342                rt_set_errno(-RT_ETIMEOUT);
;;;343    
;;;344                return RT_NULL;
;;;345            }
;;;346    
;;;347            RT_DEBUG_NOT_IN_INTERRUPT;
000020  f7fffffe          BL       rt_hw_interrupt_disable
000024  4681              MOV      r9,r0
000026  f7fffffe          BL       rt_interrupt_get_nest
00002a  b180              CBZ      r0,|L2.78|
00002c  493b              LDR      r1,|L2.284|
00002e  a03c              ADR      r0,|L2.288|
000030  f7fffffe          BL       rt_kprintf
000034  f88d6000          STRB     r6,[sp,#0]
000038  f240135b          MOV      r3,#0x15b
00003c  4a37              LDR      r2,|L2.284|
00003e  a141              ADR      r1,|L2.324|
000040  a041              ADR      r0,|L2.328|
000042  f7fffffe          BL       rt_kprintf
                  |L2.70|
000046  f89d0000          LDRB     r0,[sp,#0]
00004a  2800              CMP      r0,#0
00004c  d0fb              BEQ      |L2.70|
                  |L2.78|
00004e  4648              MOV      r0,r9
000050  f7fffffe          BL       rt_hw_interrupt_enable
;;;348    
;;;349            thread->error = RT_EOK;
;;;350    
;;;351            /* need suspend thread */
;;;352            rt_thread_suspend(thread);
000054  4628              MOV      r0,r5
000056  632e              STR      r6,[r5,#0x30]
000058  f7fffffe          BL       rt_thread_suspend
00005c  6ae2              LDR      r2,[r4,#0x2c]
;;;353            rt_list_insert_after(&(mp->suspend_thread), &(thread->tlist));
00005e  f1050014          ADD      r0,r5,#0x14
000062  f104012c          ADD      r1,r4,#0x2c
000066  6050              STR      r0,[r2,#4]
000068  6ae2              LDR      r2,[r4,#0x2c]
00006a  616a              STR      r2,[r5,#0x14]
00006c  62e0              STR      r0,[r4,#0x2c]
;;;354            mp->suspend_thread_count++;
00006e  61a9              STR      r1,[r5,#0x18]
000070  6b60              LDR      r0,[r4,#0x34]
000072  1c40              ADDS     r0,r0,#1
;;;355    
;;;356            if (time > 0)
000074  6360              STR      r0,[r4,#0x34]
000076  9802              LDR      r0,[sp,#8]
000078  2800              CMP      r0,#0
00007a  dd0c              BLE      |L2.150|
;;;357            {
;;;358                /* get the start tick of timer */
;;;359                before_sleep = rt_tick_get();
00007c  f7fffffe          BL       rt_tick_get
000080  4607              MOV      r7,r0
;;;360    
;;;361                /* init thread timer and start it */
;;;362                rt_timer_control(&(thread->thread_timer),
000082  f105004c          ADD      r0,r5,#0x4c
000086  aa02              ADD      r2,sp,#8
000088  2100              MOVS     r1,#0
00008a  4681              MOV      r9,r0
00008c  f7fffffe          BL       rt_timer_control
000090  4648              MOV      r0,r9
;;;363                                 RT_TIMER_CTRL_SET_TIME,
;;;364                                 &time);
;;;365                rt_timer_start(&(thread->thread_timer));
000092  f7fffffe          BL       rt_timer_start
                  |L2.150|
;;;366            }
;;;367    
;;;368            /* enable interrupt */
;;;369            rt_hw_interrupt_enable(level);
000096  4640              MOV      r0,r8
000098  f7fffffe          BL       rt_hw_interrupt_enable
;;;370    
;;;371            /* do a schedule */
;;;372            rt_schedule();
00009c  f7fffffe          BL       rt_schedule
;;;373    
;;;374            if (thread->error != RT_EOK)
0000a0  6b28              LDR      r0,[r5,#0x30]
0000a2  b150              CBZ      r0,|L2.186|
                  |L2.164|
;;;375                return RT_NULL;
0000a4  2000              MOVS     r0,#0
                  |L2.166|
;;;376    
;;;377            if (time > 0)
;;;378            {
;;;379                time -= rt_tick_get() - before_sleep;
;;;380                if (time < 0)
;;;381                    time = 0;
;;;382            }
;;;383            /* disable interrupt */
;;;384            level = rt_hw_interrupt_disable();
;;;385        }
;;;386    
;;;387        /* memory block is available. decrease the free block counter */
;;;388        mp->block_free_count--;
;;;389    
;;;390        /* get block from block list */
;;;391        block_ptr = mp->block_list;
;;;392        RT_ASSERT(block_ptr != RT_NULL);
;;;393    
;;;394        /* Setup the next free node. */
;;;395        mp->block_list = *(rt_uint8_t **)block_ptr;
;;;396    
;;;397        /* point to memory pool */
;;;398        *(rt_uint8_t **)block_ptr = (rt_uint8_t *)mp;
;;;399    
;;;400        /* enable interrupt */
;;;401        rt_hw_interrupt_enable(level);
;;;402    
;;;403        RT_OBJECT_HOOK_CALL(rt_mp_alloc_hook,
;;;404                            (mp, (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *))));
;;;405    
;;;406        return (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *));
;;;407    }
0000a6  e8bd83fe          POP      {r1-r9,pc}
                  |L2.170|
0000aa  4640              MOV      r0,r8                 ;340
0000ac  f7fffffe          BL       rt_hw_interrupt_enable
0000b0  f06f0001          MVN      r0,#1                 ;342
0000b4  f7fffffe          BL       rt_set_errno
0000b8  e7f4              B        |L2.164|
                  |L2.186|
0000ba  9802              LDR      r0,[sp,#8]            ;377
0000bc  2800              CMP      r0,#0                 ;377
0000be  dd07              BLE      |L2.208|
0000c0  f7fffffe          BL       rt_tick_get
0000c4  9902              LDR      r1,[sp,#8]            ;379
0000c6  1bc0              SUBS     r0,r0,r7              ;379
0000c8  1a08              SUBS     r0,r1,r0              ;379
0000ca  9002              STR      r0,[sp,#8]            ;380
0000cc  d500              BPL      |L2.208|
0000ce  9602              STR      r6,[sp,#8]            ;381
                  |L2.208|
0000d0  f7fffffe          BL       rt_hw_interrupt_disable
0000d4  4680              MOV      r8,r0                 ;384
                  |L2.214|
0000d6  6aa0              LDR      r0,[r4,#0x28]         ;334
0000d8  2800              CMP      r0,#0                 ;334
0000da  d09e              BEQ      |L2.26|
0000dc  1e40              SUBS     r0,r0,#1              ;334
0000de  62a0              STR      r0,[r4,#0x28]         ;391
0000e0  6a25              LDR      r5,[r4,#0x20]         ;392
0000e2  b965              CBNZ     r5,|L2.254|
0000e4  f88d6000          STRB     r6,[sp,#0]            ;392
0000e8  f44f73c4          MOV      r3,#0x188             ;392
0000ec  4a0b              LDR      r2,|L2.284|
0000ee  a11e              ADR      r1,|L2.360|
0000f0  a015              ADR      r0,|L2.328|
0000f2  f7fffffe          BL       rt_kprintf
                  |L2.246|
0000f6  f89d0000          LDRB     r0,[sp,#0]            ;392
0000fa  2800              CMP      r0,#0                 ;392
0000fc  d0fb              BEQ      |L2.246|
                  |L2.254|
0000fe  6828              LDR      r0,[r5,#0]            ;395
000100  6220              STR      r0,[r4,#0x20]         ;398
000102  4640              MOV      r0,r8                 ;401
000104  602c              STR      r4,[r5,#0]            ;401
000106  f7fffffe          BL       rt_hw_interrupt_enable
00010a  481d              LDR      r0,|L2.384|
00010c  6802              LDR      r2,[r0,#0]            ;403  ; rt_mp_alloc_hook
00010e  b112              CBZ      r2,|L2.278|
000110  1d29              ADDS     r1,r5,#4              ;403
000112  4620              MOV      r0,r4                 ;403
000114  4790              BLX      r2                    ;403
                  |L2.278|
000116  1d28              ADDS     r0,r5,#4              ;406
000118  e7c5              B        |L2.166|
;;;408    RTM_EXPORT(rt_mp_alloc);
                          ENDP

00011a  0000              DCW      0x0000
                  |L2.284|
                          DCD      ||.constdata||+0x32
                  |L2.288|
000120  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000124  74696f6e
000128  5b25735d
00012c  20736861
000130  6c6c206e
000134  6f742075
000138  73656420
00013c  696e2049
000140  53520a00
                  |L2.324|
000144  3000              DCB      "0",0
000146  00                DCB      0
000147  00                DCB      0
                  |L2.328|
000148  28257329          DCB      "(%s) assert failed at %s:%d \n",0
00014c  20617373
000150  65727420
000154  6661696c
000158  65642061
00015c  74202573
000160  3a256420
000164  0a00    
000166  00                DCB      0
000167  00                DCB      0
                  |L2.360|
000168  626c6f63          DCB      "block_ptr != RT_NULL",0
00016c  6b5f7074
000170  7220213d
000174  2052545f
000178  4e554c4c
00017c  00      
00017d  00                DCB      0
00017e  00                DCB      0
00017f  00                DCB      0
                  |L2.384|
                          DCD      ||.data||

                          AREA ||i.rt_mp_alloc_sethook||, CODE, READONLY, ALIGN=2

                  rt_mp_alloc_sethook PROC
;;;53      */
;;;54     void rt_mp_alloc_sethook(void (*hook)(struct rt_mempool *mp, void *block))
000000  4901              LDR      r1,|L3.8|
;;;55     {
;;;56         rt_mp_alloc_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_mp_alloc_hook
;;;57     }
000004  4770              BX       lr
;;;58     
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.rt_mp_create||, CODE, READONLY, ALIGN=2

                  rt_mp_create PROC
;;;196     */
;;;197    rt_mp_t rt_mp_create(const char *name,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;198                         rt_size_t   block_count,
;;;199                         rt_size_t   block_size)
;;;200    {
000004  4615              MOV      r5,r2
000006  460f              MOV      r7,r1
000008  4604              MOV      r4,r0
;;;201        rt_uint8_t *block_ptr;
;;;202        struct rt_mempool *mp;
;;;203        register rt_base_t offset;
;;;204    
;;;205        RT_DEBUG_NOT_IN_INTERRUPT;
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4680              MOV      r8,r0
000010  f7fffffe          BL       rt_interrupt_get_nest
000014  2600              MOVS     r6,#0
000016  b178              CBZ      r0,|L4.56|
000018  4922              LDR      r1,|L4.164|
00001a  a023              ADR      r0,|L4.168|
00001c  f7fffffe          BL       rt_kprintf
000020  f88d6000          STRB     r6,[sp,#0]
000024  23cd              MOVS     r3,#0xcd
000026  4a1f              LDR      r2,|L4.164|
000028  a128              ADR      r1,|L4.204|
00002a  a029              ADR      r0,|L4.208|
00002c  f7fffffe          BL       rt_kprintf
                  |L4.48|
000030  f89d0000          LDRB     r0,[sp,#0]
000034  2800              CMP      r0,#0
000036  d0fb              BEQ      |L4.48|
                  |L4.56|
000038  4640              MOV      r0,r8
00003a  f7fffffe          BL       rt_hw_interrupt_enable
;;;206    
;;;207        /* allocate object */
;;;208        mp = (struct rt_mempool *)rt_object_allocate(RT_Object_Class_MemPool, name);
00003e  4621              MOV      r1,r4
000040  2006              MOVS     r0,#6
000042  f7fffffe          BL       rt_object_allocate
000046  1e04              SUBS     r4,r0,#0
;;;209        /* allocate object failed */
;;;210        if (mp == RT_NULL)
000048  d019              BEQ      |L4.126|
00004a  1ded              ADDS     r5,r5,#7
;;;211            return RT_NULL;
;;;212    
;;;213        /* initialize memory pool */
;;;214        block_size     = RT_ALIGN(block_size, RT_ALIGN_SIZE);
00004c  f0250007          BIC      r0,r5,#7
;;;215        mp->block_size = block_size;
000050  1d05              ADDS     r5,r0,#4
;;;216        mp->size       = (block_size + sizeof(rt_uint8_t *)) * block_count;
000052  61e0              STR      r0,[r4,#0x1c]
000054  fb05f007          MUL      r0,r5,r7
;;;217    
;;;218        /* allocate memory */
;;;219        mp->start_address = rt_malloc((block_size + sizeof(rt_uint8_t *)) *
000058  61a0              STR      r0,[r4,#0x18]
00005a  f7fffffe          BL       rt_malloc
;;;220                                      block_count);
;;;221        if (mp->start_address == RT_NULL)
00005e  6160              STR      r0,[r4,#0x14]
000060  b148              CBZ      r0,|L4.118|
;;;222        {
;;;223            /* no memory, delete memory pool object */
;;;224            rt_object_delete(&(mp->parent));
;;;225    
;;;226            return RT_NULL;
;;;227        }
;;;228    
;;;229        mp->block_total_count = block_count;
;;;230        mp->block_free_count  = mp->block_total_count;
000062  6267              STR      r7,[r4,#0x24]
;;;231    
;;;232        /* initialize suspended thread list */
;;;233        rt_list_init(&(mp->suspend_thread));
000064  f104002c          ADD      r0,r4,#0x2c
000068  6320              STR      r0,[r4,#0x30]
;;;234        mp->suspend_thread_count = 0;
;;;235    
;;;236        /* initialize free block list */
;;;237        block_ptr = (rt_uint8_t *)mp->start_address;
00006a  e9c4700a          STRD     r7,r0,[r4,#0x28]
00006e  6366              STR      r6,[r4,#0x34]
;;;238        for (offset = 0; offset < mp->block_total_count; offset ++)
000070  2000              MOVS     r0,#0
000072  6961              LDR      r1,[r4,#0x14]
000074  e00c              B        |L4.144|
                  |L4.118|
000076  4620              MOV      r0,r4                 ;224
000078  f7fffffe          BL       rt_object_delete
00007c  2000              MOVS     r0,#0                 ;226
                  |L4.126|
;;;239        {
;;;240            *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *)))
;;;241                = block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *));
;;;242        }
;;;243    
;;;244        *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *)))
;;;245            = RT_NULL;
;;;246    
;;;247        mp->block_list = block_ptr;
;;;248    
;;;249        return mp;
;;;250    }
00007e  e8bd83f8          POP      {r3-r9,pc}
                  |L4.130|
000082  1c42              ADDS     r2,r0,#1              ;240
000084  fb021305          MLA      r3,r2,r5,r1           ;240
000088  fb00f205          MUL      r2,r0,r5              ;240
00008c  1c40              ADDS     r0,r0,#1              ;240
00008e  508b              STR      r3,[r1,r2]            ;240
                  |L4.144|
000090  6a62              LDR      r2,[r4,#0x24]         ;238
000092  4282              CMP      r2,r0                 ;238
000094  d8f5              BHI      |L4.130|
000096  1e40              SUBS     r0,r0,#1              ;238
000098  4368              MULS     r0,r5,r0              ;244
00009a  500e              STR      r6,[r1,r0]            ;244
00009c  4620              MOV      r0,r4                 ;249
00009e  6221              STR      r1,[r4,#0x20]         ;249
0000a0  e7ed              B        |L4.126|
;;;251    RTM_EXPORT(rt_mp_create);
                          ENDP

0000a2  0000              DCW      0x0000
                  |L4.164|
                          DCD      ||.constdata||+0x18
                  |L4.168|
0000a8  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0000ac  74696f6e
0000b0  5b25735d
0000b4  20736861
0000b8  6c6c206e
0000bc  6f742075
0000c0  73656420
0000c4  696e2049
0000c8  53520a00
                  |L4.204|
0000cc  3000              DCB      "0",0
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L4.208|
0000d0  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000d4  20617373
0000d8  65727420
0000dc  6661696c
0000e0  65642061
0000e4  74202573
0000e8  3a256420
0000ec  0a00    
0000ee  00                DCB      0
0000ef  00                DCB      0

                          AREA ||i.rt_mp_delete||, CODE, READONLY, ALIGN=2

                  rt_mp_delete PROC
;;;259     */
;;;260    rt_err_t rt_mp_delete(rt_mp_t mp)
000000  b5f8              PUSH     {r3-r7,lr}
;;;261    {
000002  4604              MOV      r4,r0
;;;262        struct rt_thread *thread;
;;;263        register rt_ubase_t temp;
;;;264    
;;;265        RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4606              MOV      r6,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2500              MOVS     r5,#0
000010  b180              CBZ      r0,|L5.52|
000012  4920              LDR      r1,|L5.148|
000014  a020              ADR      r0,|L5.152|
000016  f7fffffe          BL       rt_kprintf
00001a  f88d5000          STRB     r5,[sp,#0]
00001e  f2401309          MOV      r3,#0x109
000022  4a1c              LDR      r2,|L5.148|
000024  a125              ADR      r1,|L5.188|
000026  a026              ADR      r0,|L5.192|
000028  f7fffffe          BL       rt_kprintf
                  |L5.44|
00002c  f89d0000          LDRB     r0,[sp,#0]
000030  2800              CMP      r0,#0
000032  d0fb              BEQ      |L5.44|
                  |L5.52|
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       rt_hw_interrupt_enable
;;;266    
;;;267        /* parameter check */
;;;268        RT_ASSERT(mp != RT_NULL);
00003a  b964              CBNZ     r4,|L5.86|
00003c  f88d5000          STRB     r5,[sp,#0]
000040  f44f7386          MOV      r3,#0x10c
000044  4a13              LDR      r2,|L5.148|
000046  a126              ADR      r1,|L5.224|
000048  a01d              ADR      r0,|L5.192|
00004a  f7fffffe          BL       rt_kprintf
                  |L5.78|
00004e  f89d0000          LDRB     r0,[sp,#0]
000052  2800              CMP      r0,#0
000054  d0fb              BEQ      |L5.78|
                  |L5.86|
;;;269    
;;;270        /* wake up all suspended threads */
;;;271        while (!rt_list_isempty(&(mp->suspend_thread)))
;;;272        {
;;;273            /* disable interrupt */
;;;274            temp = rt_hw_interrupt_disable();
;;;275    
;;;276            /* get next suspend thread */
;;;277            thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
;;;278            /* set error code to RT_ERROR */
;;;279            thread->error = -RT_ERROR;
000056  f04f36ff          MOV      r6,#0xffffffff
00005a  f104072c          ADD      r7,r4,#0x2c           ;271
                  |L5.94|
00005e  4638              MOV      r0,r7                 ;271
000060  f7fffffe          BL       rt_list_isempty
000064  b138              CBZ      r0,|L5.118|
;;;280    
;;;281            /*
;;;282             * resume thread
;;;283             * In rt_thread_resume function, it will remove current thread from
;;;284             * suspend list
;;;285             */
;;;286            rt_thread_resume(thread);
;;;287    
;;;288            /* decrease suspended thread count */
;;;289            mp->suspend_thread_count --;
;;;290    
;;;291            /* enable interrupt */
;;;292            rt_hw_interrupt_enable(temp);
;;;293        }
;;;294    
;;;295    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;296        /* the mp object belongs to an application module */
;;;297        if (mp->parent.flag & RT_OBJECT_FLAG_MODULE)
;;;298            rt_module_free(mp->parent.module_id, mp->start_address);
;;;299        else
;;;300    #endif
;;;301    
;;;302        /* release allocated room */
;;;303        rt_free(mp->start_address);
000066  6960              LDR      r0,[r4,#0x14]
000068  f7fffffe          BL       rt_free
;;;304    
;;;305        /* detach object */
;;;306        rt_object_delete(&(mp->parent));
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       rt_object_delete
;;;307    
;;;308        return RT_EOK;
000072  2000              MOVS     r0,#0
;;;309    }
000074  bdf8              POP      {r3-r7,pc}
                  |L5.118|
000076  f7fffffe          BL       rt_hw_interrupt_disable
00007a  4605              MOV      r5,r0                 ;274
00007c  6ae0              LDR      r0,[r4,#0x2c]         ;279
00007e  61c6              STR      r6,[r0,#0x1c]         ;279
000080  3814              SUBS     r0,r0,#0x14           ;279
000082  f7fffffe          BL       rt_thread_resume
000086  6b60              LDR      r0,[r4,#0x34]         ;289
000088  1e40              SUBS     r0,r0,#1              ;289
00008a  6360              STR      r0,[r4,#0x34]         ;292
00008c  4628              MOV      r0,r5                 ;292
00008e  f7fffffe          BL       rt_hw_interrupt_enable
000092  e7e4              B        |L5.94|
;;;310    RTM_EXPORT(rt_mp_delete);
                          ENDP

                  |L5.148|
                          DCD      ||.constdata||+0x25
                  |L5.152|
000098  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00009c  74696f6e
0000a0  5b25735d
0000a4  20736861
0000a8  6c6c206e
0000ac  6f742075
0000b0  73656420
0000b4  696e2049
0000b8  53520a00
                  |L5.188|
0000bc  3000              DCB      "0",0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L5.192|
0000c0  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000c4  20617373
0000c8  65727420
0000cc  6661696c
0000d0  65642061
0000d4  74202573
0000d8  3a256420
0000dc  0a00    
0000de  00                DCB      0
0000df  00                DCB      0
                  |L5.224|
0000e0  6d702021          DCB      "mp != RT_NULL",0
0000e4  3d205254
0000e8  5f4e554c
0000ec  4c00    
0000ee  00                DCB      0
0000ef  00                DCB      0

                          AREA ||i.rt_mp_detach||, CODE, READONLY, ALIGN=2

                  rt_mp_detach PROC
;;;145     */
;;;146    rt_err_t rt_mp_detach(struct rt_mempool *mp)
000000  b5f8              PUSH     {r3-r7,lr}
;;;147    {
000002  0004              MOVS     r4,r0
000004  d10b              BNE      |L6.30|
;;;148        struct rt_thread *thread;
;;;149        register rt_ubase_t temp;
;;;150    
;;;151        /* parameter check */
;;;152        RT_ASSERT(mp != RT_NULL);
000006  f88d0000          STRB     r0,[sp,#0]
00000a  2398              MOVS     r3,#0x98
00000c  4a12              LDR      r2,|L6.88|
00000e  a113              ADR      r1,|L6.92|
000010  a016              ADR      r0,|L6.108|
000012  f7fffffe          BL       rt_kprintf
                  |L6.22|
000016  f89d0000          LDRB     r0,[sp,#0]
00001a  2800              CMP      r0,#0
00001c  d0fb              BEQ      |L6.22|
                  |L6.30|
;;;153    
;;;154        /* wake up all suspended threads */
;;;155        while (!rt_list_isempty(&(mp->suspend_thread)))
;;;156        {
;;;157            /* disable interrupt */
;;;158            temp = rt_hw_interrupt_disable();
;;;159    
;;;160            /* get next suspend thread */
;;;161            thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
;;;162            /* set error code to RT_ERROR */
;;;163            thread->error = -RT_ERROR;
00001e  f04f36ff          MOV      r6,#0xffffffff
000022  f104072c          ADD      r7,r4,#0x2c           ;155
                  |L6.38|
000026  4638              MOV      r0,r7                 ;155
000028  f7fffffe          BL       rt_list_isempty
00002c  b120              CBZ      r0,|L6.56|
;;;164    
;;;165            /*
;;;166             * resume thread
;;;167             * In rt_thread_resume function, it will remove current thread from
;;;168             * suspend list
;;;169             */
;;;170            rt_thread_resume(thread);
;;;171    
;;;172            /* decrease suspended thread count */
;;;173            mp->suspend_thread_count --;
;;;174    
;;;175            /* enable interrupt */
;;;176            rt_hw_interrupt_enable(temp);
;;;177        }
;;;178    
;;;179        /* detach object */
;;;180        rt_object_detach(&(mp->parent));
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       rt_object_detach
;;;181    
;;;182        return RT_EOK;
000034  2000              MOVS     r0,#0
;;;183    }
000036  bdf8              POP      {r3-r7,pc}
                  |L6.56|
000038  f7fffffe          BL       rt_hw_interrupt_disable
00003c  4605              MOV      r5,r0                 ;158
00003e  6ae0              LDR      r0,[r4,#0x2c]         ;163
000040  61c6              STR      r6,[r0,#0x1c]         ;163
000042  3814              SUBS     r0,r0,#0x14           ;163
000044  f7fffffe          BL       rt_thread_resume
000048  6b60              LDR      r0,[r4,#0x34]         ;173
00004a  1e40              SUBS     r0,r0,#1              ;173
00004c  6360              STR      r0,[r4,#0x34]         ;176
00004e  4628              MOV      r0,r5                 ;176
000050  f7fffffe          BL       rt_hw_interrupt_enable
000054  e7e7              B        |L6.38|
;;;184    RTM_EXPORT(rt_mp_detach);
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      ||.constdata||+0xb
                  |L6.92|
00005c  6d702021          DCB      "mp != RT_NULL",0
000060  3d205254
000064  5f4e554c
000068  4c00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L6.108|
00006c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000070  20617373
000074  65727420
000078  6661696c
00007c  65642061
000080  74202573
000084  3a256420
000088  0a00    
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.rt_mp_free||, CODE, READONLY, ALIGN=2

                  rt_mp_free PROC
;;;414     */
;;;415    void rt_mp_free(void *block)
000000  b570              PUSH     {r4-r6,lr}
;;;416    {
;;;417        rt_uint8_t **block_ptr;
;;;418        struct rt_mempool *mp;
;;;419        struct rt_thread *thread;
;;;420        register rt_base_t level;
;;;421    
;;;422        /* get the control block of pool which the block belongs to */
;;;423        block_ptr = (rt_uint8_t **)((rt_uint8_t *)block - sizeof(rt_uint8_t *));
;;;424        mp        = (struct rt_mempool *)*block_ptr;
;;;425    
;;;426        RT_OBJECT_HOOK_CALL(rt_mp_free_hook, (mp, block));
000002  4914              LDR      r1,|L7.84|
000004  1f05              SUBS     r5,r0,#4              ;423
000006  682c              LDR      r4,[r5,#0]
000008  684a              LDR      r2,[r1,#4]            ;416  ; rt_mp_free_hook
00000a  b112              CBZ      r2,|L7.18|
00000c  4601              MOV      r1,r0
00000e  4620              MOV      r0,r4
000010  4790              BLX      r2
                  |L7.18|
;;;427    
;;;428        /* disable interrupt */
;;;429        level = rt_hw_interrupt_disable();
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4606              MOV      r6,r0
;;;430    
;;;431        /* increase the free block count */
;;;432        mp->block_free_count ++;
000018  6aa0              LDR      r0,[r4,#0x28]
00001a  1c40              ADDS     r0,r0,#1
;;;433    
;;;434        /* link the block into the block list */
;;;435        *block_ptr = mp->block_list;
00001c  62a0              STR      r0,[r4,#0x28]
00001e  6a20              LDR      r0,[r4,#0x20]
;;;436        mp->block_list = (rt_uint8_t *)block_ptr;
000020  6028              STR      r0,[r5,#0]
;;;437    
;;;438        if (mp->suspend_thread_count > 0)
000022  6225              STR      r5,[r4,#0x20]
000024  6b60              LDR      r0,[r4,#0x34]
000026  b178              CBZ      r0,|L7.72|
;;;439        {
;;;440            /* get the suspended thread */
;;;441            thread = rt_list_entry(mp->suspend_thread.next,
;;;442                                   struct rt_thread,
;;;443                                   tlist);
;;;444    
;;;445            /* set error */
;;;446            thread->error = RT_EOK;
000028  6ae0              LDR      r0,[r4,#0x2c]
00002a  2100              MOVS     r1,#0
00002c  61c1              STR      r1,[r0,#0x1c]
00002e  3814              SUBS     r0,r0,#0x14
;;;447    
;;;448            /* resume thread */
;;;449            rt_thread_resume(thread);
000030  f7fffffe          BL       rt_thread_resume
;;;450    
;;;451            /* decrease suspended thread count */
;;;452            mp->suspend_thread_count --;
000034  6b60              LDR      r0,[r4,#0x34]
000036  1e40              SUBS     r0,r0,#1
;;;453    
;;;454            /* enable interrupt */
;;;455            rt_hw_interrupt_enable(level);
000038  6360              STR      r0,[r4,#0x34]
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       rt_hw_interrupt_enable
;;;456    
;;;457            /* do a schedule */
;;;458            rt_schedule();
000040  e8bd4070          POP      {r4-r6,lr}
000044  f7ffbffe          B.W      rt_schedule
                  |L7.72|
;;;459    
;;;460            return;
;;;461        }
;;;462    
;;;463        /* enable interrupt */
;;;464        rt_hw_interrupt_enable(level);
000048  4630              MOV      r0,r6
00004a  e8bd4070          POP      {r4-r6,lr}
00004e  f7ffbffe          B.W      rt_hw_interrupt_enable
;;;465    }
;;;466    RTM_EXPORT(rt_mp_free);
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      ||.data||

                          AREA ||i.rt_mp_free_sethook||, CODE, READONLY, ALIGN=2

                  rt_mp_free_sethook PROC
;;;64      */
;;;65     void rt_mp_free_sethook(void (*hook)(struct rt_mempool *mp, void *block))
000000  4901              LDR      r1,|L8.8|
;;;66     {
;;;67         rt_mp_free_hook = hook;
000002  6048              STR      r0,[r1,#4]  ; rt_mp_free_hook
;;;68     }
000004  4770              BX       lr
;;;69     
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||.data||

                          AREA ||i.rt_mp_init||, CODE, READONLY, ALIGN=2

                  rt_mp_init PROC
;;;90      */
;;;91     rt_err_t rt_mp_init(struct rt_mempool *mp,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;92                         const char        *name,
;;;93                         void              *start,
;;;94                         rt_size_t          size,
;;;95                         rt_size_t          block_size)
;;;96     {
000004  461e              MOV      r6,r3
000006  f8dd8020          LDR      r8,[sp,#0x20]
00000a  4617              MOV      r7,r2
00000c  4689              MOV      r9,r1
00000e  0004              MOVS     r4,r0
000010  f04f0500          MOV      r5,#0
000014  d10b              BNE      |L9.46|
;;;97         rt_uint8_t *block_ptr;
;;;98         register rt_base_t offset;
;;;99     
;;;100        /* parameter check */
;;;101        RT_ASSERT(mp != RT_NULL);
000016  f88d5000          STRB     r5,[sp,#0]
00001a  2365              MOVS     r3,#0x65
00001c  4a1a              LDR      r2,|L9.136|
00001e  a11b              ADR      r1,|L9.140|
000020  a01e              ADR      r0,|L9.156|
000022  f7fffffe          BL       rt_kprintf
                  |L9.38|
000026  f89d0000          LDRB     r0,[sp,#0]
00002a  2800              CMP      r0,#0
00002c  d0fb              BEQ      |L9.38|
                  |L9.46|
;;;102    
;;;103        /* initialize object */
;;;104        rt_object_init(&(mp->parent), RT_Object_Class_MemPool, name);
00002e  464a              MOV      r2,r9
000030  2106              MOVS     r1,#6
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       rt_object_init
;;;105    
;;;106        /* initialize memory pool */
;;;107        mp->start_address = start;
;;;108        mp->size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
;;;109    
;;;110        /* align the block size */
;;;111        block_size = RT_ALIGN(block_size, RT_ALIGN_SIZE);
000038  f1080107          ADD      r1,r8,#7
00003c  f0260007          BIC      r0,r6,#7              ;108
000040  f0210207          BIC      r2,r1,#7
000044  6167              STR      r7,[r4,#0x14]
000046  e9c40206          STRD     r0,r2,[r4,#0x18]
00004a  1d12              ADDS     r2,r2,#4
;;;112        mp->block_size = block_size;
;;;113    
;;;114        /* align to align size byte */
;;;115        mp->block_total_count = mp->size / (mp->block_size + sizeof(rt_uint8_t *));
00004c  fbb0f0f2          UDIV     r0,r0,r2
;;;116        mp->block_free_count  = mp->block_total_count;
000050  6260              STR      r0,[r4,#0x24]
;;;117    
;;;118        /* initialize suspended thread list */
;;;119        rt_list_init(&(mp->suspend_thread));
000052  62a0              STR      r0,[r4,#0x28]
000054  f104002c          ADD      r0,r4,#0x2c
000058  6320              STR      r0,[r4,#0x30]
;;;120        mp->suspend_thread_count = 0;
;;;121    
;;;122        /* initialize free block list */
;;;123        block_ptr = (rt_uint8_t *)mp->start_address;
00005a  6365              STR      r5,[r4,#0x34]
00005c  62e0              STR      r0,[r4,#0x2c]
;;;124        for (offset = 0; offset < mp->block_total_count; offset ++)
00005e  2000              MOVS     r0,#0
000060  6961              LDR      r1,[r4,#0x14]
000062  e006              B        |L9.114|
                  |L9.100|
;;;125        {
;;;126            *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *))) =
000064  1c43              ADDS     r3,r0,#1
000066  fb031602          MLA      r6,r3,r2,r1
00006a  fb00f302          MUL      r3,r0,r2
00006e  1c40              ADDS     r0,r0,#1
000070  50ce              STR      r6,[r1,r3]
                  |L9.114|
000072  6a63              LDR      r3,[r4,#0x24]         ;124
000074  4283              CMP      r3,r0                 ;124
000076  d8f5              BHI      |L9.100|
000078  1e40              SUBS     r0,r0,#1              ;124
;;;127                (rt_uint8_t *)(block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *)));
;;;128        }
;;;129    
;;;130        *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *))) =
00007a  4350              MULS     r0,r2,r0
00007c  500d              STR      r5,[r1,r0]
;;;131            RT_NULL;
;;;132    
;;;133        mp->block_list = block_ptr;
;;;134    
;;;135        return RT_EOK;
00007e  2000              MOVS     r0,#0
000080  6221              STR      r1,[r4,#0x20]
;;;136    }
000082  e8bd83f8          POP      {r3-r9,pc}
;;;137    RTM_EXPORT(rt_mp_init);
                          ENDP

000086  0000              DCW      0x0000
                  |L9.136|
                          DCD      ||.constdata||
                  |L9.140|
00008c  6d702021          DCB      "mp != RT_NULL",0
000090  3d205254
000094  5f4e554c
000098  4c00    
00009a  00                DCB      0
00009b  00                DCB      0
                  |L9.156|
00009c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000a0  20617373
0000a4  65727420
0000a8  6661696c
0000ac  65642061
0000b0  74202573
0000b4  3a256420
0000b8  0a00    
0000ba  00                DCB      0
0000bb  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000004  705f696e          DCB      0x70,0x5f,0x69,0x6e
000008  697400            DCB      0x69,0x74,0x00
                  |symbol_number.32|
00000b  72                DCB      0x72
00000c  745f6d70          DCB      0x74,0x5f,0x6d,0x70
000010  5f646574          DCB      0x5f,0x64,0x65,0x74
000014  61636800          DCB      0x61,0x63,0x68,0x00
                  |symbol_number.33|
000018  72745f6d          DCB      0x72,0x74,0x5f,0x6d
00001c  705f6372          DCB      0x70,0x5f,0x63,0x72
000020  65617465          DCB      0x65,0x61,0x74,0x65
000024  00                DCB      0x00
                  |symbol_number.34|
000025  72745f            DCB      0x72,0x74,0x5f
000028  6d705f64          DCB      0x6d,0x70,0x5f,0x64
00002c  656c6574          DCB      0x65,0x6c,0x65,0x74
000030  6500              DCB      0x65,0x00
                  |symbol_number.35|
000032  7274              DCB      0x72,0x74
000034  5f6d705f          DCB      0x5f,0x6d,0x70,0x5f
000038  616c6c6f          DCB      0x61,0x6c,0x6c,0x6f
00003c  6300              DCB      0x63,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  rt_mp_alloc_hook
                          DCD      0x00000000
                  rt_mp_free_hook
                          DCD      0x00000000
