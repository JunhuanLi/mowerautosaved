; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_rtc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_rtc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_rtc.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rtc.c]
                          THUMB

                          AREA ||i.RTC_AlarmCmd||, CODE, READONLY, ALIGN=2

                  RTC_AlarmCmd PROC
;;;1282     */
;;;1283   ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
000000  b538              PUSH     {r3-r5,lr}
;;;1284   {
000002  4604              MOV      r4,r0
;;;1285     __IO uint32_t alarmcounter = 0x00;
000004  2000              MOVS     r0,#0
000006  460d              MOV      r5,r1                 ;1284
;;;1286     uint32_t alarmstatus = 0x00;
;;;1287     ErrorStatus status = ERROR;
;;;1288       
;;;1289     /* Check the parameters */
;;;1290     assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
000008  f4147f40          TST      r4,#0x300
00000c  9000              STR      r0,[sp,#0]            ;1284
00000e  d104              BNE      |L1.26|
000010  f240510a          MOV      r1,#0x50a
000014  4816              LDR      r0,|L1.112|
000016  f7fffffe          BL       assert_failed
                  |L1.26|
;;;1291     assert_param(IS_FUNCTIONAL_STATE(NewState));
00001a  b135              CBZ      r5,|L1.42|
00001c  2d01              CMP      r5,#1
00001e  d004              BEQ      |L1.42|
000020  f240510b          MOV      r1,#0x50b
000024  4812              LDR      r0,|L1.112|
000026  f7fffffe          BL       assert_failed
                  |L1.42|
;;;1292   
;;;1293     /* Disable the write protection for RTC registers */
;;;1294     RTC->WPR = 0xCA;
00002a  4b12              LDR      r3,|L1.116|
00002c  20ca              MOVS     r0,#0xca
00002e  6018              STR      r0,[r3,#0]
;;;1295     RTC->WPR = 0x53;
000030  2053              MOVS     r0,#0x53
000032  6018              STR      r0,[r3,#0]
;;;1296   
;;;1297     /* Configure the Alarm state */
;;;1298     if (NewState != DISABLE)
;;;1299     {
;;;1300       RTC->CR |= (uint32_t)RTC_Alarm;
000034  480f              LDR      r0,|L1.116|
000036  381c              SUBS     r0,r0,#0x1c
;;;1301   
;;;1302       status = SUCCESS;    
;;;1303     }
;;;1304     else
;;;1305     { 
;;;1306       /* Disable the Alarm in RTC_CR register */
;;;1307       RTC->CR &= (uint32_t)~RTC_Alarm;
000038  6801              LDR      r1,[r0,#0]
00003a  b115              CBZ      r5,|L1.66|
00003c  4321              ORRS     r1,r1,r4              ;1300
00003e  6001              STR      r1,[r0,#0]            ;1300
000040  e012              B        |L1.104|
                  |L1.66|
000042  43a1              BICS     r1,r1,r4
000044  6001              STR      r1,[r0,#0]
;;;1308      
;;;1309       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1310       do
;;;1311       {
;;;1312         alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
000046  490b              LDR      r1,|L1.116|
000048  3918              SUBS     r1,r1,#0x18
;;;1313         alarmcounter++;  
;;;1314       } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
00004a  138d              ASRS     r5,r1,#14
                  |L1.76|
00004c  6808              LDR      r0,[r1,#0]            ;1312
00004e  9a00              LDR      r2,[sp,#0]            ;1313
000050  ea002014          AND      r0,r0,r4,LSR #8       ;1312
000054  1c52              ADDS     r2,r2,#1              ;1313
000056  9200              STR      r2,[sp,#0]
000058  42aa              CMP      r2,r5
00005a  d001              BEQ      |L1.96|
00005c  2800              CMP      r0,#0
00005e  d0f5              BEQ      |L1.76|
                  |L1.96|
;;;1315       
;;;1316       if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
000060  6808              LDR      r0,[r1,#0]
000062  ea102014          ANDS     r0,r0,r4,LSR #8
000066  d000              BEQ      |L1.106|
                  |L1.104|
;;;1317       {
;;;1318         status = ERROR;
;;;1319       } 
;;;1320       else
;;;1321       {
;;;1322         status = SUCCESS;
000068  2001              MOVS     r0,#1
                  |L1.106|
;;;1323       }        
;;;1324     } 
;;;1325   
;;;1326     /* Enable the write protection for RTC registers */
;;;1327     RTC->WPR = 0xFF; 
00006a  21ff              MOVS     r1,#0xff
00006c  6019              STR      r1,[r3,#0]
;;;1328     
;;;1329     return status;
;;;1330   }
00006e  bd38              POP      {r3-r5,pc}
;;;1331   
                          ENDP

                  |L1.112|
                          DCD      ||.conststring||
                  |L1.116|
                          DCD      0x40002824

                          AREA ||i.RTC_AlarmStructInit||, CODE, READONLY, ALIGN=1

                  RTC_AlarmStructInit PROC
;;;1198     */
;;;1199   void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  2100              MOVS     r1,#0
;;;1200   {
;;;1201     /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;1202     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;1203     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;1204     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;1205     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
000008  7081              STRB     r1,[r0,#2]
;;;1206   
;;;1207     /* Alarm Date Settings : Date = 1st day of the month */
;;;1208     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
;;;1209     RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
00000a  2201              MOVS     r2,#1
00000c  6081              STR      r1,[r0,#8]
00000e  7302              STRB     r2,[r0,#0xc]
;;;1210   
;;;1211     /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;1212     RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
000010  6041              STR      r1,[r0,#4]
;;;1213   }
000012  4770              BX       lr
;;;1214   
                          ENDP


                          AREA ||i.RTC_AlarmSubSecondConfig||, CODE, READONLY, ALIGN=2

                  RTC_AlarmSubSecondConfig PROC
;;;1376     */
;;;1377   void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1378   {
;;;1379     uint32_t tmpreg = 0;
;;;1380   
;;;1381     /* Check the parameters */
;;;1382     assert_param(IS_RTC_ALARM(RTC_Alarm));
000004  f44f7780          MOV      r7,#0x100
000008  4614              MOV      r4,r2                 ;1378
00000a  460d              MOV      r5,r1                 ;1378
00000c  4606              MOV      r6,r0                 ;1378
00000e  42b8              CMP      r0,r7
000010  d007              BEQ      |L3.34|
000012  f5b67f00          CMP      r6,#0x200
000016  d004              BEQ      |L3.34|
000018  f2405166          MOV      r1,#0x566
00001c  4827              LDR      r0,|L3.188|
00001e  f7fffffe          BL       assert_failed
                  |L3.34|
;;;1383     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
000022  f5b54f00          CMP      r5,#0x8000
000026  d304              BCC      |L3.50|
000028  f2405167          MOV      r1,#0x567
00002c  4823              LDR      r0,|L3.188|
00002e  f7fffffe          BL       assert_failed
                  |L3.50|
;;;1384     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
000032  b38c              CBZ      r4,|L3.152|
000034  f1b47f80          CMP      r4,#0x1000000
000038  d02e              BEQ      |L3.152|
00003a  f1b47f00          CMP      r4,#0x2000000
00003e  d02b              BEQ      |L3.152|
000040  f1b47f40          CMP      r4,#0x3000000
000044  d028              BEQ      |L3.152|
000046  f1b46f80          CMP      r4,#0x4000000
00004a  d025              BEQ      |L3.152|
00004c  f1b46fa0          CMP      r4,#0x5000000
000050  d022              BEQ      |L3.152|
000052  f1b46fc0          CMP      r4,#0x6000000
000056  d01f              BEQ      |L3.152|
000058  f1b46fe0          CMP      r4,#0x7000000
00005c  d01c              BEQ      |L3.152|
00005e  f1b46f00          CMP      r4,#0x8000000
000062  d019              BEQ      |L3.152|
000064  f1b46f10          CMP      r4,#0x9000000
000068  d016              BEQ      |L3.152|
00006a  f1b46f20          CMP      r4,#0xa000000
00006e  d013              BEQ      |L3.152|
000070  f1b46f30          CMP      r4,#0xb000000
000074  d010              BEQ      |L3.152|
000076  f1b46f40          CMP      r4,#0xc000000
00007a  d00d              BEQ      |L3.152|
00007c  f1b46f50          CMP      r4,#0xd000000
000080  d00a              BEQ      |L3.152|
000082  f1b46f60          CMP      r4,#0xe000000
000086  d007              BEQ      |L3.152|
000088  f1b46f70          CMP      r4,#0xf000000
00008c  d004              BEQ      |L3.152|
00008e  f44f61ad          MOV      r1,#0x568
000092  480a              LDR      r0,|L3.188|
000094  f7fffffe          BL       assert_failed
                  |L3.152|
;;;1385     
;;;1386     /* Disable the write protection for RTC registers */
;;;1387     RTC->WPR = 0xCA;
000098  4809              LDR      r0,|L3.192|
00009a  21ca              MOVS     r1,#0xca
00009c  6001              STR      r1,[r0,#0]
;;;1388     RTC->WPR = 0x53;
00009e  2153              MOVS     r1,#0x53
0000a0  6001              STR      r1,[r0,#0]
;;;1389     
;;;1390     /* Configure the Alarm A or Alarm B SubSecond registers */
;;;1391     tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
0000a2  4325              ORRS     r5,r5,r4
;;;1392     
;;;1393     if (RTC_Alarm == RTC_Alarm_A)
0000a4  42be              CMP      r6,r7
0000a6  d102              BNE      |L3.174|
;;;1394     {
;;;1395       /* Configure the AlarmA SubSecond register */
;;;1396       RTC->ALRMASSR = tmpreg;
0000a8  4905              LDR      r1,|L3.192|
0000aa  3120              ADDS     r1,r1,#0x20
0000ac  e001              B        |L3.178|
                  |L3.174|
;;;1397     }
;;;1398     else
;;;1399     {
;;;1400       /* Configure the Alarm B SubSecond register */
;;;1401       RTC->ALRMBSSR = tmpreg;
0000ae  4904              LDR      r1,|L3.192|
0000b0  3124              ADDS     r1,r1,#0x24
                  |L3.178|
0000b2  600d              STR      r5,[r1,#0]
;;;1402     }
;;;1403   
;;;1404     /* Enable the write protection for RTC registers */
;;;1405     RTC->WPR = 0xFF;
0000b4  21ff              MOVS     r1,#0xff
0000b6  6001              STR      r1,[r0,#0]
;;;1406   
;;;1407   }
0000b8  e8bd81f0          POP      {r4-r8,pc}
;;;1408   
                          ENDP

                  |L3.188|
                          DCD      ||.conststring||
                  |L3.192|
                          DCD      0x40002824

                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;2712     */
;;;2713   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  0901              LSRS     r1,r0,#4
;;;2714   {
;;;2715     uint8_t tmp = 0;
;;;2716     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000002  eb010181          ADD      r1,r1,r1,LSL #2
;;;2717     return (tmp + (Value & (uint8_t)0x0F));
000006  f000000f          AND      r0,r0,#0xf
00000a  eb000041          ADD      r0,r0,r1,LSL #1
00000e  b2c0              UXTB     r0,r0
;;;2718   }
000010  4770              BX       lr
;;;2719   
                          ENDP


                          AREA ||i.RTC_BypassShadowCmd||, CODE, READONLY, ALIGN=2

                  RTC_BypassShadowCmd PROC
;;;697    */
;;;698    void RTC_BypassShadowCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;699    {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L5.20|
;;;700      /* Check the parameters */
;;;701      assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L5.20|
00000a  f24021bd          MOV      r1,#0x2bd
00000e  480a              LDR      r0,|L5.56|
000010  f7fffffe          BL       assert_failed
                  |L5.20|
;;;702    
;;;703      /* Disable the write protection for RTC registers */
;;;704      RTC->WPR = 0xCA;
000014  4909              LDR      r1,|L5.60|
000016  20ca              MOVS     r0,#0xca
000018  6008              STR      r0,[r1,#0]
;;;705      RTC->WPR = 0x53;
00001a  2053              MOVS     r0,#0x53
00001c  6008              STR      r0,[r1,#0]
;;;706      
;;;707      if (NewState != DISABLE)
;;;708      {
;;;709        /* Set the BYPSHAD bit */
;;;710        RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
00001e  4807              LDR      r0,|L5.60|
000020  381c              SUBS     r0,r0,#0x1c
;;;711      }
;;;712      else
;;;713      {
;;;714        /* Reset the BYPSHAD bit */
;;;715        RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
000022  6802              LDR      r2,[r0,#0]
000024  b114              CBZ      r4,|L5.44|
000026  f0420220          ORR      r2,r2,#0x20           ;710
00002a  e001              B        |L5.48|
                  |L5.44|
00002c  f00202df          AND      r2,r2,#0xdf
                  |L5.48|
000030  6002              STR      r2,[r0,#0]
;;;716      }
;;;717    
;;;718      /* Enable the write protection for RTC registers */
;;;719      RTC->WPR = 0xFF;
000032  20ff              MOVS     r0,#0xff
000034  6008              STR      r0,[r1,#0]
;;;720    }
000036  bd10              POP      {r4,pc}
;;;721    
                          ENDP

                  |L5.56|
                          DCD      ||.conststring||
                  |L5.60|
                          DCD      0x40002824

                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;2694     */
;;;2695   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  2100              MOVS     r1,#0
;;;2696   {
000002  e003              B        |L6.12|
                  |L6.4|
000004  1c49              ADDS     r1,r1,#1
;;;2697     uint8_t bcdhigh = 0;
;;;2698     
;;;2699     while (Value >= 10)
;;;2700     {
;;;2701       bcdhigh++;
000006  380a              SUBS     r0,r0,#0xa
000008  b2c9              UXTB     r1,r1
;;;2702       Value -= 10;
00000a  b2c0              UXTB     r0,r0
                  |L6.12|
00000c  280a              CMP      r0,#0xa               ;2699
00000e  d2f9              BCS      |L6.4|
;;;2703     }
;;;2704     
;;;2705     return  ((uint8_t)(bcdhigh << 4) | Value);
000010  0709              LSLS     r1,r1,#28
000012  ea406011          ORR      r0,r0,r1,LSR #24
;;;2706   }
000016  4770              BX       lr
;;;2707   
                          ENDP


                          AREA ||i.RTC_CalibOutputCmd||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputCmd PROC
;;;1810     */
;;;1811   void RTC_CalibOutputCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1812   {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L7.20|
;;;1813     /* Check the parameters */
;;;1814     assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L7.20|
00000a  f2407116          MOV      r1,#0x716
00000e  480a              LDR      r0,|L7.56|
000010  f7fffffe          BL       assert_failed
                  |L7.20|
;;;1815     
;;;1816     /* Disable the write protection for RTC registers */
;;;1817     RTC->WPR = 0xCA;
000014  4909              LDR      r1,|L7.60|
000016  20ca              MOVS     r0,#0xca
000018  6008              STR      r0,[r1,#0]
;;;1818     RTC->WPR = 0x53;
00001a  2053              MOVS     r0,#0x53
00001c  6008              STR      r0,[r1,#0]
;;;1819     
;;;1820     if (NewState != DISABLE)
;;;1821     {
;;;1822       /* Enable the RTC clock output */
;;;1823       RTC->CR |= (uint32_t)RTC_CR_COE;
00001e  4807              LDR      r0,|L7.60|
000020  381c              SUBS     r0,r0,#0x1c
;;;1824     }
;;;1825     else
;;;1826     { 
;;;1827       /* Disable the RTC clock output */
;;;1828       RTC->CR &= (uint32_t)~RTC_CR_COE;
000022  6802              LDR      r2,[r0,#0]
000024  b114              CBZ      r4,|L7.44|
000026  f4420200          ORR      r2,r2,#0x800000       ;1823
00002a  e001              B        |L7.48|
                  |L7.44|
00002c  f4220200          BIC      r2,r2,#0x800000
                  |L7.48|
000030  6002              STR      r2,[r0,#0]
;;;1829     }
;;;1830     
;;;1831     /* Enable the write protection for RTC registers */
;;;1832     RTC->WPR = 0xFF; 
000032  20ff              MOVS     r0,#0xff
000034  6008              STR      r0,[r1,#0]
;;;1833   }
000036  bd10              POP      {r4,pc}
;;;1834   
                          ENDP

                  |L7.56|
                          DCD      ||.conststring||
                  |L7.60|
                          DCD      0x40002824

                          AREA ||i.RTC_CalibOutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputConfig PROC
;;;1842   */
;;;1843   void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
000000  b510              PUSH     {r4,lr}
;;;1844   {
000002  0004              MOVS     r4,r0
000004  d007              BEQ      |L8.22|
;;;1845     /* Check the parameters */
;;;1846     assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
000006  f5b42f00          CMP      r4,#0x80000
00000a  d004              BEQ      |L8.22|
00000c  f2407136          MOV      r1,#0x736
000010  4809              LDR      r0,|L8.56|
000012  f7fffffe          BL       assert_failed
                  |L8.22|
;;;1847   
;;;1848     /* Disable the write protection for RTC registers */
;;;1849     RTC->WPR = 0xCA;
000016  4909              LDR      r1,|L8.60|
000018  20ca              MOVS     r0,#0xca
00001a  6008              STR      r0,[r1,#0]
;;;1850     RTC->WPR = 0x53;
00001c  2053              MOVS     r0,#0x53
00001e  6008              STR      r0,[r1,#0]
;;;1851     
;;;1852     /*clear flags before config*/
;;;1853     RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
000020  4806              LDR      r0,|L8.60|
000022  381c              SUBS     r0,r0,#0x1c
000024  6802              LDR      r2,[r0,#0]
000026  f4222200          BIC      r2,r2,#0x80000
00002a  6002              STR      r2,[r0,#0]
;;;1854   
;;;1855     /* Configure the RTC_CR register */
;;;1856     RTC->CR |= (uint32_t)RTC_CalibOutput;
00002c  6802              LDR      r2,[r0,#0]
00002e  4322              ORRS     r2,r2,r4
000030  6002              STR      r2,[r0,#0]
;;;1857   
;;;1858     /* Enable the write protection for RTC registers */
;;;1859     RTC->WPR = 0xFF;
000032  20ff              MOVS     r0,#0xff
000034  6008              STR      r0,[r1,#0]
;;;1860   }
000036  bd10              POP      {r4,pc}
;;;1861   
                          ENDP

                  |L8.56|
                          DCD      ||.conststring||
                  |L8.60|
                          DCD      0x40002824

                          AREA ||i.RTC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RTC_ClearFlag PROC
;;;2611     */
;;;2612   void RTC_ClearFlag(uint32_t RTC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;2613   {
000002  0004              MOVS     r4,r0
000004  d004              BEQ      |L9.16|
;;;2614     /* Check the parameters */
;;;2615     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
000006  f64f7020          MOV      r0,#0xff20
00000a  ea340000          BICS     r0,r4,r0
00000e  d004              BEQ      |L9.26|
                  |L9.16|
000010  f6402137          MOV      r1,#0xa37
000014  4806              LDR      r0,|L9.48|
000016  f7fffffe          BL       assert_failed
                  |L9.26|
;;;2616   
;;;2617     /* Clear the Flags in the RTC_ISR register */
;;;2618     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
00001a  b2a0              UXTH     r0,r4
00001c  f0400080          ORR      r0,r0,#0x80
000020  43c1              MVNS     r1,r0
000022  4804              LDR      r0,|L9.52|
000024  6802              LDR      r2,[r0,#0]
000026  f0020280          AND      r2,r2,#0x80
00002a  4311              ORRS     r1,r1,r2
00002c  6001              STR      r1,[r0,#0]
;;;2619   }
00002e  bd10              POP      {r4,pc}
;;;2620   
                          ENDP

                  |L9.48|
                          DCD      ||.conststring||
                  |L9.52|
                          DCD      0x4000280c

                          AREA ||i.RTC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RTC_ClearITPendingBit PROC
;;;2671     */
;;;2672   void RTC_ClearITPendingBit(uint32_t RTC_IT)
000000  b510              PUSH     {r4,lr}
;;;2673   {
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L10.12|
;;;2674     uint32_t tmpreg = 0;
;;;2675   
;;;2676     /* Check the parameters */
;;;2677     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
000006  f434303c          BICS     r0,r4,#0x2f000
00000a  d004              BEQ      |L10.22|
                  |L10.12|
00000c  f6402175          MOV      r1,#0xa75
000010  4807              LDR      r0,|L10.48|
000012  f7fffffe          BL       assert_failed
                  |L10.22|
;;;2678   
;;;2679     /* Get the RTC_ISR Interrupt pending bits mask */
;;;2680     tmpreg = (uint32_t)(RTC_IT >> 4);
;;;2681   
;;;2682     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;2683     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
000016  f3c4100f          UBFX     r0,r4,#4,#16
00001a  f0400080          ORR      r0,r0,#0x80
00001e  43c1              MVNS     r1,r0
000020  4804              LDR      r0,|L10.52|
000022  6802              LDR      r2,[r0,#0]
000024  f0020280          AND      r2,r2,#0x80
000028  4311              ORRS     r1,r1,r2
00002a  6001              STR      r1,[r0,#0]
;;;2684   }
00002c  bd10              POP      {r4,pc}
;;;2685   
                          ENDP

00002e  0000              DCW      0x0000
                  |L10.48|
                          DCD      ||.conststring||
                  |L10.52|
                          DCD      0x4000280c

                          AREA ||i.RTC_CoarseCalibCmd||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibCmd PROC
;;;1764     */
;;;1765   ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1766   {
000002  0004              MOVS     r4,r0
;;;1767     ErrorStatus status = ERROR;
000004  f04f0500          MOV      r5,#0
000008  d006              BEQ      |L11.24|
;;;1768     
;;;1769     /* Check the parameters */
;;;1770     assert_param(IS_FUNCTIONAL_STATE(NewState));
00000a  2c01              CMP      r4,#1
00000c  d004              BEQ      |L11.24|
00000e  f24061ea          MOV      r1,#0x6ea
000012  480e              LDR      r0,|L11.76|
000014  f7fffffe          BL       assert_failed
                  |L11.24|
;;;1771   
;;;1772     /* Disable the write protection for RTC registers */
;;;1773     RTC->WPR = 0xCA;
000018  4e0d              LDR      r6,|L11.80|
00001a  20ca              MOVS     r0,#0xca
00001c  6030              STR      r0,[r6,#0]
;;;1774     RTC->WPR = 0x53;
00001e  2053              MOVS     r0,#0x53
000020  6030              STR      r0,[r6,#0]
;;;1775     
;;;1776     /* Set Initialization mode */
;;;1777     if (RTC_EnterInitMode() == ERROR)
000022  f7fffffe          BL       RTC_EnterInitMode
000026  b160              CBZ      r0,|L11.66|
;;;1778     {
;;;1779       status =  ERROR;
;;;1780     }
;;;1781     else
;;;1782     {
;;;1783       if (NewState != DISABLE)
;;;1784       {
;;;1785         /* Enable the Coarse Calibration */
;;;1786         RTC->CR |= (uint32_t)RTC_CR_DCE;
000028  4809              LDR      r0,|L11.80|
00002a  381c              SUBS     r0,r0,#0x1c
;;;1787       }
;;;1788       else
;;;1789       { 
;;;1790         /* Disable the Coarse Calibration */
;;;1791         RTC->CR &= (uint32_t)~RTC_CR_DCE;
00002c  6801              LDR      r1,[r0,#0]
00002e  b114              CBZ      r4,|L11.54|
000030  f0410180          ORR      r1,r1,#0x80           ;1786
000034  e001              B        |L11.58|
                  |L11.54|
000036  f0210180          BIC      r1,r1,#0x80
                  |L11.58|
00003a  6001              STR      r1,[r0,#0]
;;;1792       }
;;;1793       /* Exit Initialization mode */
;;;1794       RTC_ExitInitMode();
00003c  f7fffffe          BL       RTC_ExitInitMode
;;;1795       
;;;1796       status = SUCCESS;
000040  2501              MOVS     r5,#1
                  |L11.66|
;;;1797     } 
;;;1798     
;;;1799     /* Enable the write protection for RTC registers */
;;;1800     RTC->WPR = 0xFF; 
000042  20ff              MOVS     r0,#0xff
000044  6030              STR      r0,[r6,#0]
;;;1801     
;;;1802     return status;
000046  4628              MOV      r0,r5
;;;1803   }
000048  bd70              POP      {r4-r6,pc}
;;;1804   
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      ||.conststring||
                  |L11.80|
                          DCD      0x40002824

                          AREA ||i.RTC_CoarseCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibConfig PROC
;;;1723     */
;;;1724   ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1725   {
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
;;;1726     ErrorStatus status = ERROR;
000008  f04f0500          MOV      r5,#0
00000c  d006              BEQ      |L12.28|
;;;1727      
;;;1728     /* Check the parameters */
;;;1729     assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
00000e  2c80              CMP      r4,#0x80
000010  d004              BEQ      |L12.28|
000012  f24061c1          MOV      r1,#0x6c1
000016  480f              LDR      r0,|L12.84|
000018  f7fffffe          BL       assert_failed
                  |L12.28|
;;;1730     assert_param(IS_RTC_CALIB_VALUE(Value)); 
00001c  2e20              CMP      r6,#0x20
00001e  d304              BCC      |L12.42|
000020  f24061c2          MOV      r1,#0x6c2
000024  480b              LDR      r0,|L12.84|
000026  f7fffffe          BL       assert_failed
                  |L12.42|
;;;1731   
;;;1732     /* Disable the write protection for RTC registers */
;;;1733     RTC->WPR = 0xCA;
00002a  4f0b              LDR      r7,|L12.88|
00002c  20ca              MOVS     r0,#0xca
00002e  6038              STR      r0,[r7,#0]
;;;1734     RTC->WPR = 0x53;
000030  2053              MOVS     r0,#0x53
000032  6038              STR      r0,[r7,#0]
;;;1735   
;;;1736     /* Set Initialization mode */
;;;1737     if (RTC_EnterInitMode() == ERROR)
000034  f7fffffe          BL       RTC_EnterInitMode
000038  b130              CBZ      r0,|L12.72|
;;;1738     {
;;;1739       status = ERROR;
;;;1740     } 
;;;1741     else
;;;1742     {
;;;1743       /* Set the coarse calibration value */
;;;1744       RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
00003a  4807              LDR      r0,|L12.88|
00003c  4334              ORRS     r4,r4,r6
00003e  380c              SUBS     r0,r0,#0xc
000040  6004              STR      r4,[r0,#0]
;;;1745       /* Exit Initialization mode */
;;;1746       RTC_ExitInitMode();
000042  f7fffffe          BL       RTC_ExitInitMode
;;;1747       
;;;1748       status = SUCCESS;
000046  2501              MOVS     r5,#1
                  |L12.72|
;;;1749     } 
;;;1750   
;;;1751     /* Enable the write protection for RTC registers */
;;;1752     RTC->WPR = 0xFF; 
000048  20ff              MOVS     r0,#0xff
00004a  6038              STR      r0,[r7,#0]
;;;1753     
;;;1754     return status;
00004c  4628              MOV      r0,r5
;;;1755   }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;1756   
                          ENDP

000052  0000              DCW      0x0000
                  |L12.84|
                          DCD      ||.conststring||
                  |L12.88|
                          DCD      0x40002824

                          AREA ||i.RTC_DateStructInit||, CODE, READONLY, ALIGN=1

                  RTC_DateStructInit PROC
;;;1008     */
;;;1009   void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
000000  2101              MOVS     r1,#1
;;;1010   {
;;;1011     /* Monday, January 01 xx00 */
;;;1012     RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000002  7001              STRB     r1,[r0,#0]
;;;1013     RTC_DateStruct->RTC_Date = 1;
000004  7081              STRB     r1,[r0,#2]
;;;1014     RTC_DateStruct->RTC_Month = RTC_Month_January;
000006  7041              STRB     r1,[r0,#1]
;;;1015     RTC_DateStruct->RTC_Year = 0;
000008  2100              MOVS     r1,#0
00000a  70c1              STRB     r1,[r0,#3]
;;;1016   }
00000c  4770              BX       lr
;;;1017   
                          ENDP


                          AREA ||i.RTC_DayLightSavingConfig||, CODE, READONLY, ALIGN=2

                  RTC_DayLightSavingConfig PROC
;;;1603     */
;;;1604   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
000000  b570              PUSH     {r4-r6,lr}
;;;1605   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1606     /* Check the parameters */
;;;1607     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
000006  f5b03f00          CMP      r0,#0x20000
00000a  d007              BEQ      |L14.28|
00000c  f5b43f80          CMP      r4,#0x10000
000010  d004              BEQ      |L14.28|
000012  f2406147          MOV      r1,#0x647
000016  480f              LDR      r0,|L14.84|
000018  f7fffffe          BL       assert_failed
                  |L14.28|
;;;1608     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
00001c  b13d              CBZ      r5,|L14.46|
00001e  f5b52f80          CMP      r5,#0x40000
000022  d004              BEQ      |L14.46|
000024  f44f61c9          MOV      r1,#0x648
000028  480a              LDR      r0,|L14.84|
00002a  f7fffffe          BL       assert_failed
                  |L14.46|
;;;1609   
;;;1610     /* Disable the write protection for RTC registers */
;;;1611     RTC->WPR = 0xCA;
00002e  490a              LDR      r1,|L14.88|
000030  20ca              MOVS     r0,#0xca
000032  6008              STR      r0,[r1,#0]
;;;1612     RTC->WPR = 0x53;
000034  2053              MOVS     r0,#0x53
000036  6008              STR      r0,[r1,#0]
;;;1613   
;;;1614     /* Clear the bits to be configured */
;;;1615     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
000038  4807              LDR      r0,|L14.88|
00003a  381c              SUBS     r0,r0,#0x1c
00003c  6802              LDR      r2,[r0,#0]
00003e  f4222280          BIC      r2,r2,#0x40000
000042  6002              STR      r2,[r0,#0]
;;;1616   
;;;1617     /* Configure the RTC_CR register */
;;;1618     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
000044  6802              LDR      r2,[r0,#0]
000046  432c              ORRS     r4,r4,r5
000048  4322              ORRS     r2,r2,r4
00004a  6002              STR      r2,[r0,#0]
;;;1619   
;;;1620     /* Enable the write protection for RTC registers */
;;;1621     RTC->WPR = 0xFF; 
00004c  20ff              MOVS     r0,#0xff
00004e  6008              STR      r0,[r1,#0]
;;;1622   }
000050  bd70              POP      {r4-r6,pc}
;;;1623   
                          ENDP

000052  0000              DCW      0x0000
                  |L14.84|
                          DCD      ||.conststring||
                  |L14.88|
                          DCD      0x40002824

                          AREA ||i.RTC_DeInit||, CODE, READONLY, ALIGN=2

                  RTC_DeInit PROC
;;;366      */
;;;367    ErrorStatus RTC_DeInit(void)
000000  b578              PUSH     {r3-r6,lr}
;;;368    {
;;;369      __IO uint32_t wutcounter = 0x00;
000002  2500              MOVS     r5,#0
;;;370      uint32_t wutwfstatus = 0x00;
;;;371      ErrorStatus status = ERROR;
;;;372      
;;;373      /* Disable the write protection for RTC registers */
;;;374      RTC->WPR = 0xCA;
000004  4e22              LDR      r6,|L15.144|
000006  20ca              MOVS     r0,#0xca
000008  9500              STR      r5,[sp,#0]
00000a  462c              MOV      r4,r5                 ;371
00000c  6030              STR      r0,[r6,#0]
;;;375      RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6030              STR      r0,[r6,#0]
;;;376    
;;;377      /* Set Initialization mode */
;;;378      if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  b3a0              CBZ      r0,|L15.130|
;;;379      {
;;;380        status = ERROR;
;;;381      }  
;;;382      else
;;;383      {
;;;384        /* Reset TR, DR and CR registers */
;;;385        RTC->TR = (uint32_t)0x00000000;
000018  481d              LDR      r0,|L15.144|
00001a  3824              SUBS     r0,r0,#0x24
00001c  6005              STR      r5,[r0,#0]
;;;386        RTC->DR = (uint32_t)0x00002101;
00001e  491c              LDR      r1,|L15.144|
000020  f2421001          MOV      r0,#0x2101
000024  3920              SUBS     r1,r1,#0x20
000026  6008              STR      r0,[r1,#0]
;;;387        /* Reset All CR bits except CR[2:0] */
;;;388        RTC->CR &= (uint32_t)0x00000007;
000028  1d0b              ADDS     r3,r1,#4
00002a  6818              LDR      r0,[r3,#0]
00002c  f0000007          AND      r0,r0,#7
000030  6018              STR      r0,[r3,#0]
;;;389      
;;;390        /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;391        do
;;;392        {
;;;393          wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
;;;394          wutcounter++;  
;;;395        } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
000032  138c              ASRS     r4,r1,#14
000034  1d19              ADDS     r1,r3,#4              ;393
                  |L15.54|
000036  6808              LDR      r0,[r1,#0]            ;393
000038  9a00              LDR      r2,[sp,#0]            ;394
00003a  f0000004          AND      r0,r0,#4              ;393
00003e  1c52              ADDS     r2,r2,#1              ;394
000040  9200              STR      r2,[sp,#0]
000042  42a2              CMP      r2,r4
000044  d001              BEQ      |L15.74|
000046  2800              CMP      r0,#0
000048  d0f5              BEQ      |L15.54|
                  |L15.74|
;;;396        
;;;397        if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
00004a  6808              LDR      r0,[r1,#0]
00004c  0740              LSLS     r0,r0,#29
00004e  d51c              BPL      |L15.138|
;;;398        {
;;;399          status = ERROR;
;;;400        }
;;;401        else
;;;402        {
;;;403          /* Reset all RTC CR register bits */
;;;404          RTC->CR &= (uint32_t)0x00000000;
000050  6818              LDR      r0,[r3,#0]
000052  601d              STR      r5,[r3,#0]
;;;405          RTC->WUTR = (uint32_t)0x0000FFFF;
000054  4a0e              LDR      r2,|L15.144|
000056  f64f70ff          MOV      r0,#0xffff
00005a  3a10              SUBS     r2,r2,#0x10
00005c  6010              STR      r0,[r2,#0]
;;;406          RTC->PRER = (uint32_t)0x007F00FF;
00005e  1f12              SUBS     r2,r2,#4
000060  480c              LDR      r0,|L15.148|
000062  6010              STR      r0,[r2,#0]
;;;407          RTC->CALIBR = (uint32_t)0x00000000;
000064  480a              LDR      r0,|L15.144|
000066  380c              SUBS     r0,r0,#0xc
000068  6005              STR      r5,[r0,#0]
;;;408          RTC->ALRMAR = (uint32_t)0x00000000;        
00006a  1d00              ADDS     r0,r0,#4
00006c  6005              STR      r5,[r0,#0]
;;;409          RTC->ALRMBR = (uint32_t)0x00000000;
00006e  1d00              ADDS     r0,r0,#4
000070  6005              STR      r5,[r0,#0]
;;;410          
;;;411          /* Reset ISR register and exit initialization mode */
;;;412          RTC->ISR = (uint32_t)0x00000000;
000072  600d              STR      r5,[r1,#0]
;;;413          
;;;414          /* Reset Tamper and alternate functions configuration register */
;;;415          RTC->TAFCR = 0x00000000;
000074  4806              LDR      r0,|L15.144|
000076  301c              ADDS     r0,r0,#0x1c
000078  6005              STR      r5,[r0,#0]
;;;416      
;;;417          if(RTC_WaitForSynchro() == ERROR)
00007a  f7fffffe          BL       RTC_WaitForSynchro
00007e  b120              CBZ      r0,|L15.138|
;;;418          {
;;;419            status = ERROR;
;;;420          }
;;;421          else
;;;422          {
;;;423            status = SUCCESS;      
000080  2401              MOVS     r4,#1
                  |L15.130|
;;;424          }
;;;425        }
;;;426      }
;;;427      
;;;428      /* Enable the write protection for RTC registers */
;;;429      RTC->WPR = 0xFF;  
000082  20ff              MOVS     r0,#0xff
000084  6030              STR      r0,[r6,#0]
;;;430      
;;;431      return status;
000086  4620              MOV      r0,r4
;;;432    }
000088  bd78              POP      {r3-r6,pc}
                  |L15.138|
00008a  2400              MOVS     r4,#0                 ;419
00008c  e7f9              B        |L15.130|
;;;433    
                          ENDP

00008e  0000              DCW      0x0000
                  |L15.144|
                          DCD      0x40002824
                  |L15.148|
                          DCD      0x007f00ff

                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=2

                  RTC_EnterInitMode PROC
;;;539      */
;;;540    ErrorStatus RTC_EnterInitMode(void)
000000  b508              PUSH     {r3,lr}
;;;541    {
;;;542      __IO uint32_t initcounter = 0x00;
;;;543      ErrorStatus status = ERROR;
;;;544      uint32_t initstatus = 0x00;
;;;545         
;;;546      /* Check if the Initialization mode is set */
;;;547      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
000002  490d              LDR      r1,|L16.56|
000004  2000              MOVS     r0,#0                 ;542
000006  9000              STR      r0,[sp,#0]
000008  6808              LDR      r0,[r1,#0]
00000a  0640              LSLS     r0,r0,#25
00000c  d412              BMI      |L16.52|
;;;548      {
;;;549        /* Set the Initialization mode */
;;;550        RTC->ISR = (uint32_t)RTC_INIT_MASK;
00000e  f04f30ff          MOV      r0,#0xffffffff
000012  6008              STR      r0,[r1,#0]
;;;551        
;;;552        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;553        do
;;;554        {
;;;555          initstatus = RTC->ISR & RTC_ISR_INITF;
;;;556          initcounter++;  
;;;557        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
000014  138b              ASRS     r3,r1,#14
                  |L16.22|
000016  6808              LDR      r0,[r1,#0]            ;555
000018  9a00              LDR      r2,[sp,#0]            ;556
00001a  f0000040          AND      r0,r0,#0x40           ;555
00001e  1c52              ADDS     r2,r2,#1              ;556
000020  9200              STR      r2,[sp,#0]
000022  429a              CMP      r2,r3
000024  d001              BEQ      |L16.42|
000026  2800              CMP      r0,#0
000028  d0f5              BEQ      |L16.22|
                  |L16.42|
;;;558        
;;;559        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
00002a  6808              LDR      r0,[r1,#0]
00002c  0640              LSLS     r0,r0,#25
00002e  d401              BMI      |L16.52|
;;;560        {
;;;561          status = SUCCESS;
;;;562        }
;;;563        else
;;;564        {
;;;565          status = ERROR;
000030  2000              MOVS     r0,#0
;;;566        }        
;;;567      }
;;;568      else
;;;569      {
;;;570        status = SUCCESS;  
;;;571      } 
;;;572        
;;;573      return (status);  
;;;574    }
000032  bd08              POP      {r3,pc}
                  |L16.52|
000034  2001              MOVS     r0,#1                 ;570
000036  bd08              POP      {r3,pc}
;;;575    
                          ENDP

                  |L16.56|
                          DCD      0x4000280c

                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitInitMode PROC
;;;584      */
;;;585    void RTC_ExitInitMode(void)
000000  4802              LDR      r0,|L17.12|
;;;586    { 
;;;587      /* Exit Initialization mode */
;;;588      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
000002  6801              LDR      r1,[r0,#0]
000004  f0210180          BIC      r1,r1,#0x80
000008  6001              STR      r1,[r0,#0]
;;;589    }
00000a  4770              BX       lr
;;;590    
                          ENDP

                  |L17.12|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarm PROC
;;;1228     */
;;;1229   void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1230   {
000002  4614              MOV      r4,r2
000004  460e              MOV      r6,r1
000006  0005              MOVS     r5,r0
000008  d006              BEQ      |L18.24|
;;;1231     uint32_t tmpreg = 0;
;;;1232   
;;;1233     /* Check the parameters */
;;;1234     assert_param(IS_RTC_FORMAT(RTC_Format));
00000a  2d01              CMP      r5,#1
00000c  d004              BEQ      |L18.24|
00000e  f24041d2          MOV      r1,#0x4d2
000012  481d              LDR      r0,|L18.136|
000014  f7fffffe          BL       assert_failed
                  |L18.24|
;;;1235     assert_param(IS_RTC_ALARM(RTC_Alarm)); 
000018  f5b67f80          CMP      r6,#0x100
00001c  d031              BEQ      |L18.130|
00001e  f5b67f00          CMP      r6,#0x200
000022  d004              BEQ      |L18.46|
000024  f24041d3          MOV      r1,#0x4d3
000028  4817              LDR      r0,|L18.136|
00002a  f7fffffe          BL       assert_failed
                  |L18.46|
;;;1236   
;;;1237     /* Get the RTC_ALRMxR register */
;;;1238     if (RTC_Alarm == RTC_Alarm_A)
;;;1239     {
;;;1240       tmpreg = (uint32_t)(RTC->ALRMAR);
;;;1241     }
;;;1242     else
;;;1243     {
;;;1244       tmpreg = (uint32_t)(RTC->ALRMBR);
00002e  4817              LDR      r0,|L18.140|
                  |L18.48|
000030  6801              LDR      r1,[r0,#0]
;;;1245     }
;;;1246   
;;;1247     /* Fill the structure with the read parameters */
;;;1248     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
000032  f3c14005          UBFX     r0,r1,#16,#6
000036  7020              STRB     r0,[r4,#0]
;;;1249                                                        RTC_ALRMAR_HU)) >> 16);
;;;1250     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
000038  f3c12206          UBFX     r2,r1,#8,#7
00003c  7062              STRB     r2,[r4,#1]
;;;1251                                                        RTC_ALRMAR_MNU)) >> 8);
;;;1252     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
00003e  f001027f          AND      r2,r1,#0x7f
000042  70a2              STRB     r2,[r4,#2]
;;;1253                                                        RTC_ALRMAR_SU));
;;;1254     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
000044  2240              MOVS     r2,#0x40
000046  ea024211          AND      r2,r2,r1,LSR #16
00004a  70e2              STRB     r2,[r4,#3]
;;;1255     RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
00004c  f3c16205          UBFX     r2,r1,#24,#6
000050  7322              STRB     r2,[r4,#0xc]
;;;1256     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
000052  f0014280          AND      r2,r1,#0x40000000
;;;1257     RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
000056  f0013180          AND      r1,r1,#0x80808080
00005a  e9c41201          STRD     r1,r2,[r4,#4]
00005e  2d00              CMP      r5,#0
000060  d10e              BNE      |L18.128|
;;;1258   
;;;1259     if (RTC_Format == RTC_Format_BIN)
;;;1260     {
;;;1261       RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000062  f7fffffe          BL       RTC_Bcd2ToByte
000066  7020              STRB     r0,[r4,#0]
;;;1262                                                           RTC_AlarmTime.RTC_Hours);
;;;1263       RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000068  7860              LDRB     r0,[r4,#1]
00006a  f7fffffe          BL       RTC_Bcd2ToByte
00006e  7060              STRB     r0,[r4,#1]
;;;1264                                                           RTC_AlarmTime.RTC_Minutes);
;;;1265       RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000070  78a0              LDRB     r0,[r4,#2]
000072  f7fffffe          BL       RTC_Bcd2ToByte
000076  70a0              STRB     r0,[r4,#2]
;;;1266                                                           RTC_AlarmTime.RTC_Seconds);
;;;1267       RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000078  7b20              LDRB     r0,[r4,#0xc]
00007a  f7fffffe          BL       RTC_Bcd2ToByte
00007e  7320              STRB     r0,[r4,#0xc]
                  |L18.128|
;;;1268     }  
;;;1269   }
000080  bd70              POP      {r4-r6,pc}
                  |L18.130|
000082  4802              LDR      r0,|L18.140|
000084  1f00              SUBS     r0,r0,#4              ;1240
000086  e7d3              B        |L18.48|
;;;1270   
                          ENDP

                  |L18.136|
                          DCD      ||.conststring||
                  |L18.140|
                          DCD      0x40002820

                          AREA ||i.RTC_GetAlarmSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarmSubSecond PROC
;;;1417     */
;;;1418   uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
000000  f5b07f80          CMP      r0,#0x100
;;;1419   {
000004  d004              BEQ      |L19.16|
;;;1420     uint32_t tmpreg = 0;
;;;1421     
;;;1422     /* Get the RTC_ALRMxR register */
;;;1423     if (RTC_Alarm == RTC_Alarm_A)
;;;1424     {
;;;1425       tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
;;;1426     }
;;;1427     else
;;;1428     {
;;;1429       tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
000006  4804              LDR      r0,|L19.24|
                  |L19.8|
000008  6800              LDR      r0,[r0,#0]            ;1425
00000a  f3c0000e          UBFX     r0,r0,#0,#15          ;1425
;;;1430     } 
;;;1431     
;;;1432     return (tmpreg);
;;;1433   }
00000e  4770              BX       lr
                  |L19.16|
000010  4801              LDR      r0,|L19.24|
000012  1f00              SUBS     r0,r0,#4              ;1425
000014  e7f8              B        |L19.8|
;;;1434   
                          ENDP

000016  0000              DCW      0x0000
                  |L19.24|
                          DCD      0x40002848

                          AREA ||i.RTC_GetDate||, CODE, READONLY, ALIGN=2

                  RTC_GetDate PROC
;;;1027     */
;;;1028   void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1029   {
000002  460c              MOV      r4,r1
000004  0005              MOVS     r5,r0
000006  d006              BEQ      |L20.22|
;;;1030     uint32_t tmpreg = 0;
;;;1031   
;;;1032     /* Check the parameters */
;;;1033     assert_param(IS_RTC_FORMAT(RTC_Format));
000008  2d01              CMP      r5,#1
00000a  d004              BEQ      |L20.22|
00000c  f2404109          MOV      r1,#0x409
000010  480f              LDR      r0,|L20.80|
000012  f7fffffe          BL       assert_failed
                  |L20.22|
;;;1034     
;;;1035     /* Get the RTC_TR register */
;;;1036     tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
000016  480f              LDR      r0,|L20.84|
000018  6801              LDR      r1,[r0,#0]
00001a  480f              LDR      r0,|L20.88|
00001c  4001              ANDS     r1,r1,r0
;;;1037   
;;;1038     /* Fill the structure fields with the read parameters */
;;;1039     RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
00001e  0c08              LSRS     r0,r1,#16
000020  70e0              STRB     r0,[r4,#3]
;;;1040     RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000022  f3c12204          UBFX     r2,r1,#8,#5
000026  7062              STRB     r2,[r4,#1]
;;;1041     RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
000028  f001023f          AND      r2,r1,#0x3f
00002c  70a2              STRB     r2,[r4,#2]
;;;1042     RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
00002e  f3c13142          UBFX     r1,r1,#13,#3
000032  7021              STRB     r1,[r4,#0]
;;;1043   
;;;1044     /* Check the input parameters format */
;;;1045     if (RTC_Format == RTC_Format_BIN)
000034  2d00              CMP      r5,#0
000036  d10a              BNE      |L20.78|
;;;1046     {
;;;1047       /* Convert the structure parameters to Binary format */
;;;1048       RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
000038  f7fffffe          BL       RTC_Bcd2ToByte
00003c  70e0              STRB     r0,[r4,#3]
;;;1049       RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
00003e  7860              LDRB     r0,[r4,#1]
000040  f7fffffe          BL       RTC_Bcd2ToByte
000044  7060              STRB     r0,[r4,#1]
;;;1050       RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
000046  78a0              LDRB     r0,[r4,#2]
000048  f7fffffe          BL       RTC_Bcd2ToByte
00004c  70a0              STRB     r0,[r4,#2]
                  |L20.78|
;;;1051     }
;;;1052   }
00004e  bd70              POP      {r4-r6,pc}
;;;1053   
                          ENDP

                  |L20.80|
                          DCD      ||.conststring||
                  |L20.84|
                          DCD      0x40002804
                  |L20.88|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetFlagStatus PROC
;;;2575     */
;;;2576   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;2577   {
;;;2578     FlagStatus bitstatus = RESET;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;2577
;;;2579     uint32_t tmpreg = 0;
;;;2580     
;;;2581     /* Check the parameters */
;;;2582     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
000006  f5b05f80          CMP      r0,#0x1000
00000a  d022              BEQ      |L21.82|
00000c  f5b46f00          CMP      r4,#0x800
000010  d01f              BEQ      |L21.82|
000012  f5b46f80          CMP      r4,#0x400
000016  d01c              BEQ      |L21.82|
000018  f5b47f00          CMP      r4,#0x200
00001c  d019              BEQ      |L21.82|
00001e  f5b47f80          CMP      r4,#0x100
000022  d016              BEQ      |L21.82|
000024  2c40              CMP      r4,#0x40
000026  d014              BEQ      |L21.82|
000028  2c20              CMP      r4,#0x20
00002a  d012              BEQ      |L21.82|
00002c  2c04              CMP      r4,#4
00002e  d010              BEQ      |L21.82|
000030  2c02              CMP      r4,#2
000032  d00e              BEQ      |L21.82|
000034  2c01              CMP      r4,#1
000036  d00c              BEQ      |L21.82|
000038  f5b45f00          CMP      r4,#0x2000
00003c  d009              BEQ      |L21.82|
00003e  f5b43f80          CMP      r4,#0x10000
000042  d006              BEQ      |L21.82|
000044  2c08              CMP      r4,#8
000046  d004              BEQ      |L21.82|
000048  f6402116          MOV      r1,#0xa16
00004c  4806              LDR      r0,|L21.104|
00004e  f7fffffe          BL       assert_failed
                  |L21.82|
;;;2583     
;;;2584     /* Get all the flags */
;;;2585     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
000052  4806              LDR      r0,|L21.108|
000054  6800              LDR      r0,[r0,#0]
000056  f6437177          MOV      r1,#0x3f77
00005a  4008              ANDS     r0,r0,r1
;;;2586     
;;;2587     /* Return the status of the flag */
;;;2588     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
00005c  4220              TST      r0,r4
00005e  d000              BEQ      |L21.98|
;;;2589     {
;;;2590       bitstatus = SET;
000060  2501              MOVS     r5,#1
                  |L21.98|
;;;2591     }
;;;2592     else
;;;2593     {
;;;2594       bitstatus = RESET;
;;;2595     }
;;;2596     return bitstatus;
000062  4628              MOV      r0,r5
;;;2597   }
000064  bd70              POP      {r4-r6,pc}
;;;2598   
                          ENDP

000066  0000              DCW      0x0000
                  |L21.104|
                          DCD      ||.conststring||
                  |L21.108|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetITStatus PROC
;;;2631     */
;;;2632   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;2633   {
;;;2634     ITStatus bitstatus = RESET;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;2633
;;;2635     uint32_t tmpreg = 0, enablestatus = 0;
;;;2636    
;;;2637     /* Check the parameters */
;;;2638     assert_param(IS_RTC_GET_IT(RTC_IT));
000006  f5b04f00          CMP      r0,#0x8000
00000a  d010              BEQ      |L22.46|
00000c  f5b44f80          CMP      r4,#0x4000
000010  d00d              BEQ      |L22.46|
000012  f5b45f00          CMP      r4,#0x2000
000016  d00a              BEQ      |L22.46|
000018  f5b45f80          CMP      r4,#0x1000
00001c  d007              BEQ      |L22.46|
00001e  f5b43f00          CMP      r4,#0x20000
000022  d004              BEQ      |L22.46|
000024  f640214e          MOV      r1,#0xa4e
000028  480c              LDR      r0,|L22.92|
00002a  f7fffffe          BL       assert_failed
                  |L22.46|
;;;2639     
;;;2640     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;2641     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
00002e  480c              LDR      r0,|L22.96|
000030  6800              LDR      r0,[r0,#0]
000032  f0000104          AND      r1,r0,#4
;;;2642    
;;;2643     /* Get the Interrupt enable Status */
;;;2644     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
000036  480a              LDR      r0,|L22.96|
000038  3838              SUBS     r0,r0,#0x38
00003a  6800              LDR      r0,[r0,#0]
00003c  ea0131d4          AND      r1,r1,r4,LSR #15
000040  4020              ANDS     r0,r0,r4
000042  4308              ORRS     r0,r0,r1
;;;2645     
;;;2646     /* Get the Interrupt pending bit */
;;;2647     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
000044  4907              LDR      r1,|L22.100|
000046  6809              LDR      r1,[r1,#0]
000048  ea011114          AND      r1,r1,r4,LSR #4
;;;2648     
;;;2649     /* Get the status of the Interrupt */
;;;2650     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
00004c  d003              BEQ      |L22.86|
00004e  0408              LSLS     r0,r1,#16
000050  0c00              LSRS     r0,r0,#16
000052  d000              BEQ      |L22.86|
;;;2651     {
;;;2652       bitstatus = SET;
000054  2501              MOVS     r5,#1
                  |L22.86|
;;;2653     }
;;;2654     else
;;;2655     {
;;;2656       bitstatus = RESET;
;;;2657     }
;;;2658     return bitstatus;
000056  4628              MOV      r0,r5
;;;2659   }
000058  bd70              POP      {r4-r6,pc}
;;;2660   
                          ENDP

00005a  0000              DCW      0x0000
                  |L22.92|
                          DCD      ||.conststring||
                  |L22.96|
                          DCD      0x40002840
                  |L22.100|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetStoreOperation||, CODE, READONLY, ALIGN=2

                  RTC_GetStoreOperation PROC
;;;1630     */
;;;1631   uint32_t RTC_GetStoreOperation(void)
000000  4802              LDR      r0,|L23.12|
;;;1632   {
;;;1633     return (RTC->CR & RTC_CR_BCK);
000002  6800              LDR      r0,[r0,#0]
000004  f4002080          AND      r0,r0,#0x40000
;;;1634   }
000008  4770              BX       lr
;;;1635   
                          ENDP

00000a  0000              DCW      0x0000
                  |L23.12|
                          DCD      0x40002808

                          AREA ||i.RTC_GetSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetSubSecond PROC
;;;900      */
;;;901    uint32_t RTC_GetSubSecond(void)
000000  4802              LDR      r0,|L24.12|
;;;902    {
;;;903      uint32_t tmpreg = 0;
;;;904      
;;;905      /* Get subseconds values from the correspondent registers*/
;;;906      tmpreg = (uint32_t)(RTC->SSR);
000002  6800              LDR      r0,[r0,#0]
;;;907      
;;;908      /* Read DR register to unfroze calendar registers */
;;;909      (void) (RTC->DR);
000004  4901              LDR      r1,|L24.12|
000006  3924              SUBS     r1,r1,#0x24
000008  6809              LDR      r1,[r1,#0]
;;;910      
;;;911      return (tmpreg);
;;;912    }
00000a  4770              BX       lr
;;;913    
                          ENDP

                  |L24.12|
                          DCD      0x40002828

                          AREA ||i.RTC_GetTime||, CODE, READONLY, ALIGN=2

                  RTC_GetTime PROC
;;;867      */
;;;868    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;869    {
000002  460c              MOV      r4,r1
000004  0005              MOVS     r5,r0
000006  d006              BEQ      |L25.22|
;;;870      uint32_t tmpreg = 0;
;;;871    
;;;872      /* Check the parameters */
;;;873      assert_param(IS_RTC_FORMAT(RTC_Format));
000008  2d01              CMP      r5,#1
00000a  d004              BEQ      |L25.22|
00000c  f2403169          MOV      r1,#0x369
000010  4810              LDR      r0,|L25.84|
000012  f7fffffe          BL       assert_failed
                  |L25.22|
;;;874    
;;;875      /* Get the RTC_TR register */
;;;876      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
000016  4810              LDR      r0,|L25.88|
000018  6801              LDR      r1,[r0,#0]
00001a  4810              LDR      r0,|L25.92|
00001c  4001              ANDS     r1,r1,r0
;;;877      
;;;878      /* Fill the structure fields with the read parameters */
;;;879      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00001e  f3c14005          UBFX     r0,r1,#16,#6
000022  7020              STRB     r0,[r4,#0]
;;;880      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
000024  f3c12206          UBFX     r2,r1,#8,#7
000028  7062              STRB     r2,[r4,#1]
;;;881      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
00002a  f001027f          AND      r2,r1,#0x7f
00002e  70a2              STRB     r2,[r4,#2]
;;;882      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
000030  2240              MOVS     r2,#0x40
000032  ea024111          AND      r1,r2,r1,LSR #16
000036  70e1              STRB     r1,[r4,#3]
;;;883    
;;;884      /* Check the input parameters format */
;;;885      if (RTC_Format == RTC_Format_BIN)
000038  2d00              CMP      r5,#0
00003a  d10a              BNE      |L25.82|
;;;886      {
;;;887        /* Convert the structure parameters to Binary format */
;;;888        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00003c  f7fffffe          BL       RTC_Bcd2ToByte
000040  7020              STRB     r0,[r4,#0]
;;;889        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
000042  7860              LDRB     r0,[r4,#1]
000044  f7fffffe          BL       RTC_Bcd2ToByte
000048  7060              STRB     r0,[r4,#1]
;;;890        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
00004a  78a0              LDRB     r0,[r4,#2]
00004c  f7fffffe          BL       RTC_Bcd2ToByte
000050  70a0              STRB     r0,[r4,#2]
                  |L25.82|
;;;891      }
;;;892    }
000052  bd70              POP      {r4-r6,pc}
;;;893    
                          ENDP

                  |L25.84|
                          DCD      ||.conststring||
                  |L25.88|
                          DCD      0x40002800
                  |L25.92|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStamp PROC
;;;1998     */
;;;1999   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
000000  b570              PUSH     {r4-r6,lr}
;;;2000                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;2001   {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  0006              MOVS     r6,r0
000008  d006              BEQ      |L26.24|
;;;2002     uint32_t tmptime = 0, tmpdate = 0;
;;;2003   
;;;2004     /* Check the parameters */
;;;2005     assert_param(IS_RTC_FORMAT(RTC_Format));
00000a  2e01              CMP      r6,#1
00000c  d004              BEQ      |L26.24|
00000e  f24071d5          MOV      r1,#0x7d5
000012  4820              LDR      r0,|L26.148|
000014  f7fffffe          BL       assert_failed
                  |L26.24|
;;;2006   
;;;2007     /* Get the TimeStamp time and date registers values */
;;;2008     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
000018  481f              LDR      r0,|L26.152|
00001a  6801              LDR      r1,[r0,#0]
00001c  481f              LDR      r0,|L26.156|
00001e  4001              ANDS     r1,r1,r0
;;;2009     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
000020  481d              LDR      r0,|L26.152|
000022  1d00              ADDS     r0,r0,#4
000024  6800              LDR      r0,[r0,#0]
000026  f64f723f          MOV      r2,#0xff3f
00002a  4010              ANDS     r0,r0,r2
;;;2010   
;;;2011     /* Fill the Time structure fields with the read parameters */
;;;2012     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00002c  f3c14205          UBFX     r2,r1,#16,#6
000030  702a              STRB     r2,[r5,#0]
;;;2013     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
000032  f3c12206          UBFX     r2,r1,#8,#7
000036  706a              STRB     r2,[r5,#1]
;;;2014     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000038  f001027f          AND      r2,r1,#0x7f
00003c  70aa              STRB     r2,[r5,#2]
;;;2015     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
00003e  2240              MOVS     r2,#0x40
000040  ea024111          AND      r1,r2,r1,LSR #16
000044  70e9              STRB     r1,[r5,#3]
;;;2016   
;;;2017     /* Fill the Date structure fields with the read parameters */
;;;2018     RTC_StampDateStruct->RTC_Year = 0;
000046  2100              MOVS     r1,#0
000048  70e1              STRB     r1,[r4,#3]
;;;2019     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
00004a  f3c02104          UBFX     r1,r0,#8,#5
00004e  7061              STRB     r1,[r4,#1]
;;;2020     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
000050  f000013f          AND      r1,r0,#0x3f
000054  70a1              STRB     r1,[r4,#2]
;;;2021     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
000056  f3c03042          UBFX     r0,r0,#13,#3
00005a  7020              STRB     r0,[r4,#0]
;;;2022   
;;;2023     /* Check the input parameters format */
;;;2024     if (RTC_Format == RTC_Format_BIN)
00005c  2e00              CMP      r6,#0
00005e  d117              BNE      |L26.144|
;;;2025     {
;;;2026       /* Convert the Time structure parameters to Binary format */
;;;2027       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
000060  7828              LDRB     r0,[r5,#0]
000062  f7fffffe          BL       RTC_Bcd2ToByte
000066  7028              STRB     r0,[r5,#0]
;;;2028       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
000068  7868              LDRB     r0,[r5,#1]
00006a  f7fffffe          BL       RTC_Bcd2ToByte
00006e  7068              STRB     r0,[r5,#1]
;;;2029       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
000070  78a8              LDRB     r0,[r5,#2]
000072  f7fffffe          BL       RTC_Bcd2ToByte
000076  70a8              STRB     r0,[r5,#2]
;;;2030   
;;;2031       /* Convert the Date structure parameters to Binary format */
;;;2032       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
000078  7860              LDRB     r0,[r4,#1]
00007a  f7fffffe          BL       RTC_Bcd2ToByte
00007e  7060              STRB     r0,[r4,#1]
;;;2033       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
000080  78a0              LDRB     r0,[r4,#2]
000082  f7fffffe          BL       RTC_Bcd2ToByte
000086  70a0              STRB     r0,[r4,#2]
;;;2034       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
000088  7820              LDRB     r0,[r4,#0]
00008a  f7fffffe          BL       RTC_Bcd2ToByte
00008e  7020              STRB     r0,[r4,#0]
                  |L26.144|
;;;2035     }
;;;2036   }
000090  bd70              POP      {r4-r6,pc}
;;;2037   
                          ENDP

000092  0000              DCW      0x0000
                  |L26.148|
                          DCD      ||.conststring||
                  |L26.152|
                          DCD      0x40002830
                  |L26.156|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStampSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStampSubSecond PROC
;;;2042     */
;;;2043   uint32_t RTC_GetTimeStampSubSecond(void)
000000  4801              LDR      r0,|L27.8|
;;;2044   {
;;;2045     /* Get timestamp subseconds values from the correspondent registers */
;;;2046     return (uint32_t)(RTC->TSSSR);
000002  6800              LDR      r0,[r0,#0]
;;;2047   }
000004  4770              BX       lr
;;;2048   
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x40002838

                          AREA ||i.RTC_GetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_GetWakeUpCounter PROC
;;;1514     */
;;;1515   uint32_t RTC_GetWakeUpCounter(void)
000000  4801              LDR      r0,|L28.8|
;;;1516   {
;;;1517     /* Get the counter value */
;;;1518     return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
000002  6800              LDR      r0,[r0,#0]
000004  b280              UXTH     r0,r0
;;;1519   }
000006  4770              BX       lr
;;;1520   
                          ENDP

                  |L28.8|
                          DCD      0x40002814

                          AREA ||i.RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;2529     */
;;;2530   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;2531   {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d004              BEQ      |L29.18|
;;;2532     /* Check the parameters */
;;;2533     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
000008  f24f0104          MOV      r1,#0xf004
00000c  ea340001          BICS     r0,r4,r1
000010  d004              BEQ      |L29.28|
                  |L29.18|
000012  f64011e5          MOV      r1,#0x9e5
000016  4813              LDR      r0,|L29.100|
000018  f7fffffe          BL       assert_failed
                  |L29.28|
;;;2534     assert_param(IS_FUNCTIONAL_STATE(NewState));
00001c  b135              CBZ      r5,|L29.44|
00001e  2d01              CMP      r5,#1
000020  d004              BEQ      |L29.44|
000022  f64011e6          MOV      r1,#0x9e6
000026  480f              LDR      r0,|L29.100|
000028  f7fffffe          BL       assert_failed
                  |L29.44|
;;;2535   
;;;2536     /* Disable the write protection for RTC registers */
;;;2537     RTC->WPR = 0xCA;
00002c  4e0e              LDR      r6,|L29.104|
00002e  20ca              MOVS     r0,#0xca
000030  6030              STR      r0,[r6,#0]
;;;2538     RTC->WPR = 0x53;
000032  2053              MOVS     r0,#0x53
000034  6030              STR      r0,[r6,#0]
;;;2539   
;;;2540     if (NewState != DISABLE)
;;;2541     {
;;;2542       /* Configure the Interrupts in the RTC_CR register */
;;;2543       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
000036  4a0c              LDR      r2,|L29.104|
000038  f0240004          BIC      r0,r4,#4
00003c  3a1c              SUBS     r2,r2,#0x1c
;;;2544       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2545       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
00003e  4b0a              LDR      r3,|L29.104|
000040  f0040104          AND      r1,r4,#4
;;;2546     }
;;;2547     else
;;;2548     {
;;;2549       /* Configure the Interrupts in the RTC_CR register */
;;;2550       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
000044  6814              LDR      r4,[r2,#0]
000046  331c              ADDS     r3,r3,#0x1c           ;2545
000048  b125              CBZ      r5,|L29.84|
00004a  4304              ORRS     r4,r4,r0              ;2543
00004c  6014              STR      r4,[r2,#0]            ;2543
00004e  6818              LDR      r0,[r3,#0]            ;2545
000050  4308              ORRS     r0,r0,r1              ;2545
000052  e003              B        |L29.92|
                  |L29.84|
000054  4384              BICS     r4,r4,r0
000056  6014              STR      r4,[r2,#0]
;;;2551       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2552       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000058  6818              LDR      r0,[r3,#0]
00005a  4388              BICS     r0,r0,r1
                  |L29.92|
00005c  6018              STR      r0,[r3,#0]
;;;2553     }
;;;2554     /* Enable the write protection for RTC registers */
;;;2555     RTC->WPR = 0xFF; 
00005e  20ff              MOVS     r0,#0xff
000060  6030              STR      r0,[r6,#0]
;;;2556   }
000062  bd70              POP      {r4-r6,pc}
;;;2557   
                          ENDP

                  |L29.100|
                          DCD      ||.conststring||
                  |L29.104|
                          DCD      0x40002824

                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=2

                  RTC_Init PROC
;;;444      */
;;;445    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;446    {
000002  4604              MOV      r4,r0
;;;447      ErrorStatus status = ERROR;
;;;448      
;;;449      /* Check the parameters */
;;;450      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
000004  6800              LDR      r0,[r0,#0]
000006  2600              MOVS     r6,#0                 ;447
000008  2840              CMP      r0,#0x40
00000a  d005              BEQ      |L30.24|
00000c  b120              CBZ      r0,|L30.24|
00000e  f44f71e1          MOV      r1,#0x1c2
000012  481b              LDR      r0,|L30.128|
000014  f7fffffe          BL       assert_failed
                  |L30.24|
;;;451      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
000018  6860              LDR      r0,[r4,#4]
00001a  287f              CMP      r0,#0x7f
00001c  d904              BLS      |L30.40|
00001e  f24011c3          MOV      r1,#0x1c3
000022  4817              LDR      r0,|L30.128|
000024  f7fffffe          BL       assert_failed
                  |L30.40|
;;;452      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
000028  68a0              LDR      r0,[r4,#8]
00002a  f5b04f00          CMP      r0,#0x8000
00002e  d304              BCC      |L30.58|
000030  f44f71e2          MOV      r1,#0x1c4
000034  4812              LDR      r0,|L30.128|
000036  f7fffffe          BL       assert_failed
                  |L30.58|
;;;453    
;;;454      /* Disable the write protection for RTC registers */
;;;455      RTC->WPR = 0xCA;
00003a  4d12              LDR      r5,|L30.132|
00003c  20ca              MOVS     r0,#0xca
00003e  6028              STR      r0,[r5,#0]
;;;456      RTC->WPR = 0x53;
000040  2053              MOVS     r0,#0x53
000042  6028              STR      r0,[r5,#0]
;;;457    
;;;458      /* Set Initialization mode */
;;;459      if (RTC_EnterInitMode() == ERROR)
000044  f7fffffe          BL       RTC_EnterInitMode
000048  b1a8              CBZ      r0,|L30.118|
;;;460      {
;;;461        status = ERROR;
;;;462      } 
;;;463      else
;;;464      {
;;;465        /* Clear RTC CR FMT Bit */
;;;466        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
00004a  480e              LDR      r0,|L30.132|
00004c  381c              SUBS     r0,r0,#0x1c
00004e  6801              LDR      r1,[r0,#0]
000050  f0210140          BIC      r1,r1,#0x40
000054  6001              STR      r1,[r0,#0]
;;;467        /* Set RTC_CR register */
;;;468        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
000056  6801              LDR      r1,[r0,#0]
000058  6822              LDR      r2,[r4,#0]
00005a  4311              ORRS     r1,r1,r2
00005c  6001              STR      r1,[r0,#0]
;;;469      
;;;470        /* Configure the RTC PRER */
;;;471        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
00005e  4809              LDR      r0,|L30.132|
000060  68a1              LDR      r1,[r4,#8]
000062  3814              SUBS     r0,r0,#0x14
000064  6001              STR      r1,[r0,#0]
;;;472        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
000066  6801              LDR      r1,[r0,#0]
000068  88a2              LDRH     r2,[r4,#4]
00006a  ea414102          ORR      r1,r1,r2,LSL #16
00006e  6001              STR      r1,[r0,#0]
;;;473    
;;;474        /* Exit Initialization mode */
;;;475        RTC_ExitInitMode();
000070  f7fffffe          BL       RTC_ExitInitMode
;;;476    
;;;477        status = SUCCESS;    
000074  2601              MOVS     r6,#1
                  |L30.118|
;;;478      }
;;;479      /* Enable the write protection for RTC registers */
;;;480      RTC->WPR = 0xFF; 
000076  20ff              MOVS     r0,#0xff
000078  6028              STR      r0,[r5,#0]
;;;481      
;;;482      return status;
00007a  4630              MOV      r0,r6
;;;483    }
00007c  bd70              POP      {r4-r6,pc}
;;;484    
                          ENDP

00007e  0000              DCW      0x0000
                  |L30.128|
                          DCD      ||.conststring||
                  |L30.132|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputConfig PROC
;;;1669     */
;;;1670   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
000000  b570              PUSH     {r4-r6,lr}
;;;1671   {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d00d              BEQ      |L31.36|
;;;1672     /* Check the parameters */
;;;1673     assert_param(IS_RTC_OUTPUT(RTC_Output));
000008  f5b41f00          CMP      r4,#0x200000
00000c  d00a              BEQ      |L31.36|
00000e  f5b40f80          CMP      r4,#0x400000
000012  d007              BEQ      |L31.36|
000014  f5b40fc0          CMP      r4,#0x600000
000018  d004              BEQ      |L31.36|
00001a  f2406189          MOV      r1,#0x689
00001e  480f              LDR      r0,|L31.92|
000020  f7fffffe          BL       assert_failed
                  |L31.36|
;;;1674     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
000024  b13d              CBZ      r5,|L31.54|
000026  f5b51f80          CMP      r5,#0x100000
00002a  d004              BEQ      |L31.54|
00002c  f240618a          MOV      r1,#0x68a
000030  480a              LDR      r0,|L31.92|
000032  f7fffffe          BL       assert_failed
                  |L31.54|
;;;1675   
;;;1676     /* Disable the write protection for RTC registers */
;;;1677     RTC->WPR = 0xCA;
000036  490a              LDR      r1,|L31.96|
000038  20ca              MOVS     r0,#0xca
00003a  6008              STR      r0,[r1,#0]
;;;1678     RTC->WPR = 0x53;
00003c  2053              MOVS     r0,#0x53
00003e  6008              STR      r0,[r1,#0]
;;;1679   
;;;1680     /* Clear the bits to be configured */
;;;1681     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
000040  4807              LDR      r0,|L31.96|
000042  381c              SUBS     r0,r0,#0x1c
000044  6802              LDR      r2,[r0,#0]
000046  f42202e0          BIC      r2,r2,#0x700000
00004a  6002              STR      r2,[r0,#0]
;;;1682   
;;;1683     /* Configure the output selection and polarity */
;;;1684     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
00004c  6802              LDR      r2,[r0,#0]
00004e  432c              ORRS     r4,r4,r5
000050  4322              ORRS     r2,r2,r4
000052  6002              STR      r2,[r0,#0]
;;;1685   
;;;1686     /* Enable the write protection for RTC registers */
;;;1687     RTC->WPR = 0xFF; 
000054  20ff              MOVS     r0,#0xff
000056  6008              STR      r0,[r1,#0]
;;;1688   }
000058  bd70              POP      {r4-r6,pc}
;;;1689   
                          ENDP

00005a  0000              DCW      0x0000
                  |L31.92|
                          DCD      ||.conststring||
                  |L31.96|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputTypeConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputTypeConfig PROC
;;;2372     */
;;;2373   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
000000  b510              PUSH     {r4,lr}
;;;2374   {
000002  0004              MOVS     r4,r0
000004  d007              BEQ      |L32.22|
;;;2375     /* Check the parameters */
;;;2376     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
000006  f5b42f80          CMP      r4,#0x40000
00000a  d004              BEQ      |L32.22|
00000c  f6401148          MOV      r1,#0x948
000010  4805              LDR      r0,|L32.40|
000012  f7fffffe          BL       assert_failed
                  |L32.22|
;;;2377     
;;;2378     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
000016  4805              LDR      r0,|L32.44|
000018  6801              LDR      r1,[r0,#0]
00001a  f4212180          BIC      r1,r1,#0x40000
00001e  6001              STR      r1,[r0,#0]
;;;2379     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
000020  6801              LDR      r1,[r0,#0]
000022  4321              ORRS     r1,r1,r4
000024  6001              STR      r1,[r0,#0]
;;;2380   }
000026  bd10              POP      {r4,pc}
;;;2381   
                          ENDP

                  |L32.40|
                          DCD      ||.conststring||
                  |L32.44|
                          DCD      0x40002840

                          AREA ||i.RTC_ReadBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_ReadBackupRegister PROC
;;;2296     */
;;;2297   uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
000000  b538              PUSH     {r3-r5,lr}
;;;2298   {
000002  0004              MOVS     r4,r0
;;;2299     __IO uint32_t tmp = 0;
000004  f04f0000          MOV      r0,#0
000008  9000              STR      r0,[sp,#0]            ;2298
00000a  d02a              BEQ      |L33.98|
;;;2300     
;;;2301     /* Check the parameters */
;;;2302     assert_param(IS_RTC_BKP(RTC_BKP_DR));
00000c  2c01              CMP      r4,#1
00000e  d028              BEQ      |L33.98|
000010  2c02              CMP      r4,#2
000012  d026              BEQ      |L33.98|
000014  2c03              CMP      r4,#3
000016  d024              BEQ      |L33.98|
000018  2c04              CMP      r4,#4
00001a  d022              BEQ      |L33.98|
00001c  2c05              CMP      r4,#5
00001e  d020              BEQ      |L33.98|
000020  2c06              CMP      r4,#6
000022  d01e              BEQ      |L33.98|
000024  2c07              CMP      r4,#7
000026  d01c              BEQ      |L33.98|
000028  2c08              CMP      r4,#8
00002a  d01a              BEQ      |L33.98|
00002c  2c09              CMP      r4,#9
00002e  d018              BEQ      |L33.98|
000030  2c0a              CMP      r4,#0xa
000032  d016              BEQ      |L33.98|
000034  2c0b              CMP      r4,#0xb
000036  d014              BEQ      |L33.98|
000038  2c0c              CMP      r4,#0xc
00003a  d012              BEQ      |L33.98|
00003c  2c0d              CMP      r4,#0xd
00003e  d010              BEQ      |L33.98|
000040  2c0e              CMP      r4,#0xe
000042  d00e              BEQ      |L33.98|
000044  2c0f              CMP      r4,#0xf
000046  d00c              BEQ      |L33.98|
000048  2c10              CMP      r4,#0x10
00004a  d00a              BEQ      |L33.98|
00004c  2c11              CMP      r4,#0x11
00004e  d008              BEQ      |L33.98|
000050  2c12              CMP      r4,#0x12
000052  d006              BEQ      |L33.98|
000054  2c13              CMP      r4,#0x13
000056  d004              BEQ      |L33.98|
000058  f64001fe          MOV      r1,#0x8fe
00005c  4804              LDR      r0,|L33.112|
00005e  f7fffffe          BL       assert_failed
                  |L33.98|
;;;2303   
;;;2304     tmp = RTC_BASE + 0x50;
000062  4804              LDR      r0,|L33.116|
;;;2305     tmp += (RTC_BKP_DR * 4);
000064  eb000084          ADD      r0,r0,r4,LSL #2
;;;2306     
;;;2307     /* Read the specified register */
;;;2308     return (*(__IO uint32_t *)tmp);
000068  9000              STR      r0,[sp,#0]
00006a  6800              LDR      r0,[r0,#0]
;;;2309   }
00006c  bd38              POP      {r3-r5,pc}
;;;2310   
                          ENDP

00006e  0000              DCW      0x0000
                  |L33.112|
                          DCD      ||.conststring||
                  |L33.116|
                          DCD      0x40002850

                          AREA ||i.RTC_RefClockCmd||, CODE, READONLY, ALIGN=2

                  RTC_RefClockCmd PROC
;;;649      */
;;;650    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;651    { 
000002  0004              MOVS     r4,r0
;;;652      ErrorStatus status = ERROR;
000004  f04f0500          MOV      r5,#0
000008  d006              BEQ      |L34.24|
;;;653      
;;;654      /* Check the parameters */
;;;655      assert_param(IS_FUNCTIONAL_STATE(NewState));
00000a  2c01              CMP      r4,#1
00000c  d004              BEQ      |L34.24|
00000e  f240218f          MOV      r1,#0x28f
000012  480e              LDR      r0,|L34.76|
000014  f7fffffe          BL       assert_failed
                  |L34.24|
;;;656      
;;;657      /* Disable the write protection for RTC registers */
;;;658      RTC->WPR = 0xCA;
000018  4e0d              LDR      r6,|L34.80|
00001a  20ca              MOVS     r0,#0xca
00001c  6030              STR      r0,[r6,#0]
;;;659      RTC->WPR = 0x53;
00001e  2053              MOVS     r0,#0x53
000020  6030              STR      r0,[r6,#0]
;;;660        
;;;661      /* Set Initialization mode */
;;;662      if (RTC_EnterInitMode() == ERROR)
000022  f7fffffe          BL       RTC_EnterInitMode
000026  b160              CBZ      r0,|L34.66|
;;;663      {
;;;664        status = ERROR;
;;;665      } 
;;;666      else
;;;667      {  
;;;668        if (NewState != DISABLE)
;;;669        {
;;;670          /* Enable the RTC reference clock detection */
;;;671          RTC->CR |= RTC_CR_REFCKON;   
000028  4809              LDR      r0,|L34.80|
00002a  381c              SUBS     r0,r0,#0x1c
;;;672        }
;;;673        else
;;;674        {
;;;675          /* Disable the RTC reference clock detection */
;;;676          RTC->CR &= ~RTC_CR_REFCKON;    
00002c  6801              LDR      r1,[r0,#0]
00002e  b114              CBZ      r4,|L34.54|
000030  f0410110          ORR      r1,r1,#0x10           ;671
000034  e001              B        |L34.58|
                  |L34.54|
000036  f0210110          BIC      r1,r1,#0x10
                  |L34.58|
00003a  6001              STR      r1,[r0,#0]
;;;677        }
;;;678        /* Exit Initialization mode */
;;;679        RTC_ExitInitMode();
00003c  f7fffffe          BL       RTC_ExitInitMode
;;;680        
;;;681        status = SUCCESS;
000040  2501              MOVS     r5,#1
                  |L34.66|
;;;682      }
;;;683      
;;;684      /* Enable the write protection for RTC registers */
;;;685      RTC->WPR = 0xFF;  
000042  20ff              MOVS     r0,#0xff
000044  6030              STR      r0,[r6,#0]
;;;686      
;;;687      return status; 
000046  4628              MOV      r0,r5
;;;688    }
000048  bd70              POP      {r4-r6,pc}
;;;689    
                          ENDP

00004a  0000              DCW      0x0000
                  |L34.76|
                          DCD      ||.conststring||
                  |L34.80|
                          DCD      0x40002824

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;1087     */
;;;1088   void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1089   {
000004  4614              MOV      r4,r2
000006  460d              MOV      r5,r1
000008  0007              MOVS     r7,r0
00000a  d006              BEQ      |L35.26|
;;;1090     uint32_t tmpreg = 0;
;;;1091     
;;;1092     /* Check the parameters */
;;;1093     assert_param(IS_RTC_FORMAT(RTC_Format));
00000c  2f01              CMP      r7,#1
00000e  d004              BEQ      |L35.26|
000010  f2404145          MOV      r1,#0x445
000014  487f              LDR      r0,|L35.532|
000016  f7fffffe          BL       assert_failed
                  |L35.26|
;;;1094     assert_param(IS_RTC_ALARM(RTC_Alarm));
00001a  f44f7680          MOV      r6,#0x100
00001e  42b5              CMP      r5,r6
000020  d007              BEQ      |L35.50|
000022  f5b57f00          CMP      r5,#0x200
000026  d004              BEQ      |L35.50|
000028  f2404146          MOV      r1,#0x446
00002c  4879              LDR      r0,|L35.532|
00002e  f7fffffe          BL       assert_failed
                  |L35.50|
;;;1095     assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
000032  6860              LDR      r0,[r4,#4]
000034  f0103f7f          TST      r0,#0x7f7f7f7f
000038  d004              BEQ      |L35.68|
00003a  f2404147          MOV      r1,#0x447
00003e  4875              LDR      r0,|L35.532|
000040  f7fffffe          BL       assert_failed
                  |L35.68|
;;;1096     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
000044  68a0              LDR      r0,[r4,#8]
000046  b138              CBZ      r0,|L35.88|
000048  f1b04f80          CMP      r0,#0x40000000
00004c  d004              BEQ      |L35.88|
00004e  f44f6189          MOV      r1,#0x448
000052  4870              LDR      r0,|L35.532|
000054  f7fffffe          BL       assert_failed
                  |L35.88|
;;;1097   
;;;1098     if (RTC_Format == RTC_Format_BIN)
;;;1099     {
;;;1100       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000058  496f              LDR      r1,|L35.536|
00005a  2000              MOVS     r0,#0                 ;1096
;;;1101       {
;;;1102         assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1103         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
;;;1104       } 
;;;1105       else
;;;1106       {
;;;1107         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1108         assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1109       }
;;;1110       assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;1111       assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;1112       
;;;1113       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1114       {
;;;1115         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1116       }
;;;1117       else
;;;1118       {
;;;1119         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1120       }
;;;1121     }
;;;1122     else
;;;1123     {
;;;1124       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00005c  6809              LDR      r1,[r1,#0]
00005e  ea4f6141          LSL      r1,r1,#25
000062  b19f              CBZ      r7,|L35.140|
000064  2900              CMP      r1,#0
000066  da5c              BGE      |L35.290|
;;;1125       {
;;;1126         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
000068  7820              LDRB     r0,[r4,#0]
00006a  f7fffffe          BL       RTC_Bcd2ToByte
00006e  1e40              SUBS     r0,r0,#1
;;;1127         assert_param(IS_RTC_HOUR12(tmpreg));
000070  280b              CMP      r0,#0xb
000072  d904              BLS      |L35.126|
000074  f2404167          MOV      r1,#0x467
000078  4866              LDR      r0,|L35.532|
00007a  f7fffffe          BL       assert_failed
                  |L35.126|
;;;1128         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
00007e  78e0              LDRB     r0,[r4,#3]
000080  b3f0              CBZ      r0,|L35.256|
000082  2840              CMP      r0,#0x40
000084  d058              BEQ      |L35.312|
000086  f44f618d          MOV      r1,#0x468
00008a  e052              B        |L35.306|
                  |L35.140|
00008c  2900              CMP      r1,#0                 ;1100
00008e  da0f              BGE      |L35.176|
000090  7820              LDRB     r0,[r4,#0]            ;1102
000092  1e40              SUBS     r0,r0,#1              ;1102
000094  280b              CMP      r0,#0xb               ;1102
000096  d904              BLS      |L35.162|
000098  f240414e          MOV      r1,#0x44e             ;1102
00009c  485d              LDR      r0,|L35.532|
00009e  f7fffffe          BL       assert_failed
                  |L35.162|
0000a2  78e0              LDRB     r0,[r4,#3]            ;1103
0000a4  b168              CBZ      r0,|L35.194|
0000a6  2840              CMP      r0,#0x40              ;1103
0000a8  d00b              BEQ      |L35.194|
0000aa  f240414f          MOV      r1,#0x44f             ;1103
0000ae  e005              B        |L35.188|
                  |L35.176|
0000b0  70e0              STRB     r0,[r4,#3]            ;1107
0000b2  7820              LDRB     r0,[r4,#0]            ;1108
0000b4  2817              CMP      r0,#0x17              ;1108
0000b6  d904              BLS      |L35.194|
0000b8  f2404154          MOV      r1,#0x454             ;1108
                  |L35.188|
0000bc  4855              LDR      r0,|L35.532|
0000be  f7fffffe          BL       assert_failed
                  |L35.194|
0000c2  7860              LDRB     r0,[r4,#1]            ;1110
0000c4  283b              CMP      r0,#0x3b              ;1110
0000c6  d904              BLS      |L35.210|
0000c8  f2404156          MOV      r1,#0x456             ;1110
0000cc  4851              LDR      r0,|L35.532|
0000ce  f7fffffe          BL       assert_failed
                  |L35.210|
0000d2  78a0              LDRB     r0,[r4,#2]            ;1111
0000d4  283b              CMP      r0,#0x3b              ;1111
0000d6  d904              BLS      |L35.226|
0000d8  f2404157          MOV      r1,#0x457             ;1111
0000dc  484d              LDR      r0,|L35.532|
0000de  f7fffffe          BL       assert_failed
                  |L35.226|
0000e2  68a0              LDR      r0,[r4,#8]            ;1113
0000e4  2800              CMP      r0,#0                 ;1113
0000e6  7b20              LDRB     r0,[r4,#0xc]          ;1119
0000e8  d015              BEQ      |L35.278|
0000ea  2801              CMP      r0,#1                 ;1119
0000ec  d067              BEQ      |L35.446|
0000ee  2802              CMP      r0,#2                 ;1119
0000f0  d065              BEQ      |L35.446|
0000f2  2803              CMP      r0,#3                 ;1119
0000f4  d063              BEQ      |L35.446|
0000f6  2804              CMP      r0,#4                 ;1119
0000f8  d061              BEQ      |L35.446|
0000fa  2805              CMP      r0,#5                 ;1119
0000fc  d05f              BEQ      |L35.446|
0000fe  e000              B        |L35.258|
                  |L35.256|
000100  e01a              B        |L35.312|
                  |L35.258|
000102  2806              CMP      r0,#6                 ;1119
000104  d05b              BEQ      |L35.446|
000106  2807              CMP      r0,#7                 ;1119
000108  d059              BEQ      |L35.446|
00010a  f240415f          MOV      r1,#0x45f             ;1119
                  |L35.270|
00010e  4841              LDR      r0,|L35.532|
000110  f7fffffe          BL       assert_failed
000114  e053              B        |L35.446|
                  |L35.278|
000116  1e40              SUBS     r0,r0,#1              ;1115
000118  281e              CMP      r0,#0x1e              ;1115
00011a  d950              BLS      |L35.446|
00011c  f240415b          MOV      r1,#0x45b             ;1115
000120  e7f5              B        |L35.270|
                  |L35.290|
;;;1129       } 
;;;1130       else
;;;1131       {
;;;1132         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
000122  70e0              STRB     r0,[r4,#3]
;;;1133         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
000124  7820              LDRB     r0,[r4,#0]
000126  f7fffffe          BL       RTC_Bcd2ToByte
00012a  2817              CMP      r0,#0x17
00012c  d904              BLS      |L35.312|
00012e  f240416d          MOV      r1,#0x46d
                  |L35.306|
000132  4838              LDR      r0,|L35.532|
000134  f7fffffe          BL       assert_failed
                  |L35.312|
;;;1134       }
;;;1135       
;;;1136       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
000138  7860              LDRB     r0,[r4,#1]
00013a  f7fffffe          BL       RTC_Bcd2ToByte
00013e  283b              CMP      r0,#0x3b
000140  d904              BLS      |L35.332|
000142  f44f618e          MOV      r1,#0x470
000146  4833              LDR      r0,|L35.532|
000148  f7fffffe          BL       assert_failed
                  |L35.332|
;;;1137       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
00014c  78a0              LDRB     r0,[r4,#2]
00014e  f7fffffe          BL       RTC_Bcd2ToByte
000152  283b              CMP      r0,#0x3b
000154  d904              BLS      |L35.352|
000156  f2404171          MOV      r1,#0x471
00015a  482e              LDR      r0,|L35.532|
00015c  f7fffffe          BL       assert_failed
                  |L35.352|
;;;1138       
;;;1139       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
000160  68a0              LDR      r0,[r4,#8]
000162  2800              CMP      r0,#0
;;;1140       {
;;;1141         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1142         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
;;;1143       }
;;;1144       else
;;;1145       {
;;;1146         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000164  7b20              LDRB     r0,[r4,#0xc]
000166  d022              BEQ      |L35.430|
000168  f7fffffe          BL       RTC_Bcd2ToByte
;;;1147         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
00016c  2801              CMP      r0,#1
00016e  d010              BEQ      |L35.402|
000170  2802              CMP      r0,#2
000172  d00e              BEQ      |L35.402|
000174  2803              CMP      r0,#3
000176  d00c              BEQ      |L35.402|
000178  2804              CMP      r0,#4
00017a  d00a              BEQ      |L35.402|
00017c  2805              CMP      r0,#5
00017e  d008              BEQ      |L35.402|
000180  2806              CMP      r0,#6
000182  d006              BEQ      |L35.402|
000184  2807              CMP      r0,#7
000186  d004              BEQ      |L35.402|
000188  f240417b          MOV      r1,#0x47b
                  |L35.396|
00018c  4821              LDR      r0,|L35.532|
00018e  f7fffffe          BL       assert_failed
                  |L35.402|
;;;1148       }    
;;;1149     }
;;;1150   
;;;1151     /* Check the input parameters format */
;;;1152     if (RTC_Format != RTC_Format_BIN)
;;;1153     {
;;;1154       tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
000192  78a0              LDRB     r0,[r4,#2]
000194  7821              LDRB     r1,[r4,#0]
000196  78e2              LDRB     r2,[r4,#3]
000198  ea404001          ORR      r0,r0,r1,LSL #16
00019c  7861              LDRB     r1,[r4,#1]
00019e  0209              LSLS     r1,r1,#8
0001a0  ea414102          ORR      r1,r1,r2,LSL #16
0001a4  4308              ORRS     r0,r0,r1
0001a6  7b21              LDRB     r1,[r4,#0xc]
0001a8  ea406001          ORR      r0,r0,r1,LSL #24
0001ac  e01c              B        |L35.488|
                  |L35.430|
0001ae  f7fffffe          BL       RTC_Bcd2ToByte
0001b2  1e40              SUBS     r0,r0,#1              ;1141
0001b4  281e              CMP      r0,#0x1e              ;1142
0001b6  d9ec              BLS      |L35.402|
0001b8  f2404176          MOV      r1,#0x476             ;1142
0001bc  e7e6              B        |L35.396|
                  |L35.446|
;;;1155                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1156                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;1157                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1158                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1159                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1160                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1161     }  
;;;1162     else
;;;1163     {
;;;1164       tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
0001be  7820              LDRB     r0,[r4,#0]
0001c0  f7fffffe          BL       RTC_ByteToBcd2
0001c4  0407              LSLS     r7,r0,#16
0001c6  7860              LDRB     r0,[r4,#1]
0001c8  f7fffffe          BL       RTC_ByteToBcd2
0001cc  ea472700          ORR      r7,r7,r0,LSL #8
0001d0  78a0              LDRB     r0,[r4,#2]
0001d2  f7fffffe          BL       RTC_ByteToBcd2
0001d6  4307              ORRS     r7,r7,r0
0001d8  78e0              LDRB     r0,[r4,#3]
0001da  ea474700          ORR      r7,r7,r0,LSL #16
0001de  7b20              LDRB     r0,[r4,#0xc]
0001e0  f7fffffe          BL       RTC_ByteToBcd2
0001e4  ea476000          ORR      r0,r7,r0,LSL #24
                  |L35.488|
0001e8  68a1              LDR      r1,[r4,#8]
;;;1165                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1166                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;1167                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1168                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1169                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1170                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1171     } 
;;;1172   
;;;1173     /* Disable the write protection for RTC registers */
;;;1174     RTC->WPR = 0xCA;
0001ea  22ca              MOVS     r2,#0xca
0001ec  4308              ORRS     r0,r0,r1              ;1164
0001ee  6861              LDR      r1,[r4,#4]            ;1164
0001f0  4308              ORRS     r0,r0,r1              ;1164
0001f2  4909              LDR      r1,|L35.536|
0001f4  311c              ADDS     r1,r1,#0x1c
0001f6  600a              STR      r2,[r1,#0]
;;;1175     RTC->WPR = 0x53;
0001f8  2253              MOVS     r2,#0x53
0001fa  600a              STR      r2,[r1,#0]
;;;1176   
;;;1177     /* Configure the Alarm register */
;;;1178     if (RTC_Alarm == RTC_Alarm_A)
0001fc  42b5              CMP      r5,r6
0001fe  d102              BNE      |L35.518|
;;;1179     {
;;;1180       RTC->ALRMAR = (uint32_t)tmpreg;
000200  4a05              LDR      r2,|L35.536|
000202  3214              ADDS     r2,r2,#0x14
000204  e001              B        |L35.522|
                  |L35.518|
;;;1181     }
;;;1182     else
;;;1183     {
;;;1184       RTC->ALRMBR = (uint32_t)tmpreg;
000206  4a04              LDR      r2,|L35.536|
000208  3218              ADDS     r2,r2,#0x18
                  |L35.522|
00020a  6010              STR      r0,[r2,#0]
;;;1185     }
;;;1186   
;;;1187     /* Enable the write protection for RTC registers */
;;;1188     RTC->WPR = 0xFF;   
00020c  20ff              MOVS     r0,#0xff
00020e  6008              STR      r0,[r1,#0]
;;;1189   }
000210  e8bd81f0          POP      {r4-r8,pc}
;;;1190   
                          ENDP

                  |L35.532|
                          DCD      ||.conststring||
                  |L35.536|
                          DCD      0x40002808

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;925      */
;;;926    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;927    {
000002  460c              MOV      r4,r1
000004  0005              MOVS     r5,r0
;;;928      uint32_t tmpreg = 0;
;;;929      ErrorStatus status = ERROR;
000006  f04f0600          MOV      r6,#0
00000a  d046              BEQ      |L36.154|
;;;930      
;;;931      /* Check the parameters */
;;;932      assert_param(IS_RTC_FORMAT(RTC_Format));
00000c  2d01              CMP      r5,#1
00000e  d004              BEQ      |L36.26|
000010  f44f7169          MOV      r1,#0x3a4
000014  4844              LDR      r0,|L36.296|
000016  f7fffffe          BL       assert_failed
                  |L36.26|
;;;933    
;;;934      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
;;;935      {
;;;936        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
;;;937      }  
;;;938      if (RTC_Format == RTC_Format_BIN)
;;;939      {
;;;940        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;941        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;942        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
;;;943      }
;;;944      else
;;;945      {
;;;946        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
00001a  78e0              LDRB     r0,[r4,#3]
00001c  f7fffffe          BL       RTC_Bcd2ToByte
000020  2863              CMP      r0,#0x63
000022  d904              BLS      |L36.46|
000024  f24031b2          MOV      r1,#0x3b2
000028  483f              LDR      r0,|L36.296|
00002a  f7fffffe          BL       assert_failed
                  |L36.46|
;;;947        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
00002e  7860              LDRB     r0,[r4,#1]
000030  f7fffffe          BL       RTC_Bcd2ToByte
000034  1e40              SUBS     r0,r0,#1
;;;948        assert_param(IS_RTC_MONTH(tmpreg));
000036  280b              CMP      r0,#0xb
000038  d904              BLS      |L36.68|
00003a  f44f716d          MOV      r1,#0x3b4
00003e  483a              LDR      r0,|L36.296|
000040  f7fffffe          BL       assert_failed
                  |L36.68|
;;;949        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
000044  78a0              LDRB     r0,[r4,#2]
000046  f7fffffe          BL       RTC_Bcd2ToByte
00004a  1e40              SUBS     r0,r0,#1
;;;950        assert_param(IS_RTC_DATE(tmpreg));
00004c  281e              CMP      r0,#0x1e
00004e  d904              BLS      |L36.90|
000050  f24031b6          MOV      r1,#0x3b6
                  |L36.84|
000054  4834              LDR      r0,|L36.296|
000056  f7fffffe          BL       assert_failed
                  |L36.90|
;;;951      }
;;;952      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
00005a  7821              LDRB     r1,[r4,#0]
00005c  2901              CMP      r1,#1
00005e  d010              BEQ      |L36.130|
000060  2902              CMP      r1,#2
000062  d00e              BEQ      |L36.130|
000064  2903              CMP      r1,#3
000066  d00c              BEQ      |L36.130|
000068  2904              CMP      r1,#4
00006a  d00a              BEQ      |L36.130|
00006c  2905              CMP      r1,#5
00006e  d008              BEQ      |L36.130|
000070  2906              CMP      r1,#6
000072  d006              BEQ      |L36.130|
000074  2907              CMP      r1,#7
000076  d004              BEQ      |L36.130|
000078  f44f716e          MOV      r1,#0x3b8
00007c  482a              LDR      r0,|L36.296|
00007e  f7fffffe          BL       assert_failed
                  |L36.130|
;;;953    
;;;954      /* Check the input parameters format */
;;;955      if (RTC_Format != RTC_Format_BIN)
000082  b34d              CBZ      r5,|L36.216|
;;;956      {
;;;957        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
000084  78a0              LDRB     r0,[r4,#2]
000086  78e1              LDRB     r1,[r4,#3]
000088  ea404501          ORR      r5,r0,r1,LSL #16
00008c  7860              LDRB     r0,[r4,#1]
00008e  7821              LDRB     r1,[r4,#0]
000090  0200              LSLS     r0,r0,#8
000092  ea403041          ORR      r0,r0,r1,LSL #13
000096  4305              ORRS     r5,r5,r0
000098  e02e              B        |L36.248|
                  |L36.154|
00009a  7860              LDRB     r0,[r4,#1]            ;934
00009c  06c1              LSLS     r1,r0,#27             ;934
00009e  d503              BPL      |L36.168|
0000a0  f0200010          BIC      r0,r0,#0x10           ;936
0000a4  300a              ADDS     r0,r0,#0xa            ;936
0000a6  7060              STRB     r0,[r4,#1]            ;936
                  |L36.168|
0000a8  78e0              LDRB     r0,[r4,#3]            ;940
0000aa  2863              CMP      r0,#0x63              ;940
0000ac  d904              BLS      |L36.184|
0000ae  f44f716b          MOV      r1,#0x3ac             ;940
0000b2  481d              LDR      r0,|L36.296|
0000b4  f7fffffe          BL       assert_failed
                  |L36.184|
0000b8  7860              LDRB     r0,[r4,#1]            ;941
0000ba  1e40              SUBS     r0,r0,#1              ;941
0000bc  280b              CMP      r0,#0xb               ;941
0000be  d904              BLS      |L36.202|
0000c0  f24031ad          MOV      r1,#0x3ad             ;941
0000c4  4818              LDR      r0,|L36.296|
0000c6  f7fffffe          BL       assert_failed
                  |L36.202|
0000ca  78a0              LDRB     r0,[r4,#2]            ;942
0000cc  1e40              SUBS     r0,r0,#1              ;942
0000ce  281e              CMP      r0,#0x1e              ;942
0000d0  d9c3              BLS      |L36.90|
0000d2  f24031ae          MOV      r1,#0x3ae             ;942
0000d6  e7bd              B        |L36.84|
                  |L36.216|
;;;958                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;959                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;960                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;961      }  
;;;962      else
;;;963      {
;;;964        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
0000d8  78e0              LDRB     r0,[r4,#3]
0000da  f7fffffe          BL       RTC_ByteToBcd2
0000de  0405              LSLS     r5,r0,#16
0000e0  7860              LDRB     r0,[r4,#1]
0000e2  f7fffffe          BL       RTC_ByteToBcd2
0000e6  ea452500          ORR      r5,r5,r0,LSL #8
0000ea  78a0              LDRB     r0,[r4,#2]
0000ec  f7fffffe          BL       RTC_ByteToBcd2
0000f0  4305              ORRS     r5,r5,r0
0000f2  7820              LDRB     r0,[r4,#0]
0000f4  ea453540          ORR      r5,r5,r0,LSL #13
                  |L36.248|
;;;965                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;966                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;967                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;968      }
;;;969    
;;;970      /* Disable the write protection for RTC registers */
;;;971      RTC->WPR = 0xCA;
0000f8  4c0c              LDR      r4,|L36.300|
0000fa  20ca              MOVS     r0,#0xca
0000fc  6020              STR      r0,[r4,#0]
;;;972      RTC->WPR = 0x53;
0000fe  2053              MOVS     r0,#0x53
000100  6020              STR      r0,[r4,#0]
;;;973    
;;;974      /* Set Initialization mode */
;;;975      if (RTC_EnterInitMode() == ERROR)
000102  f7fffffe          BL       RTC_EnterInitMode
000106  b150              CBZ      r0,|L36.286|
;;;976      {
;;;977        status = ERROR;
;;;978      } 
;;;979      else
;;;980      {
;;;981        /* Set the RTC_DR register */
;;;982        RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
000108  4809              LDR      r0,|L36.304|
00010a  4005              ANDS     r5,r5,r0
00010c  4807              LDR      r0,|L36.300|
00010e  3820              SUBS     r0,r0,#0x20
000110  6005              STR      r5,[r0,#0]
;;;983    
;;;984        /* Exit Initialization mode */
;;;985        RTC_ExitInitMode(); 
000112  f7fffffe          BL       RTC_ExitInitMode
;;;986    
;;;987        if(RTC_WaitForSynchro() == ERROR)
000116  f7fffffe          BL       RTC_WaitForSynchro
00011a  b100              CBZ      r0,|L36.286|
;;;988        {
;;;989          status = ERROR;
;;;990        }
;;;991        else
;;;992        {
;;;993          status = SUCCESS;
00011c  2601              MOVS     r6,#1
                  |L36.286|
;;;994        }
;;;995      }
;;;996      /* Enable the write protection for RTC registers */
;;;997      RTC->WPR = 0xFF;   
00011e  20ff              MOVS     r0,#0xff
000120  6020              STR      r0,[r4,#0]
;;;998      
;;;999      return status;
000122  4630              MOV      r0,r6
;;;1000   }
000124  bd70              POP      {r4-r6,pc}
;;;1001   
                          ENDP

000126  0000              DCW      0x0000
                  |L36.296|
                          DCD      ||.conststring||
                  |L36.300|
                          DCD      0x40002824
                  |L36.304|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;752      */
;;;753    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;754    {
;;;755      uint32_t tmpreg = 0;
;;;756      ErrorStatus status = ERROR;
000004  2600              MOVS     r6,#0
;;;757        
;;;758      /* Check the parameters */
;;;759      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;760      
;;;761      if (RTC_Format == RTC_Format_BIN)
;;;762      {
;;;763        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000006  4f50              LDR      r7,|L37.328|
000008  460c              MOV      r4,r1                 ;754
00000a  4635              MOV      r5,r6                 ;756
00000c  b1e0              CBZ      r0,|L37.72|
00000e  2801              CMP      r0,#1                 ;759
000010  d004              BEQ      |L37.28|
000012  f24021f7          MOV      r1,#0x2f7             ;759
000016  484d              LDR      r0,|L37.332|
000018  f7fffffe          BL       assert_failed
                  |L37.28|
;;;764        {
;;;765          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;766          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
;;;767        } 
;;;768        else
;;;769        {
;;;770          RTC_TimeStruct->RTC_H12 = 0x00;
;;;771          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
;;;772        }
;;;773        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;774        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
;;;775      }
;;;776      else
;;;777      {
;;;778        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00001c  6838              LDR      r0,[r7,#0]
00001e  0640              LSLS     r0,r0,#25
000020  d567              BPL      |L37.242|
;;;779        {
;;;780          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
000022  7820              LDRB     r0,[r4,#0]
000024  f7fffffe          BL       RTC_Bcd2ToByte
000028  1e40              SUBS     r0,r0,#1
;;;781          assert_param(IS_RTC_HOUR12(tmpreg));
00002a  280b              CMP      r0,#0xb
00002c  d904              BLS      |L37.56|
00002e  f240310d          MOV      r1,#0x30d
000032  4846              LDR      r0,|L37.332|
000034  f7fffffe          BL       assert_failed
                  |L37.56|
;;;782          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
000038  78e0              LDRB     r0,[r4,#3]
00003a  2800              CMP      r0,#0
00003c  d064              BEQ      |L37.264|
00003e  2840              CMP      r0,#0x40
000040  d062              BEQ      |L37.264|
000042  f240310e          MOV      r1,#0x30e
000046  e05c              B        |L37.258|
                  |L37.72|
000048  6838              LDR      r0,[r7,#0]            ;763
00004a  0640              LSLS     r0,r0,#25             ;763
00004c  d50f              BPL      |L37.110|
00004e  7820              LDRB     r0,[r4,#0]            ;765
000050  1e40              SUBS     r0,r0,#1              ;765
000052  280b              CMP      r0,#0xb               ;765
000054  d904              BLS      |L37.96|
000056  f24021fd          MOV      r1,#0x2fd             ;765
00005a  483c              LDR      r0,|L37.332|
00005c  f7fffffe          BL       assert_failed
                  |L37.96|
000060  78e1              LDRB     r1,[r4,#3]            ;766
000062  b169              CBZ      r1,|L37.128|
000064  2940              CMP      r1,#0x40              ;766
000066  d00b              BEQ      |L37.128|
000068  f24021fe          MOV      r1,#0x2fe             ;766
00006c  e005              B        |L37.122|
                  |L37.110|
00006e  70e5              STRB     r5,[r4,#3]            ;770
000070  7820              LDRB     r0,[r4,#0]            ;771
000072  2817              CMP      r0,#0x17              ;771
000074  d904              BLS      |L37.128|
000076  f2403103          MOV      r1,#0x303             ;771
                  |L37.122|
00007a  4834              LDR      r0,|L37.332|
00007c  f7fffffe          BL       assert_failed
                  |L37.128|
000080  7860              LDRB     r0,[r4,#1]            ;773
000082  283b              CMP      r0,#0x3b              ;773
000084  d904              BLS      |L37.144|
000086  f2403105          MOV      r1,#0x305             ;773
00008a  4830              LDR      r0,|L37.332|
00008c  f7fffffe          BL       assert_failed
                  |L37.144|
000090  78a0              LDRB     r0,[r4,#2]            ;774
000092  283b              CMP      r0,#0x3b              ;774
000094  d904              BLS      |L37.160|
000096  f2403106          MOV      r1,#0x306             ;774
00009a  482c              LDR      r0,|L37.332|
00009c  f7fffffe          BL       assert_failed
                  |L37.160|
;;;783        } 
;;;784        else
;;;785        {
;;;786          RTC_TimeStruct->RTC_H12 = 0x00;
;;;787          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
;;;788        }
;;;789        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;790        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
;;;791      }
;;;792      
;;;793      /* Check the input parameters format */
;;;794      if (RTC_Format != RTC_Format_BIN)
;;;795      {
;;;796        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
;;;797                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;798                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;799                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;800      }  
;;;801      else
;;;802      {
;;;803        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
0000a0  7820              LDRB     r0,[r4,#0]
0000a2  f7fffffe          BL       RTC_ByteToBcd2
0000a6  0405              LSLS     r5,r0,#16
0000a8  7860              LDRB     r0,[r4,#1]
0000aa  f7fffffe          BL       RTC_ByteToBcd2
0000ae  ea452500          ORR      r5,r5,r0,LSL #8
0000b2  78a0              LDRB     r0,[r4,#2]
0000b4  f7fffffe          BL       RTC_ByteToBcd2
0000b8  4305              ORRS     r5,r5,r0
0000ba  78e0              LDRB     r0,[r4,#3]
0000bc  ea454500          ORR      r5,r5,r0,LSL #16
                  |L37.192|
;;;804                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;805                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;806                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;807      }  
;;;808    
;;;809      /* Disable the write protection for RTC registers */
;;;810      RTC->WPR = 0xCA;
0000c0  4c21              LDR      r4,|L37.328|
0000c2  20ca              MOVS     r0,#0xca
0000c4  341c              ADDS     r4,r4,#0x1c
0000c6  6020              STR      r0,[r4,#0]
;;;811      RTC->WPR = 0x53;
0000c8  2053              MOVS     r0,#0x53
0000ca  6020              STR      r0,[r4,#0]
;;;812    
;;;813      /* Set Initialization mode */
;;;814      if (RTC_EnterInitMode() == ERROR)
0000cc  f7fffffe          BL       RTC_EnterInitMode
0000d0  b150              CBZ      r0,|L37.232|
;;;815      {
;;;816        status = ERROR;
;;;817      } 
;;;818      else
;;;819      {
;;;820        /* Set the RTC_TR register */
;;;821        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
0000d2  481f              LDR      r0,|L37.336|
0000d4  4005              ANDS     r5,r5,r0
0000d6  481c              LDR      r0,|L37.328|
0000d8  3808              SUBS     r0,r0,#8
0000da  6005              STR      r5,[r0,#0]
;;;822    
;;;823        /* Exit Initialization mode */
;;;824        RTC_ExitInitMode(); 
0000dc  f7fffffe          BL       RTC_ExitInitMode
;;;825    
;;;826        if(RTC_WaitForSynchro() == ERROR)
0000e0  f7fffffe          BL       RTC_WaitForSynchro
0000e4  b100              CBZ      r0,|L37.232|
;;;827        {
;;;828          status = ERROR;
;;;829        }
;;;830        else
;;;831        {
;;;832          status = SUCCESS;
0000e6  2601              MOVS     r6,#1
                  |L37.232|
;;;833        }
;;;834      
;;;835      }
;;;836      /* Enable the write protection for RTC registers */
;;;837      RTC->WPR = 0xFF; 
0000e8  20ff              MOVS     r0,#0xff
0000ea  6020              STR      r0,[r4,#0]
;;;838        
;;;839      return status;
0000ec  4630              MOV      r0,r6
;;;840    }
0000ee  e8bd81f0          POP      {r4-r8,pc}
                  |L37.242|
0000f2  70e5              STRB     r5,[r4,#3]            ;786
0000f4  7820              LDRB     r0,[r4,#0]            ;787
0000f6  f7fffffe          BL       RTC_Bcd2ToByte
0000fa  2817              CMP      r0,#0x17              ;787
0000fc  d904              BLS      |L37.264|
0000fe  f2403113          MOV      r1,#0x313             ;787
                  |L37.258|
000102  4812              LDR      r0,|L37.332|
000104  f7fffffe          BL       assert_failed
                  |L37.264|
000108  7860              LDRB     r0,[r4,#1]            ;789
00010a  f7fffffe          BL       RTC_Bcd2ToByte
00010e  283b              CMP      r0,#0x3b              ;789
000110  d904              BLS      |L37.284|
000112  f2403115          MOV      r1,#0x315             ;789
000116  480d              LDR      r0,|L37.332|
000118  f7fffffe          BL       assert_failed
                  |L37.284|
00011c  78a0              LDRB     r0,[r4,#2]            ;790
00011e  f7fffffe          BL       RTC_Bcd2ToByte
000122  283b              CMP      r0,#0x3b              ;790
000124  d904              BLS      |L37.304|
000126  f2403116          MOV      r1,#0x316             ;790
00012a  4808              LDR      r0,|L37.332|
00012c  f7fffffe          BL       assert_failed
                  |L37.304|
000130  78a0              LDRB     r0,[r4,#2]            ;796
000132  7821              LDRB     r1,[r4,#0]            ;796
000134  ea404501          ORR      r5,r0,r1,LSL #16      ;796
000138  7860              LDRB     r0,[r4,#1]            ;796
00013a  78e1              LDRB     r1,[r4,#3]            ;796
00013c  0200              LSLS     r0,r0,#8              ;796
00013e  ea404001          ORR      r0,r0,r1,LSL #16      ;796
000142  4305              ORRS     r5,r5,r0              ;796
000144  e7bc              B        |L37.192|
;;;841    
                          ENDP

000146  0000              DCW      0x0000
                  |L37.328|
                          DCD      0x40002808
                  |L37.332|
                          DCD      ||.conststring||
                  |L37.336|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_SetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_SetWakeUpCounter PROC
;;;1493     */
;;;1494   void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
000000  b510              PUSH     {r4,lr}
;;;1495   {
000002  4604              MOV      r4,r0
;;;1496     /* Check the parameters */
;;;1497     assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
000004  f5b03f80          CMP      r0,#0x10000
000008  d304              BCC      |L38.20|
00000a  f24051d9          MOV      r1,#0x5d9
00000e  4807              LDR      r0,|L38.44|
000010  f7fffffe          BL       assert_failed
                  |L38.20|
;;;1498     
;;;1499     /* Disable the write protection for RTC registers */
;;;1500     RTC->WPR = 0xCA;
000014  4906              LDR      r1,|L38.48|
000016  20ca              MOVS     r0,#0xca
000018  6008              STR      r0,[r1,#0]
;;;1501     RTC->WPR = 0x53;
00001a  2053              MOVS     r0,#0x53
00001c  6008              STR      r0,[r1,#0]
;;;1502     
;;;1503     /* Configure the Wakeup Timer counter */
;;;1504     RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
00001e  4804              LDR      r0,|L38.48|
000020  3810              SUBS     r0,r0,#0x10
000022  6004              STR      r4,[r0,#0]
;;;1505     
;;;1506     /* Enable the write protection for RTC registers */
;;;1507     RTC->WPR = 0xFF; 
000024  20ff              MOVS     r0,#0xff
000026  6008              STR      r0,[r1,#0]
;;;1508   }
000028  bd10              POP      {r4,pc}
;;;1509   
                          ENDP

00002a  0000              DCW      0x0000
                  |L38.44|
                          DCD      ||.conststring||
                  |L38.48|
                          DCD      0x40002824

                          AREA ||i.RTC_SmoothCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_SmoothCalibConfig PROC
;;;1878   */
;;;1879   ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1880                                     uint32_t RTC_SmoothCalibPlusPulses,
;;;1881                                     uint32_t RTC_SmouthCalibMinusPulsesValue)
;;;1882   {
000004  4617              MOV      r7,r2
000006  460e              MOV      r6,r1
000008  0005              MOVS     r5,r0
;;;1883     ErrorStatus status = ERROR;
;;;1884     uint32_t recalpfcount = 0;
00000a  f04f0400          MOV      r4,#0
00000e  d00a              BEQ      |L39.38|
;;;1885   
;;;1886     /* Check the parameters */
;;;1887     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
000010  f5b55f00          CMP      r5,#0x2000
000014  d007              BEQ      |L39.38|
000016  f5b54f80          CMP      r5,#0x4000
00001a  d004              BEQ      |L39.38|
00001c  f240715f          MOV      r1,#0x75f
000020  481a              LDR      r0,|L39.140|
000022  f7fffffe          BL       assert_failed
                  |L39.38|
;;;1888     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
000026  f5b64f00          CMP      r6,#0x8000
00002a  d005              BEQ      |L39.56|
00002c  b126              CBZ      r6,|L39.56|
00002e  f44f61ec          MOV      r1,#0x760
000032  4816              LDR      r0,|L39.140|
000034  f7fffffe          BL       assert_failed
                  |L39.56|
;;;1889     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
000038  f5b77f00          CMP      r7,#0x200
00003c  d304              BCC      |L39.72|
00003e  f2407161          MOV      r1,#0x761
000042  4812              LDR      r0,|L39.140|
000044  f7fffffe          BL       assert_failed
                  |L39.72|
;;;1890   
;;;1891     /* Disable the write protection for RTC registers */
;;;1892     RTC->WPR = 0xCA;
000048  4911              LDR      r1,|L39.144|
00004a  20ca              MOVS     r0,#0xca
00004c  6008              STR      r0,[r1,#0]
;;;1893     RTC->WPR = 0x53;
00004e  2053              MOVS     r0,#0x53
000050  6008              STR      r0,[r1,#0]
;;;1894     
;;;1895     /* check if a calibration is pending*/
;;;1896     if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
000052  480f              LDR      r0,|L39.144|
000054  3818              SUBS     r0,r0,#0x18
000056  6802              LDR      r2,[r0,#0]
000058  03d2              LSLS     r2,r2,#15
00005a  d508              BPL      |L39.110|
;;;1897     {
;;;1898       /* wait until the Calibration is completed*/
;;;1899       while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
00005c  f44f3200          MOV      r2,#0x20000
                  |L39.96|
000060  6803              LDR      r3,[r0,#0]
000062  03db              LSLS     r3,r3,#15
000064  d503              BPL      |L39.110|
000066  4294              CMP      r4,r2
000068  d001              BEQ      |L39.110|
00006a  1c64              ADDS     r4,r4,#1
;;;1900       {
;;;1901         recalpfcount++;
00006c  e7f8              B        |L39.96|
                  |L39.110|
;;;1902       }
;;;1903     }
;;;1904   
;;;1905     /* check if the calibration pending is completed or if there is no calibration operation at all*/
;;;1906     if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
00006e  6800              LDR      r0,[r0,#0]
000070  03c0              LSLS     r0,r0,#15
000072  d406              BMI      |L39.130|
;;;1907     {
;;;1908       /* Configure the Smooth calibration settings */
;;;1909       RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
000074  4335              ORRS     r5,r5,r6
000076  4806              LDR      r0,|L39.144|
000078  433d              ORRS     r5,r5,r7
00007a  3018              ADDS     r0,r0,#0x18
00007c  6005              STR      r5,[r0,#0]
;;;1910   
;;;1911       status = SUCCESS;
00007e  2001              MOVS     r0,#1
000080  e000              B        |L39.132|
                  |L39.130|
;;;1912     }
;;;1913     else
;;;1914     {
;;;1915       status = ERROR;
000082  2000              MOVS     r0,#0
                  |L39.132|
;;;1916     }
;;;1917   
;;;1918     /* Enable the write protection for RTC registers */
;;;1919     RTC->WPR = 0xFF;
000084  22ff              MOVS     r2,#0xff
000086  600a              STR      r2,[r1,#0]
;;;1920     
;;;1921     return (ErrorStatus)(status);
;;;1922   }
000088  e8bd81f0          POP      {r4-r8,pc}
;;;1923   
                          ENDP

                  |L39.140|
                          DCD      ||.conststring||
                  |L39.144|
                          DCD      0x40002824

                          AREA ||i.RTC_StructInit||, CODE, READONLY, ALIGN=1

                  RTC_StructInit PROC
;;;490      */
;;;491    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
000000  2100              MOVS     r1,#0
;;;492    {
;;;493      /* Initialize the RTC_HourFormat member */
;;;494      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
;;;495        
;;;496      /* Initialize the RTC_AsynchPrediv member */
;;;497      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
000002  6001              STR      r1,[r0,#0]
000004  217f              MOVS     r1,#0x7f
;;;498    
;;;499      /* Initialize the RTC_SynchPrediv member */
;;;500      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
000006  6041              STR      r1,[r0,#4]
000008  21ff              MOVS     r1,#0xff
00000a  6081              STR      r1,[r0,#8]
;;;501    }
00000c  4770              BX       lr
;;;502    
                          ENDP


                          AREA ||i.RTC_SynchroShiftConfig||, CODE, READONLY, ALIGN=2

                  RTC_SynchroShiftConfig PROC
;;;2410   */
;;;2411   ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2412   {
000004  460f              MOV      r7,r1
000006  0005              MOVS     r5,r0
;;;2413     ErrorStatus status = ERROR;
;;;2414     uint32_t shpfcount = 0;
000008  f04f0400          MOV      r4,#0
00000c  d007              BEQ      |L41.30|
;;;2415   
;;;2416     /* Check the parameters */
;;;2417     assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
00000e  f1b54f00          CMP      r5,#0x80000000
000012  d004              BEQ      |L41.30|
000014  f6401171          MOV      r1,#0x971
000018  4819              LDR      r0,|L41.128|
00001a  f7fffffe          BL       assert_failed
                  |L41.30|
;;;2418     assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
00001e  f5b74f00          CMP      r7,#0x8000
000022  d304              BCC      |L41.46|
000024  f6401172          MOV      r1,#0x972
000028  4815              LDR      r0,|L41.128|
00002a  f7fffffe          BL       assert_failed
                  |L41.46|
;;;2419   
;;;2420     /* Disable the write protection for RTC registers */
;;;2421     RTC->WPR = 0xCA;
00002e  4e15              LDR      r6,|L41.132|
000030  20ca              MOVS     r0,#0xca
000032  6030              STR      r0,[r6,#0]
;;;2422     RTC->WPR = 0x53;
000034  2053              MOVS     r0,#0x53
000036  6030              STR      r0,[r6,#0]
;;;2423     
;;;2424     /* Check if a Shift is pending*/
;;;2425     if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
000038  4812              LDR      r0,|L41.132|
00003a  3818              SUBS     r0,r0,#0x18
00003c  6801              LDR      r1,[r0,#0]
00003e  0709              LSLS     r1,r1,#28
000040  d507              BPL      |L41.82|
;;;2426     {
;;;2427       /* Wait until the shift is completed*/
;;;2428       while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
000042  1482              ASRS     r2,r0,#18
                  |L41.68|
000044  6801              LDR      r1,[r0,#0]
000046  0709              LSLS     r1,r1,#28
000048  d503              BPL      |L41.82|
00004a  4294              CMP      r4,r2
00004c  d001              BEQ      |L41.82|
00004e  1c64              ADDS     r4,r4,#1
;;;2429       {
;;;2430         shpfcount++;
000050  e7f8              B        |L41.68|
                  |L41.82|
;;;2431       }
;;;2432     }
;;;2433   
;;;2434     /* Check if the Shift pending is completed or if there is no Shift operation at all*/
;;;2435     if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
000052  6800              LDR      r0,[r0,#0]
000054  0700              LSLS     r0,r0,#28
000056  d40d              BMI      |L41.116|
;;;2436     {
;;;2437       /* check if the reference clock detection is disabled */
;;;2438       if((RTC->CR & RTC_CR_REFCKON) == RESET)
000058  480a              LDR      r0,|L41.132|
00005a  381c              SUBS     r0,r0,#0x1c
00005c  6800              LDR      r0,[r0,#0]
00005e  06c0              LSLS     r0,r0,#27
000060  d408              BMI      |L41.116|
;;;2439       {
;;;2440         /* Configure the Shift settings */
;;;2441         RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
000062  4808              LDR      r0,|L41.132|
000064  432f              ORRS     r7,r7,r5
000066  3008              ADDS     r0,r0,#8
000068  6007              STR      r7,[r0,#0]
;;;2442       
;;;2443         if(RTC_WaitForSynchro() == ERROR)
00006a  f7fffffe          BL       RTC_WaitForSynchro
00006e  b110              CBZ      r0,|L41.118|
;;;2444         {
;;;2445           status = ERROR;
;;;2446         }
;;;2447         else
;;;2448         {
;;;2449           status = SUCCESS;
000070  2001              MOVS     r0,#1
000072  e000              B        |L41.118|
                  |L41.116|
;;;2450         }
;;;2451       }
;;;2452       else
;;;2453       {
;;;2454         status = ERROR;
000074  2000              MOVS     r0,#0
                  |L41.118|
;;;2455       }
;;;2456     }
;;;2457     else
;;;2458     {
;;;2459       status = ERROR;
;;;2460     }
;;;2461   
;;;2462     /* Enable the write protection for RTC registers */
;;;2463     RTC->WPR = 0xFF;
000076  21ff              MOVS     r1,#0xff
000078  6031              STR      r1,[r6,#0]
;;;2464     
;;;2465     return (ErrorStatus)(status);
;;;2466   }
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;2467   
                          ENDP

00007e  0000              DCW      0x0000
                  |L41.128|
                          DCD      ||.conststring||
                  |L41.132|
                          DCD      0x40002824

                          AREA ||i.RTC_TamperCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperCmd PROC
;;;2103     */
;;;2104   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;2105   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;2106     /* Check the parameters */
;;;2107     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
000006  2801              CMP      r0,#1
000008  d004              BEQ      |L42.20|
00000a  f640013b          MOV      r1,#0x83b
00000e  4809              LDR      r0,|L42.52|
000010  f7fffffe          BL       assert_failed
                  |L42.20|
;;;2108     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2109     
;;;2110     if (NewState != DISABLE)
;;;2111     {
;;;2112       /* Enable the selected Tamper pin */
;;;2113       RTC->TAFCR |= (uint32_t)RTC_Tamper;
000014  4e08              LDR      r6,|L42.56|
000016  b14d              CBZ      r5,|L42.44|
000018  2d01              CMP      r5,#1                 ;2108
00001a  d004              BEQ      |L42.38|
00001c  f640013c          MOV      r1,#0x83c             ;2108
000020  4804              LDR      r0,|L42.52|
000022  f7fffffe          BL       assert_failed
                  |L42.38|
000026  6830              LDR      r0,[r6,#0]
000028  4320              ORRS     r0,r0,r4
00002a  e001              B        |L42.48|
                  |L42.44|
;;;2114     }
;;;2115     else
;;;2116     {
;;;2117       /* Disable the selected Tamper pin */
;;;2118       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
00002c  6830              LDR      r0,[r6,#0]
00002e  43a0              BICS     r0,r0,r4
                  |L42.48|
000030  6030              STR      r0,[r6,#0]            ;2113
;;;2119     }  
;;;2120   }
000032  bd70              POP      {r4-r6,pc}
;;;2121   
                          ENDP

                  |L42.52|
                          DCD      ||.conststring||
                  |L42.56|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperFilterConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperFilterConfig PROC
;;;2134     */
;;;2135   void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
000000  b510              PUSH     {r4,lr}
;;;2136   {
000002  0004              MOVS     r4,r0
000004  d00d              BEQ      |L43.34|
;;;2137     /* Check the parameters */
;;;2138     assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
000006  f5b46f00          CMP      r4,#0x800
00000a  d00a              BEQ      |L43.34|
00000c  f5b45f80          CMP      r4,#0x1000
000010  d007              BEQ      |L43.34|
000012  f5b45fc0          CMP      r4,#0x1800
000016  d004              BEQ      |L43.34|
000018  f640015a          MOV      r1,#0x85a
00001c  4805              LDR      r0,|L43.52|
00001e  f7fffffe          BL       assert_failed
                  |L43.34|
;;;2139      
;;;2140     /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
;;;2141     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
000022  4805              LDR      r0,|L43.56|
000024  6801              LDR      r1,[r0,#0]
000026  f42151c0          BIC      r1,r1,#0x1800
00002a  6001              STR      r1,[r0,#0]
;;;2142   
;;;2143     /* Configure the RTC_TAFCR register */
;;;2144     RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
00002c  6801              LDR      r1,[r0,#0]
00002e  4321              ORRS     r1,r1,r4
000030  6001              STR      r1,[r0,#0]
;;;2145   }
000032  bd10              POP      {r4,pc}
;;;2146   
                          ENDP

                  |L43.52|
                          DCD      ||.conststring||
                  |L43.56|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinSelection PROC
;;;2336     */
;;;2337   void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
000000  b510              PUSH     {r4,lr}
;;;2338   {
000002  0004              MOVS     r4,r0
000004  d007              BEQ      |L44.22|
;;;2339     /* Check the parameters */
;;;2340     assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
000006  f5b43f80          CMP      r4,#0x10000
00000a  d004              BEQ      |L44.22|
00000c  f6401124          MOV      r1,#0x924
000010  4805              LDR      r0,|L44.40|
000012  f7fffffe          BL       assert_failed
                  |L44.22|
;;;2341     
;;;2342     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
000016  4805              LDR      r0,|L44.44|
000018  6801              LDR      r1,[r0,#0]
00001a  f4213180          BIC      r1,r1,#0x10000
00001e  6001              STR      r1,[r0,#0]
;;;2343     RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
000020  6801              LDR      r1,[r0,#0]
000022  4321              ORRS     r1,r1,r4
000024  6001              STR      r1,[r0,#0]
;;;2344   }
000026  bd10              POP      {r4,pc}
;;;2345   
                          ENDP

                  |L44.40|
                          DCD      ||.conststring||
                  |L44.44|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinsPrechargeDuration||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinsPrechargeDuration PROC
;;;2191     */
;;;2192   void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
000000  b510              PUSH     {r4,lr}
;;;2193   {
000002  0004              MOVS     r4,r0
000004  d00d              BEQ      |L45.34|
;;;2194     /* Check the parameters */
;;;2195     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
000006  f5b45f00          CMP      r4,#0x2000
00000a  d00a              BEQ      |L45.34|
00000c  f5b44f80          CMP      r4,#0x4000
000010  d007              BEQ      |L45.34|
000012  f5b44fc0          CMP      r4,#0x6000
000016  d004              BEQ      |L45.34|
000018  f6400193          MOV      r1,#0x893
00001c  4805              LDR      r0,|L45.52|
00001e  f7fffffe          BL       assert_failed
                  |L45.34|
;;;2196      
;;;2197     /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
;;;2198     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
000022  4805              LDR      r0,|L45.56|
000024  6801              LDR      r1,[r0,#0]
000026  f42141c0          BIC      r1,r1,#0x6000
00002a  6001              STR      r1,[r0,#0]
;;;2199   
;;;2200     /* Configure the RTC_TAFCR register */
;;;2201     RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
00002c  6801              LDR      r1,[r0,#0]
00002e  4321              ORRS     r1,r1,r4
000030  6001              STR      r1,[r0,#0]
;;;2202   }
000032  bd10              POP      {r4,pc}
;;;2203   
                          ENDP

                  |L45.52|
                          DCD      ||.conststring||
                  |L45.56|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPullUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperPullUpCmd PROC
;;;2234     */
;;;2235   void RTC_TamperPullUpCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;2236   {
;;;2237     /* Check the parameters */
;;;2238     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2239     
;;;2240    if (NewState != DISABLE)
;;;2241     {
;;;2242       /* Enable precharge of the selected Tamper pin */
;;;2243       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
000002  4c09              LDR      r4,|L46.40|
000004  b150              CBZ      r0,|L46.28|
000006  2801              CMP      r0,#1                 ;2238
000008  d004              BEQ      |L46.20|
00000a  f64001be          MOV      r1,#0x8be             ;2238
00000e  4807              LDR      r0,|L46.44|
000010  f7fffffe          BL       assert_failed
                  |L46.20|
000014  6820              LDR      r0,[r4,#0]
000016  f4204000          BIC      r0,r0,#0x8000
00001a  e002              B        |L46.34|
                  |L46.28|
;;;2244     }
;;;2245     else
;;;2246     {
;;;2247       /* Disable precharge of the selected Tamper pin */
;;;2248       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
00001c  6820              LDR      r0,[r4,#0]
00001e  f4404000          ORR      r0,r0,#0x8000
                  |L46.34|
000022  6020              STR      r0,[r4,#0]            ;2243
;;;2249     } 
;;;2250   }
000024  bd10              POP      {r4,pc}
;;;2251   
                          ENDP

000026  0000              DCW      0x0000
                  |L46.40|
                          DCD      0x40002840
                  |L46.44|
                          DCD      ||.conststring||

                          AREA ||i.RTC_TamperSamplingFreqConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperSamplingFreqConfig PROC
;;;2168     */
;;;2169   void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
000000  b510              PUSH     {r4,lr}
;;;2170   {
000002  0004              MOVS     r4,r0
000004  d019              BEQ      |L47.58|
;;;2171     /* Check the parameters */
;;;2172     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
000006  f5b47f80          CMP      r4,#0x100
00000a  d016              BEQ      |L47.58|
00000c  f5b47f00          CMP      r4,#0x200
000010  d013              BEQ      |L47.58|
000012  f5b47f40          CMP      r4,#0x300
000016  d010              BEQ      |L47.58|
000018  f5b46f80          CMP      r4,#0x400
00001c  d00d              BEQ      |L47.58|
00001e  f5b46fa0          CMP      r4,#0x500
000022  d00a              BEQ      |L47.58|
000024  f5b46fc0          CMP      r4,#0x600
000028  d007              BEQ      |L47.58|
00002a  f5b46fe0          CMP      r4,#0x700
00002e  d004              BEQ      |L47.58|
000030  f640017c          MOV      r1,#0x87c
000034  4805              LDR      r0,|L47.76|
000036  f7fffffe          BL       assert_failed
                  |L47.58|
;;;2173    
;;;2174     /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
;;;2175     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
00003a  4805              LDR      r0,|L47.80|
00003c  6801              LDR      r1,[r0,#0]
00003e  f42161e0          BIC      r1,r1,#0x700
000042  6001              STR      r1,[r0,#0]
;;;2176   
;;;2177     /* Configure the RTC_TAFCR register */
;;;2178     RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
000044  6801              LDR      r1,[r0,#0]
000046  4321              ORRS     r1,r1,r4
000048  6001              STR      r1,[r0,#0]
;;;2179   }
00004a  bd10              POP      {r4,pc}
;;;2180   
                          ENDP

                  |L47.76|
                          DCD      ||.conststring||
                  |L47.80|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperTriggerConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperTriggerConfig PROC
;;;2077     */
;;;2078   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000000  b570              PUSH     {r4-r6,lr}
;;;2079   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;2080     /* Check the parameters */
;;;2081     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
000006  2801              CMP      r0,#1
000008  d004              BEQ      |L48.20|
00000a  f6400121          MOV      r1,#0x821
00000e  480a              LDR      r0,|L48.56|
000010  f7fffffe          BL       assert_failed
                  |L48.20|
;;;2082     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;2083    
;;;2084     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
;;;2085     {  
;;;2086       /* Configure the RTC_TAFCR register */
;;;2087       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
000014  4e09              LDR      r6,|L48.60|
000016  b15d              CBZ      r5,|L48.48|
000018  2d01              CMP      r5,#1                 ;2082
00001a  d004              BEQ      |L48.38|
00001c  f6400122          MOV      r1,#0x822             ;2082
000020  4805              LDR      r0,|L48.56|
000022  f7fffffe          BL       assert_failed
                  |L48.38|
;;;2088     }
;;;2089     else
;;;2090     { 
;;;2091       /* Configure the RTC_TAFCR register */
;;;2092       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
000026  6830              LDR      r0,[r6,#0]
000028  ea400044          ORR      r0,r0,r4,LSL #1
                  |L48.44|
00002c  6030              STR      r0,[r6,#0]            ;2087
;;;2093     }  
;;;2094   }
00002e  bd70              POP      {r4-r6,pc}
                  |L48.48|
000030  6830              LDR      r0,[r6,#0]            ;2087
000032  ea200044          BIC      r0,r0,r4,LSL #1       ;2087
000036  e7f9              B        |L48.44|
;;;2095   
                          ENDP

                  |L48.56|
                          DCD      ||.conststring||
                  |L48.60|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampCmd PROC
;;;1954     */
;;;1955   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1956   {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d006              BEQ      |L49.22|
;;;1957     uint32_t tmpreg = 0;
;;;1958   
;;;1959     /* Check the parameters */
;;;1960     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
000008  2c08              CMP      r4,#8
00000a  d004              BEQ      |L49.22|
00000c  f44f61f5          MOV      r1,#0x7a8
000010  480f              LDR      r0,|L49.80|
000012  f7fffffe          BL       assert_failed
                  |L49.22|
;;;1961     assert_param(IS_FUNCTIONAL_STATE(NewState));
000016  b135              CBZ      r5,|L49.38|
000018  2d01              CMP      r5,#1
00001a  d004              BEQ      |L49.38|
00001c  f24071a9          MOV      r1,#0x7a9
000020  480b              LDR      r0,|L49.80|
000022  f7fffffe          BL       assert_failed
                  |L49.38|
;;;1962   
;;;1963     /* Get the RTC_CR register and clear the bits to be configured */
;;;1964     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000026  4a0b              LDR      r2,|L49.84|
000028  6810              LDR      r0,[r2,#0]
00002a  f6400108          MOV      r1,#0x808
00002e  4388              BICS     r0,r0,r1
;;;1965   
;;;1966     /* Get the new configuration */
;;;1967     if (NewState != DISABLE)
;;;1968     {
;;;1969       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
;;;1970     }
;;;1971     else
;;;1972     {
;;;1973       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
000030  ea400004          ORR      r0,r0,r4
000034  b10d              CBZ      r5,|L49.58|
000036  f4406000          ORR      r0,r0,#0x800          ;1969
                  |L49.58|
;;;1974     }
;;;1975   
;;;1976     /* Disable the write protection for RTC registers */
;;;1977     RTC->WPR = 0xCA;
00003a  4906              LDR      r1,|L49.84|
00003c  23ca              MOVS     r3,#0xca
00003e  311c              ADDS     r1,r1,#0x1c
000040  600b              STR      r3,[r1,#0]
;;;1978     RTC->WPR = 0x53;
000042  2353              MOVS     r3,#0x53
000044  600b              STR      r3,[r1,#0]
;;;1979   
;;;1980     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;1981     RTC->CR = (uint32_t)tmpreg;
000046  6010              STR      r0,[r2,#0]
;;;1982   
;;;1983     /* Enable the write protection for RTC registers */
;;;1984     RTC->WPR = 0xFF; 
000048  20ff              MOVS     r0,#0xff
00004a  6008              STR      r0,[r1,#0]
;;;1985   }
00004c  bd70              POP      {r4-r6,pc}
;;;1986   
                          ENDP

00004e  0000              DCW      0x0000
                  |L49.80|
                          DCD      ||.conststring||
                  |L49.84|
                          DCD      0x40002808

                          AREA ||i.RTC_TimeStampOnTamperDetectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampOnTamperDetectionCmd PROC
;;;2211     */
;;;2212   void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;2213   {
;;;2214     /* Check the parameters */
;;;2215     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2216      
;;;2217     if (NewState != DISABLE)
;;;2218     {
;;;2219       /* Save timestamp on tamper detection event */
;;;2220       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
000002  4c09              LDR      r4,|L50.40|
000004  b150              CBZ      r0,|L50.28|
000006  2801              CMP      r0,#1                 ;2215
000008  d004              BEQ      |L50.20|
00000a  f64001a7          MOV      r1,#0x8a7             ;2215
00000e  4807              LDR      r0,|L50.44|
000010  f7fffffe          BL       assert_failed
                  |L50.20|
000014  6820              LDR      r0,[r4,#0]
000016  f0400080          ORR      r0,r0,#0x80
00001a  e002              B        |L50.34|
                  |L50.28|
;;;2221     }
;;;2222     else
;;;2223     {
;;;2224       /* Tamper detection does not cause a timestamp to be saved */
;;;2225       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
00001c  6820              LDR      r0,[r4,#0]
00001e  f0200080          BIC      r0,r0,#0x80
                  |L50.34|
000022  6020              STR      r0,[r4,#0]            ;2220
;;;2226     }
;;;2227   }
000024  bd10              POP      {r4,pc}
;;;2228   
                          ENDP

000026  0000              DCW      0x0000
                  |L50.40|
                          DCD      0x40002840
                  |L50.44|
                          DCD      ||.conststring||

                          AREA ||i.RTC_TimeStampPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampPinSelection PROC
;;;2353     */
;;;2354   void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
000000  b510              PUSH     {r4,lr}
;;;2355   {
000002  0004              MOVS     r4,r0
000004  d007              BEQ      |L51.22|
;;;2356     /* Check the parameters */
;;;2357     assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
000006  f5b43f00          CMP      r4,#0x20000
00000a  d004              BEQ      |L51.22|
00000c  f6401135          MOV      r1,#0x935
000010  4805              LDR      r0,|L51.40|
000012  f7fffffe          BL       assert_failed
                  |L51.22|
;;;2358     
;;;2359     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
000016  4805              LDR      r0,|L51.44|
000018  6801              LDR      r1,[r0,#0]
00001a  f4213100          BIC      r1,r1,#0x20000
00001e  6001              STR      r1,[r0,#0]
;;;2360     RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
000020  6801              LDR      r1,[r0,#0]
000022  4321              ORRS     r1,r1,r4
000024  6001              STR      r1,[r0,#0]
;;;2361   }
000026  bd10              POP      {r4,pc}
;;;2362   
                          ENDP

                  |L51.40|
                          DCD      ||.conststring||
                  |L51.44|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStructInit||, CODE, READONLY, ALIGN=1

                  RTC_TimeStructInit PROC
;;;848      */
;;;849    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
000000  2100              MOVS     r1,#0
;;;850    {
;;;851      /* Time = 00h:00min:00sec */
;;;852      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;853      RTC_TimeStruct->RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;854      RTC_TimeStruct->RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;855      RTC_TimeStruct->RTC_Seconds = 0; 
000008  7081              STRB     r1,[r0,#2]
;;;856    }
00000a  4770              BX       lr
;;;857    
                          ENDP


                          AREA ||i.RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;606      */
;;;607    ErrorStatus RTC_WaitForSynchro(void)
000000  b518              PUSH     {r3,r4,lr}
;;;608    {
;;;609      __IO uint32_t synchrocounter = 0;
000002  2000              MOVS     r0,#0
;;;610      ErrorStatus status = ERROR;
;;;611      uint32_t synchrostatus = 0x00;
;;;612    
;;;613      /* Disable the write protection for RTC registers */
;;;614      RTC->WPR = 0xCA;
000004  4b10              LDR      r3,|L53.72|
000006  9000              STR      r0,[sp,#0]
000008  20ca              MOVS     r0,#0xca
00000a  6018              STR      r0,[r3,#0]
;;;615      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6018              STR      r0,[r3,#0]
;;;616        
;;;617      /* Clear RSF flag */
;;;618      RTC->ISR &= (uint32_t)RTC_RSF_MASK;
000010  490d              LDR      r1,|L53.72|
000012  3918              SUBS     r1,r1,#0x18
000014  6808              LDR      r0,[r1,#0]
000016  f02000a0          BIC      r0,r0,#0xa0
00001a  6008              STR      r0,[r1,#0]
;;;619        
;;;620      /* Wait the registers to be synchronised */
;;;621      do
;;;622      {
;;;623        synchrostatus = RTC->ISR & RTC_ISR_RSF;
;;;624        synchrocounter++;  
;;;625      } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
00001c  f44f3400          MOV      r4,#0x20000
                  |L53.32|
000020  6808              LDR      r0,[r1,#0]            ;623
000022  9a00              LDR      r2,[sp,#0]            ;624
000024  f0000020          AND      r0,r0,#0x20           ;623
000028  1c52              ADDS     r2,r2,#1              ;624
00002a  9200              STR      r2,[sp,#0]
00002c  42a2              CMP      r2,r4
00002e  d001              BEQ      |L53.52|
000030  2800              CMP      r0,#0
000032  d0f5              BEQ      |L53.32|
                  |L53.52|
;;;626        
;;;627      if ((RTC->ISR & RTC_ISR_RSF) != RESET)
000034  6808              LDR      r0,[r1,#0]
000036  0680              LSLS     r0,r0,#26
000038  d501              BPL      |L53.62|
;;;628      {
;;;629        status = SUCCESS;
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L53.64|
                  |L53.62|
;;;630      }
;;;631      else
;;;632      {
;;;633        status = ERROR;
00003e  2000              MOVS     r0,#0
                  |L53.64|
;;;634      }        
;;;635    
;;;636      /* Enable the write protection for RTC registers */
;;;637      RTC->WPR = 0xFF; 
000040  21ff              MOVS     r1,#0xff
000042  6019              STR      r1,[r3,#0]
;;;638        
;;;639      return (status); 
;;;640    }
000044  bd18              POP      {r3,r4,pc}
;;;641    
                          ENDP

000046  0000              DCW      0x0000
                  |L53.72|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpClockConfig||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpClockConfig PROC
;;;1466     */
;;;1467   void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
000000  b510              PUSH     {r4,lr}
;;;1468   {
000002  0004              MOVS     r4,r0
000004  d00e              BEQ      |L54.36|
;;;1469     /* Check the parameters */
;;;1470     assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
000006  2c01              CMP      r4,#1
000008  d00c              BEQ      |L54.36|
00000a  2c02              CMP      r4,#2
00000c  d00a              BEQ      |L54.36|
00000e  2c03              CMP      r4,#3
000010  d008              BEQ      |L54.36|
000012  2c04              CMP      r4,#4
000014  d006              BEQ      |L54.36|
000016  2c06              CMP      r4,#6
000018  d004              BEQ      |L54.36|
00001a  f24051be          MOV      r1,#0x5be
00001e  480a              LDR      r0,|L54.72|
000020  f7fffffe          BL       assert_failed
                  |L54.36|
;;;1471   
;;;1472     /* Disable the write protection for RTC registers */
;;;1473     RTC->WPR = 0xCA;
000024  4909              LDR      r1,|L54.76|
000026  20ca              MOVS     r0,#0xca
000028  6008              STR      r0,[r1,#0]
;;;1474     RTC->WPR = 0x53;
00002a  2053              MOVS     r0,#0x53
00002c  6008              STR      r0,[r1,#0]
;;;1475   
;;;1476     /* Clear the Wakeup Timer clock source bits in CR register */
;;;1477     RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
00002e  4807              LDR      r0,|L54.76|
000030  381c              SUBS     r0,r0,#0x1c
000032  6802              LDR      r2,[r0,#0]
000034  f0220207          BIC      r2,r2,#7
000038  6002              STR      r2,[r0,#0]
;;;1478   
;;;1479     /* Configure the clock source */
;;;1480     RTC->CR |= (uint32_t)RTC_WakeUpClock;
00003a  6802              LDR      r2,[r0,#0]
00003c  4322              ORRS     r2,r2,r4
00003e  6002              STR      r2,[r0,#0]
;;;1481     
;;;1482     /* Enable the write protection for RTC registers */
;;;1483     RTC->WPR = 0xFF; 
000040  20ff              MOVS     r0,#0xff
000042  6008              STR      r0,[r1,#0]
;;;1484   }
000044  bd10              POP      {r4,pc}
;;;1485   
                          ENDP

000046  0000              DCW      0x0000
                  |L54.72|
                          DCD      ||.conststring||
                  |L54.76|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpCmd PROC
;;;1526     */
;;;1527   ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
000000  b538              PUSH     {r3-r5,lr}
;;;1528   {
000002  0004              MOVS     r4,r0
;;;1529     __IO uint32_t wutcounter = 0x00;
000004  f04f0000          MOV      r0,#0
000008  9000              STR      r0,[sp,#0]            ;1528
00000a  d006              BEQ      |L55.26|
;;;1530     uint32_t wutwfstatus = 0x00;
;;;1531     ErrorStatus status = ERROR;
;;;1532     
;;;1533     /* Check the parameters */
;;;1534     assert_param(IS_FUNCTIONAL_STATE(NewState));
00000c  2c01              CMP      r4,#1
00000e  d004              BEQ      |L55.26|
000010  f24051fe          MOV      r1,#0x5fe
000014  4814              LDR      r0,|L55.104|
000016  f7fffffe          BL       assert_failed
                  |L55.26|
;;;1535   
;;;1536     /* Disable the write protection for RTC registers */
;;;1537     RTC->WPR = 0xCA;
00001a  4b14              LDR      r3,|L55.108|
00001c  20ca              MOVS     r0,#0xca
00001e  6018              STR      r0,[r3,#0]
;;;1538     RTC->WPR = 0x53;
000020  2053              MOVS     r0,#0x53
000022  6018              STR      r0,[r3,#0]
;;;1539   
;;;1540     if (NewState != DISABLE)
;;;1541     {
;;;1542       /* Enable the Wakeup Timer */
;;;1543       RTC->CR |= (uint32_t)RTC_CR_WUTE;
000024  4811              LDR      r0,|L55.108|
000026  381c              SUBS     r0,r0,#0x1c
;;;1544       status = SUCCESS;    
;;;1545     }
;;;1546     else
;;;1547     {
;;;1548       /* Disable the Wakeup Timer */
;;;1549       RTC->CR &= (uint32_t)~RTC_CR_WUTE;
000028  6801              LDR      r1,[r0,#0]
00002a  b11c              CBZ      r4,|L55.52|
00002c  f4416180          ORR      r1,r1,#0x400          ;1543
000030  6001              STR      r1,[r0,#0]            ;1543
000032  e014              B        |L55.94|
                  |L55.52|
000034  f4216180          BIC      r1,r1,#0x400
000038  6001              STR      r1,[r0,#0]
;;;1550       /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;1551       do
;;;1552       {
;;;1553         wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
00003a  490c              LDR      r1,|L55.108|
00003c  3918              SUBS     r1,r1,#0x18
;;;1554         wutcounter++;  
;;;1555       } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
00003e  138c              ASRS     r4,r1,#14
                  |L55.64|
000040  6808              LDR      r0,[r1,#0]            ;1553
000042  9a00              LDR      r2,[sp,#0]            ;1554
000044  f0000004          AND      r0,r0,#4              ;1553
000048  1c52              ADDS     r2,r2,#1              ;1554
00004a  9200              STR      r2,[sp,#0]
00004c  42a2              CMP      r2,r4
00004e  d001              BEQ      |L55.84|
000050  2800              CMP      r0,#0
000052  d0f5              BEQ      |L55.64|
                  |L55.84|
;;;1556       
;;;1557       if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000054  6808              LDR      r0,[r1,#0]
000056  0740              LSLS     r0,r0,#29
000058  d401              BMI      |L55.94|
;;;1558       {
;;;1559         status = ERROR;
00005a  2000              MOVS     r0,#0
00005c  e000              B        |L55.96|
                  |L55.94|
;;;1560       }
;;;1561       else
;;;1562       {
;;;1563         status = SUCCESS;
00005e  2001              MOVS     r0,#1
                  |L55.96|
;;;1564       }    
;;;1565     }
;;;1566   
;;;1567     /* Enable the write protection for RTC registers */
;;;1568     RTC->WPR = 0xFF; 
000060  21ff              MOVS     r1,#0xff
000062  6019              STR      r1,[r3,#0]
;;;1569     
;;;1570     return status;
;;;1571   }
000064  bd38              POP      {r3-r5,pc}
;;;1572   
                          ENDP

000066  0000              DCW      0x0000
                  |L55.104|
                          DCD      ||.conststring||
                  |L55.108|
                          DCD      0x40002824

                          AREA ||i.RTC_WriteBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_WriteBackupRegister PROC
;;;2275     */
;;;2276   void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
000000  b538              PUSH     {r3-r5,lr}
;;;2277   {
000002  0004              MOVS     r4,r0
;;;2278     __IO uint32_t tmp = 0;
000004  f04f0000          MOV      r0,#0
000008  460d              MOV      r5,r1                 ;2277
00000a  9000              STR      r0,[sp,#0]            ;2277
00000c  d02a              BEQ      |L56.100|
;;;2279     
;;;2280     /* Check the parameters */
;;;2281     assert_param(IS_RTC_BKP(RTC_BKP_DR));
00000e  2c01              CMP      r4,#1
000010  d028              BEQ      |L56.100|
000012  2c02              CMP      r4,#2
000014  d026              BEQ      |L56.100|
000016  2c03              CMP      r4,#3
000018  d024              BEQ      |L56.100|
00001a  2c04              CMP      r4,#4
00001c  d022              BEQ      |L56.100|
00001e  2c05              CMP      r4,#5
000020  d020              BEQ      |L56.100|
000022  2c06              CMP      r4,#6
000024  d01e              BEQ      |L56.100|
000026  2c07              CMP      r4,#7
000028  d01c              BEQ      |L56.100|
00002a  2c08              CMP      r4,#8
00002c  d01a              BEQ      |L56.100|
00002e  2c09              CMP      r4,#9
000030  d018              BEQ      |L56.100|
000032  2c0a              CMP      r4,#0xa
000034  d016              BEQ      |L56.100|
000036  2c0b              CMP      r4,#0xb
000038  d014              BEQ      |L56.100|
00003a  2c0c              CMP      r4,#0xc
00003c  d012              BEQ      |L56.100|
00003e  2c0d              CMP      r4,#0xd
000040  d010              BEQ      |L56.100|
000042  2c0e              CMP      r4,#0xe
000044  d00e              BEQ      |L56.100|
000046  2c0f              CMP      r4,#0xf
000048  d00c              BEQ      |L56.100|
00004a  2c10              CMP      r4,#0x10
00004c  d00a              BEQ      |L56.100|
00004e  2c11              CMP      r4,#0x11
000050  d008              BEQ      |L56.100|
000052  2c12              CMP      r4,#0x12
000054  d006              BEQ      |L56.100|
000056  2c13              CMP      r4,#0x13
000058  d004              BEQ      |L56.100|
00005a  f64001e9          MOV      r1,#0x8e9
00005e  4804              LDR      r0,|L56.112|
000060  f7fffffe          BL       assert_failed
                  |L56.100|
;;;2282   
;;;2283     tmp = RTC_BASE + 0x50;
000064  4803              LDR      r0,|L56.116|
;;;2284     tmp += (RTC_BKP_DR * 4);
000066  eb000084          ADD      r0,r0,r4,LSL #2
;;;2285   
;;;2286     /* Write the specified register */
;;;2287     *(__IO uint32_t *)tmp = (uint32_t)Data;
00006a  9000              STR      r0,[sp,#0]
00006c  6005              STR      r5,[r0,#0]
;;;2288   }
00006e  bd38              POP      {r3-r5,pc}
;;;2289   
                          ENDP

                  |L56.112|
                          DCD      ||.conststring||
                  |L56.116|
                          DCD      0x40002850

                          AREA ||i.RTC_WriteProtectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_WriteProtectionCmd PROC
;;;512      */
;;;513    void RTC_WriteProtectionCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;514    {
;;;515      /* Check the parameters */
;;;516      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;517        
;;;518      if (NewState != DISABLE)
;;;519      {
;;;520        /* Enable the write protection for RTC registers */
;;;521        RTC->WPR = 0xFF;   
000002  4c08              LDR      r4,|L57.36|
000004  b140              CBZ      r0,|L57.24|
000006  2801              CMP      r0,#1                 ;516
000008  d004              BEQ      |L57.20|
00000a  f44f7101          MOV      r1,#0x204             ;516
00000e  4806              LDR      r0,|L57.40|
000010  f7fffffe          BL       assert_failed
                  |L57.20|
000014  20ff              MOVS     r0,#0xff
000016  e002              B        |L57.30|
                  |L57.24|
;;;522      }
;;;523      else
;;;524      {
;;;525        /* Disable the write protection for RTC registers */
;;;526        RTC->WPR = 0xCA;
000018  20ca              MOVS     r0,#0xca
00001a  6020              STR      r0,[r4,#0]
;;;527        RTC->WPR = 0x53;    
00001c  2053              MOVS     r0,#0x53
                  |L57.30|
00001e  6020              STR      r0,[r4,#0]            ;521
;;;528      }
;;;529    }
000020  bd10              POP      {r4,pc}
;;;530    
                          ENDP

000022  0000              DCW      0x0000
                  |L57.36|
                          DCD      0x40002824
                  |L57.40|
                          DCD      ||.conststring||

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_rtc.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f727463
00004a  2e6300  

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_rtc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_rtc_c_81435638____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REVSH|
#line 128
|__asm___15_stm32f4xx_rtc_c_81435638____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
