; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_spi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_spi.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_spi.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c]
                          THUMB

                          AREA ||i.I2S_Cmd||, CODE, READONLY, ALIGN=2

                  I2S_Cmd PROC
;;;534      */
;;;535    void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;536    {
000002  4604              MOV      r4,r0
;;;537      /* Check the parameters */
;;;538      assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
000004  4811              LDR      r0,|L1.76|
000006  460d              MOV      r5,r1                 ;536
000008  4284              CMP      r4,r0
00000a  d00d              BEQ      |L1.40|
00000c  4810              LDR      r0,|L1.80|
00000e  4284              CMP      r4,r0
000010  d00a              BEQ      |L1.40|
000012  4810              LDR      r0,|L1.84|
000014  4284              CMP      r4,r0
000016  d007              BEQ      |L1.40|
000018  f1b42f40          CMP      r4,#0x40004000
00001c  d004              BEQ      |L1.40|
00001e  f240211a          MOV      r1,#0x21a
000022  480d              LDR      r0,|L1.88|
000024  f7fffffe          BL       assert_failed
                  |L1.40|
;;;539      assert_param(IS_FUNCTIONAL_STATE(NewState));
000028  b155              CBZ      r5,|L1.64|
00002a  2d01              CMP      r5,#1
00002c  d004              BEQ      |L1.56|
00002e  f240211b          MOV      r1,#0x21b
000032  4809              LDR      r0,|L1.88|
000034  f7fffffe          BL       assert_failed
                  |L1.56|
;;;540      
;;;541      if (NewState != DISABLE)
;;;542      {
;;;543        /* Enable the selected SPI peripheral (in I2S mode) */
;;;544        SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
000038  8ba0              LDRH     r0,[r4,#0x1c]
00003a  f4406080          ORR      r0,r0,#0x400
00003e  e002              B        |L1.70|
                  |L1.64|
;;;545      }
;;;546      else
;;;547      {
;;;548        /* Disable the selected SPI peripheral in I2S mode */
;;;549        SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
000040  8ba0              LDRH     r0,[r4,#0x1c]
000042  f4206080          BIC      r0,r0,#0x400
                  |L1.70|
000046  83a0              STRH     r0,[r4,#0x1c]         ;544
;;;550      }
;;;551    }
000048  bd70              POP      {r4-r6,pc}
;;;552    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      0x40003800
                  |L1.80|
                          DCD      0x40003c00
                  |L1.84|
                          DCD      0x40003400
                  |L1.88|
                          DCD      ||.conststring||

                          AREA ||i.I2S_FullDuplexConfig||, CODE, READONLY, ALIGN=2

                  I2S_FullDuplexConfig PROC
;;;699      */
;;;700    void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;701    {
000004  4605              MOV      r5,r0
;;;702      uint16_t tmpreg = 0, tmp = 0;
;;;703      
;;;704      /* Check the I2S parameters */
;;;705      assert_param(IS_I2S_EXT_PERIPH(I2Sxext));
000006  482f              LDR      r0,|L2.196|
000008  2600              MOVS     r6,#0                 ;702
00000a  460c              MOV      r4,r1                 ;701
00000c  4285              CMP      r5,r0
00000e  d007              BEQ      |L2.32|
000010  f1b52f40          CMP      r5,#0x40004000
000014  d004              BEQ      |L2.32|
000016  f24021c1          MOV      r1,#0x2c1
00001a  482b              LDR      r0,|L2.200|
00001c  f7fffffe          BL       assert_failed
                  |L2.32|
;;;706      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
000020  8820              LDRH     r0,[r4,#0]
000022  f44f7780          MOV      r7,#0x100
000026  f44f7800          MOV      r8,#0x200
00002a  f44f7940          MOV      r9,#0x300
00002e  b150              CBZ      r0,|L2.70|
000030  42b8              CMP      r0,r7
000032  d008              BEQ      |L2.70|
000034  4540              CMP      r0,r8
000036  d006              BEQ      |L2.70|
000038  4548              CMP      r0,r9
00003a  d004              BEQ      |L2.70|
00003c  f24021c2          MOV      r1,#0x2c2
000040  4821              LDR      r0,|L2.200|
000042  f7fffffe          BL       assert_failed
                  |L2.70|
;;;707      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
000046  8860              LDRH     r0,[r4,#2]
000048  b160              CBZ      r0,|L2.100|
00004a  2810              CMP      r0,#0x10
00004c  d00a              BEQ      |L2.100|
00004e  2820              CMP      r0,#0x20
000050  d008              BEQ      |L2.100|
000052  2830              CMP      r0,#0x30
000054  d006              BEQ      |L2.100|
000056  28b0              CMP      r0,#0xb0
000058  d004              BEQ      |L2.100|
00005a  f24021c3          MOV      r1,#0x2c3
00005e  481a              LDR      r0,|L2.200|
000060  f7fffffe          BL       assert_failed
                  |L2.100|
;;;708      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
000064  88a0              LDRH     r0,[r4,#4]
000066  b150              CBZ      r0,|L2.126|
000068  2801              CMP      r0,#1
00006a  d008              BEQ      |L2.126|
00006c  2803              CMP      r0,#3
00006e  d006              BEQ      |L2.126|
000070  2805              CMP      r0,#5
000072  d004              BEQ      |L2.126|
000074  f44f7131          MOV      r1,#0x2c4
000078  4813              LDR      r0,|L2.200|
00007a  f7fffffe          BL       assert_failed
                  |L2.126|
;;;709      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
00007e  89a0              LDRH     r0,[r4,#0xc]
000080  b130              CBZ      r0,|L2.144|
000082  2808              CMP      r0,#8
000084  d004              BEQ      |L2.144|
000086  f24021c5          MOV      r1,#0x2c5
00008a  480f              LDR      r0,|L2.200|
00008c  f7fffffe          BL       assert_failed
                  |L2.144|
;;;710    
;;;711    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;712      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;713      I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
000090  8ba8              LDRH     r0,[r5,#0x1c]
000092  f24f0140          MOV      r1,#0xf040
000096  4008              ANDS     r0,r0,r1
000098  83a8              STRH     r0,[r5,#0x1c]
;;;714      I2Sxext->I2SPR = 0x0002;
00009a  2002              MOVS     r0,#2
00009c  8428              STRH     r0,[r5,#0x20]
;;;715      
;;;716      /* Get the I2SCFGR register value */
;;;717      tmpreg = I2Sxext->I2SCFGR;
00009e  8ba9              LDRH     r1,[r5,#0x1c]
;;;718      
;;;719      /* Get the mode to be configured for the extended I2S */
;;;720      if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
0000a0  8820              LDRH     r0,[r4,#0]
0000a2  4540              CMP      r0,r8
0000a4  d000              BEQ      |L2.168|
0000a6  b900              CBNZ     r0,|L2.170|
                  |L2.168|
;;;721      {
;;;722        tmp = I2S_Mode_SlaveRx;
0000a8  463e              MOV      r6,r7
                  |L2.170|
;;;723      }
;;;724      else
;;;725      {
;;;726        if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
;;;727        {
;;;728          tmp = I2S_Mode_SlaveTx;
;;;729        }
;;;730      }
;;;731    
;;;732     
;;;733      /* Configure the I2S with the SPI_InitStruct values */
;;;734      tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
0000aa  8860              LDRH     r0,[r4,#2]
0000ac  88a2              LDRH     r2,[r4,#4]
0000ae  4310              ORRS     r0,r0,r2
0000b0  89a2              LDRH     r2,[r4,#0xc]
0000b2  4332              ORRS     r2,r2,r6
0000b4  4310              ORRS     r0,r0,r2
0000b6  4308              ORRS     r0,r0,r1
0000b8  f4406000          ORR      r0,r0,#0x800
;;;735                      (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
;;;736                      (uint16_t)I2S_InitStruct->I2S_CPOL))));
;;;737     
;;;738      /* Write to SPIx I2SCFGR */  
;;;739      I2Sxext->I2SCFGR = tmpreg;
0000bc  83a8              STRH     r0,[r5,#0x1c]
;;;740    }
0000be  e8bd87f0          POP      {r4-r10,pc}
;;;741    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L2.196|
                          DCD      0x40003400
                  |L2.200|
                          DCD      ||.conststring||

                          AREA ||i.I2S_Init||, CODE, READONLY, ALIGN=2

                  I2S_Init PROC
;;;320      */
;;;321    void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;322    {
000004  4605              MOV      r5,r0
;;;323      uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
;;;324      uint32_t tmp = 0, i2sclk = 0;
;;;325    #ifndef I2S_EXTERNAL_CLOCK_VAL
;;;326      uint32_t pllm = 0, plln = 0, pllr = 0;
;;;327    #endif /* I2S_EXTERNAL_CLOCK_VAL */
;;;328      
;;;329      /* Check the I2S parameters */
;;;330      assert_param(IS_SPI_23_PERIPH(SPIx));
000006  485c              LDR      r0,|L3.376|
000008  2602              MOVS     r6,#2                 ;323
00000a  2700              MOVS     r7,#0                 ;323
00000c  460c              MOV      r4,r1                 ;322
00000e  f04f0801          MOV      r8,#1                 ;323
000012  4285              CMP      r5,r0
000014  d007              BEQ      |L3.38|
000016  4859              LDR      r0,|L3.380|
000018  4285              CMP      r5,r0
00001a  d004              BEQ      |L3.38|
00001c  f44f71a5          MOV      r1,#0x14a
000020  4857              LDR      r0,|L3.384|
000022  f7fffffe          BL       assert_failed
                  |L3.38|
;;;331      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
000026  8820              LDRH     r0,[r4,#0]
000028  f44f7900          MOV      r9,#0x200
00002c  b160              CBZ      r0,|L3.72|
00002e  f5b07f80          CMP      r0,#0x100
000032  d009              BEQ      |L3.72|
000034  4548              CMP      r0,r9
000036  d007              BEQ      |L3.72|
000038  f5b07f40          CMP      r0,#0x300
00003c  d004              BEQ      |L3.72|
00003e  f240114b          MOV      r1,#0x14b
000042  484f              LDR      r0,|L3.384|
000044  f7fffffe          BL       assert_failed
                  |L3.72|
;;;332      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
000048  8860              LDRH     r0,[r4,#2]
00004a  b160              CBZ      r0,|L3.102|
00004c  2810              CMP      r0,#0x10
00004e  d00a              BEQ      |L3.102|
000050  2820              CMP      r0,#0x20
000052  d008              BEQ      |L3.102|
000054  2830              CMP      r0,#0x30
000056  d006              BEQ      |L3.102|
000058  28b0              CMP      r0,#0xb0
00005a  d004              BEQ      |L3.102|
00005c  f44f71a6          MOV      r1,#0x14c
000060  4847              LDR      r0,|L3.384|
000062  f7fffffe          BL       assert_failed
                  |L3.102|
;;;333      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
000066  88a0              LDRH     r0,[r4,#4]
000068  b150              CBZ      r0,|L3.128|
00006a  2801              CMP      r0,#1
00006c  d008              BEQ      |L3.128|
00006e  2803              CMP      r0,#3
000070  d006              BEQ      |L3.128|
000072  2805              CMP      r0,#5
000074  d004              BEQ      |L3.128|
000076  f240114d          MOV      r1,#0x14d
00007a  4841              LDR      r0,|L3.384|
00007c  f7fffffe          BL       assert_failed
                  |L3.128|
;;;334      assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
000080  88e0              LDRH     r0,[r4,#6]
000082  4548              CMP      r0,r9
000084  d005              BEQ      |L3.146|
000086  b120              CBZ      r0,|L3.146|
000088  f44f71a7          MOV      r1,#0x14e
00008c  483c              LDR      r0,|L3.384|
00008e  f7fffffe          BL       assert_failed
                  |L3.146|
;;;335      assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
000092  68a0              LDR      r0,[r4,#8]
000094  4a3b              LDR      r2,|L3.388|
000096  f5a051fa          SUB      r1,r0,#0x1f40
00009a  4291              CMP      r1,r2
00009c  d906              BLS      |L3.172|
00009e  2802              CMP      r0,#2
0000a0  d004              BEQ      |L3.172|
0000a2  f240114f          MOV      r1,#0x14f
0000a6  4836              LDR      r0,|L3.384|
0000a8  f7fffffe          BL       assert_failed
                  |L3.172|
;;;336      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
0000ac  89a0              LDRH     r0,[r4,#0xc]
0000ae  b130              CBZ      r0,|L3.190|
0000b0  2808              CMP      r0,#8
0000b2  d004              BEQ      |L3.190|
0000b4  f44f71a8          MOV      r1,#0x150
0000b8  4831              LDR      r0,|L3.384|
0000ba  f7fffffe          BL       assert_failed
                  |L3.190|
;;;337    
;;;338    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;339      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;340      SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
0000be  8ba8              LDRH     r0,[r5,#0x1c]
0000c0  f24f0140          MOV      r1,#0xf040
0000c4  4008              ANDS     r0,r0,r1
0000c6  83a8              STRH     r0,[r5,#0x1c]
;;;341      SPIx->I2SPR = 0x0002;
0000c8  2002              MOVS     r0,#2
0000ca  8428              STRH     r0,[r5,#0x20]
;;;342      
;;;343      /* Get the I2SCFGR register value */
;;;344      tmpreg = SPIx->I2SCFGR;
0000cc  8baa              LDRH     r2,[r5,#0x1c]
;;;345      
;;;346      /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
;;;347      if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
0000ce  68a0              LDR      r0,[r4,#8]
0000d0  2802              CMP      r0,#2
0000d2  d03b              BEQ      |L3.332|
;;;348      {
;;;349        i2sodd = (uint16_t)0;
;;;350        i2sdiv = (uint16_t)2;   
;;;351      }
;;;352      /* If the requested audio frequency is not the default, compute the prescaler */
;;;353      else
;;;354      {
;;;355        /* Check the frame length (For the Prescaler computing) *******************/
;;;356        if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
0000d4  88a0              LDRH     r0,[r4,#4]
0000d6  b108              CBZ      r0,|L3.220|
;;;357        {
;;;358          /* Packet length is 16 bits */
;;;359          packetlength = 1;
;;;360        }
;;;361        else
;;;362        {
;;;363          /* Packet length is 32 bits */
;;;364          packetlength = 2;
0000d8  f04f0802          MOV      r8,#2
                  |L3.220|
;;;365        }
;;;366    
;;;367        /* Get I2S source Clock frequency  ****************************************/
;;;368          
;;;369        /* If an external I2S clock has to be used, this define should be set  
;;;370           in the project configuration or in the stm32f4xx_conf.h file */
;;;371      #ifdef I2S_EXTERNAL_CLOCK_VAL     
;;;372        /* Set external clock as I2S clock source */
;;;373        if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
;;;374        {
;;;375          RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
;;;376        }
;;;377        
;;;378        /* Set the I2S clock to the external clock  value */
;;;379        i2sclk = I2S_EXTERNAL_CLOCK_VAL;
;;;380    
;;;381      #else /* There is no define for External I2S clock source */
;;;382        /* Set PLLI2S as I2S clock source */
;;;383        if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
0000dc  482a              LDR      r0,|L3.392|
0000de  6801              LDR      r1,[r0,#0]
0000e0  0209              LSLS     r1,r1,#8
0000e2  d503              BPL      |L3.236|
;;;384        {
;;;385          RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
0000e4  6801              LDR      r1,[r0,#0]
0000e6  f4210100          BIC      r1,r1,#0x800000
0000ea  6001              STR      r1,[r0,#0]
                  |L3.236|
;;;386        }    
;;;387        
;;;388        /* Get the PLLI2SN value */
;;;389        plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
0000ec  4826              LDR      r0,|L3.392|
0000ee  307c              ADDS     r0,r0,#0x7c
0000f0  6801              LDR      r1,[r0,#0]
;;;390                          (RCC_PLLI2SCFGR_PLLI2SN >> 6));
;;;391        
;;;392        /* Get the PLLI2SR value */
;;;393        pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
0000f2  6800              LDR      r0,[r0,#0]
0000f4  f3c11188          UBFX     r1,r1,#6,#9           ;389
;;;394                          (RCC_PLLI2SCFGR_PLLI2SR >> 28));
;;;395        
;;;396        /* Get the PLLM value */
;;;397        pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
0000f8  4b23              LDR      r3,|L3.392|
0000fa  f3c07002          UBFX     r0,r0,#28,#3          ;393
0000fe  1f1b              SUBS     r3,r3,#4
000100  681b              LDR      r3,[r3,#0]
;;;398        
;;;399        /* Get the I2S source clock value */
;;;400        i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
000102  4e22              LDR      r6,|L3.396|
000104  f003033f          AND      r3,r3,#0x3f           ;397
000108  fbb6f3f3          UDIV     r3,r6,r3
00010c  434b              MULS     r3,r1,r3
00010e  fbb3f0f0          UDIV     r0,r3,r0
;;;401      #endif /* I2S_EXTERNAL_CLOCK_VAL */
;;;402        
;;;403        /* Compute the Real divider depending on the MCLK output state, with a floating point */
;;;404        if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
000112  88e1              LDRH     r1,[r4,#6]
000114  4549              CMP      r1,r9
000116  d101              BNE      |L3.284|
;;;405        {
;;;406          /* MCLK output is enabled */
;;;407          tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
000118  0a00              LSRS     r0,r0,#8
00011a  e003              B        |L3.292|
                  |L3.284|
;;;408        }
;;;409        else
;;;410        {
;;;411          /* MCLK output is disabled */
;;;412          tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
00011c  ea4f1148          LSL      r1,r8,#5
000120  fbb0f0f1          UDIV     r0,r0,r1
                  |L3.292|
000124  eb000080          ADD      r0,r0,r0,LSL #2
000128  68a1              LDR      r1,[r4,#8]
00012a  0040              LSLS     r0,r0,#1
00012c  fbb0f0f1          UDIV     r0,r0,r1
000130  1d40              ADDS     r0,r0,#5
000132  b280              UXTH     r0,r0
;;;413        }
;;;414        
;;;415        /* Remove the flatting point */
;;;416        tmp = tmp / 10;  
000134  210a              MOVS     r1,#0xa
000136  fbb0f1f1          UDIV     r1,r0,r1
;;;417          
;;;418        /* Check the parity of the divider */
;;;419        i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
00013a  f0010001          AND      r0,r1,#1
;;;420       
;;;421        /* Compute the i2sdiv prescaler */
;;;422        i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
00013e  1a09              SUBS     r1,r1,r0
000140  f3c1064f          UBFX     r6,r1,#1,#16
;;;423       
;;;424        /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
;;;425        i2sodd = (uint16_t) (i2sodd << 8);
000144  f64f71ff          MOV      r1,#0xffff
000148  ea012700          AND      r7,r1,r0,LSL #8
                  |L3.332|
;;;426      }
;;;427    
;;;428      /* Test if the divider is 1 or 0 or greater than 0xFF */
;;;429      if ((i2sdiv < 2) || (i2sdiv > 0xFF))
00014c  1eb0              SUBS     r0,r6,#2
00014e  28fe              CMP      r0,#0xfe
000150  d301              BCC      |L3.342|
;;;430      {
;;;431        /* Set the default values */
;;;432        i2sdiv = 2;
000152  2602              MOVS     r6,#2
;;;433        i2sodd = 0;
000154  2700              MOVS     r7,#0
                  |L3.342|
;;;434      }
;;;435    
;;;436      /* Write to SPIx I2SPR register the computed value */
;;;437      SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
000156  88e0              LDRH     r0,[r4,#6]
000158  433e              ORRS     r6,r6,r7
00015a  4330              ORRS     r0,r0,r6
00015c  8428              STRH     r0,[r5,#0x20]
;;;438     
;;;439      /* Configure the I2S with the SPI_InitStruct values */
;;;440      tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
00015e  8820              LDRH     r0,[r4,#0]
000160  8861              LDRH     r1,[r4,#2]
000162  89a3              LDRH     r3,[r4,#0xc]
000164  4308              ORRS     r0,r0,r1
000166  88a1              LDRH     r1,[r4,#4]
000168  4319              ORRS     r1,r1,r3
00016a  4308              ORRS     r0,r0,r1
00016c  4310              ORRS     r0,r0,r2
00016e  f4406000          ORR      r0,r0,#0x800
;;;441                      (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
;;;442                      (uint16_t)I2S_InitStruct->I2S_CPOL))));
;;;443     
;;;444      /* Write to SPIx I2SCFGR */  
;;;445      SPIx->I2SCFGR = tmpreg;
000172  83a8              STRH     r0,[r5,#0x1c]
;;;446    }
000174  e8bd87f0          POP      {r4-r10,pc}
;;;447    
                          ENDP

                  |L3.376|
                          DCD      0x40003800
                  |L3.380|
                          DCD      0x40003c00
                  |L3.384|
                          DCD      ||.conststring||
                  |L3.388|
                          DCD      0x0002cec0
                  |L3.392|
                          DCD      0x40023808
                  |L3.396|
                          DCD      0x007a1200

                          AREA ||i.I2S_StructInit||, CODE, READONLY, ALIGN=1

                  I2S_StructInit PROC
;;;480      */
;;;481    void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
000000  2100              MOVS     r1,#0
;;;482    {
;;;483    /*--------------- Reset I2S init structure parameters values -----------------*/
;;;484      /* Initialize the I2S_Mode member */
;;;485      I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
000002  8001              STRH     r1,[r0,#0]
;;;486      
;;;487      /* Initialize the I2S_Standard member */
;;;488      I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
000004  8041              STRH     r1,[r0,#2]
;;;489      
;;;490      /* Initialize the I2S_DataFormat member */
;;;491      I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
000006  8081              STRH     r1,[r0,#4]
;;;492      
;;;493      /* Initialize the I2S_MCLKOutput member */
;;;494      I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;495      
;;;496      /* Initialize the I2S_AudioFreq member */
;;;497      I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
00000a  2202              MOVS     r2,#2
;;;498      
;;;499      /* Initialize the I2S_CPOL member */
;;;500      I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
00000c  6082              STR      r2,[r0,#8]
00000e  8181              STRH     r1,[r0,#0xc]
;;;501    }
000010  4770              BX       lr
;;;502    
                          ENDP


                          AREA ||i.SPI_BiDirectionalLineConfig||, CODE, READONLY, ALIGN=2

                  SPI_BiDirectionalLineConfig PROC
;;;581      */
;;;582    void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
000000  b570              PUSH     {r4-r6,lr}
;;;583    {
000002  4604              MOV      r4,r0
;;;584      /* Check the parameters */
;;;585      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  4813              LDR      r0,|L5.84|
000006  460d              MOV      r5,r1                 ;583
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L5.34|
00000c  4812              LDR      r0,|L5.88|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L5.34|
000012  4812              LDR      r0,|L5.92|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L5.34|
000018  f2402149          MOV      r1,#0x249
00001c  4810              LDR      r0,|L5.96|
00001e  f7fffffe          BL       assert_failed
                  |L5.34|
;;;586      assert_param(IS_SPI_DIRECTION(SPI_Direction));
000022  f5a5403f          SUB      r0,r5,#0xbf00
000026  f44f4180          MOV      r1,#0x4000
00002a  38ff              SUBS     r0,r0,#0xff
00002c  d007              BEQ      |L5.62|
00002e  428d              CMP      r5,r1
000030  d007              BEQ      |L5.66|
000032  f240214a          MOV      r1,#0x24a
000036  480a              LDR      r0,|L5.96|
000038  f7fffffe          BL       assert_failed
00003c  e005              B        |L5.74|
                  |L5.62|
;;;587      if (SPI_Direction == SPI_Direction_Tx)
00003e  428d              CMP      r5,r1
000040  d103              BNE      |L5.74|
                  |L5.66|
;;;588      {
;;;589        /* Set the Tx only mode */
;;;590        SPIx->CR1 |= SPI_Direction_Tx;
000042  8820              LDRH     r0,[r4,#0]
000044  f4404080          ORR      r0,r0,#0x4000
000048  e002              B        |L5.80|
                  |L5.74|
;;;591      }
;;;592      else
;;;593      {
;;;594        /* Set the Rx only mode */
;;;595        SPIx->CR1 &= SPI_Direction_Rx;
00004a  8820              LDRH     r0,[r4,#0]
00004c  f4204080          BIC      r0,r0,#0x4000
                  |L5.80|
000050  8020              STRH     r0,[r4,#0]            ;590
;;;596      }
;;;597    }
000052  bd70              POP      {r4-r6,pc}
;;;598    
                          ENDP

                  |L5.84|
                          DCD      0x40013000
                  |L5.88|
                          DCD      0x40003800
                  |L5.92|
                          DCD      0x40003c00
                  |L5.96|
                          DCD      ||.conststring||

                          AREA ||i.SPI_CalculateCRC||, CODE, READONLY, ALIGN=2

                  SPI_CalculateCRC PROC
;;;879      */
;;;880    void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;881    {
000002  4604              MOV      r4,r0
;;;882      /* Check the parameters */
;;;883      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  480f              LDR      r0,|L6.68|
000006  460d              MOV      r5,r1                 ;881
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L6.34|
00000c  480e              LDR      r0,|L6.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L6.34|
000012  480e              LDR      r0,|L6.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L6.34|
000018  f2403173          MOV      r1,#0x373
00001c  480c              LDR      r0,|L6.80|
00001e  f7fffffe          BL       assert_failed
                  |L6.34|
;;;884      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L6.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L6.50|
000028  f44f715d          MOV      r1,#0x374
00002c  4808              LDR      r0,|L6.80|
00002e  f7fffffe          BL       assert_failed
                  |L6.50|
;;;885      if (NewState != DISABLE)
;;;886      {
;;;887        /* Enable the selected SPI CRC calculation */
;;;888        SPIx->CR1 |= SPI_CR1_CRCEN;
000032  8820              LDRH     r0,[r4,#0]
000034  f4405000          ORR      r0,r0,#0x2000
000038  e002              B        |L6.64|
                  |L6.58|
;;;889      }
;;;890      else
;;;891      {
;;;892        /* Disable the selected SPI CRC calculation */
;;;893        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
00003a  8820              LDRH     r0,[r4,#0]
00003c  f4205000          BIC      r0,r0,#0x2000
                  |L6.64|
000040  8020              STRH     r0,[r4,#0]            ;888
;;;894      }
;;;895    }
000042  bd70              POP      {r4-r6,pc}
;;;896    
                          ENDP

                  |L6.68|
                          DCD      0x40013000
                  |L6.72|
                          DCD      0x40003800
                  |L6.76|
                          DCD      0x40003c00
                  |L6.80|
                          DCD      ||.conststring||

                          AREA ||i.SPI_Cmd||, CODE, READONLY, ALIGN=2

                  SPI_Cmd PROC
;;;509      */
;;;510    void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;511    {
000002  4604              MOV      r4,r0
;;;512      /* Check the parameters */
;;;513      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  480f              LDR      r0,|L7.68|
000006  460d              MOV      r5,r1                 ;511
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L7.34|
00000c  480e              LDR      r0,|L7.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L7.34|
000012  480e              LDR      r0,|L7.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L7.34|
000018  f2402101          MOV      r1,#0x201
00001c  480c              LDR      r0,|L7.80|
00001e  f7fffffe          BL       assert_failed
                  |L7.34|
;;;514      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L7.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L7.50|
000028  f2402102          MOV      r1,#0x202
00002c  4808              LDR      r0,|L7.80|
00002e  f7fffffe          BL       assert_failed
                  |L7.50|
;;;515      if (NewState != DISABLE)
;;;516      {
;;;517        /* Enable the selected SPI peripheral */
;;;518        SPIx->CR1 |= SPI_CR1_SPE;
000032  8820              LDRH     r0,[r4,#0]
000034  f0400040          ORR      r0,r0,#0x40
000038  e002              B        |L7.64|
                  |L7.58|
;;;519      }
;;;520      else
;;;521      {
;;;522        /* Disable the selected SPI peripheral */
;;;523        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
00003a  8820              LDRH     r0,[r4,#0]
00003c  f0200040          BIC      r0,r0,#0x40
                  |L7.64|
000040  8020              STRH     r0,[r4,#0]            ;518
;;;524      }
;;;525    }
000042  bd70              POP      {r4-r6,pc}
;;;526    
                          ENDP

                  |L7.68|
                          DCD      0x40013000
                  |L7.72|
                          DCD      0x40003800
                  |L7.76|
                          DCD      0x40003c00
                  |L7.80|
                          DCD      ||.conststring||

                          AREA ||i.SPI_DataSizeConfig||, CODE, READONLY, ALIGN=2

                  SPI_DataSizeConfig PROC
;;;561      */
;;;562    void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
000000  b570              PUSH     {r4-r6,lr}
;;;563    {
000002  4604              MOV      r4,r0
;;;564      /* Check the parameters */
;;;565      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  480f              LDR      r0,|L8.68|
000006  460d              MOV      r5,r1                 ;563
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L8.34|
00000c  480e              LDR      r0,|L8.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L8.34|
000012  480e              LDR      r0,|L8.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L8.34|
000018  f2402135          MOV      r1,#0x235
00001c  480c              LDR      r0,|L8.80|
00001e  f7fffffe          BL       assert_failed
                  |L8.34|
;;;566      assert_param(IS_SPI_DATASIZE(SPI_DataSize));
000022  f5b56f00          CMP      r5,#0x800
000026  d005              BEQ      |L8.52|
000028  b125              CBZ      r5,|L8.52|
00002a  f2402136          MOV      r1,#0x236
00002e  4808              LDR      r0,|L8.80|
000030  f7fffffe          BL       assert_failed
                  |L8.52|
;;;567      /* Clear DFF bit */
;;;568      SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
000034  8820              LDRH     r0,[r4,#0]
000036  f4206000          BIC      r0,r0,#0x800
00003a  8020              STRH     r0,[r4,#0]
;;;569      /* Set new DFF bit value */
;;;570      SPIx->CR1 |= SPI_DataSize;
00003c  8820              LDRH     r0,[r4,#0]
00003e  4328              ORRS     r0,r0,r5
000040  8020              STRH     r0,[r4,#0]
;;;571    }
000042  bd70              POP      {r4-r6,pc}
;;;572    
                          ENDP

                  |L8.68|
                          DCD      0x40013000
                  |L8.72|
                          DCD      0x40003800
                  |L8.76|
                          DCD      0x40003c00
                  |L8.80|
                          DCD      ||.conststring||

                          AREA ||i.SPI_GetCRC||, CODE, READONLY, ALIGN=2

                  SPI_GetCRC PROC
;;;919      */
;;;920    uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
000000  b570              PUSH     {r4-r6,lr}
;;;921    {
000002  4604              MOV      r4,r0
;;;922      uint16_t crcreg = 0;
;;;923      /* Check the parameters */
;;;924      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  480d              LDR      r0,|L9.60|
000006  460d              MOV      r5,r1                 ;921
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L9.34|
00000c  480c              LDR      r0,|L9.64|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L9.34|
000012  480c              LDR      r0,|L9.68|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L9.34|
000018  f44f7167          MOV      r1,#0x39c
00001c  480a              LDR      r0,|L9.72|
00001e  f7fffffe          BL       assert_failed
                  |L9.34|
;;;925      assert_param(IS_SPI_CRC(SPI_CRC));
000022  b135              CBZ      r5,|L9.50|
000024  2d01              CMP      r5,#1
000026  d006              BEQ      |L9.54|
000028  f240319d          MOV      r1,#0x39d
00002c  4806              LDR      r0,|L9.72|
00002e  f7fffffe          BL       assert_failed
                  |L9.50|
;;;926      if (SPI_CRC != SPI_CRC_Rx)
;;;927      {
;;;928        /* Get the Tx CRC register */
;;;929        crcreg = SPIx->TXCRCR;
000032  8b20              LDRH     r0,[r4,#0x18]
;;;930      }
;;;931      else
;;;932      {
;;;933        /* Get the Rx CRC register */
;;;934        crcreg = SPIx->RXCRCR;
;;;935      }
;;;936      /* Return the selected CRC register */
;;;937      return crcreg;
;;;938    }
000034  bd70              POP      {r4-r6,pc}
                  |L9.54|
000036  8aa0              LDRH     r0,[r4,#0x14]         ;934
000038  bd70              POP      {r4-r6,pc}
;;;939    
                          ENDP

00003a  0000              DCW      0x0000
                  |L9.60|
                          DCD      0x40013000
                  |L9.64|
                          DCD      0x40003800
                  |L9.68|
                          DCD      0x40003c00
                  |L9.72|
                          DCD      ||.conststring||

                          AREA ||i.SPI_GetCRCPolynomial||, CODE, READONLY, ALIGN=2

                  SPI_GetCRCPolynomial PROC
;;;944      */
;;;945    uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
000000  b510              PUSH     {r4,lr}
;;;946    {
000002  4604              MOV      r4,r0
;;;947      /* Check the parameters */
;;;948      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  4807              LDR      r0,|L10.36|
000006  4284              CMP      r4,r0
000008  d00a              BEQ      |L10.32|
00000a  4807              LDR      r0,|L10.40|
00000c  4284              CMP      r4,r0
00000e  d007              BEQ      |L10.32|
000010  4806              LDR      r0,|L10.44|
000012  4284              CMP      r4,r0
000014  d004              BEQ      |L10.32|
000016  f44f716d          MOV      r1,#0x3b4
00001a  4805              LDR      r0,|L10.48|
00001c  f7fffffe          BL       assert_failed
                  |L10.32|
;;;949      
;;;950      /* Return the CRC polynomial register */
;;;951      return SPIx->CRCPR;
000020  8a20              LDRH     r0,[r4,#0x10]
;;;952    }
000022  bd10              POP      {r4,pc}
;;;953    
                          ENDP

                  |L10.36|
                          DCD      0x40013000
                  |L10.40|
                          DCD      0x40003800
                  |L10.44|
                          DCD      0x40003c00
                  |L10.48|
                          DCD      ||.conststring||

                          AREA ||i.SPI_I2S_ClearFlag||, CODE, READONLY, ALIGN=2

                  SPI_I2S_ClearFlag PROC
;;;1175     */
;;;1176   void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1177   {
000002  4604              MOV      r4,r0
;;;1178     /* Check the parameters */
;;;1179     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
000004  480f              LDR      r0,|L11.68|
000006  460d              MOV      r5,r1                 ;1177
000008  4284              CMP      r4,r0
00000a  d010              BEQ      |L11.46|
00000c  480e              LDR      r0,|L11.72|
00000e  4284              CMP      r4,r0
000010  d00d              BEQ      |L11.46|
000012  480e              LDR      r0,|L11.76|
000014  4284              CMP      r4,r0
000016  d00a              BEQ      |L11.46|
000018  480d              LDR      r0,|L11.80|
00001a  4284              CMP      r4,r0
00001c  d007              BEQ      |L11.46|
00001e  f1b42f40          CMP      r4,#0x40004000
000022  d004              BEQ      |L11.46|
000024  f240419b          MOV      r1,#0x49b
000028  480a              LDR      r0,|L11.84|
00002a  f7fffffe          BL       assert_failed
                  |L11.46|
;;;1180     assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
00002e  2d10              CMP      r5,#0x10
000030  d004              BEQ      |L11.60|
000032  f240419c          MOV      r1,#0x49c
000036  4807              LDR      r0,|L11.84|
000038  f7fffffe          BL       assert_failed
                  |L11.60|
;;;1181       
;;;1182     /* Clear the selected SPI CRC Error (CRCERR) flag */
;;;1183     SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
00003c  43e8              MVNS     r0,r5
00003e  8120              STRH     r0,[r4,#8]
;;;1184   }
000040  bd70              POP      {r4-r6,pc}
;;;1185   
                          ENDP

000042  0000              DCW      0x0000
                  |L11.68|
                          DCD      0x40013000
                  |L11.72|
                          DCD      0x40003800
                  |L11.76|
                          DCD      0x40003c00
                  |L11.80|
                          DCD      0x40003400
                  |L11.84|
                          DCD      ||.conststring||

                          AREA ||i.SPI_I2S_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  SPI_I2S_ClearITPendingBit PROC
;;;1255     */
;;;1256   void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1257   {
000002  4604              MOV      r4,r0
;;;1258     uint16_t itpos = 0;
;;;1259     /* Check the parameters */
;;;1260     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
000004  4811              LDR      r0,|L12.76|
000006  460d              MOV      r5,r1                 ;1257
000008  4284              CMP      r4,r0
00000a  d010              BEQ      |L12.46|
00000c  4810              LDR      r0,|L12.80|
00000e  4284              CMP      r4,r0
000010  d00d              BEQ      |L12.46|
000012  4810              LDR      r0,|L12.84|
000014  4284              CMP      r4,r0
000016  d00a              BEQ      |L12.46|
000018  480f              LDR      r0,|L12.88|
00001a  4284              CMP      r4,r0
00001c  d007              BEQ      |L12.46|
00001e  f1b42f40          CMP      r4,#0x40004000
000022  d004              BEQ      |L12.46|
000024  f24041ec          MOV      r1,#0x4ec
000028  480c              LDR      r0,|L12.92|
00002a  f7fffffe          BL       assert_failed
                  |L12.46|
;;;1261     assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
00002e  2d54              CMP      r5,#0x54
000030  d004              BEQ      |L12.60|
000032  f24041ed          MOV      r1,#0x4ed
000036  4809              LDR      r0,|L12.92|
000038  f7fffffe          BL       assert_failed
                  |L12.60|
;;;1262   
;;;1263     /* Get the SPI_I2S IT index */
;;;1264     itpos = 0x01 << (SPI_I2S_IT & 0x0F);
00003c  f005010f          AND      r1,r5,#0xf
000040  2001              MOVS     r0,#1
000042  4088              LSLS     r0,r0,r1
;;;1265   
;;;1266     /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
;;;1267     SPIx->SR = (uint16_t)~itpos;
000044  43c0              MVNS     r0,r0
000046  8120              STRH     r0,[r4,#8]
;;;1268   }
000048  bd70              POP      {r4-r6,pc}
;;;1269   
                          ENDP

00004a  0000              DCW      0x0000
                  |L12.76|
                          DCD      0x40013000
                  |L12.80|
                          DCD      0x40003800
                  |L12.84|
                          DCD      0x40003c00
                  |L12.88|
                          DCD      0x40003400
                  |L12.92|
                          DCD      ||.conststring||

                          AREA ||i.SPI_I2S_DMACmd||, CODE, READONLY, ALIGN=2

                  SPI_I2S_DMACmd PROC
;;;981      */
;;;982    void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;983    {
000002  4604              MOV      r4,r0
;;;984      /* Check the parameters */
;;;985      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
000004  4816              LDR      r0,|L13.96|
000006  4616              MOV      r6,r2                 ;983
000008  460d              MOV      r5,r1                 ;983
00000a  4284              CMP      r4,r0
00000c  d010              BEQ      |L13.48|
00000e  4815              LDR      r0,|L13.100|
000010  4284              CMP      r4,r0
000012  d00d              BEQ      |L13.48|
000014  4814              LDR      r0,|L13.104|
000016  4284              CMP      r4,r0
000018  d00a              BEQ      |L13.48|
00001a  4814              LDR      r0,|L13.108|
00001c  4284              CMP      r4,r0
00001e  d007              BEQ      |L13.48|
000020  f1b42f40          CMP      r4,#0x40004000
000024  d004              BEQ      |L13.48|
000026  f24031d9          MOV      r1,#0x3d9
00002a  4811              LDR      r0,|L13.112|
00002c  f7fffffe          BL       assert_failed
                  |L13.48|
;;;986      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b136              CBZ      r6,|L13.64|
000032  2e01              CMP      r6,#1
000034  d004              BEQ      |L13.64|
000036  f24031da          MOV      r1,#0x3da
00003a  480d              LDR      r0,|L13.112|
00003c  f7fffffe          BL       assert_failed
                  |L13.64|
;;;987      assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
000040  08a8              LSRS     r0,r5,#2
000042  d100              BNE      |L13.70|
000044  b925              CBNZ     r5,|L13.80|
                  |L13.70|
000046  f24031db          MOV      r1,#0x3db
00004a  4809              LDR      r0,|L13.112|
00004c  f7fffffe          BL       assert_failed
                  |L13.80|
;;;988    
;;;989      if (NewState != DISABLE)
;;;990      {
;;;991        /* Enable the selected SPI DMA requests */
;;;992        SPIx->CR2 |= SPI_I2S_DMAReq;
;;;993      }
;;;994      else
;;;995      {
;;;996        /* Disable the selected SPI DMA requests */
;;;997        SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
000050  88a0              LDRH     r0,[r4,#4]
000052  b10e              CBZ      r6,|L13.88|
000054  4328              ORRS     r0,r0,r5              ;992
000056  e000              B        |L13.90|
                  |L13.88|
000058  43a8              BICS     r0,r0,r5
                  |L13.90|
00005a  80a0              STRH     r0,[r4,#4]            ;992
;;;998      }
;;;999    }
00005c  bd70              POP      {r4-r6,pc}
;;;1000   
                          ENDP

00005e  0000              DCW      0x0000
                  |L13.96|
                          DCD      0x40013000
                  |L13.100|
                          DCD      0x40003800
                  |L13.104|
                          DCD      0x40003c00
                  |L13.108|
                          DCD      0x40003400
                  |L13.112|
                          DCD      ||.conststring||

                          AREA ||i.SPI_I2S_DeInit||, CODE, READONLY, ALIGN=2

                  SPI_I2S_DeInit PROC
;;;217      */
;;;218    void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;219    {
;;;220      /* Check the parameters */
;;;221      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  4d17              LDR      r5,|L14.100|
000006  4e18              LDR      r6,|L14.104|
000008  4f18              LDR      r7,|L14.108|
00000a  4604              MOV      r4,r0                 ;219
00000c  42a8              CMP      r0,r5
00000e  d007              BEQ      |L14.32|
000010  42b4              CMP      r4,r6
000012  d005              BEQ      |L14.32|
000014  42bc              CMP      r4,r7
000016  d003              BEQ      |L14.32|
000018  21dd              MOVS     r1,#0xdd
00001a  4815              LDR      r0,|L14.112|
00001c  f7fffffe          BL       assert_failed
                  |L14.32|
;;;222    
;;;223      if (SPIx == SPI1)
000020  42ac              CMP      r4,r5
000022  d10a              BNE      |L14.58|
;;;224      {
;;;225        /* Enable SPI1 reset state */
;;;226        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
000024  2101              MOVS     r1,#1
000026  030c              LSLS     r4,r1,#12
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;227        /* Release SPI1 from reset state */
;;;228        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
00002e  4620              MOV      r0,r4
000030  e8bd41f0          POP      {r4-r8,lr}
000034  2100              MOVS     r1,#0
000036  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L14.58|
;;;229      }
;;;230      else if (SPIx == SPI2)
00003a  42b4              CMP      r4,r6
00003c  d102              BNE      |L14.68|
;;;231      {
;;;232        /* Enable SPI2 reset state */
;;;233        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
00003e  2101              MOVS     r1,#1
000040  038c              LSLS     r4,r1,#14
;;;234        /* Release SPI2 from reset state */
;;;235        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
000042  e003              B        |L14.76|
                  |L14.68|
;;;236        }
;;;237      else
;;;238      {
;;;239        if (SPIx == SPI3)
000044  42bc              CMP      r4,r7
000046  d10a              BNE      |L14.94|
;;;240        {
;;;241          /* Enable SPI3 reset state */
;;;242          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
000048  2101              MOVS     r1,#1
00004a  03cc              LSLS     r4,r1,#15
                  |L14.76|
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;243          /* Release SPI3 from reset state */
;;;244          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
000052  4620              MOV      r0,r4
000054  e8bd41f0          POP      {r4-r8,lr}
000058  2100              MOVS     r1,#0
00005a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L14.94|
;;;245        }
;;;246      }
;;;247    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;248    
                          ENDP

000062  0000              DCW      0x0000
                  |L14.100|
                          DCD      0x40013000
                  |L14.104|
                          DCD      0x40003800
                  |L14.108|
                          DCD      0x40003c00
                  |L14.112|
                          DCD      ||.conststring||

                          AREA ||i.SPI_I2S_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  SPI_I2S_GetFlagStatus PROC
;;;1134     */
;;;1135   FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1136   {
000002  4605              MOV      r5,r0
;;;1137     FlagStatus bitstatus = RESET;
;;;1138     /* Check the parameters */
;;;1139     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
000004  4819              LDR      r0,|L15.108|
000006  2600              MOVS     r6,#0                 ;1137
000008  460c              MOV      r4,r1                 ;1136
00000a  4285              CMP      r5,r0
00000c  d010              BEQ      |L15.48|
00000e  4818              LDR      r0,|L15.112|
000010  4285              CMP      r5,r0
000012  d00d              BEQ      |L15.48|
000014  4817              LDR      r0,|L15.116|
000016  4285              CMP      r5,r0
000018  d00a              BEQ      |L15.48|
00001a  4817              LDR      r0,|L15.120|
00001c  4285              CMP      r5,r0
00001e  d007              BEQ      |L15.48|
000020  f1b52f40          CMP      r5,#0x40004000
000024  d004              BEQ      |L15.48|
000026  f2404173          MOV      r1,#0x473
00002a  4814              LDR      r0,|L15.124|
00002c  f7fffffe          BL       assert_failed
                  |L15.48|
;;;1140     assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
000030  2c80              CMP      r4,#0x80
000032  d015              BEQ      |L15.96|
000034  2c40              CMP      r4,#0x40
000036  d013              BEQ      |L15.96|
000038  2c20              CMP      r4,#0x20
00003a  d011              BEQ      |L15.96|
00003c  2c10              CMP      r4,#0x10
00003e  d00f              BEQ      |L15.96|
000040  2c08              CMP      r4,#8
000042  d00d              BEQ      |L15.96|
000044  2c04              CMP      r4,#4
000046  d00b              BEQ      |L15.96|
000048  2c02              CMP      r4,#2
00004a  d009              BEQ      |L15.96|
00004c  2c01              CMP      r4,#1
00004e  d007              BEQ      |L15.96|
000050  f5b47f80          CMP      r4,#0x100
000054  d004              BEQ      |L15.96|
000056  f2404174          MOV      r1,#0x474
00005a  4808              LDR      r0,|L15.124|
00005c  f7fffffe          BL       assert_failed
                  |L15.96|
;;;1141     
;;;1142     /* Check the status of the specified SPI flag */
;;;1143     if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
000060  8928              LDRH     r0,[r5,#8]
000062  4220              TST      r0,r4
000064  d000              BEQ      |L15.104|
;;;1144     {
;;;1145       /* SPI_I2S_FLAG is set */
;;;1146       bitstatus = SET;
000066  2601              MOVS     r6,#1
                  |L15.104|
;;;1147     }
;;;1148     else
;;;1149     {
;;;1150       /* SPI_I2S_FLAG is reset */
;;;1151       bitstatus = RESET;
;;;1152     }
;;;1153     /* Return the SPI_I2S_FLAG status */
;;;1154     return  bitstatus;
000068  4630              MOV      r0,r6
;;;1155   }
00006a  bd70              POP      {r4-r6,pc}
;;;1156   
                          ENDP

                  |L15.108|
                          DCD      0x40013000
                  |L15.112|
                          DCD      0x40003800
                  |L15.116|
                          DCD      0x40003c00
                  |L15.120|
                          DCD      0x40003400
                  |L15.124|
                          DCD      ||.conststring||

                          AREA ||i.SPI_I2S_GetITStatus||, CODE, READONLY, ALIGN=2

                  SPI_I2S_GetITStatus PROC
;;;1200     */
;;;1201   ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1202   {
000002  4605              MOV      r5,r0
;;;1203     ITStatus bitstatus = RESET;
;;;1204     uint16_t itpos = 0, itmask = 0, enablestatus = 0;
;;;1205   
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
000004  481d              LDR      r0,|L16.124|
000006  2600              MOVS     r6,#0                 ;1203
000008  460c              MOV      r4,r1                 ;1202
00000a  4285              CMP      r5,r0
00000c  d010              BEQ      |L16.48|
00000e  481c              LDR      r0,|L16.128|
000010  4285              CMP      r5,r0
000012  d00d              BEQ      |L16.48|
000014  481b              LDR      r0,|L16.132|
000016  4285              CMP      r5,r0
000018  d00a              BEQ      |L16.48|
00001a  481b              LDR      r0,|L16.136|
00001c  4285              CMP      r5,r0
00001e  d007              BEQ      |L16.48|
000020  f1b52f40          CMP      r5,#0x40004000
000024  d004              BEQ      |L16.48|
000026  f24041b7          MOV      r1,#0x4b7
00002a  4818              LDR      r0,|L16.140|
00002c  f7fffffe          BL       assert_failed
                  |L16.48|
;;;1208     assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
000030  2c60              CMP      r4,#0x60
000032  d010              BEQ      |L16.86|
000034  2c71              CMP      r4,#0x71
000036  d00e              BEQ      |L16.86|
000038  2c54              CMP      r4,#0x54
00003a  d00c              BEQ      |L16.86|
00003c  2c55              CMP      r4,#0x55
00003e  d00a              BEQ      |L16.86|
000040  2c56              CMP      r4,#0x56
000042  d008              BEQ      |L16.86|
000044  2c53              CMP      r4,#0x53
000046  d006              BEQ      |L16.86|
000048  2c58              CMP      r4,#0x58
00004a  d004              BEQ      |L16.86|
00004c  f44f6197          MOV      r1,#0x4b8
000050  480e              LDR      r0,|L16.140|
000052  f7fffffe          BL       assert_failed
                  |L16.86|
;;;1209   
;;;1210     /* Get the SPI_I2S_IT index */
;;;1211     itpos = 0x01 << (SPI_I2S_IT & 0x0F);
000056  f004000f          AND      r0,r4,#0xf
00005a  2301              MOVS     r3,#1
00005c  fa03f200          LSL      r2,r3,r0
000060  b291              UXTH     r1,r2
;;;1212   
;;;1213     /* Get the SPI_I2S_IT IT mask */
;;;1214     itmask = SPI_I2S_IT >> 4;
000062  0920              LSRS     r0,r4,#4
;;;1215   
;;;1216     /* Set the IT mask */
;;;1217     itmask = 0x01 << itmask;
000064  fa03f200          LSL      r2,r3,r0
;;;1218   
;;;1219     /* Get the SPI_I2S_IT enable bit status */
;;;1220     enablestatus = (SPIx->CR2 & itmask) ;
000068  88a8              LDRH     r0,[r5,#4]
00006a  b292              UXTH     r2,r2                 ;1217
00006c  4010              ANDS     r0,r0,r2
;;;1221   
;;;1222     /* Check the status of the specified SPI interrupt */
;;;1223     if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
00006e  892a              LDRH     r2,[r5,#8]
000070  420a              TST      r2,r1
000072  d001              BEQ      |L16.120|
000074  b100              CBZ      r0,|L16.120|
;;;1224     {
;;;1225       /* SPI_I2S_IT is set */
;;;1226       bitstatus = SET;
000076  2601              MOVS     r6,#1
                  |L16.120|
;;;1227     }
;;;1228     else
;;;1229     {
;;;1230       /* SPI_I2S_IT is reset */
;;;1231       bitstatus = RESET;
;;;1232     }
;;;1233     /* Return the SPI_I2S_IT status */
;;;1234     return bitstatus;
000078  4630              MOV      r0,r6
;;;1235   }
00007a  bd70              POP      {r4-r6,pc}
;;;1236   
                          ENDP

                  |L16.124|
                          DCD      0x40013000
                  |L16.128|
                          DCD      0x40003800
                  |L16.132|
                          DCD      0x40003c00
                  |L16.136|
                          DCD      0x40003400
                  |L16.140|
                          DCD      ||.conststring||

                          AREA ||i.SPI_I2S_ITConfig||, CODE, READONLY, ALIGN=2

                  SPI_I2S_ITConfig PROC
;;;1090     */
;;;1091   void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1092   {
000002  4604              MOV      r4,r0
;;;1093     uint16_t itpos = 0, itmask = 0 ;
;;;1094     
;;;1095     /* Check the parameters */
;;;1096     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
000004  4819              LDR      r0,|L17.108|
000006  4616              MOV      r6,r2                 ;1092
000008  460d              MOV      r5,r1                 ;1092
00000a  4284              CMP      r4,r0
00000c  d010              BEQ      |L17.48|
00000e  4818              LDR      r0,|L17.112|
000010  4284              CMP      r4,r0
000012  d00d              BEQ      |L17.48|
000014  4817              LDR      r0,|L17.116|
000016  4284              CMP      r4,r0
000018  d00a              BEQ      |L17.48|
00001a  4817              LDR      r0,|L17.120|
00001c  4284              CMP      r4,r0
00001e  d007              BEQ      |L17.48|
000020  f1b42f40          CMP      r4,#0x40004000
000024  d004              BEQ      |L17.48|
000026  f44f6189          MOV      r1,#0x448
00002a  4814              LDR      r0,|L17.124|
00002c  f7fffffe          BL       assert_failed
                  |L17.48|
;;;1097     assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b136              CBZ      r6,|L17.64|
000032  2e01              CMP      r6,#1
000034  d004              BEQ      |L17.64|
000036  f2404149          MOV      r1,#0x449
00003a  4810              LDR      r0,|L17.124|
00003c  f7fffffe          BL       assert_failed
                  |L17.64|
;;;1098     assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
000040  2d71              CMP      r5,#0x71
000042  d008              BEQ      |L17.86|
000044  2d60              CMP      r5,#0x60
000046  d006              BEQ      |L17.86|
000048  2d50              CMP      r5,#0x50
00004a  d004              BEQ      |L17.86|
00004c  f240414a          MOV      r1,#0x44a
000050  480a              LDR      r0,|L17.124|
000052  f7fffffe          BL       assert_failed
                  |L17.86|
;;;1099   
;;;1100     /* Get the SPI IT index */
;;;1101     itpos = SPI_I2S_IT >> 4;
000056  0928              LSRS     r0,r5,#4
;;;1102   
;;;1103     /* Set the IT mask */
;;;1104     itmask = (uint16_t)1 << (uint16_t)itpos;
000058  2101              MOVS     r1,#1
00005a  4081              LSLS     r1,r1,r0
00005c  b288              UXTH     r0,r1
;;;1105   
;;;1106     if (NewState != DISABLE)
;;;1107     {
;;;1108       /* Enable the selected SPI interrupt */
;;;1109       SPIx->CR2 |= itmask;
;;;1110     }
;;;1111     else
;;;1112     {
;;;1113       /* Disable the selected SPI interrupt */
;;;1114       SPIx->CR2 &= (uint16_t)~itmask;
00005e  88a1              LDRH     r1,[r4,#4]
000060  b10e              CBZ      r6,|L17.102|
000062  4301              ORRS     r1,r1,r0              ;1109
000064  e000              B        |L17.104|
                  |L17.102|
000066  4381              BICS     r1,r1,r0
                  |L17.104|
000068  80a1              STRH     r1,[r4,#4]            ;1109
;;;1115     }
;;;1116   }
00006a  bd70              POP      {r4-r6,pc}
;;;1117   
                          ENDP

                  |L17.108|
                          DCD      0x40013000
                  |L17.112|
                          DCD      0x40003800
                  |L17.116|
                          DCD      0x40003c00
                  |L17.120|
                          DCD      0x40003400
                  |L17.124|
                          DCD      ||.conststring||

                          AREA ||i.SPI_I2S_ReceiveData||, CODE, READONLY, ALIGN=2

                  SPI_I2S_ReceiveData PROC
;;;774      */
;;;775    uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
000000  b510              PUSH     {r4,lr}
;;;776    {
000002  4604              MOV      r4,r0
;;;777      /* Check the parameters */
;;;778      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
000004  480a              LDR      r0,|L18.48|
000006  4284              CMP      r4,r0
000008  d010              BEQ      |L18.44|
00000a  480a              LDR      r0,|L18.52|
00000c  4284              CMP      r4,r0
00000e  d00d              BEQ      |L18.44|
000010  4809              LDR      r0,|L18.56|
000012  4284              CMP      r4,r0
000014  d00a              BEQ      |L18.44|
000016  4809              LDR      r0,|L18.60|
000018  4284              CMP      r4,r0
00001a  d007              BEQ      |L18.44|
00001c  f1b42f40          CMP      r4,#0x40004000
000020  d004              BEQ      |L18.44|
000022  f240310a          MOV      r1,#0x30a
000026  4806              LDR      r0,|L18.64|
000028  f7fffffe          BL       assert_failed
                  |L18.44|
;;;779      
;;;780      /* Return the data in the DR register */
;;;781      return SPIx->DR;
00002c  89a0              LDRH     r0,[r4,#0xc]
;;;782    }
00002e  bd10              POP      {r4,pc}
;;;783    
                          ENDP

                  |L18.48|
                          DCD      0x40013000
                  |L18.52|
                          DCD      0x40003800
                  |L18.56|
                          DCD      0x40003c00
                  |L18.60|
                          DCD      0x40003400
                  |L18.64|
                          DCD      ||.conststring||

                          AREA ||i.SPI_I2S_SendData||, CODE, READONLY, ALIGN=2

                  SPI_I2S_SendData PROC
;;;790      */
;;;791    void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;792    {
000002  4604              MOV      r4,r0
;;;793      /* Check the parameters */
;;;794      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
000004  480b              LDR      r0,|L19.52|
000006  460d              MOV      r5,r1                 ;792
000008  4284              CMP      r4,r0
00000a  d010              BEQ      |L19.46|
00000c  480a              LDR      r0,|L19.56|
00000e  4284              CMP      r4,r0
000010  d00d              BEQ      |L19.46|
000012  480a              LDR      r0,|L19.60|
000014  4284              CMP      r4,r0
000016  d00a              BEQ      |L19.46|
000018  4809              LDR      r0,|L19.64|
00001a  4284              CMP      r4,r0
00001c  d007              BEQ      |L19.46|
00001e  f1b42f40          CMP      r4,#0x40004000
000022  d004              BEQ      |L19.46|
000024  f240311a          MOV      r1,#0x31a
000028  4806              LDR      r0,|L19.68|
00002a  f7fffffe          BL       assert_failed
                  |L19.46|
;;;795      
;;;796      /* Write in the DR register the data to be sent */
;;;797      SPIx->DR = Data;
00002e  81a5              STRH     r5,[r4,#0xc]
;;;798    }
000030  bd70              POP      {r4-r6,pc}
;;;799    
                          ENDP

000032  0000              DCW      0x0000
                  |L19.52|
                          DCD      0x40013000
                  |L19.56|
                          DCD      0x40003800
                  |L19.60|
                          DCD      0x40003c00
                  |L19.64|
                          DCD      0x40003400
                  |L19.68|
                          DCD      ||.conststring||

                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=2

                  SPI_Init PROC
;;;256      */
;;;257    void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;258    {
000002  4605              MOV      r5,r0
;;;259      uint16_t tmpreg = 0;
;;;260      
;;;261      /* check the parameters */
;;;262      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  4847              LDR      r0,|L20.292|
000006  460c              MOV      r4,r1                 ;258
000008  4285              CMP      r5,r0
00000a  d00a              BEQ      |L20.34|
00000c  4846              LDR      r0,|L20.296|
00000e  4285              CMP      r5,r0
000010  d007              BEQ      |L20.34|
000012  4846              LDR      r0,|L20.300|
000014  4285              CMP      r5,r0
000016  d004              BEQ      |L20.34|
000018  f44f7183          MOV      r1,#0x106
00001c  4844              LDR      r0,|L20.304|
00001e  f7fffffe          BL       assert_failed
                  |L20.34|
;;;263      
;;;264      /* Check the SPI parameters */
;;;265      assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
000022  8820              LDRH     r0,[r4,#0]
000024  b168              CBZ      r0,|L20.66|
000026  f5b06f80          CMP      r0,#0x400
00002a  d00a              BEQ      |L20.66|
00002c  f5b04f00          CMP      r0,#0x8000
000030  d007              BEQ      |L20.66|
000032  f5b04f40          CMP      r0,#0xc000
000036  d004              BEQ      |L20.66|
000038  f2401109          MOV      r1,#0x109
00003c  483c              LDR      r0,|L20.304|
00003e  f7fffffe          BL       assert_failed
                  |L20.66|
;;;266      assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
000042  8860              LDRH     r0,[r4,#2]
000044  f5b07f82          CMP      r0,#0x104
000048  d005              BEQ      |L20.86|
00004a  b120              CBZ      r0,|L20.86|
00004c  f44f7185          MOV      r1,#0x10a
000050  4837              LDR      r0,|L20.304|
000052  f7fffffe          BL       assert_failed
                  |L20.86|
;;;267      assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
000056  88a0              LDRH     r0,[r4,#4]
000058  f5b06f00          CMP      r0,#0x800
00005c  d005              BEQ      |L20.106|
00005e  b120              CBZ      r0,|L20.106|
000060  f240110b          MOV      r1,#0x10b
000064  4832              LDR      r0,|L20.304|
000066  f7fffffe          BL       assert_failed
                  |L20.106|
;;;268      assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
00006a  88e0              LDRH     r0,[r4,#6]
00006c  b130              CBZ      r0,|L20.124|
00006e  2802              CMP      r0,#2
000070  d004              BEQ      |L20.124|
000072  f44f7186          MOV      r1,#0x10c
000076  482e              LDR      r0,|L20.304|
000078  f7fffffe          BL       assert_failed
                  |L20.124|
;;;269      assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
00007c  8920              LDRH     r0,[r4,#8]
00007e  b130              CBZ      r0,|L20.142|
000080  2801              CMP      r0,#1
000082  d004              BEQ      |L20.142|
000084  f240110d          MOV      r1,#0x10d
000088  4829              LDR      r0,|L20.304|
00008a  f7fffffe          BL       assert_failed
                  |L20.142|
;;;270      assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
00008e  8960              LDRH     r0,[r4,#0xa]
000090  f5b07f00          CMP      r0,#0x200
000094  d005              BEQ      |L20.162|
000096  b120              CBZ      r0,|L20.162|
000098  f44f7187          MOV      r1,#0x10e
00009c  4824              LDR      r0,|L20.304|
00009e  f7fffffe          BL       assert_failed
                  |L20.162|
;;;271      assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
0000a2  89a0              LDRH     r0,[r4,#0xc]
0000a4  b190              CBZ      r0,|L20.204|
0000a6  2808              CMP      r0,#8
0000a8  d010              BEQ      |L20.204|
0000aa  2810              CMP      r0,#0x10
0000ac  d00e              BEQ      |L20.204|
0000ae  2818              CMP      r0,#0x18
0000b0  d00c              BEQ      |L20.204|
0000b2  2820              CMP      r0,#0x20
0000b4  d00a              BEQ      |L20.204|
0000b6  2828              CMP      r0,#0x28
0000b8  d008              BEQ      |L20.204|
0000ba  2830              CMP      r0,#0x30
0000bc  d006              BEQ      |L20.204|
0000be  2838              CMP      r0,#0x38
0000c0  d004              BEQ      |L20.204|
0000c2  f240110f          MOV      r1,#0x10f
0000c6  481a              LDR      r0,|L20.304|
0000c8  f7fffffe          BL       assert_failed
                  |L20.204|
;;;272      assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
0000cc  89e0              LDRH     r0,[r4,#0xe]
0000ce  b130              CBZ      r0,|L20.222|
0000d0  2880              CMP      r0,#0x80
0000d2  d004              BEQ      |L20.222|
0000d4  f44f7188          MOV      r1,#0x110
0000d8  4815              LDR      r0,|L20.304|
0000da  f7fffffe          BL       assert_failed
                  |L20.222|
;;;273      assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
0000de  8a20              LDRH     r0,[r4,#0x10]
0000e0  b920              CBNZ     r0,|L20.236|
0000e2  f2401111          MOV      r1,#0x111
0000e6  4812              LDR      r0,|L20.304|
0000e8  f7fffffe          BL       assert_failed
                  |L20.236|
;;;274    
;;;275    /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;276      /* Get the SPIx CR1 value */
;;;277      tmpreg = SPIx->CR1;
0000ec  8828              LDRH     r0,[r5,#0]
;;;278      /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
;;;279      tmpreg &= CR1_CLEAR_MASK;
;;;280      /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
;;;281         master/salve mode, CPOL and CPHA */
;;;282      /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
;;;283      /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
;;;284      /* Set LSBFirst bit according to SPI_FirstBit value */
;;;285      /* Set BR bits according to SPI_BaudRatePrescaler value */
;;;286      /* Set CPOL bit according to SPI_CPOL value */
;;;287      /* Set CPHA bit according to SPI_CPHA value */
;;;288      tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
0000ee  8821              LDRH     r1,[r4,#0]
0000f0  8862              LDRH     r2,[r4,#2]
0000f2  88e3              LDRH     r3,[r4,#6]
0000f4  4311              ORRS     r1,r1,r2
0000f6  88a2              LDRH     r2,[r4,#4]
0000f8  f4005041          AND      r0,r0,#0x3040         ;279
0000fc  431a              ORRS     r2,r2,r3
0000fe  4311              ORRS     r1,r1,r2
000100  8922              LDRH     r2,[r4,#8]
000102  4311              ORRS     r1,r1,r2
000104  8962              LDRH     r2,[r4,#0xa]
000106  4311              ORRS     r1,r1,r2
000108  89a2              LDRH     r2,[r4,#0xc]
00010a  4311              ORRS     r1,r1,r2
00010c  89e2              LDRH     r2,[r4,#0xe]
00010e  4311              ORRS     r1,r1,r2
000110  4301              ORRS     r1,r1,r0
;;;289                      SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
;;;290                      SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
;;;291                      SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
;;;292      /* Write to SPIx CR1 */
;;;293      SPIx->CR1 = tmpreg;
000112  8029              STRH     r1,[r5,#0]
;;;294    
;;;295      /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;296      SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
000114  8ba8              LDRH     r0,[r5,#0x1c]
000116  f4206000          BIC      r0,r0,#0x800
00011a  83a8              STRH     r0,[r5,#0x1c]
;;;297    /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;298      /* Write to SPIx CRCPOLY */
;;;299      SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
00011c  8a20              LDRH     r0,[r4,#0x10]
00011e  8228              STRH     r0,[r5,#0x10]
;;;300    }
000120  bd70              POP      {r4-r6,pc}
;;;301    
                          ENDP

000122  0000              DCW      0x0000
                  |L20.292|
                          DCD      0x40013000
                  |L20.296|
                          DCD      0x40003800
                  |L20.300|
                          DCD      0x40003c00
                  |L20.304|
                          DCD      ||.conststring||

                          AREA ||i.SPI_NSSInternalSoftwareConfig||, CODE, READONLY, ALIGN=2

                  SPI_NSSInternalSoftwareConfig PROC
;;;607      */
;;;608    void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
000000  b570              PUSH     {r4-r6,lr}
;;;609    {
000002  4604              MOV      r4,r0
;;;610      /* Check the parameters */
;;;611      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  4812              LDR      r0,|L21.80|
000006  460d              MOV      r5,r1                 ;609
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L21.34|
00000c  4811              LDR      r0,|L21.84|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L21.34|
000012  4811              LDR      r0,|L21.88|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L21.34|
000018  f2402163          MOV      r1,#0x263
00001c  480f              LDR      r0,|L21.92|
00001e  f7fffffe          BL       assert_failed
                  |L21.34|
;;;612      assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
000022  f5b57f80          CMP      r5,#0x100
000026  d00a              BEQ      |L21.62|
000028  f64f66ff          MOV      r6,#0xfeff
00002c  42b5              CMP      r5,r6
00002e  d004              BEQ      |L21.58|
000030  f44f7119          MOV      r1,#0x264
000034  4809              LDR      r0,|L21.92|
000036  f7fffffe          BL       assert_failed
                  |L21.58|
;;;613      if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
00003a  42b5              CMP      r5,r6
00003c  d003              BEQ      |L21.70|
                  |L21.62|
;;;614      {
;;;615        /* Set NSS pin internally by software */
;;;616        SPIx->CR1 |= SPI_NSSInternalSoft_Set;
00003e  8820              LDRH     r0,[r4,#0]
000040  f4407080          ORR      r0,r0,#0x100
000044  e002              B        |L21.76|
                  |L21.70|
;;;617      }
;;;618      else
;;;619      {
;;;620        /* Reset NSS pin internally by software */
;;;621        SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
000046  8820              LDRH     r0,[r4,#0]
000048  f4207080          BIC      r0,r0,#0x100
                  |L21.76|
00004c  8020              STRH     r0,[r4,#0]            ;616
;;;622      }
;;;623    }
00004e  bd70              POP      {r4-r6,pc}
;;;624    
                          ENDP

                  |L21.80|
                          DCD      0x40013000
                  |L21.84|
                          DCD      0x40003800
                  |L21.88|
                          DCD      0x40003c00
                  |L21.92|
                          DCD      ||.conststring||

                          AREA ||i.SPI_SSOutputCmd||, CODE, READONLY, ALIGN=2

                  SPI_SSOutputCmd PROC
;;;631      */
;;;632    void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;633    {
000002  4604              MOV      r4,r0
;;;634      /* Check the parameters */
;;;635      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  480f              LDR      r0,|L22.68|
000006  460d              MOV      r5,r1                 ;633
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L22.34|
00000c  480e              LDR      r0,|L22.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L22.34|
000012  480e              LDR      r0,|L22.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L22.34|
000018  f240217b          MOV      r1,#0x27b
00001c  480c              LDR      r0,|L22.80|
00001e  f7fffffe          BL       assert_failed
                  |L22.34|
;;;636      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L22.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L22.50|
000028  f44f711f          MOV      r1,#0x27c
00002c  4808              LDR      r0,|L22.80|
00002e  f7fffffe          BL       assert_failed
                  |L22.50|
;;;637      if (NewState != DISABLE)
;;;638      {
;;;639        /* Enable the selected SPI SS output */
;;;640        SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
000032  88a0              LDRH     r0,[r4,#4]
000034  f0400004          ORR      r0,r0,#4
000038  e002              B        |L22.64|
                  |L22.58|
;;;641      }
;;;642      else
;;;643      {
;;;644        /* Disable the selected SPI SS output */
;;;645        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
00003a  88a0              LDRH     r0,[r4,#4]
00003c  f0200004          BIC      r0,r0,#4
                  |L22.64|
000040  80a0              STRH     r0,[r4,#4]            ;640
;;;646      }
;;;647    }
000042  bd70              POP      {r4-r6,pc}
;;;648    
                          ENDP

                  |L22.68|
                          DCD      0x40013000
                  |L22.72|
                          DCD      0x40003800
                  |L22.76|
                          DCD      0x40003c00
                  |L22.80|
                          DCD      ||.conststring||

                          AREA ||i.SPI_StructInit||, CODE, READONLY, ALIGN=1

                  SPI_StructInit PROC
;;;452      */
;;;453    void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
000000  2100              MOVS     r1,#0
;;;454    {
;;;455    /*--------------- Reset SPI init structure parameters values -----------------*/
;;;456      /* Initialize the SPI_Direction member */
;;;457      SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
000002  8001              STRH     r1,[r0,#0]
;;;458      /* initialize the SPI_Mode member */
;;;459      SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
000004  8041              STRH     r1,[r0,#2]
;;;460      /* initialize the SPI_DataSize member */
;;;461      SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
000006  8081              STRH     r1,[r0,#4]
;;;462      /* Initialize the SPI_CPOL member */
;;;463      SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
000008  80c1              STRH     r1,[r0,#6]
;;;464      /* Initialize the SPI_CPHA member */
;;;465      SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
00000a  8101              STRH     r1,[r0,#8]
;;;466      /* Initialize the SPI_NSS member */
;;;467      SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
00000c  8141              STRH     r1,[r0,#0xa]
;;;468      /* Initialize the SPI_BaudRatePrescaler member */
;;;469      SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
00000e  8181              STRH     r1,[r0,#0xc]
;;;470      /* Initialize the SPI_FirstBit member */
;;;471      SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
000010  81c1              STRH     r1,[r0,#0xe]
;;;472      /* Initialize the SPI_CRCPolynomial member */
;;;473      SPI_InitStruct->SPI_CRCPolynomial = 7;
000012  2107              MOVS     r1,#7
000014  8201              STRH     r1,[r0,#0x10]
;;;474    }
000016  4770              BX       lr
;;;475    
                          ENDP


                          AREA ||i.SPI_TIModeCmd||, CODE, READONLY, ALIGN=2

                  SPI_TIModeCmd PROC
;;;662      */
;;;663    void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;664    {
000002  4604              MOV      r4,r0
;;;665      /* Check the parameters */
;;;666      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  480f              LDR      r0,|L24.68|
000006  460d              MOV      r5,r1                 ;664
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L24.34|
00000c  480e              LDR      r0,|L24.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L24.34|
000012  480e              LDR      r0,|L24.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L24.34|
000018  f240219a          MOV      r1,#0x29a
00001c  480c              LDR      r0,|L24.80|
00001e  f7fffffe          BL       assert_failed
                  |L24.34|
;;;667      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L24.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L24.50|
000028  f240219b          MOV      r1,#0x29b
00002c  4808              LDR      r0,|L24.80|
00002e  f7fffffe          BL       assert_failed
                  |L24.50|
;;;668    
;;;669      if (NewState != DISABLE)
;;;670      {
;;;671        /* Enable the TI mode for the selected SPI peripheral */
;;;672        SPIx->CR2 |= SPI_CR2_FRF;
000032  88a0              LDRH     r0,[r4,#4]
000034  f0400010          ORR      r0,r0,#0x10
000038  e002              B        |L24.64|
                  |L24.58|
;;;673      }
;;;674      else
;;;675      {
;;;676        /* Disable the TI mode for the selected SPI peripheral */
;;;677        SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
00003a  88a0              LDRH     r0,[r4,#4]
00003c  f0200010          BIC      r0,r0,#0x10
                  |L24.64|
000040  80a0              STRH     r0,[r4,#4]            ;672
;;;678      }
;;;679    }
000042  bd70              POP      {r4-r6,pc}
;;;680    
                          ENDP

                  |L24.68|
                          DCD      0x40013000
                  |L24.72|
                          DCD      0x40003800
                  |L24.76|
                          DCD      0x40003c00
                  |L24.80|
                          DCD      ||.conststring||

                          AREA ||i.SPI_TransmitCRC||, CODE, READONLY, ALIGN=2

                  SPI_TransmitCRC PROC
;;;901      */
;;;902    void SPI_TransmitCRC(SPI_TypeDef* SPIx)
000000  b510              PUSH     {r4,lr}
;;;903    {
000002  4604              MOV      r4,r0
;;;904      /* Check the parameters */
;;;905      assert_param(IS_SPI_ALL_PERIPH(SPIx));
000004  4809              LDR      r0,|L25.44|
000006  4284              CMP      r4,r0
000008  d00a              BEQ      |L25.32|
00000a  4809              LDR      r0,|L25.48|
00000c  4284              CMP      r4,r0
00000e  d007              BEQ      |L25.32|
000010  4808              LDR      r0,|L25.52|
000012  4284              CMP      r4,r0
000014  d004              BEQ      |L25.32|
000016  f2403189          MOV      r1,#0x389
00001a  4807              LDR      r0,|L25.56|
00001c  f7fffffe          BL       assert_failed
                  |L25.32|
;;;906      
;;;907      /* Enable the selected SPI CRC transmission */
;;;908      SPIx->CR1 |= SPI_CR1_CRCNEXT;
000020  8820              LDRH     r0,[r4,#0]
000022  f4405080          ORR      r0,r0,#0x1000
000026  8020              STRH     r0,[r4,#0]
;;;909    }
000028  bd10              POP      {r4,pc}
;;;910    
                          ENDP

00002a  0000              DCW      0x0000
                  |L25.44|
                          DCD      0x40013000
                  |L25.48|
                          DCD      0x40003800
                  |L25.52|
                          DCD      0x40003c00
                  |L25.56|
                          DCD      ||.conststring||

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_spi.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f737069
00004a  2e6300  

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_spi.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_spi_c_2b928927____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_spi_c_2b928927____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_spi_c_2b928927____REVSH|
#line 128
|__asm___15_stm32f4xx_spi_c_2b928927____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
