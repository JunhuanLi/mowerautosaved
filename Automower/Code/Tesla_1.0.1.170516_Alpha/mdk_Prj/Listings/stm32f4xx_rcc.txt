; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_rcc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_rcc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_rcc.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockCmd PROC
;;;1084     */
;;;1085   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1086   {
000002  4604              MOV      r4,r0
;;;1087     /* Check the parameters */
;;;1088     assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
000004  480c              LDR      r0,|L1.56|
000006  460d              MOV      r5,r1                 ;1086
000008  4204              TST      r4,r0
00000a  d100              BNE      |L1.14|
00000c  b924              CBNZ     r4,|L1.24|
                  |L1.14|
00000e  f44f6188          MOV      r1,#0x440
000012  480a              LDR      r0,|L1.60|
000014  f7fffffe          BL       assert_failed
                  |L1.24|
;;;1089   
;;;1090     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1091     if (NewState != DISABLE)
;;;1092     {
;;;1093       RCC->AHB1ENR |= RCC_AHB1Periph;
000018  4e09              LDR      r6,|L1.64|
00001a  b14d              CBZ      r5,|L1.48|
00001c  2d01              CMP      r5,#1                 ;1090
00001e  d004              BEQ      |L1.42|
000020  f2404142          MOV      r1,#0x442             ;1090
000024  4805              LDR      r0,|L1.60|
000026  f7fffffe          BL       assert_failed
                  |L1.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L1.52|
                  |L1.48|
;;;1094     }
;;;1095     else
;;;1096     {
;;;1097       RCC->AHB1ENR &= ~RCC_AHB1Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L1.52|
000034  6030              STR      r0,[r6,#0]            ;1093
;;;1098     }
;;;1099   }
000036  bd70              POP      {r4-r6,pc}
;;;1100   
                          ENDP

                  |L1.56|
                          DCD      0x818bee00
                  |L1.60|
                          DCD      ||.conststring||
                  |L1.64|
                          DCD      0x40023830

                          AREA ||i.RCC_AHB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;1454     */
;;;1455   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1456   {
000002  4604              MOV      r4,r0
;;;1457     /* Check the parameters */
;;;1458     assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
000004  480c              LDR      r0,|L2.56|
000006  460d              MOV      r5,r1                 ;1456
000008  4204              TST      r4,r0
00000a  d100              BNE      |L2.14|
00000c  b924              CBNZ     r4,|L2.24|
                  |L2.14|
00000e  f24051b2          MOV      r1,#0x5b2
000012  480a              LDR      r0,|L2.60|
000014  f7fffffe          BL       assert_failed
                  |L2.24|
;;;1459     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1460     if (NewState != DISABLE)
;;;1461     {
;;;1462       RCC->AHB1LPENR |= RCC_AHB1Periph;
000018  4e09              LDR      r6,|L2.64|
00001a  b14d              CBZ      r5,|L2.48|
00001c  2d01              CMP      r5,#1                 ;1459
00001e  d004              BEQ      |L2.42|
000020  f24051b3          MOV      r1,#0x5b3             ;1459
000024  4805              LDR      r0,|L2.60|
000026  f7fffffe          BL       assert_failed
                  |L2.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L2.52|
                  |L2.48|
;;;1463     }
;;;1464     else
;;;1465     {
;;;1466       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L2.52|
000034  6030              STR      r0,[r6,#0]            ;1462
;;;1467     }
;;;1468   }
000036  bd70              POP      {r4-r6,pc}
;;;1469   
                          ENDP

                  |L2.56|
                          DCD      0x81986e00
                  |L2.60|
                          DCD      ||.conststring||
                  |L2.64|
                          DCD      0x40023850

                          AREA ||i.RCC_AHB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphResetCmd PROC
;;;1272     */
;;;1273   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1274   {
000002  4604              MOV      r4,r0
;;;1275     /* Check the parameters */
;;;1276     assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
000004  480c              LDR      r0,|L3.56|
000006  460d              MOV      r5,r1                 ;1274
000008  4204              TST      r4,r0
00000a  d100              BNE      |L3.14|
00000c  b924              CBNZ     r4,|L3.24|
                  |L3.14|
00000e  f24041fc          MOV      r1,#0x4fc
000012  480a              LDR      r0,|L3.60|
000014  f7fffffe          BL       assert_failed
                  |L3.24|
;;;1277     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1278   
;;;1279     if (NewState != DISABLE)
;;;1280     {
;;;1281       RCC->AHB1RSTR |= RCC_AHB1Periph;
000018  4e09              LDR      r6,|L3.64|
00001a  b14d              CBZ      r5,|L3.48|
00001c  2d01              CMP      r5,#1                 ;1277
00001e  d004              BEQ      |L3.42|
000020  f24041fd          MOV      r1,#0x4fd             ;1277
000024  4805              LDR      r0,|L3.60|
000026  f7fffffe          BL       assert_failed
                  |L3.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L3.52|
                  |L3.48|
;;;1282     }
;;;1283     else
;;;1284     {
;;;1285       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L3.52|
000034  6030              STR      r0,[r6,#0]            ;1281
;;;1286     }
;;;1287   }
000036  bd70              POP      {r4-r6,pc}
;;;1288   
                          ENDP

                  |L3.56|
                          DCD      0xdd9fee00
                  |L3.60|
                          DCD      ||.conststring||
                  |L3.64|
                          DCD      0x40023810

                          AREA ||i.RCC_AHB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockCmd PROC
;;;1116     */
;;;1117   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1118   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
000006  f03000f1          BICS     r0,r0,#0xf1
00000a  d100              BNE      |L4.14|
00000c  b924              CBNZ     r4,|L4.24|
                  |L4.14|
00000e  f44f618c          MOV      r1,#0x460
000012  4809              LDR      r0,|L4.56|
000014  f7fffffe          BL       assert_failed
                  |L4.24|
;;;1121     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1122   
;;;1123     if (NewState != DISABLE)
;;;1124     {
;;;1125       RCC->AHB2ENR |= RCC_AHB2Periph;
000018  4e08              LDR      r6,|L4.60|
00001a  b14d              CBZ      r5,|L4.48|
00001c  2d01              CMP      r5,#1                 ;1121
00001e  d004              BEQ      |L4.42|
000020  f2404161          MOV      r1,#0x461             ;1121
000024  4804              LDR      r0,|L4.56|
000026  f7fffffe          BL       assert_failed
                  |L4.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L4.52|
                  |L4.48|
;;;1126     }
;;;1127     else
;;;1128     {
;;;1129       RCC->AHB2ENR &= ~RCC_AHB2Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L4.52|
000034  6030              STR      r0,[r6,#0]            ;1125
;;;1130     }
;;;1131   }
000036  bd70              POP      {r4-r6,pc}
;;;1132   
                          ENDP

                  |L4.56|
                          DCD      ||.conststring||
                  |L4.60|
                          DCD      0x40023834

                          AREA ||i.RCC_AHB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;1486     */
;;;1487   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1488   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1489     /* Check the parameters */
;;;1490     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
000006  f03000f1          BICS     r0,r0,#0xf1
00000a  d100              BNE      |L5.14|
00000c  b924              CBNZ     r4,|L5.24|
                  |L5.14|
00000e  f24051d2          MOV      r1,#0x5d2
000012  4809              LDR      r0,|L5.56|
000014  f7fffffe          BL       assert_failed
                  |L5.24|
;;;1491     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1492     if (NewState != DISABLE)
;;;1493     {
;;;1494       RCC->AHB2LPENR |= RCC_AHB2Periph;
000018  4e08              LDR      r6,|L5.60|
00001a  b14d              CBZ      r5,|L5.48|
00001c  2d01              CMP      r5,#1                 ;1491
00001e  d004              BEQ      |L5.42|
000020  f24051d3          MOV      r1,#0x5d3             ;1491
000024  4804              LDR      r0,|L5.56|
000026  f7fffffe          BL       assert_failed
                  |L5.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L5.52|
                  |L5.48|
;;;1495     }
;;;1496     else
;;;1497     {
;;;1498       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L5.52|
000034  6030              STR      r0,[r6,#0]            ;1494
;;;1499     }
;;;1500   }
000036  bd70              POP      {r4-r6,pc}
;;;1501   
                          ENDP

                  |L5.56|
                          DCD      ||.conststring||
                  |L5.60|
                          DCD      0x40023854

                          AREA ||i.RCC_AHB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphResetCmd PROC
;;;1301     */
;;;1302   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1303   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1304     /* Check the parameters */
;;;1305     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
000006  f03000f1          BICS     r0,r0,#0xf1
00000a  d100              BNE      |L6.14|
00000c  b924              CBNZ     r4,|L6.24|
                  |L6.14|
00000e  f2405119          MOV      r1,#0x519
000012  4809              LDR      r0,|L6.56|
000014  f7fffffe          BL       assert_failed
                  |L6.24|
;;;1306     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1307   
;;;1308     if (NewState != DISABLE)
;;;1309     {
;;;1310       RCC->AHB2RSTR |= RCC_AHB2Periph;
000018  4e08              LDR      r6,|L6.60|
00001a  b14d              CBZ      r5,|L6.48|
00001c  2d01              CMP      r5,#1                 ;1306
00001e  d004              BEQ      |L6.42|
000020  f240511a          MOV      r1,#0x51a             ;1306
000024  4804              LDR      r0,|L6.56|
000026  f7fffffe          BL       assert_failed
                  |L6.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L6.52|
                  |L6.48|
;;;1311     }
;;;1312     else
;;;1313     {
;;;1314       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L6.52|
000034  6030              STR      r0,[r6,#0]            ;1310
;;;1315     }
;;;1316   }
000036  bd70              POP      {r4-r6,pc}
;;;1317   
                          ENDP

                  |L6.56|
                          DCD      ||.conststring||
                  |L6.60|
                          DCD      0x40023814

                          AREA ||i.RCC_AHB3PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockCmd PROC
;;;1143     */
;;;1144   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1145   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1146     /* Check the parameters */
;;;1147     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
000006  0840              LSRS     r0,r0,#1
000008  d100              BNE      |L7.12|
00000a  b924              CBNZ     r4,|L7.22|
                  |L7.12|
00000c  f240417b          MOV      r1,#0x47b
000010  4809              LDR      r0,|L7.56|
000012  f7fffffe          BL       assert_failed
                  |L7.22|
;;;1148     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1149   
;;;1150     if (NewState != DISABLE)
;;;1151     {
;;;1152       RCC->AHB3ENR |= RCC_AHB3Periph;
000016  4e09              LDR      r6,|L7.60|
000018  b14d              CBZ      r5,|L7.46|
00001a  2d01              CMP      r5,#1                 ;1148
00001c  d004              BEQ      |L7.40|
00001e  f240417c          MOV      r1,#0x47c             ;1148
000022  4805              LDR      r0,|L7.56|
000024  f7fffffe          BL       assert_failed
                  |L7.40|
000028  6830              LDR      r0,[r6,#0]
00002a  4320              ORRS     r0,r0,r4
00002c  e001              B        |L7.50|
                  |L7.46|
;;;1153     }
;;;1154     else
;;;1155     {
;;;1156       RCC->AHB3ENR &= ~RCC_AHB3Periph;
00002e  6830              LDR      r0,[r6,#0]
000030  43a0              BICS     r0,r0,r4
                  |L7.50|
000032  6030              STR      r0,[r6,#0]            ;1152
;;;1157     }
;;;1158   }
000034  bd70              POP      {r4-r6,pc}
;;;1159   
                          ENDP

000036  0000              DCW      0x0000
                  |L7.56|
                          DCD      ||.conststring||
                  |L7.60|
                          DCD      0x40023838

                          AREA ||i.RCC_AHB3PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;1513     */
;;;1514   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1515   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1516     /* Check the parameters */
;;;1517     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
000006  0840              LSRS     r0,r0,#1
000008  d100              BNE      |L8.12|
00000a  b924              CBNZ     r4,|L8.22|
                  |L8.12|
00000c  f24051ed          MOV      r1,#0x5ed
000010  4809              LDR      r0,|L8.56|
000012  f7fffffe          BL       assert_failed
                  |L8.22|
;;;1518     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1519     if (NewState != DISABLE)
;;;1520     {
;;;1521       RCC->AHB3LPENR |= RCC_AHB3Periph;
000016  4e09              LDR      r6,|L8.60|
000018  b14d              CBZ      r5,|L8.46|
00001a  2d01              CMP      r5,#1                 ;1518
00001c  d004              BEQ      |L8.40|
00001e  f24051ee          MOV      r1,#0x5ee             ;1518
000022  4805              LDR      r0,|L8.56|
000024  f7fffffe          BL       assert_failed
                  |L8.40|
000028  6830              LDR      r0,[r6,#0]
00002a  4320              ORRS     r0,r0,r4
00002c  e001              B        |L8.50|
                  |L8.46|
;;;1522     }
;;;1523     else
;;;1524     {
;;;1525       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
00002e  6830              LDR      r0,[r6,#0]
000030  43a0              BICS     r0,r0,r4
                  |L8.50|
000032  6030              STR      r0,[r6,#0]            ;1521
;;;1526     }
;;;1527   }
000034  bd70              POP      {r4-r6,pc}
;;;1528   
                          ENDP

000036  0000              DCW      0x0000
                  |L8.56|
                          DCD      ||.conststring||
                  |L8.60|
                          DCD      0x40023858

                          AREA ||i.RCC_AHB3PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphResetCmd PROC
;;;1325     */
;;;1326   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1327   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1328     /* Check the parameters */
;;;1329     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
000006  0840              LSRS     r0,r0,#1
000008  d100              BNE      |L9.12|
00000a  b924              CBNZ     r4,|L9.22|
                  |L9.12|
00000c  f2405131          MOV      r1,#0x531
000010  4809              LDR      r0,|L9.56|
000012  f7fffffe          BL       assert_failed
                  |L9.22|
;;;1330     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1331   
;;;1332     if (NewState != DISABLE)
;;;1333     {
;;;1334       RCC->AHB3RSTR |= RCC_AHB3Periph;
000016  4e09              LDR      r6,|L9.60|
000018  b14d              CBZ      r5,|L9.46|
00001a  2d01              CMP      r5,#1                 ;1330
00001c  d004              BEQ      |L9.40|
00001e  f2405132          MOV      r1,#0x532             ;1330
000022  4805              LDR      r0,|L9.56|
000024  f7fffffe          BL       assert_failed
                  |L9.40|
000028  6830              LDR      r0,[r6,#0]
00002a  4320              ORRS     r0,r0,r4
00002c  e001              B        |L9.50|
                  |L9.46|
;;;1335     }
;;;1336     else
;;;1337     {
;;;1338       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
00002e  6830              LDR      r0,[r6,#0]
000030  43a0              BICS     r0,r0,r4
                  |L9.50|
000032  6030              STR      r0,[r6,#0]            ;1334
;;;1339     }
;;;1340   }
000034  bd70              POP      {r4-r6,pc}
;;;1341   
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      ||.conststring||
                  |L9.60|
                          DCD      0x40023818

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1193     */
;;;1194   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1195   {
000002  4604              MOV      r4,r0
;;;1196     /* Check the parameters */
;;;1197     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
000004  480c              LDR      r0,|L10.56|
000006  460d              MOV      r5,r1                 ;1195
000008  4204              TST      r4,r0
00000a  d100              BNE      |L10.14|
00000c  b924              CBNZ     r4,|L10.24|
                  |L10.14|
00000e  f24041ad          MOV      r1,#0x4ad
000012  480a              LDR      r0,|L10.60|
000014  f7fffffe          BL       assert_failed
                  |L10.24|
;;;1198     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1199   
;;;1200     if (NewState != DISABLE)
;;;1201     {
;;;1202       RCC->APB1ENR |= RCC_APB1Periph;
000018  4e09              LDR      r6,|L10.64|
00001a  b14d              CBZ      r5,|L10.48|
00001c  2d01              CMP      r5,#1                 ;1198
00001e  d004              BEQ      |L10.42|
000020  f24041ae          MOV      r1,#0x4ae             ;1198
000024  4805              LDR      r0,|L10.60|
000026  f7fffffe          BL       assert_failed
                  |L10.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L10.52|
                  |L10.48|
;;;1203     }
;;;1204     else
;;;1205     {
;;;1206       RCC->APB1ENR &= ~RCC_APB1Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L10.52|
000034  6030              STR      r0,[r6,#0]            ;1202
;;;1207     }
;;;1208   }
000036  bd70              POP      {r4-r6,pc}
;;;1209   
                          ENDP

                  |L10.56|
                          DCD      0xc9013600
                  |L10.60|
                          DCD      ||.conststring||
                  |L10.64|
                          DCD      0x40023840

                          AREA ||i.RCC_APB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;1563     */
;;;1564   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1565   {
000002  4604              MOV      r4,r0
;;;1566     /* Check the parameters */
;;;1567     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
000004  480c              LDR      r0,|L11.56|
000006  460d              MOV      r5,r1                 ;1565
000008  4204              TST      r4,r0
00000a  d100              BNE      |L11.14|
00000c  b924              CBNZ     r4,|L11.24|
                  |L11.14|
00000e  f240611f          MOV      r1,#0x61f
000012  480a              LDR      r0,|L11.60|
000014  f7fffffe          BL       assert_failed
                  |L11.24|
;;;1568     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1569     if (NewState != DISABLE)
;;;1570     {
;;;1571       RCC->APB1LPENR |= RCC_APB1Periph;
000018  4e09              LDR      r6,|L11.64|
00001a  b14d              CBZ      r5,|L11.48|
00001c  2d01              CMP      r5,#1                 ;1568
00001e  d004              BEQ      |L11.42|
000020  f44f61c4          MOV      r1,#0x620             ;1568
000024  4805              LDR      r0,|L11.60|
000026  f7fffffe          BL       assert_failed
                  |L11.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L11.52|
                  |L11.48|
;;;1572     }
;;;1573     else
;;;1574     {
;;;1575       RCC->APB1LPENR &= ~RCC_APB1Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L11.52|
000034  6030              STR      r0,[r6,#0]            ;1571
;;;1576     }
;;;1577   }
000036  bd70              POP      {r4-r6,pc}
;;;1578   
                          ENDP

                  |L11.56|
                          DCD      0xc9013600
                  |L11.60|
                          DCD      ||.conststring||
                  |L11.64|
                          DCD      0x40023860

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1372     */
;;;1373   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1374   {
000002  4604              MOV      r4,r0
;;;1375     /* Check the parameters */
;;;1376     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
000004  480c              LDR      r0,|L12.56|
000006  460d              MOV      r5,r1                 ;1374
000008  4204              TST      r4,r0
00000a  d100              BNE      |L12.14|
00000c  b924              CBNZ     r4,|L12.24|
                  |L12.14|
00000e  f44f61ac          MOV      r1,#0x560
000012  480a              LDR      r0,|L12.60|
000014  f7fffffe          BL       assert_failed
                  |L12.24|
;;;1377     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1378     if (NewState != DISABLE)
;;;1379     {
;;;1380       RCC->APB1RSTR |= RCC_APB1Periph;
000018  4e09              LDR      r6,|L12.64|
00001a  b14d              CBZ      r5,|L12.48|
00001c  2d01              CMP      r5,#1                 ;1377
00001e  d004              BEQ      |L12.42|
000020  f2405161          MOV      r1,#0x561             ;1377
000024  4805              LDR      r0,|L12.60|
000026  f7fffffe          BL       assert_failed
                  |L12.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L12.52|
                  |L12.48|
;;;1381     }
;;;1382     else
;;;1383     {
;;;1384       RCC->APB1RSTR &= ~RCC_APB1Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L12.52|
000034  6030              STR      r0,[r6,#0]            ;1380
;;;1385     }
;;;1386   }
000036  bd70              POP      {r4-r6,pc}
;;;1387   
                          ENDP

                  |L12.56|
                          DCD      0xc9013600
                  |L12.60|
                          DCD      ||.conststring||
                  |L12.64|
                          DCD      0x40023820

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1233     */
;;;1234   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1235   {
000002  4604              MOV      r4,r0
;;;1236     /* Check the parameters */
;;;1237     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
000004  480c              LDR      r0,|L13.56|
000006  460d              MOV      r5,r1                 ;1235
000008  4204              TST      r4,r0
00000a  d100              BNE      |L13.14|
00000c  b924              CBNZ     r4,|L13.24|
                  |L13.14|
00000e  f24041d5          MOV      r1,#0x4d5
000012  480a              LDR      r0,|L13.60|
000014  f7fffffe          BL       assert_failed
                  |L13.24|
;;;1238     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1239   
;;;1240     if (NewState != DISABLE)
;;;1241     {
;;;1242       RCC->APB2ENR |= RCC_APB2Periph;
000018  4e09              LDR      r6,|L13.64|
00001a  b14d              CBZ      r5,|L13.48|
00001c  2d01              CMP      r5,#1                 ;1238
00001e  d004              BEQ      |L13.42|
000020  f24041d6          MOV      r1,#0x4d6             ;1238
000024  4805              LDR      r0,|L13.60|
000026  f7fffffe          BL       assert_failed
                  |L13.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L13.52|
                  |L13.48|
;;;1243     }
;;;1244     else
;;;1245     {
;;;1246       RCC->APB2ENR &= ~RCC_APB2Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L13.52|
000034  6030              STR      r0,[r6,#0]            ;1242
;;;1247     }
;;;1248   }
000036  bd70              POP      {r4-r6,pc}
;;;1249   
                          ENDP

                  |L13.56|
                          DCD      0xfff8a0cc
                  |L13.60|
                          DCD      ||.conststring||
                  |L13.64|
                          DCD      0x40023844

                          AREA ||i.RCC_APB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;1603     */
;;;1604   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1605   {
000002  4604              MOV      r4,r0
;;;1606     /* Check the parameters */
;;;1607     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
000004  480c              LDR      r0,|L14.56|
000006  460d              MOV      r5,r1                 ;1605
000008  4204              TST      r4,r0
00000a  d100              BNE      |L14.14|
00000c  b924              CBNZ     r4,|L14.24|
                  |L14.14|
00000e  f2406147          MOV      r1,#0x647
000012  480a              LDR      r0,|L14.60|
000014  f7fffffe          BL       assert_failed
                  |L14.24|
;;;1608     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1609     if (NewState != DISABLE)
;;;1610     {
;;;1611       RCC->APB2LPENR |= RCC_APB2Periph;
000018  4e09              LDR      r6,|L14.64|
00001a  b14d              CBZ      r5,|L14.48|
00001c  2d01              CMP      r5,#1                 ;1608
00001e  d004              BEQ      |L14.42|
000020  f44f61c9          MOV      r1,#0x648             ;1608
000024  4805              LDR      r0,|L14.60|
000026  f7fffffe          BL       assert_failed
                  |L14.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L14.52|
                  |L14.48|
;;;1612     }
;;;1613     else
;;;1614     {
;;;1615       RCC->APB2LPENR &= ~RCC_APB2Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L14.52|
000034  6030              STR      r0,[r6,#0]            ;1611
;;;1616     }
;;;1617   }
000036  bd70              POP      {r4-r6,pc}
;;;1618   
                          ENDP

                  |L14.56|
                          DCD      0xfff8a0cc
                  |L14.60|
                          DCD      ||.conststring||
                  |L14.64|
                          DCD      0x40023864

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1408     */
;;;1409   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1410   {
000002  4604              MOV      r4,r0
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
000004  480c              LDR      r0,|L15.56|
000006  460d              MOV      r5,r1                 ;1410
000008  4204              TST      r4,r0
00000a  d100              BNE      |L15.14|
00000c  b924              CBNZ     r4,|L15.24|
                  |L15.14|
00000e  f2405184          MOV      r1,#0x584
000012  480a              LDR      r0,|L15.60|
000014  f7fffffe          BL       assert_failed
                  |L15.24|
;;;1413     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1414     if (NewState != DISABLE)
;;;1415     {
;;;1416       RCC->APB2RSTR |= RCC_APB2Periph;
000018  4e09              LDR      r6,|L15.64|
00001a  b14d              CBZ      r5,|L15.48|
00001c  2d01              CMP      r5,#1                 ;1413
00001e  d004              BEQ      |L15.42|
000020  f2405185          MOV      r1,#0x585             ;1413
000024  4805              LDR      r0,|L15.60|
000026  f7fffffe          BL       assert_failed
                  |L15.42|
00002a  6830              LDR      r0,[r6,#0]
00002c  4320              ORRS     r0,r0,r4
00002e  e001              B        |L15.52|
                  |L15.48|
;;;1417     }
;;;1418     else
;;;1419     {
;;;1420       RCC->APB2RSTR &= ~RCC_APB2Periph;
000030  6830              LDR      r0,[r6,#0]
000032  43a0              BICS     r0,r0,r4
                  |L15.52|
000034  6030              STR      r0,[r6,#0]            ;1416
;;;1421     }
;;;1422   }
000036  bd70              POP      {r4-r6,pc}
;;;1423   
                          ENDP

                  |L15.56|
                          DCD      0xfff8a6cc
                  |L15.60|
                          DCD      ||.conststring||
                  |L15.64|
                          DCD      0x40023824

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;291      */
;;;292    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  b510              PUSH     {r4,lr}
;;;293    {
000002  4604              MOV      r4,r0
;;;294      uint32_t tmpreg = 0;
;;;295      /* Check the parameters */
;;;296      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
000004  281f              CMP      r0,#0x1f
000006  d904              BLS      |L16.18|
000008  f44f7194          MOV      r1,#0x128
00000c  4805              LDR      r0,|L16.36|
00000e  f7fffffe          BL       assert_failed
                  |L16.18|
;;;297    
;;;298      tmpreg = RCC->CR;
000012  4905              LDR      r1,|L16.40|
000014  6808              LDR      r0,[r1,#0]
;;;299    
;;;300      /* Clear HSITRIM[4:0] bits */
;;;301      tmpreg &= ~RCC_CR_HSITRIM;
000016  f02000f8          BIC      r0,r0,#0xf8
;;;302    
;;;303      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;304      tmpreg |= (uint32_t)HSICalibrationValue << 3;
00001a  ea4000c4          ORR      r0,r0,r4,LSL #3
;;;305    
;;;306      /* Store the new value */
;;;307      RCC->CR = tmpreg;
00001e  6008              STR      r0,[r1,#0]
;;;308    }
000020  bd10              POP      {r4,pc}
;;;309    
                          ENDP

000022  0000              DCW      0x0000
                  |L16.36|
                          DCD      ||.conststring||
                  |L16.40|
                          DCD      0x40023800

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1028     */
;;;1029   void RCC_BackupResetCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1030   {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L17.20|
;;;1031     /* Check the parameters */
;;;1032     assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L17.20|
00000a  f44f6181          MOV      r1,#0x408
00000e  4803              LDR      r0,|L17.28|
000010  f7fffffe          BL       assert_failed
                  |L17.20|
;;;1033     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000014  4802              LDR      r0,|L17.32|
000016  6004              STR      r4,[r0,#0]
;;;1034   }
000018  bd10              POP      {r4,pc}
;;;1035   
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      ||.conststring||
                  |L17.32|
                          DCD      0x42470e40

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1729     */
;;;1730   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L18.12|
;;;1731   {
;;;1732     /* Set RMVF bit to clear the reset flags */
;;;1733     RCC->CSR |= RCC_CSR_RMVF;
000002  6801              LDR      r1,[r0,#0]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6001              STR      r1,[r0,#0]
;;;1734   }
00000a  4770              BX       lr
;;;1735   
                          ENDP

                  |L18.12|
                          DCD      0x40023874

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1781     */
;;;1782   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  b510              PUSH     {r4,lr}
;;;1783   {
000002  4604              MOV      r4,r0
;;;1784     /* Check the parameters */
;;;1785     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
000004  0640              LSLS     r0,r0,#25
000006  d400              BMI      |L19.10|
000008  b924              CBNZ     r4,|L19.20|
                  |L19.10|
00000a  f24061f9          MOV      r1,#0x6f9
00000e  4803              LDR      r0,|L19.28|
000010  f7fffffe          BL       assert_failed
                  |L19.20|
;;;1786   
;;;1787     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1788        pending bits */
;;;1789     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000014  4802              LDR      r0,|L19.32|
000016  7004              STRB     r4,[r0,#0]
;;;1790   }
000018  bd10              POP      {r4,pc}
;;;1791   
                          ENDP

00001a  0000              DCW      0x0000
                  |L19.28|
                          DCD      ||.conststring||
                  |L19.32|
                          DCD      0x4002380e

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;517      */
;;;518    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;519    {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L20.20|
;;;520      /* Check the parameters */
;;;521      assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L20.20|
00000a  f2402109          MOV      r1,#0x209
00000e  4803              LDR      r0,|L20.28|
000010  f7fffffe          BL       assert_failed
                  |L20.20|
;;;522      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000014  4802              LDR      r0,|L20.32|
000016  64c4              STR      r4,[r0,#0x4c]
;;;523    }
000018  bd10              POP      {r4,pc}
;;;524    
                          ENDP

00001a  0000              DCW      0x0000
                  |L20.28|
                          DCD      ||.conststring||
                  |L20.32|
                          DCD      0x42470000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;195      */
;;;196    void RCC_DeInit(void)
000000  480b              LDR      r0,|L21.48|
;;;197    {
;;;198      /* Set HSION bit */
;;;199      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;200    
;;;201      /* Reset CFGR register */
;;;202      RCC->CFGR = 0x00000000;
00000a  4a09              LDR      r2,|L21.48|
00000c  2100              MOVS     r1,#0
00000e  3208              ADDS     r2,r2,#8
000010  6011              STR      r1,[r2,#0]
;;;203    
;;;204      /* Reset HSEON, CSSON and PLLON bits */
;;;205      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6802              LDR      r2,[r0,#0]
000014  4b07              LDR      r3,|L21.52|
000016  401a              ANDS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
;;;206    
;;;207      /* Reset PLLCFGR register */
;;;208      RCC->PLLCFGR = 0x24003010;
00001a  1d03              ADDS     r3,r0,#4
00001c  4a06              LDR      r2,|L21.56|
00001e  601a              STR      r2,[r3,#0]
;;;209    
;;;210      /* Reset HSEBYP bit */
;;;211      RCC->CR &= (uint32_t)0xFFFBFFFF;
000020  6802              LDR      r2,[r0,#0]
000022  f4222280          BIC      r2,r2,#0x40000
000026  6002              STR      r2,[r0,#0]
;;;212    
;;;213      /* Disable all interrupts */
;;;214      RCC->CIR = 0x00000000;
000028  4801              LDR      r0,|L21.48|
00002a  300c              ADDS     r0,r0,#0xc
00002c  6001              STR      r1,[r0,#0]
;;;215    }
00002e  4770              BX       lr
;;;216    
                          ENDP

                  |L21.48|
                          DCD      0x40023800
                  |L21.52|
                          DCD      0xfef6ffff
                  |L21.56|
                          DCD      0x24003010

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;854      */
;;;855    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b570              PUSH     {r4-r6,lr}
;;;856    {
;;;857      uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
;;;858    
;;;859      /* Get SYSCLK source -------------------------------------------------------*/
;;;860      tmp = RCC->CFGR & RCC_CFGR_SWS;
000002  4b20              LDR      r3,|L22.132|
000004  6819              LDR      r1,[r3,#0]
;;;861    
;;;862      switch (tmp)
;;;863      {
;;;864        case 0x00:  /* HSI used as system clock source */
;;;865          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000006  4c20              LDR      r4,|L22.136|
000008  f011010c          ANDS     r1,r1,#0xc            ;860
00000c  d004              BEQ      |L22.24|
;;;866          break;
;;;867        case 0x04:  /* HSE used as system clock  source */
;;;868          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
00000e  1066              ASRS     r6,r4,#1
000010  2904              CMP      r1,#4                 ;862
000012  d003              BEQ      |L22.28|
000014  2908              CMP      r1,#8                 ;862
000016  d003              BEQ      |L22.32|
                  |L22.24|
000018  6004              STR      r4,[r0,#0]            ;866
00001a  e01b              B        |L22.84|
                  |L22.28|
;;;869          break;
00001c  6006              STR      r6,[r0,#0]
00001e  e019              B        |L22.84|
                  |L22.32|
;;;870        case 0x08:  /* PLL used as system clock  source */
;;;871    
;;;872          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;873             SYSCLK = PLL_VCO / PLLP
;;;874             */    
;;;875          pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
000020  4a18              LDR      r2,|L22.132|
000022  1f12              SUBS     r2,r2,#4
000024  6811              LDR      r1,[r2,#0]
000026  f3c15580          UBFX     r5,r1,#22,#1
;;;876          pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
00002a  6811              LDR      r1,[r2,#0]
00002c  f001013f          AND      r1,r1,#0x3f
;;;877          
;;;878          if (pllsource != 0)
000030  b115              CBZ      r5,|L22.56|
;;;879          {
;;;880            /* HSE used as PLL clock source */
;;;881            pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
000032  fbb6f1f1          UDIV     r1,r6,r1
000036  e001              B        |L22.60|
                  |L22.56|
;;;882          }
;;;883          else
;;;884          {
;;;885            /* HSI used as PLL clock source */
;;;886            pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
000038  fbb4f1f1          UDIV     r1,r4,r1
                  |L22.60|
00003c  6814              LDR      r4,[r2,#0]
;;;887          }
;;;888    
;;;889          pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
00003e  6812              LDR      r2,[r2,#0]
000040  f3c41488          UBFX     r4,r4,#6,#9           ;886
000044  4361              MULS     r1,r4,r1              ;886
000046  f3c24201          UBFX     r2,r2,#16,#2
00004a  1c52              ADDS     r2,r2,#1
00004c  0052              LSLS     r2,r2,#1
;;;890          RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
00004e  fbb1f1f2          UDIV     r1,r1,r2
000052  6001              STR      r1,[r0,#0]
                  |L22.84|
;;;891          break;
;;;892        default:
;;;893          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;894          break;
;;;895      }
;;;896      /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;897    
;;;898      /* Get HCLK prescaler */
;;;899      tmp = RCC->CFGR & RCC_CFGR_HPRE;
000054  6819              LDR      r1,[r3,#0]
;;;900      tmp = tmp >> 4;
;;;901      presc = APBAHBPrescTable[tmp];
;;;902      /* HCLK clock frequency */
;;;903      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;904    
;;;905      /* Get PCLK1 prescaler */
;;;906      tmp = RCC->CFGR & RCC_CFGR_PPRE1;
;;;907      tmp = tmp >> 10;
;;;908      presc = APBAHBPrescTable[tmp];
;;;909      /* PCLK1 clock frequency */
;;;910      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;911    
;;;912      /* Get PCLK2 prescaler */
;;;913      tmp = RCC->CFGR & RCC_CFGR_PPRE2;
;;;914      tmp = tmp >> 13;
;;;915      presc = APBAHBPrescTable[tmp];
;;;916      /* PCLK2 clock frequency */
;;;917      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;918    }
000056  220f              MOVS     r2,#0xf
000058  ea021111          AND      r1,r2,r1,LSR #4
00005c  4a0b              LDR      r2,|L22.140|
00005e  5c54              LDRB     r4,[r2,r1]            ;901
000060  6801              LDR      r1,[r0,#0]            ;903
000062  40e1              LSRS     r1,r1,r4              ;903
000064  6041              STR      r1,[r0,#4]            ;906
000066  681c              LDR      r4,[r3,#0]            ;906
000068  2507              MOVS     r5,#7
00006a  ea052494          AND      r4,r5,r4,LSR #10
00006e  5d14              LDRB     r4,[r2,r4]            ;908
000070  fa21f404          LSR      r4,r1,r4              ;910
000074  6084              STR      r4,[r0,#8]            ;913
000076  681b              LDR      r3,[r3,#0]            ;913
000078  ea053353          AND      r3,r5,r3,LSR #13
00007c  5cd2              LDRB     r2,[r2,r3]            ;915
00007e  40d1              LSRS     r1,r1,r2              ;917
000080  60c1              STR      r1,[r0,#0xc]          ;917
000082  bd70              POP      {r4-r6,pc}
;;;919    
                          ENDP

                  |L22.132|
                          DCD      0x40023808
                  |L22.136|
                          DCD      0x00f42400
                  |L22.140|
                          DCD      ||.data||

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1684     */
;;;1685   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1686   {
;;;1687     uint32_t tmp = 0;
;;;1688     uint32_t statusreg = 0;
;;;1689     FlagStatus bitstatus = RESET;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;1686
;;;1690   
;;;1691     /* Check the parameters */
;;;1692     assert_param(IS_RCC_FLAG(RCC_FLAG));
000006  2821              CMP      r0,#0x21
000008  d01c              BEQ      |L23.68|
00000a  2c31              CMP      r4,#0x31
00000c  d01a              BEQ      |L23.68|
00000e  2c39              CMP      r4,#0x39
000010  d018              BEQ      |L23.68|
000012  2c41              CMP      r4,#0x41
000014  d016              BEQ      |L23.68|
000016  2c61              CMP      r4,#0x61
000018  d014              BEQ      |L23.68|
00001a  2c79              CMP      r4,#0x79
00001c  d012              BEQ      |L23.68|
00001e  2c7a              CMP      r4,#0x7a
000020  d010              BEQ      |L23.68|
000022  2c7b              CMP      r4,#0x7b
000024  d00e              BEQ      |L23.68|
000026  2c7c              CMP      r4,#0x7c
000028  d00c              BEQ      |L23.68|
00002a  2c7d              CMP      r4,#0x7d
00002c  d00a              BEQ      |L23.68|
00002e  2c7e              CMP      r4,#0x7e
000030  d008              BEQ      |L23.68|
000032  2c7f              CMP      r4,#0x7f
000034  d006              BEQ      |L23.68|
000036  2c3b              CMP      r4,#0x3b
000038  d004              BEQ      |L23.68|
00003a  f240619c          MOV      r1,#0x69c
00003e  480c              LDR      r0,|L23.112|
000040  f7fffffe          BL       assert_failed
                  |L23.68|
;;;1693   
;;;1694     /* Get the RCC register index */
;;;1695     tmp = RCC_FLAG >> 5;
000044  0960              LSRS     r0,r4,#5
;;;1696     if (tmp == 1)               /* The flag to check is in CR register */
000046  2801              CMP      r0,#1
000048  d00c              BEQ      |L23.100|
;;;1697     {
;;;1698       statusreg = RCC->CR;
;;;1699     }
;;;1700     else if (tmp == 2)          /* The flag to check is in BDCR register */
00004a  2802              CMP      r0,#2
00004c  d00d              BEQ      |L23.106|
;;;1701     {
;;;1702       statusreg = RCC->BDCR;
;;;1703     }
;;;1704     else                       /* The flag to check is in CSR register */
;;;1705     {
;;;1706       statusreg = RCC->CSR;
00004e  4809              LDR      r0,|L23.116|
                  |L23.80|
000050  6800              LDR      r0,[r0,#0]            ;1702
;;;1707     }
;;;1708   
;;;1709     /* Get the flag position */
;;;1710     tmp = RCC_FLAG & FLAG_MASK;
000052  f004011f          AND      r1,r4,#0x1f
;;;1711     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000056  2201              MOVS     r2,#1
000058  408a              LSLS     r2,r2,r1
00005a  4202              TST      r2,r0
00005c  d000              BEQ      |L23.96|
;;;1712     {
;;;1713       bitstatus = SET;
00005e  2501              MOVS     r5,#1
                  |L23.96|
;;;1714     }
;;;1715     else
;;;1716     {
;;;1717       bitstatus = RESET;
;;;1718     }
;;;1719     /* Return the flag status */
;;;1720     return bitstatus;
000060  4628              MOV      r0,r5
;;;1721   }
000062  bd70              POP      {r4-r6,pc}
                  |L23.100|
000064  4803              LDR      r0,|L23.116|
000066  3874              SUBS     r0,r0,#0x74           ;1698
000068  e7f2              B        |L23.80|
                  |L23.106|
00006a  4802              LDR      r0,|L23.116|
00006c  1f00              SUBS     r0,r0,#4              ;1702
00006e  e7ef              B        |L23.80|
;;;1722   
                          ENDP

                  |L23.112|
                          DCD      ||.conststring||
                  |L23.116|
                          DCD      0x40023874

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1748     */
;;;1749   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1750   {
;;;1751     ITStatus bitstatus = RESET;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;1750
;;;1752   
;;;1753     /* Check the parameters */
;;;1754     assert_param(IS_RCC_GET_IT(RCC_IT));
000006  2801              CMP      r0,#1
000008  d010              BEQ      |L24.44|
00000a  2c02              CMP      r4,#2
00000c  d00e              BEQ      |L24.44|
00000e  2c04              CMP      r4,#4
000010  d00c              BEQ      |L24.44|
000012  2c08              CMP      r4,#8
000014  d00a              BEQ      |L24.44|
000016  2c10              CMP      r4,#0x10
000018  d008              BEQ      |L24.44|
00001a  2c80              CMP      r4,#0x80
00001c  d006              BEQ      |L24.44|
00001e  2c20              CMP      r4,#0x20
000020  d004              BEQ      |L24.44|
000022  f24061da          MOV      r1,#0x6da
000026  4805              LDR      r0,|L24.60|
000028  f7fffffe          BL       assert_failed
                  |L24.44|
;;;1755   
;;;1756     /* Check the status of the specified RCC interrupt */
;;;1757     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
00002c  4804              LDR      r0,|L24.64|
00002e  6800              LDR      r0,[r0,#0]
000030  4220              TST      r0,r4
000032  d000              BEQ      |L24.54|
;;;1758     {
;;;1759       bitstatus = SET;
000034  2501              MOVS     r5,#1
                  |L24.54|
;;;1760     }
;;;1761     else
;;;1762     {
;;;1763       bitstatus = RESET;
;;;1764     }
;;;1765     /* Return the RCC_IT status */
;;;1766     return  bitstatus;
000036  4628              MOV      r0,r5
;;;1767   }
000038  bd70              POP      {r4-r6,pc}
;;;1768   
                          ENDP

00003a  0000              DCW      0x0000
                  |L24.60|
                          DCD      ||.conststring||
                  |L24.64|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;714      */
;;;715    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L25.12|
;;;716    {
;;;717      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6800              LDR      r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;718    }
000008  4770              BX       lr
;;;719    
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      0x40023808

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;739      */
;;;740    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  b510              PUSH     {r4,lr}
;;;741    {
000002  0004              MOVS     r4,r0
000004  d014              BEQ      |L26.48|
;;;742      uint32_t tmpreg = 0;
;;;743      
;;;744      /* Check the parameters */
;;;745      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
000006  2c80              CMP      r4,#0x80
000008  d012              BEQ      |L26.48|
00000a  2c90              CMP      r4,#0x90
00000c  d010              BEQ      |L26.48|
00000e  2ca0              CMP      r4,#0xa0
000010  d00e              BEQ      |L26.48|
000012  2cb0              CMP      r4,#0xb0
000014  d00c              BEQ      |L26.48|
000016  2cc0              CMP      r4,#0xc0
000018  d00a              BEQ      |L26.48|
00001a  2cd0              CMP      r4,#0xd0
00001c  d008              BEQ      |L26.48|
00001e  2ce0              CMP      r4,#0xe0
000020  d006              BEQ      |L26.48|
000022  2cf0              CMP      r4,#0xf0
000024  d004              BEQ      |L26.48|
000026  f24021e9          MOV      r1,#0x2e9
00002a  4805              LDR      r0,|L26.64|
00002c  f7fffffe          BL       assert_failed
                  |L26.48|
;;;746    
;;;747      tmpreg = RCC->CFGR;
000030  4904              LDR      r1,|L26.68|
000032  6808              LDR      r0,[r1,#0]
;;;748    
;;;749      /* Clear HPRE[3:0] bits */
;;;750      tmpreg &= ~RCC_CFGR_HPRE;
000034  f02000f0          BIC      r0,r0,#0xf0
;;;751    
;;;752      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;753      tmpreg |= RCC_SYSCLK;
000038  4320              ORRS     r0,r0,r4
;;;754    
;;;755      /* Store the new value */
;;;756      RCC->CFGR = tmpreg;
00003a  6008              STR      r0,[r1,#0]
;;;757    }
00003c  bd10              POP      {r4,pc}
;;;758    
                          ENDP

00003e  0000              DCW      0x0000
                  |L26.64|
                          DCD      ||.conststring||
                  |L26.68|
                          DCD      0x40023808

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;236      */
;;;237    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  b510              PUSH     {r4,lr}
;;;238    {
000002  0004              MOVS     r4,r0
000004  d007              BEQ      |L27.22|
;;;239      /* Check the parameters */
;;;240      assert_param(IS_RCC_HSE(RCC_HSE));
000006  2c01              CMP      r4,#1
000008  d005              BEQ      |L27.22|
00000a  2c05              CMP      r4,#5
00000c  d003              BEQ      |L27.22|
00000e  21f0              MOVS     r1,#0xf0
000010  4803              LDR      r0,|L27.32|
000012  f7fffffe          BL       assert_failed
                  |L27.22|
;;;241    
;;;242      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;243      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000016  4803              LDR      r0,|L27.36|
000018  2100              MOVS     r1,#0
00001a  7001              STRB     r1,[r0,#0]
;;;244    
;;;245      /* Set the new HSE configuration -------------------------------------------*/
;;;246      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
00001c  7004              STRB     r4,[r0,#0]
;;;247    }
00001e  bd10              POP      {r4,pc}
;;;248    
                          ENDP

                  |L27.32|
                          DCD      ||.conststring||
                  |L27.36|
                          DCD      0x40023802

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;327      */
;;;328    void RCC_HSICmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;329    {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L28.20|
;;;330      /* Check the parameters */
;;;331      assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L28.20|
00000a  f240114b          MOV      r1,#0x14b
00000e  4803              LDR      r0,|L28.28|
000010  f7fffffe          BL       assert_failed
                  |L28.20|
;;;332    
;;;333      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000014  4802              LDR      r0,|L28.32|
000016  6004              STR      r4,[r0,#0]
;;;334    }
000018  bd10              POP      {r4,pc}
;;;335    
                          ENDP

00001a  0000              DCW      0x0000
                  |L28.28|
                          DCD      ||.conststring||
                  |L28.32|
                          DCD      0x42470000

                          AREA ||i.RCC_I2SCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2SCLKConfig PROC
;;;1045     */
;;;1046   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
000000  b510              PUSH     {r4,lr}
;;;1047   {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L29.20|
;;;1048     /* Check the parameters */
;;;1049     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L29.20|
00000a  f2404119          MOV      r1,#0x419
00000e  4803              LDR      r0,|L29.28|
000010  f7fffffe          BL       assert_failed
                  |L29.20|
;;;1050   
;;;1051     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
000014  4802              LDR      r0,|L29.32|
000016  f8c0415c          STR      r4,[r0,#0x15c]
;;;1052   }
00001a  bd10              POP      {r4,pc}
;;;1053   
                          ENDP

                  |L29.28|
                          DCD      ||.conststring||
                  |L29.32|
                          DCD      0x42470000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1648     */
;;;1649   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1650   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1651     /* Check the parameters */
;;;1652     assert_param(IS_RCC_IT(RCC_IT));
000006  0980              LSRS     r0,r0,#6
000008  d100              BNE      |L30.12|
00000a  b924              CBNZ     r4,|L30.22|
                  |L30.12|
00000c  f2406174          MOV      r1,#0x674
000010  4809              LDR      r0,|L30.56|
000012  f7fffffe          BL       assert_failed
                  |L30.22|
;;;1653     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1654     if (NewState != DISABLE)
;;;1655     {
;;;1656       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;1657       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
000016  4e09              LDR      r6,|L30.60|
000018  b14d              CBZ      r5,|L30.46|
00001a  2d01              CMP      r5,#1                 ;1653
00001c  d004              BEQ      |L30.40|
00001e  f2406175          MOV      r1,#0x675             ;1653
000022  4805              LDR      r0,|L30.56|
000024  f7fffffe          BL       assert_failed
                  |L30.40|
000028  7830              LDRB     r0,[r6,#0]
00002a  4320              ORRS     r0,r0,r4
00002c  e001              B        |L30.50|
                  |L30.46|
;;;1658     }
;;;1659     else
;;;1660     {
;;;1661       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;1662       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
00002e  7830              LDRB     r0,[r6,#0]
000030  43a0              BICS     r0,r0,r4
                  |L30.50|
000032  7030              STRB     r0,[r6,#0]            ;1657
;;;1663     }
;;;1664   }
000034  bd70              POP      {r4-r6,pc}
;;;1665   
                          ENDP

000036  0000              DCW      0x0000
                  |L30.56|
                          DCD      ||.conststring||
                  |L30.60|
                          DCD      0x4002380d

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;352      */
;;;353    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  b510              PUSH     {r4,lr}
;;;354    {
000002  0004              MOVS     r4,r0
000004  d008              BEQ      |L31.24|
;;;355      /* Check the parameters */
;;;356      assert_param(IS_RCC_LSE(RCC_LSE));
000006  2c01              CMP      r4,#1
000008  d006              BEQ      |L31.24|
00000a  2c04              CMP      r4,#4
00000c  d004              BEQ      |L31.24|
00000e  f44f71b2          MOV      r1,#0x164
000012  4808              LDR      r0,|L31.52|
000014  f7fffffe          BL       assert_failed
                  |L31.24|
;;;357    
;;;358      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;359      /* Reset LSEON bit */
;;;360      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000018  4807              LDR      r0,|L31.56|
00001a  2100              MOVS     r1,#0
00001c  7001              STRB     r1,[r0,#0]
;;;361    
;;;362      /* Reset LSEBYP bit */
;;;363      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
00001e  7001              STRB     r1,[r0,#0]
;;;364    
;;;365      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;366      switch (RCC_LSE)
000020  2c01              CMP      r4,#1
000022  d004              BEQ      |L31.46|
000024  2c04              CMP      r4,#4
000026  d101              BNE      |L31.44|
;;;367      {
;;;368        case RCC_LSE_ON:
;;;369          /* Set LSEON bit */
;;;370          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;371          break;
;;;372        case RCC_LSE_Bypass:
;;;373          /* Set LSEBYP and LSEON bits */
;;;374          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000028  2105              MOVS     r1,#5
                  |L31.42|
00002a  7001              STRB     r1,[r0,#0]
                  |L31.44|
;;;375          break;
;;;376        default:
;;;377          break;
;;;378      }
;;;379    }
00002c  bd10              POP      {r4,pc}
                  |L31.46|
00002e  2101              MOVS     r1,#1                 ;370
000030  e7fb              B        |L31.42|
;;;380    
                          ENDP

000032  0000              DCW      0x0000
                  |L31.52|
                          DCD      ||.conststring||
                  |L31.56|
                          DCD      0x40023870

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;392      */
;;;393    void RCC_LSICmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;394    {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L32.20|
;;;395      /* Check the parameters */
;;;396      assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L32.20|
00000a  f44f71c6          MOV      r1,#0x18c
00000e  4803              LDR      r0,|L32.28|
000010  f7fffffe          BL       assert_failed
                  |L32.20|
;;;397    
;;;398      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000014  4802              LDR      r0,|L32.32|
000016  6004              STR      r4,[r0,#0]
;;;399    }
000018  bd10              POP      {r4,pc}
;;;400    
                          ENDP

00001a  0000              DCW      0x0000
                  |L32.28|
                          DCD      ||.conststring||
                  |L32.32|
                          DCD      0x42470e80

                          AREA ||i.RCC_MCO1Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO1Config PROC
;;;542      */
;;;543    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
000000  b570              PUSH     {r4-r6,lr}
;;;544    {
000002  460c              MOV      r4,r1
000004  0005              MOVS     r5,r0
000006  d00d              BEQ      |L33.36|
;;;545      uint32_t tmpreg = 0;
;;;546      
;;;547      /* Check the parameters */
;;;548      assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
000008  f5b51f00          CMP      r5,#0x200000
00000c  d00a              BEQ      |L33.36|
00000e  f5b50f80          CMP      r5,#0x400000
000012  d007              BEQ      |L33.36|
000014  f5b50fc0          CMP      r5,#0x600000
000018  d004              BEQ      |L33.36|
00001a  f44f7109          MOV      r1,#0x224
00001e  480e              LDR      r0,|L33.88|
000020  f7fffffe          BL       assert_failed
                  |L33.36|
;;;549      assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
000024  b184              CBZ      r4,|L33.72|
000026  f1b46f80          CMP      r4,#0x4000000
00002a  d00d              BEQ      |L33.72|
00002c  f1b46fa0          CMP      r4,#0x5000000
000030  d00a              BEQ      |L33.72|
000032  f1b46fc0          CMP      r4,#0x6000000
000036  d007              BEQ      |L33.72|
000038  f1b46fe0          CMP      r4,#0x7000000
00003c  d004              BEQ      |L33.72|
00003e  f2402125          MOV      r1,#0x225
000042  4805              LDR      r0,|L33.88|
000044  f7fffffe          BL       assert_failed
                  |L33.72|
;;;550    
;;;551      tmpreg = RCC->CFGR;
000048  4904              LDR      r1,|L33.92|
00004a  6808              LDR      r0,[r1,#0]
;;;552    
;;;553      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;554      tmpreg &= CFGR_MCO1_RESET_MASK;
;;;555    
;;;556      /* Select MCO1 clock source and prescaler */
;;;557      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
00004c  4325              ORRS     r5,r5,r4
00004e  f02060ec          BIC      r0,r0,#0x7600000      ;554
000052  4305              ORRS     r5,r5,r0
;;;558    
;;;559      /* Store the new value */
;;;560      RCC->CFGR = tmpreg;  
000054  600d              STR      r5,[r1,#0]
;;;561    }
000056  bd70              POP      {r4-r6,pc}
;;;562    
                          ENDP

                  |L33.88|
                          DCD      ||.conststring||
                  |L33.92|
                          DCD      0x40023808

                          AREA ||i.RCC_MCO2Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO2Config PROC
;;;580      */
;;;581    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
000000  b570              PUSH     {r4-r6,lr}
;;;582    {
000002  460c              MOV      r4,r1
000004  0005              MOVS     r5,r0
000006  d00d              BEQ      |L34.36|
;;;583      uint32_t tmpreg = 0;
;;;584      
;;;585      /* Check the parameters */
;;;586      assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
000008  f1b54f80          CMP      r5,#0x40000000
00000c  d00a              BEQ      |L34.36|
00000e  f1b54f00          CMP      r5,#0x80000000
000012  d007              BEQ      |L34.36|
000014  f1b54f40          CMP      r5,#0xc0000000
000018  d004              BEQ      |L34.36|
00001a  f240214a          MOV      r1,#0x24a
00001e  480e              LDR      r0,|L34.88|
000020  f7fffffe          BL       assert_failed
                  |L34.36|
;;;587      assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
000024  b184              CBZ      r4,|L34.72|
000026  f1b45f00          CMP      r4,#0x20000000
00002a  d00d              BEQ      |L34.72|
00002c  f1b45f20          CMP      r4,#0x28000000
000030  d00a              BEQ      |L34.72|
000032  f1b45f40          CMP      r4,#0x30000000
000036  d007              BEQ      |L34.72|
000038  f1b45f60          CMP      r4,#0x38000000
00003c  d004              BEQ      |L34.72|
00003e  f240214b          MOV      r1,#0x24b
000042  4805              LDR      r0,|L34.88|
000044  f7fffffe          BL       assert_failed
                  |L34.72|
;;;588      
;;;589      tmpreg = RCC->CFGR;
000048  4904              LDR      r1,|L34.92|
00004a  6808              LDR      r0,[r1,#0]
;;;590      
;;;591      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;592      tmpreg &= CFGR_MCO2_RESET_MASK;
;;;593    
;;;594      /* Select MCO2 clock source and prescaler */
;;;595      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
00004c  4325              ORRS     r5,r5,r4
00004e  f0204078          BIC      r0,r0,#0xf8000000     ;592
000052  4305              ORRS     r5,r5,r0
;;;596    
;;;597      /* Store the new value */
;;;598      RCC->CFGR = tmpreg;  
000054  600d              STR      r5,[r1,#0]
;;;599    }
000056  bd70              POP      {r4-r6,pc}
;;;600    
                          ENDP

                  |L34.88|
                          DCD      ||.conststring||
                  |L34.92|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;771      */
;;;772    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  b510              PUSH     {r4,lr}
;;;773    {
000002  0004              MOVS     r4,r0
000004  d010              BEQ      |L35.40|
;;;774      uint32_t tmpreg = 0;
;;;775    
;;;776      /* Check the parameters */
;;;777      assert_param(IS_RCC_PCLK(RCC_HCLK));
000006  f5b45f80          CMP      r4,#0x1000
00000a  d00d              BEQ      |L35.40|
00000c  f5b45fa0          CMP      r4,#0x1400
000010  d00a              BEQ      |L35.40|
000012  f5b45fc0          CMP      r4,#0x1800
000016  d007              BEQ      |L35.40|
000018  f5b45fe0          CMP      r4,#0x1c00
00001c  d004              BEQ      |L35.40|
00001e  f2403109          MOV      r1,#0x309
000022  4805              LDR      r0,|L35.56|
000024  f7fffffe          BL       assert_failed
                  |L35.40|
;;;778    
;;;779      tmpreg = RCC->CFGR;
000028  4904              LDR      r1,|L35.60|
00002a  6808              LDR      r0,[r1,#0]
;;;780    
;;;781      /* Clear PPRE1[2:0] bits */
;;;782      tmpreg &= ~RCC_CFGR_PPRE1;
00002c  f42050e0          BIC      r0,r0,#0x1c00
;;;783    
;;;784      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;785      tmpreg |= RCC_HCLK;
000030  4320              ORRS     r0,r0,r4
;;;786    
;;;787      /* Store the new value */
;;;788      RCC->CFGR = tmpreg;
000032  6008              STR      r0,[r1,#0]
;;;789    }
000034  bd10              POP      {r4,pc}
;;;790    
                          ENDP

000036  0000              DCW      0x0000
                  |L35.56|
                          DCD      ||.conststring||
                  |L35.60|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;802      */
;;;803    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  b510              PUSH     {r4,lr}
;;;804    {
000002  0004              MOVS     r4,r0
000004  d010              BEQ      |L36.40|
;;;805      uint32_t tmpreg = 0;
;;;806    
;;;807      /* Check the parameters */
;;;808      assert_param(IS_RCC_PCLK(RCC_HCLK));
000006  f5b45f80          CMP      r4,#0x1000
00000a  d00d              BEQ      |L36.40|
00000c  f5b45fa0          CMP      r4,#0x1400
000010  d00a              BEQ      |L36.40|
000012  f5b45fc0          CMP      r4,#0x1800
000016  d007              BEQ      |L36.40|
000018  f5b45fe0          CMP      r4,#0x1c00
00001c  d004              BEQ      |L36.40|
00001e  f44f714a          MOV      r1,#0x328
000022  4805              LDR      r0,|L36.56|
000024  f7fffffe          BL       assert_failed
                  |L36.40|
;;;809    
;;;810      tmpreg = RCC->CFGR;
000028  4904              LDR      r1,|L36.60|
00002a  6808              LDR      r0,[r1,#0]
;;;811    
;;;812      /* Clear PPRE2[2:0] bits */
;;;813      tmpreg &= ~RCC_CFGR_PPRE2;
00002c  f4204060          BIC      r0,r0,#0xe000
;;;814    
;;;815      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;816      tmpreg |= RCC_HCLK << 3;
000030  ea4000c4          ORR      r0,r0,r4,LSL #3
;;;817    
;;;818      /* Store the new value */
;;;819      RCC->CFGR = tmpreg;
000034  6008              STR      r0,[r1,#0]
;;;820    }
000036  bd10              POP      {r4,pc}
;;;821    
                          ENDP

                  |L36.56|
                          DCD      ||.conststring||
                  |L36.60|
                          DCD      0x40023808

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;458      */
;;;459    void RCC_PLLCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;460    {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L37.20|
;;;461      /* Check the parameters */
;;;462      assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L37.20|
00000a  f44f71e7          MOV      r1,#0x1ce
00000e  4803              LDR      r0,|L37.28|
000010  f7fffffe          BL       assert_failed
                  |L37.20|
;;;463      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000014  4802              LDR      r0,|L37.32|
000016  6604              STR      r4,[r0,#0x60]
;;;464    }
000018  bd10              POP      {r4,pc}
;;;465    
                          ENDP

00001a  0000              DCW      0x0000
                  |L37.28|
                          DCD      ||.conststring||
                  |L37.32|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;435      */
;;;436    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;437    {
000004  461c              MOV      r4,r3
000006  f8dd8018          LDR      r8,[sp,#0x18]
00000a  4616              MOV      r6,r2
00000c  460f              MOV      r7,r1
00000e  0005              MOVS     r5,r0
000010  d007              BEQ      |L38.34|
;;;438      /* Check the parameters */
;;;439      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
000012  f5b50f80          CMP      r5,#0x400000
000016  d004              BEQ      |L38.34|
000018  f24011b7          MOV      r1,#0x1b7
00001c  481b              LDR      r0,|L38.140|
00001e  f7fffffe          BL       assert_failed
                  |L38.34|
;;;440      assert_param(IS_RCC_PLLM_VALUE(PLLM));
000022  2f3f              CMP      r7,#0x3f
000024  d904              BLS      |L38.48|
000026  f44f71dc          MOV      r1,#0x1b8
00002a  4818              LDR      r0,|L38.140|
00002c  f7fffffe          BL       assert_failed
                  |L38.48|
;;;441      assert_param(IS_RCC_PLLN_VALUE(PLLN));
000030  f1a600c0          SUB      r0,r6,#0xc0
000034  28f0              CMP      r0,#0xf0
000036  d904              BLS      |L38.66|
000038  f24011b9          MOV      r1,#0x1b9
00003c  4813              LDR      r0,|L38.140|
00003e  f7fffffe          BL       assert_failed
                  |L38.66|
;;;442      assert_param(IS_RCC_PLLP_VALUE(PLLP));
000042  2c02              CMP      r4,#2
000044  d00a              BEQ      |L38.92|
000046  2c04              CMP      r4,#4
000048  d008              BEQ      |L38.92|
00004a  2c06              CMP      r4,#6
00004c  d006              BEQ      |L38.92|
00004e  2c08              CMP      r4,#8
000050  d004              BEQ      |L38.92|
000052  f44f71dd          MOV      r1,#0x1ba
000056  480d              LDR      r0,|L38.140|
000058  f7fffffe          BL       assert_failed
                  |L38.92|
;;;443      assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
00005c  f1a80004          SUB      r0,r8,#4
000060  280b              CMP      r0,#0xb
000062  d904              BLS      |L38.110|
000064  f24011bb          MOV      r1,#0x1bb
000068  4808              LDR      r0,|L38.140|
00006a  f7fffffe          BL       assert_failed
                  |L38.110|
;;;444    
;;;445      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
00006e  4a08              LDR      r2,|L38.144|
000070  0861              LSRS     r1,r4,#1
000072  ea471086          ORR      r0,r7,r6,LSL #6
000076  eb024101          ADD      r1,r2,r1,LSL #16
00007a  4308              ORRS     r0,r0,r1
00007c  4905              LDR      r1,|L38.148|
00007e  4328              ORRS     r0,r0,r5
000080  ea406008          ORR      r0,r0,r8,LSL #24
000084  6008              STR      r0,[r1,#0]
;;;446                     (PLLQ << 24);
;;;447    }
000086  e8bd81f0          POP      {r4-r8,pc}
;;;448    
                          ENDP

00008a  0000              DCW      0x0000
                  |L38.140|
                          DCD      ||.conststring||
                  |L38.144|
                          DCD      0xffff0000
                  |L38.148|
                          DCD      0x40023804

                          AREA ||i.RCC_PLLI2SCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SCmd PROC
;;;499      */
;;;500    void RCC_PLLI2SCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;501    {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L39.20|
;;;502      /* Check the parameters */
;;;503      assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L39.20|
00000a  f24011f7          MOV      r1,#0x1f7
00000e  4803              LDR      r0,|L39.28|
000010  f7fffffe          BL       assert_failed
                  |L39.20|
;;;504      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000014  4802              LDR      r0,|L39.32|
000016  6684              STR      r4,[r0,#0x68]
;;;505    }
000018  bd10              POP      {r4,pc}
;;;506    
                          ENDP

00001a  0000              DCW      0x0000
                  |L39.28|
                          DCD      ||.conststring||
                  |L39.32|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLI2SConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SConfig PROC
;;;484      */
;;;485    void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
000000  b570              PUSH     {r4-r6,lr}
;;;486    {
000002  4605              MOV      r5,r0
;;;487      /* Check the parameters */
;;;488      assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
000004  38c0              SUBS     r0,r0,#0xc0
000006  460c              MOV      r4,r1                 ;486
000008  28f0              CMP      r0,#0xf0
00000a  d904              BLS      |L40.22|
00000c  f44f71f4          MOV      r1,#0x1e8
000010  4808              LDR      r0,|L40.52|
000012  f7fffffe          BL       assert_failed
                  |L40.22|
;;;489      assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
000016  1ea0              SUBS     r0,r4,#2
000018  2805              CMP      r0,#5
00001a  d904              BLS      |L40.38|
00001c  f24011e9          MOV      r1,#0x1e9
000020  4804              LDR      r0,|L40.52|
000022  f7fffffe          BL       assert_failed
                  |L40.38|
;;;490    
;;;491      RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
000026  4904              LDR      r1,|L40.56|
000028  01a8              LSLS     r0,r5,#6
00002a  ea407004          ORR      r0,r0,r4,LSL #28
00002e  6008              STR      r0,[r1,#0]
;;;492    }
000030  bd70              POP      {r4-r6,pc}
;;;493    
                          ENDP

000032  0000              DCW      0x0000
                  |L40.52|
                          DCD      ||.conststring||
                  |L40.56|
                          DCD      0x40023884

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1011     */
;;;1012   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1013   {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L41.20|
;;;1014     /* Check the parameters */
;;;1015     assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L41.20|
00000a  f24031f7          MOV      r1,#0x3f7
00000e  4803              LDR      r0,|L41.28|
000010  f7fffffe          BL       assert_failed
                  |L41.20|
;;;1016   
;;;1017     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000014  4802              LDR      r0,|L41.32|
000016  6004              STR      r4,[r0,#0]
;;;1018   }
000018  bd10              POP      {r4,pc}
;;;1019   
                          ENDP

00001a  0000              DCW      0x0000
                  |L41.28|
                          DCD      ||.conststring||
                  |L41.32|
                          DCD      0x42470e3c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;979      */
;;;980    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  b510              PUSH     {r4,lr}
;;;981    {
000002  4604              MOV      r4,r0
;;;982      uint32_t tmpreg = 0;
;;;983    
;;;984      /* Check the parameters */
;;;985      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
000004  f5b07f80          CMP      r0,#0x100
000008  d061              BEQ      |L42.206|
00000a  f5b47f00          CMP      r4,#0x200
00000e  d05e              BEQ      |L42.206|
000010  4839              LDR      r0,|L42.248|
000012  4284              CMP      r4,r0
000014  d05b              BEQ      |L42.206|
000016  4839              LDR      r0,|L42.252|
000018  4284              CMP      r4,r0
00001a  d058              BEQ      |L42.206|
00001c  4838              LDR      r0,|L42.256|
00001e  4284              CMP      r4,r0
000020  d055              BEQ      |L42.206|
000022  4838              LDR      r0,|L42.260|
000024  4284              CMP      r4,r0
000026  d052              BEQ      |L42.206|
000028  4837              LDR      r0,|L42.264|
00002a  4284              CMP      r4,r0
00002c  d04f              BEQ      |L42.206|
00002e  4837              LDR      r0,|L42.268|
000030  4284              CMP      r4,r0
000032  d04c              BEQ      |L42.206|
000034  4836              LDR      r0,|L42.272|
000036  4284              CMP      r4,r0
000038  d049              BEQ      |L42.206|
00003a  4836              LDR      r0,|L42.276|
00003c  4284              CMP      r4,r0
00003e  d046              BEQ      |L42.206|
000040  4835              LDR      r0,|L42.280|
000042  4284              CMP      r4,r0
000044  d043              BEQ      |L42.206|
000046  4835              LDR      r0,|L42.284|
000048  4284              CMP      r4,r0
00004a  d040              BEQ      |L42.206|
00004c  4834              LDR      r0,|L42.288|
00004e  4284              CMP      r4,r0
000050  d03d              BEQ      |L42.206|
000052  4834              LDR      r0,|L42.292|
000054  4284              CMP      r4,r0
000056  d03a              BEQ      |L42.206|
000058  4833              LDR      r0,|L42.296|
00005a  4284              CMP      r4,r0
00005c  d037              BEQ      |L42.206|
00005e  4833              LDR      r0,|L42.300|
000060  4284              CMP      r4,r0
000062  d034              BEQ      |L42.206|
000064  4832              LDR      r0,|L42.304|
000066  4284              CMP      r4,r0
000068  d031              BEQ      |L42.206|
00006a  4832              LDR      r0,|L42.308|
00006c  4284              CMP      r4,r0
00006e  d02e              BEQ      |L42.206|
000070  4831              LDR      r0,|L42.312|
000072  4284              CMP      r4,r0
000074  d02b              BEQ      |L42.206|
000076  4831              LDR      r0,|L42.316|
000078  4284              CMP      r4,r0
00007a  d028              BEQ      |L42.206|
00007c  4830              LDR      r0,|L42.320|
00007e  4284              CMP      r4,r0
000080  d025              BEQ      |L42.206|
000082  4830              LDR      r0,|L42.324|
000084  4284              CMP      r4,r0
000086  d022              BEQ      |L42.206|
000088  482f              LDR      r0,|L42.328|
00008a  4284              CMP      r4,r0
00008c  d01f              BEQ      |L42.206|
00008e  482f              LDR      r0,|L42.332|
000090  4284              CMP      r4,r0
000092  d01c              BEQ      |L42.206|
000094  482e              LDR      r0,|L42.336|
000096  4284              CMP      r4,r0
000098  d019              BEQ      |L42.206|
00009a  482e              LDR      r0,|L42.340|
00009c  4284              CMP      r4,r0
00009e  d016              BEQ      |L42.206|
0000a0  482d              LDR      r0,|L42.344|
0000a2  4284              CMP      r4,r0
0000a4  d013              BEQ      |L42.206|
0000a6  482d              LDR      r0,|L42.348|
0000a8  4284              CMP      r4,r0
0000aa  d010              BEQ      |L42.206|
0000ac  482c              LDR      r0,|L42.352|
0000ae  4284              CMP      r4,r0
0000b0  d00d              BEQ      |L42.206|
0000b2  482c              LDR      r0,|L42.356|
0000b4  4284              CMP      r4,r0
0000b6  d00a              BEQ      |L42.206|
0000b8  482b              LDR      r0,|L42.360|
0000ba  4284              CMP      r4,r0
0000bc  d007              BEQ      |L42.206|
0000be  482b              LDR      r0,|L42.364|
0000c0  4284              CMP      r4,r0
0000c2  d004              BEQ      |L42.206|
0000c4  f24031d9          MOV      r1,#0x3d9
0000c8  4829              LDR      r0,|L42.368|
0000ca  f7fffffe          BL       assert_failed
                  |L42.206|
;;;986    
;;;987      if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
0000ce  f3c42001          UBFX     r0,r4,#8,#2
0000d2  2803              CMP      r0,#3
0000d4  d108              BNE      |L42.232|
;;;988      { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;989        tmpreg = RCC->CFGR;
0000d6  4a27              LDR      r2,|L42.372|
0000d8  6810              LDR      r0,[r2,#0]
;;;990    
;;;991        /* Clear RTCPRE[4:0] bits */
;;;992        tmpreg &= ~RCC_CFGR_RTCPRE;
;;;993    
;;;994        /* Configure HSE division factor for RTC clock */
;;;995        tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
0000da  4b27              LDR      r3,|L42.376|
0000dc  f42011f8          BIC      r1,r0,#0x1f0000       ;992
0000e0  ea040003          AND      r0,r4,r3
0000e4  4308              ORRS     r0,r0,r1
;;;996    
;;;997        /* Store the new value */
;;;998        RCC->CFGR = tmpreg;
0000e6  6010              STR      r0,[r2,#0]
                  |L42.232|
;;;999      }
;;;1000       
;;;1001     /* Select the RTC clock source */
;;;1002     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
0000e8  4822              LDR      r0,|L42.372|
0000ea  3068              ADDS     r0,r0,#0x68
0000ec  6801              LDR      r1,[r0,#0]
0000ee  f3c4020b          UBFX     r2,r4,#0,#12
0000f2  4311              ORRS     r1,r1,r2
0000f4  6001              STR      r1,[r0,#0]
;;;1003   }
0000f6  bd10              POP      {r4,pc}
;;;1004   
                          ENDP

                  |L42.248|
                          DCD      0x00020300
                  |L42.252|
                          DCD      0x00030300
                  |L42.256|
                          DCD      0x00040300
                  |L42.260|
                          DCD      0x00050300
                  |L42.264|
                          DCD      0x00060300
                  |L42.268|
                          DCD      0x00070300
                  |L42.272|
                          DCD      0x00080300
                  |L42.276|
                          DCD      0x00090300
                  |L42.280|
                          DCD      0x000a0300
                  |L42.284|
                          DCD      0x000b0300
                  |L42.288|
                          DCD      0x000c0300
                  |L42.292|
                          DCD      0x000d0300
                  |L42.296|
                          DCD      0x000e0300
                  |L42.300|
                          DCD      0x000f0300
                  |L42.304|
                          DCD      0x00100300
                  |L42.308|
                          DCD      0x00110300
                  |L42.312|
                          DCD      0x00120300
                  |L42.316|
                          DCD      0x00130300
                  |L42.320|
                          DCD      0x00140300
                  |L42.324|
                          DCD      0x00150300
                  |L42.328|
                          DCD      0x00160300
                  |L42.332|
                          DCD      0x00170300
                  |L42.336|
                          DCD      0x00180300
                  |L42.340|
                          DCD      0x00190300
                  |L42.344|
                          DCD      0x001a0300
                  |L42.348|
                          DCD      0x001b0300
                  |L42.352|
                          DCD      0x001c0300
                  |L42.356|
                          DCD      0x001d0300
                  |L42.360|
                          DCD      0x001e0300
                  |L42.364|
                          DCD      0x001f0300
                  |L42.368|
                          DCD      ||.conststring||
                  |L42.372|
                          DCD      0x40023808
                  |L42.376|
                          DCD      0x0ffffcff

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;686      */
;;;687    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  b510              PUSH     {r4,lr}
;;;688    {
000002  0004              MOVS     r4,r0
000004  d008              BEQ      |L43.24|
;;;689      uint32_t tmpreg = 0;
;;;690    
;;;691      /* Check the parameters */
;;;692      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
000006  2c01              CMP      r4,#1
000008  d006              BEQ      |L43.24|
00000a  2c02              CMP      r4,#2
00000c  d004              BEQ      |L43.24|
00000e  f44f712d          MOV      r1,#0x2b4
000012  4805              LDR      r0,|L43.40|
000014  f7fffffe          BL       assert_failed
                  |L43.24|
;;;693    
;;;694      tmpreg = RCC->CFGR;
000018  4904              LDR      r1,|L43.44|
00001a  6808              LDR      r0,[r1,#0]
;;;695    
;;;696      /* Clear SW[1:0] bits */
;;;697      tmpreg &= ~RCC_CFGR_SW;
00001c  f0200003          BIC      r0,r0,#3
;;;698    
;;;699      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;700      tmpreg |= RCC_SYSCLKSource;
000020  4320              ORRS     r0,r0,r4
;;;701    
;;;702      /* Store the new value */
;;;703      RCC->CFGR = tmpreg;
000022  6008              STR      r0,[r1,#0]
;;;704    }
000024  bd10              POP      {r4,pc}
;;;705    
                          ENDP

000026  0000              DCW      0x0000
                  |L43.40|
                          DCD      ||.conststring||
                  |L43.44|
                          DCD      0x40023808

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;260      */
;;;261    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b538              PUSH     {r3-r5,lr}
;;;262    {
;;;263      __IO uint32_t startupcounter = 0;
000002  2000              MOVS     r0,#0
;;;264      ErrorStatus status = ERROR;
;;;265      FlagStatus hsestatus = RESET;
;;;266      /* Wait till HSE is ready and if Time out is reached exit */
;;;267      do
;;;268      {
;;;269        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;270        startupcounter++;
;;;271      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
000004  f44f64a0          MOV      r4,#0x500
000008  9000              STR      r0,[sp,#0]
                  |L44.10|
00000a  2031              MOVS     r0,#0x31              ;269
00000c  f7fffffe          BL       RCC_GetFlagStatus
000010  9900              LDR      r1,[sp,#0]            ;270
000012  1c49              ADDS     r1,r1,#1              ;270
000014  9100              STR      r1,[sp,#0]
000016  42a1              CMP      r1,r4
000018  d001              BEQ      |L44.30|
00001a  2800              CMP      r0,#0
00001c  d0f5              BEQ      |L44.10|
                  |L44.30|
;;;272    
;;;273      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
00001e  2031              MOVS     r0,#0x31
000020  f7fffffe          BL       RCC_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d000              BEQ      |L44.42|
;;;274      {
;;;275        status = SUCCESS;
000028  2001              MOVS     r0,#1
                  |L44.42|
;;;276      }
;;;277      else
;;;278      {
;;;279        status = ERROR;
;;;280      }
;;;281      return (status);
;;;282    }
00002a  bd38              POP      {r3-r5,pc}
;;;283    
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_rcc.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f726363
00004a  2e6300  

                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_rcc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_rcc_c_49e27980____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REVSH|
#line 128
|__asm___15_stm32f4xx_rcc_c_49e27980____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
