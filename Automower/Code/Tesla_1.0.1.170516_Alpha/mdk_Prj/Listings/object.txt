; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\object.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\object.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\object.crf ..\OS\src\object.c]
                          THUMB

                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
;;;65         n->next = l->next;
000002  6051              STR      r1,[r2,#4]
000004  6802              LDR      r2,[r0,#0]
;;;66     
;;;67         l->next = n;
000006  600a              STR      r2,[r1,#0]
;;;68         n->prev = l;
000008  6001              STR      r1,[r0,#0]
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_remove||, CODE, READONLY, ALIGN=1

                  rt_list_remove PROC
;;;89      */
;;;90     rt_inline void rt_list_remove(rt_list_t *n)
000000  e9d01200          LDRD     r1,r2,[r0,#0]
;;;91     {
;;;92         n->next->prev = n->prev;
000004  604a              STR      r2,[r1,#4]
000006  e9d01200          LDRD     r1,r2,[r0,#0]
;;;93         n->prev->next = n->next;
;;;94     
;;;95         n->next = n->prev = n;
00000a  6011              STR      r1,[r2,#0]
00000c  6040              STR      r0,[r0,#4]
00000e  6000              STR      r0,[r0,#0]
;;;96     }
000010  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||i.rt_object_allocate||, CODE, READONLY, ALIGN=2

                  rt_object_allocate PROC
;;;273     */
;;;274    rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;275    {
000004  4688              MOV      r8,r1
000006  4605              MOV      r5,r0
;;;276        struct rt_object *object;
;;;277        register rt_base_t temp;
;;;278        struct rt_object_information *information;
;;;279    
;;;280        RT_DEBUG_NOT_IN_INTERRUPT;
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       rt_interrupt_get_nest
000012  2600              MOVS     r6,#0
000014  b180              CBZ      r0,|L3.56|
000016  491b              LDR      r1,|L3.132|
000018  a01b              ADR      r0,|L3.136|
00001a  f7fffffe          BL       rt_kprintf
00001e  f88d6000          STRB     r6,[sp,#0]
000022  f44f738c          MOV      r3,#0x118
000026  4a17              LDR      r2,|L3.132|
000028  a120              ADR      r1,|L3.172|
00002a  a021              ADR      r0,|L3.176|
00002c  f7fffffe          BL       rt_kprintf
                  |L3.48|
000030  f89d0000          LDRB     r0,[sp,#0]
000034  2800              CMP      r0,#0
000036  d0fb              BEQ      |L3.48|
                  |L3.56|
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       rt_hw_interrupt_enable
;;;281    
;;;282    #ifdef RT_USING_MODULE
;;;283        /*
;;;284         * get module object information,
;;;285         * module object should be managed by kernel object container
;;;286         */
;;;287        information = (rt_module_self() != RT_NULL && (type != RT_Object_Class_Module)) ?
;;;288                      &rt_module_self()->module_object[type] : &rt_object_container[type];
;;;289    #else
;;;290        /* get object information */
;;;291        information = &rt_object_container[type];
00003e  4824              LDR      r0,|L3.208|
000040  eb001705          ADD      r7,r0,r5,LSL #4
;;;292    #endif
;;;293    
;;;294        object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
000044  68f8              LDR      r0,[r7,#0xc]
000046  f7fffffe          BL       rt_malloc
00004a  1e04              SUBS     r4,r0,#0
;;;295        if (object == RT_NULL)
00004c  d017              BEQ      |L3.126|
;;;296        {
;;;297            /* no memory can be allocated */
;;;298            return RT_NULL;
;;;299        }
;;;300    
;;;301        /* initialize object's parameters */
;;;302    
;;;303        /* set object type */
;;;304        object->type = type;
00004e  7225              STRB     r5,[r4,#8]
;;;305    
;;;306        /* set object flag */
;;;307        object->flag = 0;
000050  7266              STRB     r6,[r4,#9]
;;;308    
;;;309    #ifdef RT_USING_MODULE
;;;310        if (rt_module_self() != RT_NULL)
;;;311        {
;;;312            object->flag |= RT_OBJECT_FLAG_MODULE;
;;;313        }
;;;314        object->module_id = (void *)rt_module_self();
;;;315    #endif
;;;316    
;;;317        /* copy name */
;;;318        rt_strncpy(object->name, name, RT_NAME_MAX);
000052  2208              MOVS     r2,#8
000054  4641              MOV      r1,r8
000056  f7fffffe          BL       rt_strncpy
;;;319    
;;;320        RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
00005a  481d              LDR      r0,|L3.208|
00005c  3814              SUBS     r0,r0,#0x14
00005e  6801              LDR      r1,[r0,#0]  ; rt_object_attach_hook
000060  b109              CBZ      r1,|L3.102|
000062  4620              MOV      r0,r4
000064  4788              BLX      r1
                  |L3.102|
;;;321    
;;;322        /* lock interrupt */
;;;323        temp = rt_hw_interrupt_disable();
000066  f7fffffe          BL       rt_hw_interrupt_disable
00006a  4605              MOV      r5,r0
;;;324    
;;;325        /* insert object into information object list */
;;;326        rt_list_insert_after(&(information->object_list), &(object->list));
00006c  f104010c          ADD      r1,r4,#0xc
000070  1d38              ADDS     r0,r7,#4
000072  f7fffffe          BL       rt_list_insert_after
;;;327    
;;;328        /* unlock interrupt */
;;;329        rt_hw_interrupt_enable(temp);
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       rt_hw_interrupt_enable
;;;330    
;;;331        /* return object */
;;;332        return object;
00007c  4620              MOV      r0,r4
                  |L3.126|
;;;333    }
00007e  e8bd83f8          POP      {r3-r9,pc}
;;;334    
                          ENDP

000082  0000              DCW      0x0000
                  |L3.132|
                          DCD      ||.constdata||+0x11
                  |L3.136|
000088  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00008c  74696f6e
000090  5b25735d
000094  20736861
000098  6c6c206e
00009c  6f742075
0000a0  73656420
0000a4  696e2049
0000a8  53520a00
                  |L3.172|
0000ac  3000              DCB      "0",0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L3.176|
0000b0  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000b4  20617373
0000b8  65727420
0000bc  6661696c
0000c0  65642061
0000c4  74202573
0000c8  3a256420
0000cc  0a00    
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L3.208|
                          DCD      ||.data||+0x14

                          AREA ||i.rt_object_attach_sethook||, CODE, READONLY, ALIGN=2

                  rt_object_attach_sethook PROC
;;;97      */
;;;98     void rt_object_attach_sethook(void (*hook)(struct rt_object *object))
000000  4901              LDR      r1,|L4.8|
;;;99     {
;;;100        rt_object_attach_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_object_attach_hook
;;;101    }
000004  4770              BX       lr
;;;102    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||.data||

                          AREA ||i.rt_object_delete||, CODE, READONLY, ALIGN=2

                  rt_object_delete PROC
;;;339     */
;;;340    void rt_object_delete(rt_object_t object)
000000  b538              PUSH     {r3-r5,lr}
;;;341    {
000002  0004              MOVS     r4,r0
000004  f04f0500          MOV      r5,#0
000008  d10c              BNE      |L5.36|
;;;342        register rt_base_t temp;
;;;343    
;;;344        /* object check */
;;;345        RT_ASSERT(object != RT_NULL);
00000a  f88d5000          STRB     r5,[sp,#0]
00000e  f2401359          MOV      r3,#0x159
000012  4a16              LDR      r2,|L5.108|
000014  a116              ADR      r1,|L5.112|
000016  a01b              ADR      r0,|L5.132|
000018  f7fffffe          BL       rt_kprintf
                  |L5.28|
00001c  f89d1000          LDRB     r1,[sp,#0]
000020  2900              CMP      r1,#0
000022  d0fb              BEQ      |L5.28|
                  |L5.36|
;;;346        RT_ASSERT(!(object->type & RT_Object_Class_Static));
000024  7a20              LDRB     r0,[r4,#8]
000026  0600              LSLS     r0,r0,#24
000028  d50c              BPL      |L5.68|
00002a  f88d5000          STRB     r5,[sp,#0]
00002e  f44f73ad          MOV      r3,#0x15a
000032  4a0e              LDR      r2,|L5.108|
000034  a11b              ADR      r1,|L5.164|
000036  a013              ADR      r0,|L5.132|
000038  f7fffffe          BL       rt_kprintf
                  |L5.60|
00003c  f89d1000          LDRB     r1,[sp,#0]
000040  2900              CMP      r1,#0
000042  d0fb              BEQ      |L5.60|
                  |L5.68|
;;;347    
;;;348        RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
000044  4822              LDR      r0,|L5.208|
000046  6841              LDR      r1,[r0,#4]  ; rt_object_detach_hook
000048  b109              CBZ      r1,|L5.78|
00004a  4620              MOV      r0,r4
00004c  4788              BLX      r1
                  |L5.78|
;;;349    
;;;350        /* lock interrupt */
;;;351        temp = rt_hw_interrupt_disable();
00004e  f7fffffe          BL       rt_hw_interrupt_disable
000052  4605              MOV      r5,r0
;;;352    
;;;353        /* remove from old list */
;;;354        rt_list_remove(&(object->list));
000054  f104000c          ADD      r0,r4,#0xc
000058  f7fffffe          BL       rt_list_remove
;;;355    
;;;356        /* unlock interrupt */
;;;357        rt_hw_interrupt_enable(temp);
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       rt_hw_interrupt_enable
;;;358    
;;;359    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;360        if (object->flag & RT_OBJECT_FLAG_MODULE)
;;;361            rt_module_free((rt_module_t)object->module_id, object);
;;;362        else
;;;363    #endif
;;;364    
;;;365        /* free the memory of object */
;;;366        RT_KERNEL_FREE(object);
000062  4620              MOV      r0,r4
000064  e8bd4038          POP      {r3-r5,lr}
000068  f7ffbffe          B.W      rt_free
;;;367    }
;;;368    #endif
                          ENDP

                  |L5.108|
                          DCD      ||.constdata||+0x24
                  |L5.112|
000070  6f626a65          DCB      "object != RT_NULL",0
000074  63742021
000078  3d205254
00007c  5f4e554c
000080  4c00    
000082  00                DCB      0
000083  00                DCB      0
                  |L5.132|
000084  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000088  20617373
00008c  65727420
000090  6661696c
000094  65642061
000098  74202573
00009c  3a256420
0000a0  0a00    
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L5.164|
0000a4  21286f62          DCB      "!(object->type & RT_Object_Class_Static)",0
0000a8  6a656374
0000ac  2d3e7479
0000b0  70652026
0000b4  2052545f
0000b8  4f626a65
0000bc  63745f43
0000c0  6c617373
0000c4  5f537461
0000c8  74696329
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L5.208|
                          DCD      ||.data||

                          AREA ||i.rt_object_detach||, CODE, READONLY, ALIGN=2

                  rt_object_detach PROC
;;;245     */
;;;246    void rt_object_detach(rt_object_t object)
000000  b538              PUSH     {r3-r5,lr}
;;;247    {
000002  0004              MOVS     r4,r0
000004  d10b              BNE      |L6.30|
;;;248        register rt_base_t temp;
;;;249    
;;;250        /* object check */
;;;251        RT_ASSERT(object != RT_NULL);
000006  f88d0000          STRB     r0,[sp,#0]
00000a  23fb              MOVS     r3,#0xfb
00000c  4a0c              LDR      r2,|L6.64|
00000e  a10d              ADR      r1,|L6.68|
000010  a011              ADR      r0,|L6.88|
000012  f7fffffe          BL       rt_kprintf
                  |L6.22|
000016  f89d1000          LDRB     r1,[sp,#0]
00001a  2900              CMP      r1,#0
00001c  d0fb              BEQ      |L6.22|
                  |L6.30|
;;;252    
;;;253        RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
00001e  4816              LDR      r0,|L6.120|
000020  6841              LDR      r1,[r0,#4]  ; rt_object_detach_hook
000022  b109              CBZ      r1,|L6.40|
000024  4620              MOV      r0,r4
000026  4788              BLX      r1
                  |L6.40|
;;;254    
;;;255        /* lock interrupt */
;;;256        temp = rt_hw_interrupt_disable();
000028  f7fffffe          BL       rt_hw_interrupt_disable
00002c  4605              MOV      r5,r0
;;;257    
;;;258        /* remove from old list */
;;;259        rt_list_remove(&(object->list));
00002e  f104000c          ADD      r0,r4,#0xc
000032  f7fffffe          BL       rt_list_remove
;;;260    
;;;261        /* unlock interrupt */
;;;262        rt_hw_interrupt_enable(temp);
000036  4628              MOV      r0,r5
000038  e8bd4038          POP      {r3-r5,lr}
00003c  f7ffbffe          B.W      rt_hw_interrupt_enable
;;;263    }
;;;264    
                          ENDP

                  |L6.64|
                          DCD      ||.constdata||
                  |L6.68|
000044  6f626a65          DCB      "object != RT_NULL",0
000048  63742021
00004c  3d205254
000050  5f4e554c
000054  4c00    
000056  00                DCB      0
000057  00                DCB      0
                  |L6.88|
000058  28257329          DCB      "(%s) assert failed at %s:%d \n",0
00005c  20617373
000060  65727420
000064  6661696c
000068  65642061
00006c  74202573
000070  3a256420
000074  0a00    
000076  00                DCB      0
000077  00                DCB      0
                  |L6.120|
                          DCD      ||.data||

                          AREA ||i.rt_object_detach_sethook||, CODE, READONLY, ALIGN=2

                  rt_object_detach_sethook PROC
;;;108     */
;;;109    void rt_object_detach_sethook(void (*hook)(struct rt_object *object))
000000  4901              LDR      r1,|L7.8|
;;;110    {
;;;111        rt_object_detach_hook = hook;
000002  6048              STR      r0,[r1,#4]  ; rt_object_detach_hook
;;;112    }
000004  4770              BX       lr
;;;113    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||.data||

                          AREA ||i.rt_object_find||, CODE, READONLY, ALIGN=2

                  rt_object_find PROC
;;;401     */
;;;402    rt_object_t rt_object_find(const char *name, rt_uint8_t type)
000000  b5f8              PUSH     {r3-r7,lr}
;;;403    {
000002  460c              MOV      r4,r1
000004  0007              MOVS     r7,r0
000006  d001              BEQ      |L8.12|
;;;404        struct rt_object *object;
;;;405        struct rt_list_node *node;
;;;406        struct rt_object_information *information;
;;;407        extern volatile rt_uint8_t rt_interrupt_nest;
;;;408    
;;;409        /* parameter check */
;;;410        if ((name == RT_NULL) || (type > RT_Object_Class_Unknown))
000008  2c09              CMP      r4,#9
00000a  d901              BLS      |L8.16|
                  |L8.12|
;;;411            return RT_NULL;
00000c  2000              MOVS     r0,#0
;;;412    
;;;413        /* which is invoke in interrupt status */
;;;414        if (rt_interrupt_nest != 0)
;;;415            RT_ASSERT(0);
;;;416    
;;;417        /* enter critical */
;;;418        rt_enter_critical();
;;;419    
;;;420        /* try to find object */
;;;421        information = &rt_object_container[type];
;;;422        for (node  = information->object_list.next;
;;;423             node != &(information->object_list);
;;;424             node  = node->next)
;;;425        {
;;;426            object = rt_list_entry(node, struct rt_object, list);
;;;427            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
;;;428            {
;;;429                /* leave critical */
;;;430                rt_exit_critical();
;;;431    
;;;432                return object;
;;;433            }
;;;434        }
;;;435    
;;;436        /* leave critical */
;;;437        rt_exit_critical();
;;;438    
;;;439        return RT_NULL;
;;;440    }
00000e  bdf8              POP      {r3-r7,pc}
                  |L8.16|
000010  4815              LDR      r0,|L8.104|
000012  7800              LDRB     r0,[r0,#0]            ;414  ; rt_interrupt_nest
000014  b168              CBZ      r0,|L8.50|
000016  2000              MOVS     r0,#0                 ;415
000018  f88d0000          STRB     r0,[sp,#0]            ;415
00001c  f240139f          MOV      r3,#0x19f             ;415
000020  4a12              LDR      r2,|L8.108|
000022  a113              ADR      r1,|L8.112|
000024  a013              ADR      r0,|L8.116|
000026  f7fffffe          BL       rt_kprintf
                  |L8.42|
00002a  f89d0000          LDRB     r0,[sp,#0]            ;415
00002e  2800              CMP      r0,#0                 ;415
000030  d0fb              BEQ      |L8.42|
                  |L8.50|
000032  f7fffffe          BL       rt_enter_critical
000036  4817              LDR      r0,|L8.148|
000038  eb001604          ADD      r6,r0,r4,LSL #4       ;421
00003c  f8564f04          LDR      r4,[r6,#4]!           ;422
000040  e008              B        |L8.84|
                  |L8.66|
000042  f1a4050c          SUB      r5,r4,#0xc            ;426
000046  2208              MOVS     r2,#8                 ;427
000048  4639              MOV      r1,r7                 ;427
00004a  4628              MOV      r0,r5                 ;427
00004c  f7fffffe          BL       rt_strncmp
000050  b128              CBZ      r0,|L8.94|
000052  6824              LDR      r4,[r4,#0]            ;424
                  |L8.84|
000054  42b4              CMP      r4,r6                 ;423
000056  d1f4              BNE      |L8.66|
000058  f7fffffe          BL       rt_exit_critical
00005c  e7d6              B        |L8.12|
                  |L8.94|
00005e  f7fffffe          BL       rt_exit_critical
000062  4628              MOV      r0,r5                 ;432
000064  bdf8              POP      {r3-r7,pc}
;;;441    
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      rt_interrupt_nest
                  |L8.108|
                          DCD      ||.constdata||+0x4f
                  |L8.112|
000070  3000              DCB      "0",0
000072  00                DCB      0
000073  00                DCB      0
                  |L8.116|
000074  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000078  20617373
00007c  65727420
000080  6661696c
000084  65642061
000088  74202573
00008c  3a256420
000090  0a00    
000092  00                DCB      0
000093  00                DCB      0
                  |L8.148|
                          DCD      ||.data||+0x14

                          AREA ||i.rt_object_get_information||, CODE, READONLY, ALIGN=2

                  rt_object_get_information PROC
;;;189    struct rt_object_information *
;;;190    rt_object_get_information(enum rt_object_class_type type)
000000  4901              LDR      r1,|L9.8|
;;;191    {
;;;192        return &rt_object_container[type];
000002  eb011000          ADD      r0,r1,r0,LSL #4
;;;193    }
000006  4770              BX       lr
;;;194    RTM_EXPORT(rt_object_get_information);
                          ENDP

                  |L9.8|
                          DCD      ||.data||+0x14

                          AREA ||i.rt_object_init||, CODE, READONLY, ALIGN=2

                  rt_object_init PROC
;;;203     */
;;;204    void rt_object_init(struct rt_object         *object,
000000  b570              PUSH     {r4-r6,lr}
;;;205                        enum rt_object_class_type type,
;;;206                        const char               *name)
;;;207    {
000002  4604              MOV      r4,r0
;;;208        register rt_base_t temp;
;;;209        struct rt_object_information *information;
;;;210    
;;;211    #ifdef RT_USING_MODULE
;;;212        /* get module object information */
;;;213        information = (rt_module_self() != RT_NULL) ?
;;;214            &rt_module_self()->module_object[type] : &rt_object_container[type];
;;;215    #else
;;;216        /* get object information */
;;;217        information = &rt_object_container[type];
000004  480f              LDR      r0,|L10.68|
000006  4613              MOV      r3,r2                 ;207
000008  eb001501          ADD      r5,r0,r1,LSL #4
;;;218    #endif
;;;219    
;;;220        /* initialize object's parameters */
;;;221    
;;;222        /* set object type to static */
;;;223        object->type = type | RT_Object_Class_Static;
00000c  f0410080          ORR      r0,r1,#0x80
000010  7220              STRB     r0,[r4,#8]
;;;224    
;;;225        /* copy name */
;;;226        rt_strncpy(object->name, name, RT_NAME_MAX);
000012  2208              MOVS     r2,#8
000014  4619              MOV      r1,r3
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       rt_strncpy
;;;227    
;;;228        RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
00001c  4809              LDR      r0,|L10.68|
00001e  3814              SUBS     r0,r0,#0x14
000020  6801              LDR      r1,[r0,#0]  ; rt_object_attach_hook
000022  b109              CBZ      r1,|L10.40|
000024  4620              MOV      r0,r4
000026  4788              BLX      r1
                  |L10.40|
;;;229    
;;;230        /* lock interrupt */
;;;231        temp = rt_hw_interrupt_disable();
000028  f7fffffe          BL       rt_hw_interrupt_disable
00002c  4606              MOV      r6,r0
;;;232    
;;;233        /* insert object into information object list */
;;;234        rt_list_insert_after(&(information->object_list), &(object->list));
00002e  f104010c          ADD      r1,r4,#0xc
000032  1d28              ADDS     r0,r5,#4
000034  f7fffffe          BL       rt_list_insert_after
;;;235    
;;;236        /* unlock interrupt */
;;;237        rt_hw_interrupt_enable(temp);
000038  4630              MOV      r0,r6
00003a  e8bd4070          POP      {r4-r6,lr}
00003e  f7ffbffe          B.W      rt_hw_interrupt_enable
;;;238    }
;;;239    
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      ||.data||+0x14

                          AREA ||i.rt_object_is_systemobject||, CODE, READONLY, ALIGN=2

                  rt_object_is_systemobject PROC
;;;378     */
;;;379    rt_bool_t rt_object_is_systemobject(rt_object_t object)
000000  b538              PUSH     {r3-r5,lr}
;;;380    {
000002  0004              MOVS     r4,r0
000004  d10c              BNE      |L11.32|
;;;381        /* object check */
;;;382        RT_ASSERT(object != RT_NULL);
000006  f88d0000          STRB     r0,[sp,#0]
00000a  f44f73bf          MOV      r3,#0x17e
00000e  4a08              LDR      r2,|L11.48|
000010  a108              ADR      r1,|L11.52|
000012  a00d              ADR      r0,|L11.72|
000014  f7fffffe          BL       rt_kprintf
                  |L11.24|
000018  f89d1000          LDRB     r1,[sp,#0]
00001c  2900              CMP      r1,#0
00001e  d0fb              BEQ      |L11.24|
                  |L11.32|
;;;383    
;;;384        if (object->type & RT_Object_Class_Static)
000020  7a20              LDRB     r0,[r4,#8]
000022  0600              LSLS     r0,r0,#24
000024  d501              BPL      |L11.42|
;;;385            return RT_TRUE;
000026  2001              MOVS     r0,#1
;;;386    
;;;387        return RT_FALSE;
;;;388    }
000028  bd38              POP      {r3-r5,pc}
                  |L11.42|
00002a  2000              MOVS     r0,#0                 ;387
00002c  bd38              POP      {r3-r5,pc}
;;;389    
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
                          DCD      ||.constdata||+0x35
                  |L11.52|
000034  6f626a65          DCB      "object != RT_NULL",0
000038  63742021
00003c  3d205254
000040  5f4e554c
000044  4c00    
000046  00                DCB      0
000047  00                DCB      0
                  |L11.72|
000048  28257329          DCB      "(%s) assert failed at %s:%d \n",0
00004c  20617373
000050  65727420
000054  6661696c
000058  65642061
00005c  74202573
000060  3a256420
000064  0a00    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.rt_object_put_sethook||, CODE, READONLY, ALIGN=2

                  rt_object_put_sethook PROC
;;;156     */
;;;157    void rt_object_put_sethook(void (*hook)(struct rt_object *object))
000000  4901              LDR      r1,|L12.8|
;;;158    {
;;;159        rt_object_put_hook = hook;
000002  6108              STR      r0,[r1,#0x10]  ; rt_object_put_hook
;;;160    }
000004  4770              BX       lr
;;;161    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.data||

                          AREA ||i.rt_object_take_sethook||, CODE, READONLY, ALIGN=2

                  rt_object_take_sethook PROC
;;;145     */
;;;146    void rt_object_take_sethook(void (*hook)(struct rt_object *object))
000000  4901              LDR      r1,|L13.8|
;;;147    {
;;;148        rt_object_take_hook = hook;
000002  60c8              STR      r0,[r1,#0xc]  ; rt_object_take_hook
;;;149    }
000004  4770              BX       lr
;;;150    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.data||

                          AREA ||i.rt_object_trytake_sethook||, CODE, READONLY, ALIGN=2

                  rt_object_trytake_sethook PROC
;;;126     */
;;;127    void rt_object_trytake_sethook(void (*hook)(struct rt_object *object))
000000  4901              LDR      r1,|L14.8|
;;;128    {
;;;129        rt_object_trytake_hook = hook;
000002  6088              STR      r0,[r1,#8]  ; rt_object_trytake_hook
;;;130    }
000004  4770              BX       lr
;;;131    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.rt_system_object_init||, CODE, READONLY, ALIGN=1

                  rt_system_object_init PROC
;;;172     */
;;;173    void rt_system_object_init(void)
000000  4770              BX       lr
;;;174    {
;;;175    }
;;;176    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f6f          DCB      0x72,0x74,0x5f,0x6f
000004  626a6563          DCB      0x62,0x6a,0x65,0x63
000008  745f6465          DCB      0x74,0x5f,0x64,0x65
00000c  74616368          DCB      0x74,0x61,0x63,0x68
000010  00                DCB      0x00
                  |symbol_number.48|
000011  72745f            DCB      0x72,0x74,0x5f
000014  6f626a65          DCB      0x6f,0x62,0x6a,0x65
000018  63745f61          DCB      0x63,0x74,0x5f,0x61
00001c  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000020  61746500          DCB      0x61,0x74,0x65,0x00
                  |symbol_number.49|
000024  72745f6f          DCB      0x72,0x74,0x5f,0x6f
000028  626a6563          DCB      0x62,0x6a,0x65,0x63
00002c  745f6465          DCB      0x74,0x5f,0x64,0x65
000030  6c657465          DCB      0x6c,0x65,0x74,0x65
000034  00                DCB      0x00
                  |symbol_number.50|
000035  72745f            DCB      0x72,0x74,0x5f
000038  6f626a65          DCB      0x6f,0x62,0x6a,0x65
00003c  63745f69          DCB      0x63,0x74,0x5f,0x69
000040  735f7379          DCB      0x73,0x5f,0x73,0x79
000044  7374656d          DCB      0x73,0x74,0x65,0x6d
000048  6f626a65          DCB      0x6f,0x62,0x6a,0x65
00004c  637400            DCB      0x63,0x74,0x00
                  |symbol_number.51|
00004f  72                DCB      0x72
000050  745f6f62          DCB      0x74,0x5f,0x6f,0x62
000054  6a656374          DCB      0x6a,0x65,0x63,0x74
000058  5f66696e          DCB      0x5f,0x66,0x69,0x6e
00005c  6400              DCB      0x64,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  rt_object_attach_hook
                          DCD      0x00000000
                  rt_object_detach_hook
                          DCD      0x00000000
                  rt_object_trytake_hook
                          DCD      0x00000000
                  rt_object_take_hook
                          DCD      0x00000000
                  rt_object_put_hook
                          DCD      0x00000000
                  rt_object_container
000014  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      rt_object_container+0x4
                          DCD      rt_object_container+0x4
                          DCD      0x00000080
000024  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      rt_object_container+0x14
                          DCD      rt_object_container+0x14
                          DCD      0x00000020
000034  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      rt_object_container+0x24
                          DCD      rt_object_container+0x24
                          DCD      0x00000024
000044  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      rt_object_container+0x34
                          DCD      rt_object_container+0x34
                          DCD      0x00000020
000054  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      rt_object_container+0x44
                          DCD      rt_object_container+0x44
                          DCD      0x00000030
000064  05000000          DCB      0x05,0x00,0x00,0x00
                          DCD      rt_object_container+0x54
                          DCD      rt_object_container+0x54
                          DCD      0x00000034
000074  06000000          DCB      0x06,0x00,0x00,0x00
                          DCD      rt_object_container+0x64
                          DCD      rt_object_container+0x64
                          DCD      0x00000038
000084  07000000          DCB      0x07,0x00,0x00,0x00
                          DCD      rt_object_container+0x74
                          DCD      rt_object_container+0x74
                          DCD      0x00000040
000094  08000000          DCB      0x08,0x00,0x00,0x00
                          DCD      rt_object_container+0x84
                          DCD      rt_object_container+0x84
                          DCD      0x0000002c
