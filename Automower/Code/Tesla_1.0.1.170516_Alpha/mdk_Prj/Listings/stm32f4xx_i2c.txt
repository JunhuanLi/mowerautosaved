; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_i2c.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_i2c.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=2

                  I2C_ARPCmd PROC
;;;650      */
;;;651    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;652    {
000002  4604              MOV      r4,r0
;;;653      /* Check the parameters */
;;;654      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L1.68|
000006  460d              MOV      r5,r1                 ;652
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L1.34|
00000c  480e              LDR      r0,|L1.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L1.34|
000012  480e              LDR      r0,|L1.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L1.34|
000018  f240218e          MOV      r1,#0x28e
00001c  480c              LDR      r0,|L1.80|
00001e  f7fffffe          BL       assert_failed
                  |L1.34|
;;;655      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L1.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L1.50|
000028  f240218f          MOV      r1,#0x28f
00002c  4808              LDR      r0,|L1.80|
00002e  f7fffffe          BL       assert_failed
                  |L1.50|
;;;656      if (NewState != DISABLE)
;;;657      {
;;;658        /* Enable the selected I2C ARP */
;;;659        I2Cx->CR1 |= I2C_CR1_ENARP;
000032  8820              LDRH     r0,[r4,#0]
000034  f0400010          ORR      r0,r0,#0x10
000038  e002              B        |L1.64|
                  |L1.58|
;;;660      }
;;;661      else
;;;662      {
;;;663        /* Disable the selected I2C ARP */
;;;664        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
00003a  8820              LDRH     r0,[r4,#0]
00003c  f0200010          BIC      r0,r0,#0x10
                  |L1.64|
000040  8020              STRH     r0,[r4,#0]            ;659
;;;665      }
;;;666    }
000042  bd70              POP      {r4-r6,pc}
;;;667    /**
                          ENDP

                  |L1.68|
                          DCD      0x40005400
                  |L1.72|
                          DCD      0x40005800
                  |L1.76|
                          DCD      0x40005c00
                  |L1.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=2

                  I2C_AcknowledgeConfig PROC
;;;410      */
;;;411    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;412    {
000002  4604              MOV      r4,r0
;;;413      /* Check the parameters */
;;;414      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L2.68|
000006  460d              MOV      r5,r1                 ;412
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L2.34|
00000c  480e              LDR      r0,|L2.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L2.34|
000012  480e              LDR      r0,|L2.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L2.34|
000018  f44f71cf          MOV      r1,#0x19e
00001c  480c              LDR      r0,|L2.80|
00001e  f7fffffe          BL       assert_failed
                  |L2.34|
;;;415      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L2.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L2.50|
000028  f240119f          MOV      r1,#0x19f
00002c  4808              LDR      r0,|L2.80|
00002e  f7fffffe          BL       assert_failed
                  |L2.50|
;;;416      if (NewState != DISABLE)
;;;417      {
;;;418        /* Enable the acknowledgement */
;;;419        I2Cx->CR1 |= I2C_CR1_ACK;
000032  8820              LDRH     r0,[r4,#0]
000034  f4406080          ORR      r0,r0,#0x400
000038  e002              B        |L2.64|
                  |L2.58|
;;;420      }
;;;421      else
;;;422      {
;;;423        /* Disable the acknowledgement */
;;;424        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
00003a  8820              LDRH     r0,[r4,#0]
00003c  f4206080          BIC      r0,r0,#0x400
                  |L2.64|
000040  8020              STRH     r0,[r4,#0]            ;419
;;;425      }
;;;426    }
000042  bd70              POP      {r4-r6,pc}
;;;427    
                          ENDP

                  |L2.68|
                          DCD      0x40005400
                  |L2.72|
                          DCD      0x40005800
                  |L2.76|
                          DCD      0x40005c00
                  |L2.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=2

                  I2C_CalculatePEC PROC
;;;787      */
;;;788    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;789    {
000002  4604              MOV      r4,r0
;;;790      /* Check the parameters */
;;;791      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L3.68|
000006  460d              MOV      r5,r1                 ;789
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L3.34|
00000c  480e              LDR      r0,|L3.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L3.34|
000012  480e              LDR      r0,|L3.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L3.34|
000018  f2403117          MOV      r1,#0x317
00001c  480c              LDR      r0,|L3.80|
00001e  f7fffffe          BL       assert_failed
                  |L3.34|
;;;792      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L3.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L3.50|
000028  f44f7146          MOV      r1,#0x318
00002c  4808              LDR      r0,|L3.80|
00002e  f7fffffe          BL       assert_failed
                  |L3.50|
;;;793      if (NewState != DISABLE)
;;;794      {
;;;795        /* Enable the selected I2C PEC calculation */
;;;796        I2Cx->CR1 |= I2C_CR1_ENPEC;
000032  8820              LDRH     r0,[r4,#0]
000034  f0400020          ORR      r0,r0,#0x20
000038  e002              B        |L3.64|
                  |L3.58|
;;;797      }
;;;798      else
;;;799      {
;;;800        /* Disable the selected I2C PEC calculation */
;;;801        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
00003a  8820              LDRH     r0,[r4,#0]
00003c  f0200020          BIC      r0,r0,#0x20
                  |L3.64|
000040  8020              STRH     r0,[r4,#0]            ;796
;;;802      }
;;;803    }
000042  bd70              POP      {r4-r6,pc}
;;;804    
                          ENDP

                  |L3.68|
                          DCD      0x40005400
                  |L3.72|
                          DCD      0x40005800
                  |L3.76|
                          DCD      0x40005c00
                  |L3.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=2

                  I2C_CheckEvent PROC
;;;1090     */
;;;1091   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  b570              PUSH     {r4-r6,lr}
;;;1092   {
000002  4605              MOV      r5,r0
;;;1093     uint32_t lastevent = 0;
;;;1094     uint32_t flag1 = 0, flag2 = 0;
;;;1095     ErrorStatus status = ERROR;
;;;1096   
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4830              LDR      r0,|L4.200|
000006  2600              MOVS     r6,#0                 ;1095
000008  460c              MOV      r4,r1                 ;1092
00000a  4285              CMP      r5,r0
00000c  d00a              BEQ      |L4.36|
00000e  482f              LDR      r0,|L4.204|
000010  4285              CMP      r5,r0
000012  d007              BEQ      |L4.36|
000014  482e              LDR      r0,|L4.208|
000016  4285              CMP      r5,r0
000018  d004              BEQ      |L4.36|
00001a  f240414a          MOV      r1,#0x44a
00001e  482d              LDR      r0,|L4.212|
000020  f7fffffe          BL       assert_failed
                  |L4.36|
;;;1099     assert_param(IS_I2C_EVENT(I2C_EVENT));
000024  f5a420c0          SUB      r0,r4,#0x60000
000028  3882              SUBS     r0,r0,#0x82
00002a  d042              BEQ      |L4.178|
00002c  f1b41f02          CMP      r4,#0x20002
000030  d03f              BEQ      |L4.178|
000032  f5a40006          SUB      r0,r4,#0x860000
000036  3880              SUBS     r0,r0,#0x80
000038  d03b              BEQ      |L4.178|
00003a  f5b40f02          CMP      r4,#0x820000
00003e  d038              BEQ      |L4.178|
000040  f5b41f90          CMP      r4,#0x120000
000044  d035              BEQ      |L4.178|
000046  f5a43000          SUB      r0,r4,#0x20000
00004a  3840              SUBS     r0,r0,#0x40
00004c  d031              BEQ      |L4.178|
00004e  f5b00000          SUBS     r0,r0,#0x800000
000052  d02e              BEQ      |L4.178|
000054  f51000e0          ADDS     r0,r0,#0x700000
000058  d02b              BEQ      |L4.178|
00005a  f5a420c0          SUB      r0,r4,#0x60000
00005e  3884              SUBS     r0,r0,#0x84
000060  d027              BEQ      |L4.178|
000062  f5b00000          SUBS     r0,r0,#0x800000
000066  d024              BEQ      |L4.178|
000068  f51000e0          ADDS     r0,r0,#0x700000
00006c  d021              BEQ      |L4.178|
00006e  2c10              CMP      r4,#0x10
000070  d01f              BEQ      |L4.178|
000072  f46f3040          MVN      r0,#0x30000
000076  42c4              CMN      r4,r0
000078  d01b              BEQ      |L4.178|
00007a  f5a420e0          SUB      r0,r4,#0x70000
00007e  3882              SUBS     r0,r0,#0x82
000080  d017              BEQ      |L4.178|
000082  f5a43040          SUB      r0,r4,#0x30000
000086  1e80              SUBS     r0,r0,#2
000088  d013              BEQ      |L4.178|
00008a  383e              SUBS     r0,r0,#0x3e
00008c  d011              BEQ      |L4.178|
00008e  f5a420e0          SUB      r0,r4,#0x70000
000092  3884              SUBS     r0,r0,#0x84
000094  d00d              BEQ      |L4.178|
000096  1d00              ADDS     r0,r0,#4
000098  d00b              BEQ      |L4.178|
00009a  f5a43040          SUB      r0,r4,#0x30000
00009e  3808              SUBS     r0,r0,#8
0000a0  d007              BEQ      |L4.178|
0000a2  f5b46f80          CMP      r4,#0x400
0000a6  d004              BEQ      |L4.178|
0000a8  f240414b          MOV      r1,#0x44b
0000ac  4809              LDR      r0,|L4.212|
0000ae  f7fffffe          BL       assert_failed
                  |L4.178|
;;;1100   
;;;1101     /* Read the I2Cx status register */
;;;1102     flag1 = I2Cx->SR1;
0000b2  8aa8              LDRH     r0,[r5,#0x14]
;;;1103     flag2 = I2Cx->SR2;
0000b4  8b29              LDRH     r1,[r5,#0x18]
;;;1104     flag2 = flag2 << 16;
;;;1105   
;;;1106     /* Get the last event value from I2C status register */
;;;1107     lastevent = (flag1 | flag2) & FLAG_MASK;
0000b6  ea404001          ORR      r0,r0,r1,LSL #16
0000ba  f020407f          BIC      r0,r0,#0xff000000
;;;1108   
;;;1109     /* Check whether the last event contains the I2C_EVENT */
;;;1110     if ((lastevent & I2C_EVENT) == I2C_EVENT)
0000be  4384              BICS     r4,r4,r0
0000c0  d100              BNE      |L4.196|
;;;1111     {
;;;1112       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1113       status = SUCCESS;
0000c2  2601              MOVS     r6,#1
                  |L4.196|
;;;1114     }
;;;1115     else
;;;1116     {
;;;1117       /* ERROR: last event is different from I2C_EVENT */
;;;1118       status = ERROR;
;;;1119     }
;;;1120     /* Return status */
;;;1121     return status;
0000c4  4630              MOV      r0,r6
;;;1122   }
0000c6  bd70              POP      {r4-r6,pc}
;;;1123   
                          ENDP

                  |L4.200|
                          DCD      0x40005400
                  |L4.204|
                          DCD      0x40005800
                  |L4.208|
                          DCD      0x40005c00
                  |L4.212|
                          DCD      ||.conststring||

                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=2

                  I2C_ClearFlag PROC
;;;1270     */
;;;1271   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1272   {
000002  4604              MOV      r4,r0
;;;1273     uint32_t flagpos = 0;
;;;1274     /* Check the parameters */
;;;1275     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480d              LDR      r0,|L5.60|
000006  460d              MOV      r5,r1                 ;1272
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L5.34|
00000c  480c              LDR      r0,|L5.64|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L5.34|
000012  480c              LDR      r0,|L5.68|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L5.34|
000018  f24041fb          MOV      r1,#0x4fb
00001c  480a              LDR      r0,|L5.72|
00001e  f7fffffe          BL       assert_failed
                  |L5.34|
;;;1276     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
000022  f24200ff          MOV      r0,#0x20ff
000026  4205              TST      r5,r0
000028  d100              BNE      |L5.44|
00002a  b925              CBNZ     r5,|L5.54|
                  |L5.44|
00002c  f24041fc          MOV      r1,#0x4fc
000030  4805              LDR      r0,|L5.72|
000032  f7fffffe          BL       assert_failed
                  |L5.54|
;;;1277     /* Get the I2C flag position */
;;;1278     flagpos = I2C_FLAG & FLAG_MASK;
;;;1279     /* Clear the selected I2C flag */
;;;1280     I2Cx->SR1 = (uint16_t)~flagpos;
000036  43e8              MVNS     r0,r5
000038  82a0              STRH     r0,[r4,#0x14]
;;;1281   }
00003a  bd70              POP      {r4-r6,pc}
;;;1282   
                          ENDP

                  |L5.60|
                          DCD      0x40005400
                  |L5.64|
                          DCD      0x40005800
                  |L5.68|
                          DCD      0x40005c00
                  |L5.72|
                          DCD      ||.conststring||

                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  I2C_ClearITPendingBit PROC
;;;1364     */
;;;1365   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1366   {
000002  4604              MOV      r4,r0
;;;1367     uint32_t flagpos = 0;
;;;1368     /* Check the parameters */
;;;1369     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480d              LDR      r0,|L6.60|
000006  460d              MOV      r5,r1                 ;1366
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L6.34|
00000c  480c              LDR      r0,|L6.64|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L6.34|
000012  480c              LDR      r0,|L6.68|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L6.34|
000018  f2405159          MOV      r1,#0x559
00001c  480a              LDR      r0,|L6.72|
00001e  f7fffffe          BL       assert_failed
                  |L6.34|
;;;1370     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
000022  f24200ff          MOV      r0,#0x20ff
000026  4205              TST      r5,r0
000028  d100              BNE      |L6.44|
00002a  b925              CBNZ     r5,|L6.54|
                  |L6.44|
00002c  f240515a          MOV      r1,#0x55a
000030  4805              LDR      r0,|L6.72|
000032  f7fffffe          BL       assert_failed
                  |L6.54|
;;;1371   
;;;1372     /* Get the I2C flag position */
;;;1373     flagpos = I2C_IT & FLAG_MASK;
;;;1374   
;;;1375     /* Clear the selected I2C flag */
;;;1376     I2Cx->SR1 = (uint16_t)~flagpos;
000036  43e8              MVNS     r0,r5
000038  82a0              STRH     r0,[r4,#0x14]
;;;1377   }
00003a  bd70              POP      {r4-r6,pc}
;;;1378   
                          ENDP

                  |L6.60|
                          DCD      0x40005400
                  |L6.64|
                          DCD      0x40005800
                  |L6.68|
                          DCD      0x40005c00
                  |L6.72|
                          DCD      ||.conststring||

                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=2

                  I2C_Cmd PROC
;;;307      */
;;;308    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;309    {
000002  4604              MOV      r4,r0
;;;310      /* Check the parameters */
;;;311      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L7.68|
000006  460d              MOV      r5,r1                 ;309
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L7.34|
00000c  480e              LDR      r0,|L7.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L7.34|
000012  480e              LDR      r0,|L7.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L7.34|
000018  f2401137          MOV      r1,#0x137
00001c  480c              LDR      r0,|L7.80|
00001e  f7fffffe          BL       assert_failed
                  |L7.34|
;;;312      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L7.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L7.50|
000028  f44f719c          MOV      r1,#0x138
00002c  4808              LDR      r0,|L7.80|
00002e  f7fffffe          BL       assert_failed
                  |L7.50|
;;;313      if (NewState != DISABLE)
;;;314      {
;;;315        /* Enable the selected I2C peripheral */
;;;316        I2Cx->CR1 |= I2C_CR1_PE;
000032  8820              LDRH     r0,[r4,#0]
000034  f0400001          ORR      r0,r0,#1
000038  e002              B        |L7.64|
                  |L7.58|
;;;317      }
;;;318      else
;;;319      {
;;;320        /* Disable the selected I2C peripheral */
;;;321        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
00003a  8820              LDRH     r0,[r4,#0]
00003c  f0200001          BIC      r0,r0,#1
                  |L7.64|
000040  8020              STRH     r0,[r4,#0]            ;316
;;;322      }
;;;323    }
000042  bd70              POP      {r4-r6,pc}
;;;324    
                          ENDP

                  |L7.68|
                          DCD      0x40005400
                  |L7.72|
                          DCD      0x40005800
                  |L7.76|
                          DCD      0x40005c00
                  |L7.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=2

                  I2C_DMACmd PROC
;;;842      */
;;;843    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;844    {
000002  4604              MOV      r4,r0
;;;845      /* Check the parameters */
;;;846      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L8.68|
000006  460d              MOV      r5,r1                 ;844
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L8.34|
00000c  480e              LDR      r0,|L8.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L8.34|
000012  480e              LDR      r0,|L8.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L8.34|
000018  f240314e          MOV      r1,#0x34e
00001c  480c              LDR      r0,|L8.80|
00001e  f7fffffe          BL       assert_failed
                  |L8.34|
;;;847      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L8.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L8.50|
000028  f240314f          MOV      r1,#0x34f
00002c  4808              LDR      r0,|L8.80|
00002e  f7fffffe          BL       assert_failed
                  |L8.50|
;;;848      if (NewState != DISABLE)
;;;849      {
;;;850        /* Enable the selected I2C DMA requests */
;;;851        I2Cx->CR2 |= I2C_CR2_DMAEN;
000032  88a0              LDRH     r0,[r4,#4]
000034  f4406000          ORR      r0,r0,#0x800
000038  e002              B        |L8.64|
                  |L8.58|
;;;852      }
;;;853      else
;;;854      {
;;;855        /* Disable the selected I2C DMA requests */
;;;856        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
00003a  88a0              LDRH     r0,[r4,#4]
00003c  f4206000          BIC      r0,r0,#0x800
                  |L8.64|
000040  80a0              STRH     r0,[r4,#4]            ;851
;;;857      }
;;;858    }
000042  bd70              POP      {r4-r6,pc}
;;;859    
                          ENDP

                  |L8.68|
                          DCD      0x40005400
                  |L8.72|
                          DCD      0x40005800
                  |L8.76|
                          DCD      0x40005c00
                  |L8.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=2

                  I2C_DMALastTransferCmd PROC
;;;866      */
;;;867    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;868    {
000002  4604              MOV      r4,r0
;;;869      /* Check the parameters */
;;;870      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L9.68|
000006  460d              MOV      r5,r1                 ;868
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L9.34|
00000c  480e              LDR      r0,|L9.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L9.34|
000012  480e              LDR      r0,|L9.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L9.34|
000018  f2403166          MOV      r1,#0x366
00001c  480c              LDR      r0,|L9.80|
00001e  f7fffffe          BL       assert_failed
                  |L9.34|
;;;871      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L9.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L9.50|
000028  f2403167          MOV      r1,#0x367
00002c  4808              LDR      r0,|L9.80|
00002e  f7fffffe          BL       assert_failed
                  |L9.50|
;;;872      if (NewState != DISABLE)
;;;873      {
;;;874        /* Next DMA transfer is the last transfer */
;;;875        I2Cx->CR2 |= I2C_CR2_LAST;
000032  88a0              LDRH     r0,[r4,#4]
000034  f4405080          ORR      r0,r0,#0x1000
000038  e002              B        |L9.64|
                  |L9.58|
;;;876      }
;;;877      else
;;;878      {
;;;879        /* Next DMA transfer is not the last transfer */
;;;880        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
00003a  88a0              LDRH     r0,[r4,#4]
00003c  f4205080          BIC      r0,r0,#0x1000
                  |L9.64|
000040  80a0              STRH     r0,[r4,#4]            ;875
;;;881      }
;;;882    }
000042  bd70              POP      {r4-r6,pc}
;;;883    
                          ENDP

                  |L9.68|
                          DCD      0x40005400
                  |L9.72|
                          DCD      0x40005800
                  |L9.76|
                          DCD      0x40005c00
                  |L9.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;131      */
;;;132    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;133    {
;;;134      /* Check the parameters */
;;;135      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4d13              LDR      r5,|L10.84|
000006  4e14              LDR      r6,|L10.88|
000008  4f14              LDR      r7,|L10.92|
00000a  4604              MOV      r4,r0                 ;133
00000c  42a8              CMP      r0,r5
00000e  d007              BEQ      |L10.32|
000010  42b4              CMP      r4,r6
000012  d005              BEQ      |L10.32|
000014  42bc              CMP      r4,r7
000016  d003              BEQ      |L10.32|
000018  2187              MOVS     r1,#0x87
00001a  4811              LDR      r0,|L10.96|
00001c  f7fffffe          BL       assert_failed
                  |L10.32|
;;;136    
;;;137      if (I2Cx == I2C1)
000020  42ac              CMP      r4,r5
000022  d102              BNE      |L10.42|
;;;138      {
;;;139        /* Enable I2C1 reset state */
;;;140        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
000024  2101              MOVS     r1,#1
000026  054c              LSLS     r4,r1,#21
;;;141        /* Release I2C1 from reset state */
;;;142        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
000028  e008              B        |L10.60|
                  |L10.42|
;;;143      }
;;;144      else if (I2Cx == I2C2)
00002a  42b4              CMP      r4,r6
00002c  d102              BNE      |L10.52|
;;;145      {
;;;146        /* Enable I2C2 reset state */
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
00002e  2101              MOVS     r1,#1
000030  058c              LSLS     r4,r1,#22
;;;148        /* Release I2C2 from reset state */
;;;149        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
000032  e003              B        |L10.60|
                  |L10.52|
;;;150      }
;;;151      else 
;;;152      {
;;;153        if (I2Cx == I2C3)
000034  42bc              CMP      r4,r7
000036  d10a              BNE      |L10.78|
;;;154        {
;;;155          /* Enable I2C3 reset state */
;;;156          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
000038  2101              MOVS     r1,#1
00003a  05cc              LSLS     r4,r1,#23
                  |L10.60|
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;157          /* Release I2C3 from reset state */
;;;158          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
000042  4620              MOV      r0,r4
000044  e8bd41f0          POP      {r4-r8,lr}
000048  2100              MOVS     r1,#0
00004a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L10.78|
;;;159        }
;;;160      }
;;;161    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;162    
                          ENDP

000052  0000              DCW      0x0000
                  |L10.84|
                          DCD      0x40005400
                  |L10.88|
                          DCD      0x40005800
                  |L10.92|
                          DCD      0x40005c00
                  |L10.96|
                          DCD      ||.conststring||

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=2

                  I2C_DualAddressCmd PROC
;;;460      */
;;;461    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;462    {
000002  4604              MOV      r4,r0
;;;463      /* Check the parameters */
;;;464      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L11.68|
000006  460d              MOV      r5,r1                 ;462
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L11.34|
00000c  480e              LDR      r0,|L11.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L11.34|
000012  480e              LDR      r0,|L11.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L11.34|
000018  f44f71e8          MOV      r1,#0x1d0
00001c  480c              LDR      r0,|L11.80|
00001e  f7fffffe          BL       assert_failed
                  |L11.34|
;;;465      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L11.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L11.50|
000028  f24011d1          MOV      r1,#0x1d1
00002c  4808              LDR      r0,|L11.80|
00002e  f7fffffe          BL       assert_failed
                  |L11.50|
;;;466      if (NewState != DISABLE)
;;;467      {
;;;468        /* Enable dual addressing mode */
;;;469        I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
000032  89a0              LDRH     r0,[r4,#0xc]
000034  f0400001          ORR      r0,r0,#1
000038  e002              B        |L11.64|
                  |L11.58|
;;;470      }
;;;471      else
;;;472      {
;;;473        /* Disable dual addressing mode */
;;;474        I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
00003a  89a0              LDRH     r0,[r4,#0xc]
00003c  f0200001          BIC      r0,r0,#1
                  |L11.64|
000040  81a0              STRH     r0,[r4,#0xc]          ;469
;;;475      }
;;;476    }
000042  bd70              POP      {r4-r6,pc}
;;;477    
                          ENDP

                  |L11.68|
                          DCD      0x40005400
                  |L11.72|
                          DCD      0x40005800
                  |L11.76|
                          DCD      0x40005c00
                  |L11.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=2

                  I2C_FastModeDutyCycleConfig PROC
;;;560      */
;;;561    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  b570              PUSH     {r4-r6,lr}
;;;562    {
000002  4604              MOV      r4,r0
;;;563      /* Check the parameters */
;;;564      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4811              LDR      r0,|L12.76|
000006  460d              MOV      r5,r1                 ;562
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L12.34|
00000c  4810              LDR      r0,|L12.80|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L12.34|
000012  4810              LDR      r0,|L12.84|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L12.34|
000018  f44f710d          MOV      r1,#0x234
00001c  480e              LDR      r0,|L12.88|
00001e  f7fffffe          BL       assert_failed
                  |L12.34|
;;;565      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
000022  f5b54f80          CMP      r5,#0x4000
000026  d00c              BEQ      |L12.66|
000028  f5a5403f          SUB      r0,r5,#0xbf00
00002c  38ff              SUBS     r0,r0,#0xff
00002e  d004              BEQ      |L12.58|
000030  f2402135          MOV      r1,#0x235
000034  4808              LDR      r0,|L12.88|
000036  f7fffffe          BL       assert_failed
                  |L12.58|
;;;566      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
;;;567      {
;;;568        /* I2C fast mode Tlow/Thigh=2 */
;;;569        I2Cx->CCR &= I2C_DutyCycle_2;
00003a  8ba0              LDRH     r0,[r4,#0x1c]
00003c  f4204080          BIC      r0,r0,#0x4000
000040  e002              B        |L12.72|
                  |L12.66|
;;;570      }
;;;571      else
;;;572      {
;;;573        /* I2C fast mode Tlow/Thigh=16/9 */
;;;574        I2Cx->CCR |= I2C_DutyCycle_16_9;
000042  8ba0              LDRH     r0,[r4,#0x1c]
000044  f4404080          ORR      r0,r0,#0x4000
                  |L12.72|
000048  83a0              STRH     r0,[r4,#0x1c]         ;569
;;;575      }
;;;576    }
00004a  bd70              POP      {r4-r6,pc}
;;;577    
                          ENDP

                  |L12.76|
                          DCD      0x40005400
                  |L12.80|
                          DCD      0x40005800
                  |L12.84|
                          DCD      0x40005c00
                  |L12.88|
                          DCD      ||.conststring||

                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=2

                  I2C_GeneralCallCmd PROC
;;;484      */
;;;485    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;486    {
000002  4604              MOV      r4,r0
;;;487      /* Check the parameters */
;;;488      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L13.68|
000006  460d              MOV      r5,r1                 ;486
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L13.34|
00000c  480e              LDR      r0,|L13.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L13.34|
000012  480e              LDR      r0,|L13.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L13.34|
000018  f44f71f4          MOV      r1,#0x1e8
00001c  480c              LDR      r0,|L13.80|
00001e  f7fffffe          BL       assert_failed
                  |L13.34|
;;;489      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L13.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L13.50|
000028  f24011e9          MOV      r1,#0x1e9
00002c  4808              LDR      r0,|L13.80|
00002e  f7fffffe          BL       assert_failed
                  |L13.50|
;;;490      if (NewState != DISABLE)
;;;491      {
;;;492        /* Enable generall call */
;;;493        I2Cx->CR1 |= I2C_CR1_ENGC;
000032  8820              LDRH     r0,[r4,#0]
000034  f0400040          ORR      r0,r0,#0x40
000038  e002              B        |L13.64|
                  |L13.58|
;;;494      }
;;;495      else
;;;496      {
;;;497        /* Disable generall call */
;;;498        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
00003a  8820              LDRH     r0,[r4,#0]
00003c  f0200040          BIC      r0,r0,#0x40
                  |L13.64|
000040  8020              STRH     r0,[r4,#0]            ;493
;;;499      }
;;;500    }
000042  bd70              POP      {r4-r6,pc}
;;;501    
                          ENDP

                  |L13.68|
                          DCD      0x40005400
                  |L13.72|
                          DCD      0x40005800
                  |L13.76|
                          DCD      0x40005c00
                  |L13.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=2

                  I2C_GenerateSTART PROC
;;;331      */
;;;332    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;333    {
000002  4604              MOV      r4,r0
;;;334      /* Check the parameters */
;;;335      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L14.68|
000006  460d              MOV      r5,r1                 ;333
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L14.34|
00000c  480e              LDR      r0,|L14.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L14.34|
000012  480e              LDR      r0,|L14.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L14.34|
000018  f240114f          MOV      r1,#0x14f
00001c  480c              LDR      r0,|L14.80|
00001e  f7fffffe          BL       assert_failed
                  |L14.34|
;;;336      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L14.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L14.50|
000028  f44f71a8          MOV      r1,#0x150
00002c  4808              LDR      r0,|L14.80|
00002e  f7fffffe          BL       assert_failed
                  |L14.50|
;;;337      if (NewState != DISABLE)
;;;338      {
;;;339        /* Generate a START condition */
;;;340        I2Cx->CR1 |= I2C_CR1_START;
000032  8820              LDRH     r0,[r4,#0]
000034  f4407080          ORR      r0,r0,#0x100
000038  e002              B        |L14.64|
                  |L14.58|
;;;341      }
;;;342      else
;;;343      {
;;;344        /* Disable the START condition generation */
;;;345        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
00003a  8820              LDRH     r0,[r4,#0]
00003c  f4207080          BIC      r0,r0,#0x100
                  |L14.64|
000040  8020              STRH     r0,[r4,#0]            ;340
;;;346      }
;;;347    }
000042  bd70              POP      {r4-r6,pc}
;;;348    
                          ENDP

                  |L14.68|
                          DCD      0x40005400
                  |L14.72|
                          DCD      0x40005800
                  |L14.76|
                          DCD      0x40005c00
                  |L14.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=2

                  I2C_GenerateSTOP PROC
;;;355      */
;;;356    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;357    {
000002  4604              MOV      r4,r0
;;;358      /* Check the parameters */
;;;359      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L15.68|
000006  460d              MOV      r5,r1                 ;357
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L15.34|
00000c  480e              LDR      r0,|L15.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L15.34|
000012  480e              LDR      r0,|L15.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L15.34|
000018  f2401167          MOV      r1,#0x167
00001c  480c              LDR      r0,|L15.80|
00001e  f7fffffe          BL       assert_failed
                  |L15.34|
;;;360      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L15.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L15.50|
000028  f44f71b4          MOV      r1,#0x168
00002c  4808              LDR      r0,|L15.80|
00002e  f7fffffe          BL       assert_failed
                  |L15.50|
;;;361      if (NewState != DISABLE)
;;;362      {
;;;363        /* Generate a STOP condition */
;;;364        I2Cx->CR1 |= I2C_CR1_STOP;
000032  8820              LDRH     r0,[r4,#0]
000034  f4407000          ORR      r0,r0,#0x200
000038  e002              B        |L15.64|
                  |L15.58|
;;;365      }
;;;366      else
;;;367      {
;;;368        /* Disable the STOP condition generation */
;;;369        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
00003a  8820              LDRH     r0,[r4,#0]
00003c  f4207000          BIC      r0,r0,#0x200
                  |L15.64|
000040  8020              STRH     r0,[r4,#0]            ;364
;;;370      }
;;;371    }
000042  bd70              POP      {r4-r6,pc}
;;;372    
                          ENDP

                  |L15.68|
                          DCD      0x40005400
                  |L15.72|
                          DCD      0x40005800
                  |L15.76|
                          DCD      0x40005c00
                  |L15.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  I2C_GetFlagStatus PROC
;;;1193     */
;;;1194   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b57c              PUSH     {r2-r6,lr}
;;;1195   {
000002  4605              MOV      r5,r0
;;;1196     FlagStatus bitstatus = RESET;
000004  2600              MOVS     r6,#0
;;;1197     __IO uint32_t i2creg = 0, i2cxbase = 0;
;;;1198   
;;;1199     /* Check the parameters */
;;;1200     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  4833              LDR      r0,|L16.212|
000008  460c              MOV      r4,r1                 ;1195
00000a  9600              STR      r6,[sp,#0]            ;1197
00000c  9601              STR      r6,[sp,#4]
00000e  4285              CMP      r5,r0
000010  d00a              BEQ      |L16.40|
000012  4831              LDR      r0,|L16.216|
000014  4285              CMP      r5,r0
000016  d007              BEQ      |L16.40|
000018  4830              LDR      r0,|L16.220|
00001a  4285              CMP      r5,r0
00001c  d004              BEQ      |L16.40|
00001e  f44f6196          MOV      r1,#0x4b0
000022  482f              LDR      r0,|L16.224|
000024  f7fffffe          BL       assert_failed
                  |L16.40|
;;;1201     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
000028  f5b40f00          CMP      r4,#0x800000
00002c  d03d              BEQ      |L16.170|
00002e  f5b40f80          CMP      r4,#0x400000
000032  d03a              BEQ      |L16.170|
000034  f5b41f00          CMP      r4,#0x200000
000038  d037              BEQ      |L16.170|
00003a  f5b41f80          CMP      r4,#0x100000
00003e  d034              BEQ      |L16.170|
000040  f5b42f80          CMP      r4,#0x40000
000044  d031              BEQ      |L16.170|
000046  f5b43f00          CMP      r4,#0x20000
00004a  d02e              BEQ      |L16.170|
00004c  f5b43f80          CMP      r4,#0x10000
000050  d02b              BEQ      |L16.170|
000052  4824              LDR      r0,|L16.228|
000054  4284              CMP      r4,r0
000056  d028              BEQ      |L16.170|
000058  4823              LDR      r0,|L16.232|
00005a  4284              CMP      r4,r0
00005c  d025              BEQ      |L16.170|
00005e  f1b42f10          CMP      r4,#0x10001000
000062  d022              BEQ      |L16.170|
000064  4821              LDR      r0,|L16.236|
000066  4284              CMP      r4,r0
000068  d01f              BEQ      |L16.170|
00006a  4821              LDR      r0,|L16.240|
00006c  4284              CMP      r4,r0
00006e  d01c              BEQ      |L16.170|
000070  4820              LDR      r0,|L16.244|
000072  4284              CMP      r4,r0
000074  d019              BEQ      |L16.170|
000076  4820              LDR      r0,|L16.248|
000078  4284              CMP      r4,r0
00007a  d016              BEQ      |L16.170|
00007c  f1a45080          SUB      r0,r4,#0x10000000
000080  3880              SUBS     r0,r0,#0x80
000082  d012              BEQ      |L16.170|
000084  3040              ADDS     r0,r0,#0x40
000086  d010              BEQ      |L16.170|
000088  3030              ADDS     r0,r0,#0x30
00008a  d00e              BEQ      |L16.170|
00008c  3008              ADDS     r0,r0,#8
00008e  d00c              BEQ      |L16.170|
000090  1d00              ADDS     r0,r0,#4
000092  d00a              BEQ      |L16.170|
000094  1c80              ADDS     r0,r0,#2
000096  d008              BEQ      |L16.170|
000098  f06f5080          MVN      r0,#0x10000000
00009c  42c4              CMN      r4,r0
00009e  d004              BEQ      |L16.170|
0000a0  f24041b1          MOV      r1,#0x4b1
0000a4  480e              LDR      r0,|L16.224|
0000a6  f7fffffe          BL       assert_failed
                  |L16.170|
;;;1202   
;;;1203     /* Get the I2Cx peripheral base address */
;;;1204     i2cxbase = (uint32_t)I2Cx;
;;;1205     
;;;1206     /* Read flag register index */
;;;1207     i2creg = I2C_FLAG >> 28;
0000aa  0f20              LSRS     r0,r4,#28
0000ac  e9cd0500          STRD     r0,r5,[sp,#0]
;;;1208     
;;;1209     /* Get bit[23:0] of the flag */
;;;1210     I2C_FLAG &= FLAG_MASK;
;;;1211     
;;;1212     if(i2creg != 0)
0000b0  9900              LDR      r1,[sp,#0]
0000b2  f024407f          BIC      r0,r4,#0xff000000     ;1210
0000b6  b111              CBZ      r1,|L16.190|
;;;1213     {
;;;1214       /* Get the I2Cx SR1 register address */
;;;1215       i2cxbase += 0x14;
0000b8  f1050114          ADD      r1,r5,#0x14
0000bc  e002              B        |L16.196|
                  |L16.190|
;;;1216     }
;;;1217     else
;;;1218     {
;;;1219       /* Flag in I2Cx SR2 Register */
;;;1220       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
0000be  0c00              LSRS     r0,r0,#16
;;;1221       /* Get the I2Cx SR2 register address */
;;;1222       i2cxbase += 0x18;
0000c0  f1050118          ADD      r1,r5,#0x18
                  |L16.196|
;;;1223     }
;;;1224     
;;;1225     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
0000c4  9101              STR      r1,[sp,#4]
0000c6  6809              LDR      r1,[r1,#0]
0000c8  4201              TST      r1,r0
0000ca  d000              BEQ      |L16.206|
;;;1226     {
;;;1227       /* I2C_FLAG is set */
;;;1228       bitstatus = SET;
0000cc  2601              MOVS     r6,#1
                  |L16.206|
;;;1229     }
;;;1230     else
;;;1231     {
;;;1232       /* I2C_FLAG is reset */
;;;1233       bitstatus = RESET;
;;;1234     }
;;;1235     
;;;1236     /* Return the I2C_FLAG status */
;;;1237     return  bitstatus;
0000ce  4630              MOV      r0,r6
;;;1238   }
0000d0  bd7c              POP      {r2-r6,pc}
;;;1239   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L16.212|
                          DCD      0x40005400
                  |L16.216|
                          DCD      0x40005800
                  |L16.220|
                          DCD      0x40005c00
                  |L16.224|
                          DCD      ||.conststring||
                  |L16.228|
                          DCD      0x10008000
                  |L16.232|
                          DCD      0x10004000
                  |L16.236|
                          DCD      0x10000800
                  |L16.240|
                          DCD      0x10000400
                  |L16.244|
                          DCD      0x10000200
                  |L16.248|
                          DCD      0x10000100

                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=2

                  I2C_GetITStatus PROC
;;;1304     */
;;;1305   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1306   {
000002  4605              MOV      r5,r0
;;;1307     ITStatus bitstatus = RESET;
;;;1308     uint32_t enablestatus = 0;
;;;1309   
;;;1310     /* Check the parameters */
;;;1311     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4826              LDR      r0,|L17.160|
000006  2600              MOVS     r6,#0                 ;1307
000008  460c              MOV      r4,r1                 ;1306
00000a  4285              CMP      r5,r0
00000c  d00a              BEQ      |L17.36|
00000e  4825              LDR      r0,|L17.164|
000010  4285              CMP      r5,r0
000012  d007              BEQ      |L17.36|
000014  4824              LDR      r0,|L17.168|
000016  4285              CMP      r5,r0
000018  d004              BEQ      |L17.36|
00001a  f240511f          MOV      r1,#0x51f
00001e  4823              LDR      r0,|L17.172|
000020  f7fffffe          BL       assert_failed
                  |L17.36|
;;;1312     assert_param(IS_I2C_GET_IT(I2C_IT));
000024  4822              LDR      r0,|L17.176|
000026  4284              CMP      r4,r0
000028  d02a              BEQ      |L17.128|
00002a  4822              LDR      r0,|L17.180|
00002c  4284              CMP      r4,r0
00002e  d027              BEQ      |L17.128|
000030  4821              LDR      r0,|L17.184|
000032  4284              CMP      r4,r0
000034  d024              BEQ      |L17.128|
000036  4821              LDR      r0,|L17.188|
000038  4284              CMP      r4,r0
00003a  d021              BEQ      |L17.128|
00003c  4820              LDR      r0,|L17.192|
00003e  4284              CMP      r4,r0
000040  d01e              BEQ      |L17.128|
000042  4820              LDR      r0,|L17.196|
000044  4284              CMP      r4,r0
000046  d01b              BEQ      |L17.128|
000048  f1b42f01          CMP      r4,#0x1000100
00004c  d018              BEQ      |L17.128|
00004e  f1a460c0          SUB      r0,r4,#0x6000000
000052  3880              SUBS     r0,r0,#0x80
000054  d014              BEQ      |L17.128|
000056  3040              ADDS     r0,r0,#0x40
000058  d012              BEQ      |L17.128|
00005a  f1a47000          SUB      r0,r4,#0x2000000
00005e  3810              SUBS     r0,r0,#0x10
000060  d00e              BEQ      |L17.128|
000062  3008              ADDS     r0,r0,#8
000064  d00c              BEQ      |L17.128|
000066  1d00              ADDS     r0,r0,#4
000068  d00a              BEQ      |L17.128|
00006a  1c80              ADDS     r0,r0,#2
00006c  d008              BEQ      |L17.128|
00006e  f06f7000          MVN      r0,#0x2000000
000072  42c4              CMN      r4,r0
000074  d004              BEQ      |L17.128|
000076  f44f61a4          MOV      r1,#0x520
00007a  480c              LDR      r0,|L17.172|
00007c  f7fffffe          BL       assert_failed
                  |L17.128|
;;;1313   
;;;1314     /* Check if the interrupt source is enabled or not */
;;;1315     enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
000080  88a8              LDRH     r0,[r5,#4]
000082  f44f61e0          MOV      r1,#0x700
000086  ea014114          AND      r1,r1,r4,LSR #16
00008a  4008              ANDS     r0,r0,r1
;;;1316     
;;;1317     /* Get bit[23:0] of the flag */
;;;1318     I2C_IT &= FLAG_MASK;
;;;1319   
;;;1320     /* Check the status of the specified I2C flag */
;;;1321     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
00008c  8aaa              LDRH     r2,[r5,#0x14]
00008e  f024417f          BIC      r1,r4,#0xff000000     ;1318
000092  420a              TST      r2,r1
000094  d001              BEQ      |L17.154|
000096  b100              CBZ      r0,|L17.154|
;;;1322     {
;;;1323       /* I2C_IT is set */
;;;1324       bitstatus = SET;
000098  2601              MOVS     r6,#1
                  |L17.154|
;;;1325     }
;;;1326     else
;;;1327     {
;;;1328       /* I2C_IT is reset */
;;;1329       bitstatus = RESET;
;;;1330     }
;;;1331     /* Return the I2C_IT status */
;;;1332     return  bitstatus;
00009a  4630              MOV      r0,r6
;;;1333   }
00009c  bd70              POP      {r4-r6,pc}
;;;1334   
                          ENDP

00009e  0000              DCW      0x0000
                  |L17.160|
                          DCD      0x40005400
                  |L17.164|
                          DCD      0x40005800
                  |L17.168|
                          DCD      0x40005c00
                  |L17.172|
                          DCD      ||.conststring||
                  |L17.176|
                          DCD      0x01008000
                  |L17.180|
                          DCD      0x01004000
                  |L17.184|
                          DCD      0x01001000
                  |L17.188|
                          DCD      0x01000800
                  |L17.192|
                          DCD      0x01000400
                  |L17.196|
                          DCD      0x01000200

                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=2

                  I2C_GetLastEvent PROC
;;;1138     */
;;;1139   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;1140   {
000002  4604              MOV      r4,r0
;;;1141     uint32_t lastevent = 0;
;;;1142     uint32_t flag1 = 0, flag2 = 0;
;;;1143   
;;;1144     /* Check the parameters */
;;;1145     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480a              LDR      r0,|L18.48|
000006  4284              CMP      r4,r0
000008  d00a              BEQ      |L18.32|
00000a  480a              LDR      r0,|L18.52|
00000c  4284              CMP      r4,r0
00000e  d007              BEQ      |L18.32|
000010  4809              LDR      r0,|L18.56|
000012  4284              CMP      r4,r0
000014  d004              BEQ      |L18.32|
000016  f2404179          MOV      r1,#0x479
00001a  4808              LDR      r0,|L18.60|
00001c  f7fffffe          BL       assert_failed
                  |L18.32|
;;;1146   
;;;1147     /* Read the I2Cx status register */
;;;1148     flag1 = I2Cx->SR1;
000020  8aa0              LDRH     r0,[r4,#0x14]
;;;1149     flag2 = I2Cx->SR2;
000022  8b21              LDRH     r1,[r4,#0x18]
;;;1150     flag2 = flag2 << 16;
;;;1151   
;;;1152     /* Get the last event value from I2C status register */
;;;1153     lastevent = (flag1 | flag2) & FLAG_MASK;
000024  ea404001          ORR      r0,r0,r1,LSL #16
000028  f020407f          BIC      r0,r0,#0xff000000
;;;1154   
;;;1155     /* Return status */
;;;1156     return lastevent;
;;;1157   }
00002c  bd10              POP      {r4,pc}
;;;1158   
                          ENDP

00002e  0000              DCW      0x0000
                  |L18.48|
                          DCD      0x40005400
                  |L18.52|
                          DCD      0x40005800
                  |L18.56|
                          DCD      0x40005c00
                  |L18.60|
                          DCD      ||.conststring||

                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=2

                  I2C_GetPEC PROC
;;;809      */
;;;810    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;811    {
000002  4604              MOV      r4,r0
;;;812      /* Check the parameters */
;;;813      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4808              LDR      r0,|L19.40|
000006  4284              CMP      r4,r0
000008  d00a              BEQ      |L19.32|
00000a  4808              LDR      r0,|L19.44|
00000c  4284              CMP      r4,r0
00000e  d007              BEQ      |L19.32|
000010  4807              LDR      r0,|L19.48|
000012  4284              CMP      r4,r0
000014  d004              BEQ      |L19.32|
000016  f240312d          MOV      r1,#0x32d
00001a  4806              LDR      r0,|L19.52|
00001c  f7fffffe          BL       assert_failed
                  |L19.32|
;;;814      /* Return the selected I2C PEC value */
;;;815      return ((I2Cx->SR2) >> 8);
000020  8b20              LDRH     r0,[r4,#0x18]
000022  0a00              LSRS     r0,r0,#8
;;;816    }
000024  bd10              POP      {r4,pc}
;;;817    
                          ENDP

000026  0000              DCW      0x0000
                  |L19.40|
                          DCD      0x40005400
                  |L19.44|
                          DCD      0x40005800
                  |L19.48|
                          DCD      0x40005c00
                  |L19.52|
                          DCD      ||.conststring||

                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=2

                  I2C_ITConfig PROC
;;;1031     */
;;;1032   void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1033   {
000002  4604              MOV      r4,r0
;;;1034     /* Check the parameters */
;;;1035     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4813              LDR      r0,|L20.84|
000006  4616              MOV      r6,r2                 ;1033
000008  460d              MOV      r5,r1                 ;1033
00000a  4284              CMP      r4,r0
00000c  d00a              BEQ      |L20.36|
00000e  4812              LDR      r0,|L20.88|
000010  4284              CMP      r4,r0
000012  d007              BEQ      |L20.36|
000014  4811              LDR      r0,|L20.92|
000016  4284              CMP      r4,r0
000018  d004              BEQ      |L20.36|
00001a  f240410b          MOV      r1,#0x40b
00001e  4810              LDR      r0,|L20.96|
000020  f7fffffe          BL       assert_failed
                  |L20.36|
;;;1036     assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b136              CBZ      r6,|L20.52|
000026  2e01              CMP      r6,#1
000028  d004              BEQ      |L20.52|
00002a  f240410c          MOV      r1,#0x40c
00002e  480c              LDR      r0,|L20.96|
000030  f7fffffe          BL       assert_failed
                  |L20.52|
;;;1037     assert_param(IS_I2C_CONFIG_IT(I2C_IT));
000034  f43560e0          BICS     r0,r5,#0x700
000038  d100              BNE      |L20.60|
00003a  b925              CBNZ     r5,|L20.70|
                  |L20.60|
00003c  f240410d          MOV      r1,#0x40d
000040  4807              LDR      r0,|L20.96|
000042  f7fffffe          BL       assert_failed
                  |L20.70|
;;;1038     
;;;1039     if (NewState != DISABLE)
;;;1040     {
;;;1041       /* Enable the selected I2C interrupts */
;;;1042       I2Cx->CR2 |= I2C_IT;
;;;1043     }
;;;1044     else
;;;1045     {
;;;1046       /* Disable the selected I2C interrupts */
;;;1047       I2Cx->CR2 &= (uint16_t)~I2C_IT;
000046  88a0              LDRH     r0,[r4,#4]
000048  b10e              CBZ      r6,|L20.78|
00004a  4328              ORRS     r0,r0,r5              ;1042
00004c  e000              B        |L20.80|
                  |L20.78|
00004e  43a8              BICS     r0,r0,r5
                  |L20.80|
000050  80a0              STRH     r0,[r4,#4]            ;1042
;;;1048     }
;;;1049   }
000052  bd70              POP      {r4-r6,pc}
;;;1050   
                          ENDP

                  |L20.84|
                          DCD      0x40005400
                  |L20.88|
                          DCD      0x40005800
                  |L20.92|
                          DCD      0x40005c00
                  |L20.96|
                          DCD      ||.conststring||

                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;174      */
;;;175    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;176    {
000004  4604              MOV      r4,r0
;;;177      uint16_t tmpreg = 0, freqrange = 0;
;;;178      uint16_t result = 0x04;
;;;179      uint32_t pclk1 = 8000000;
;;;180      RCC_ClocksTypeDef  rcc_clocks;
;;;181      /* Check the parameters */
;;;182      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  484d              LDR      r0,|L21.316|
000008  460d              MOV      r5,r1                 ;176
00000a  4284              CMP      r4,r0
00000c  d009              BEQ      |L21.34|
00000e  484c              LDR      r0,|L21.320|
000010  4284              CMP      r4,r0
000012  d006              BEQ      |L21.34|
000014  484b              LDR      r0,|L21.324|
000016  4284              CMP      r4,r0
000018  d003              BEQ      |L21.34|
00001a  21b6              MOVS     r1,#0xb6
00001c  484a              LDR      r0,|L21.328|
00001e  f7fffffe          BL       assert_failed
                  |L21.34|
;;;183      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
000022  6828              LDR      r0,[r5,#0]
000024  4949              LDR      r1,|L21.332|
000026  1e40              SUBS     r0,r0,#1
000028  4288              CMP      r0,r1
00002a  d903              BLS      |L21.52|
00002c  21b7              MOVS     r1,#0xb7
00002e  4846              LDR      r0,|L21.328|
000030  f7fffffe          BL       assert_failed
                  |L21.52|
;;;184      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
000034  88a8              LDRH     r0,[r5,#4]
000036  b138              CBZ      r0,|L21.72|
000038  2802              CMP      r0,#2
00003a  d005              BEQ      |L21.72|
00003c  280a              CMP      r0,#0xa
00003e  d003              BEQ      |L21.72|
000040  21b8              MOVS     r1,#0xb8
000042  4841              LDR      r0,|L21.328|
000044  f7fffffe          BL       assert_failed
                  |L21.72|
;;;185      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
000048  88e8              LDRH     r0,[r5,#6]
00004a  f44f4880          MOV      r8,#0x4000
00004e  f64b77ff          MOV      r7,#0xbfff
000052  4540              CMP      r0,r8
000054  d005              BEQ      |L21.98|
000056  42b8              CMP      r0,r7
000058  d003              BEQ      |L21.98|
00005a  21b9              MOVS     r1,#0xb9
00005c  483a              LDR      r0,|L21.328|
00005e  f7fffffe          BL       assert_failed
                  |L21.98|
;;;186      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
000062  8928              LDRH     r0,[r5,#8]
000064  f44f6680          MOV      r6,#0x400
000068  42b0              CMP      r0,r6
00006a  d303              BCC      |L21.116|
00006c  21ba              MOVS     r1,#0xba
00006e  4836              LDR      r0,|L21.328|
000070  f7fffffe          BL       assert_failed
                  |L21.116|
;;;187      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
000074  8968              LDRH     r0,[r5,#0xa]
000076  42b0              CMP      r0,r6
000078  d004              BEQ      |L21.132|
00007a  b118              CBZ      r0,|L21.132|
00007c  21bb              MOVS     r1,#0xbb
00007e  4832              LDR      r0,|L21.328|
000080  f7fffffe          BL       assert_failed
                  |L21.132|
;;;188      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
000084  89a8              LDRH     r0,[r5,#0xc]
000086  4540              CMP      r0,r8
000088  d006              BEQ      |L21.152|
00008a  f5b04f40          CMP      r0,#0xc000
00008e  d003              BEQ      |L21.152|
000090  21bc              MOVS     r1,#0xbc
000092  482d              LDR      r0,|L21.328|
000094  f7fffffe          BL       assert_failed
                  |L21.152|
;;;189    
;;;190    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;191      /* Get the I2Cx CR2 value */
;;;192      tmpreg = I2Cx->CR2;
000098  88a0              LDRH     r0,[r4,#4]
;;;193      /* Clear frequency FREQ[5:0] bits */
;;;194      tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
00009a  f020063f          BIC      r6,r0,#0x3f
;;;195      /* Get pclk1 frequency value */
;;;196      RCC_GetClocksFreq(&rcc_clocks);
00009e  4668              MOV      r0,sp
0000a0  f7fffffe          BL       RCC_GetClocksFreq
;;;197      pclk1 = rcc_clocks.PCLK1_Frequency;
;;;198      /* Set frequency bits depending on pclk1 value */
;;;199      freqrange = (uint16_t)(pclk1 / 1000000);
0000a4  492a              LDR      r1,|L21.336|
0000a6  9802              LDR      r0,[sp,#8]
0000a8  fbb0f1f1          UDIV     r1,r0,r1
0000ac  b289              UXTH     r1,r1
;;;200      tmpreg |= freqrange;
0000ae  430e              ORRS     r6,r6,r1
;;;201      /* Write to I2Cx CR2 */
;;;202      I2Cx->CR2 = tmpreg;
0000b0  80a6              STRH     r6,[r4,#4]
;;;203    
;;;204    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;205      /* Disable the selected I2C peripheral to configure TRISE */
;;;206      I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
0000b2  8822              LDRH     r2,[r4,#0]
0000b4  f0220201          BIC      r2,r2,#1
0000b8  8022              STRH     r2,[r4,#0]
;;;207      /* Reset tmpreg value */
;;;208      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;209      tmpreg = 0;
;;;210    
;;;211      /* Configure speed in standard mode */
;;;212      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
0000ba  4b26              LDR      r3,|L21.340|
0000bc  682a              LDR      r2,[r5,#0]
0000be  429a              CMP      r2,r3
0000c0  d81c              BHI      |L21.252|
;;;213      {
;;;214        /* Standard mode speed calculate */
;;;215        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
0000c2  0052              LSLS     r2,r2,#1
0000c4  fbb0f0f2          UDIV     r0,r0,r2
0000c8  b280              UXTH     r0,r0
;;;216        /* Test if CCR value is under 0x4*/
;;;217        if (result < 0x04)
0000ca  2804              CMP      r0,#4
0000cc  d200              BCS      |L21.208|
;;;218        {
;;;219          /* Set minimum allowed value */
;;;220          result = 0x04;  
0000ce  2004              MOVS     r0,#4
                  |L21.208|
0000d0  1c49              ADDS     r1,r1,#1
;;;221        }
;;;222        /* Set speed value for standard mode */
;;;223        tmpreg |= result;	  
;;;224        /* Set Maximum Rise Time for standard mode */
;;;225        I2Cx->TRISE = freqrange + 1; 
0000d2  8421              STRH     r1,[r4,#0x20]
;;;226      }
;;;227      /* Configure speed in fast mode */
;;;228      /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
;;;229         input clock) must be a multiple of 10 MHz */
;;;230      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;231      {
;;;232        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
;;;233        {
;;;234          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;235          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
;;;236        }
;;;237        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;238        {
;;;239          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;240          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
;;;241          /* Set DUTY bit */
;;;242          result |= I2C_DutyCycle_16_9;
;;;243        }
;;;244    
;;;245        /* Test if CCR value is under 0x1*/
;;;246        if ((result & I2C_CCR_CCR) == 0)
;;;247        {
;;;248          /* Set minimum allowed value */
;;;249          result |= (uint16_t)0x0001;  
;;;250        }
;;;251        /* Set speed value and set F/S bit for fast mode */
;;;252        tmpreg |= (uint16_t)(result | I2C_CCR_FS);
;;;253        /* Set Maximum Rise Time for fast mode */
;;;254        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
;;;255      }
;;;256    
;;;257      /* Write to I2Cx CCR */
;;;258      I2Cx->CCR = tmpreg;
0000d4  83a0              STRH     r0,[r4,#0x1c]
;;;259      /* Enable the selected I2C peripheral */
;;;260      I2Cx->CR1 |= I2C_CR1_PE;
0000d6  8820              LDRH     r0,[r4,#0]
0000d8  f0400001          ORR      r0,r0,#1
0000dc  8020              STRH     r0,[r4,#0]
;;;261    
;;;262    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;263      /* Get the I2Cx CR1 value */
;;;264      tmpreg = I2Cx->CR1;
0000de  8820              LDRH     r0,[r4,#0]
;;;265      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;266      tmpreg &= CR1_CLEAR_MASK;
0000e0  f64f31f5          MOV      r1,#0xfbf5
0000e4  4008              ANDS     r0,r0,r1
;;;267      /* Configure I2Cx: mode and acknowledgement */
;;;268      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;269      /* Set ACK bit according to I2C_Ack value */
;;;270      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
0000e6  88a9              LDRH     r1,[r5,#4]
0000e8  896a              LDRH     r2,[r5,#0xa]
0000ea  4311              ORRS     r1,r1,r2
0000ec  4301              ORRS     r1,r1,r0
;;;271      /* Write to I2Cx CR1 */
;;;272      I2Cx->CR1 = tmpreg;
0000ee  8021              STRH     r1,[r4,#0]
;;;273    
;;;274    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;275      /* Set I2Cx Own Address1 and acknowledged address */
;;;276      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000f0  89a8              LDRH     r0,[r5,#0xc]
0000f2  8929              LDRH     r1,[r5,#8]
0000f4  4308              ORRS     r0,r0,r1
0000f6  8120              STRH     r0,[r4,#8]
;;;277    }
0000f8  e8bd81ff          POP      {r0-r8,pc}
                  |L21.252|
0000fc  88eb              LDRH     r3,[r5,#6]            ;232
0000fe  42bb              CMP      r3,r7                 ;232
000100  d105              BNE      |L21.270|
000102  eb020242          ADD      r2,r2,r2,LSL #1       ;235
000106  fbb0f0f2          UDIV     r0,r0,r2              ;235
00010a  b280              UXTH     r0,r0                 ;235
00010c  e008              B        |L21.288|
                  |L21.270|
00010e  eb0203c2          ADD      r3,r2,r2,LSL #3       ;240
000112  eb031202          ADD      r2,r3,r2,LSL #4       ;240
000116  fbb0f0f2          UDIV     r0,r0,r2              ;240
00011a  b280              UXTH     r0,r0                 ;240
00011c  f4404080          ORR      r0,r0,#0x4000         ;242
                  |L21.288|
000120  0502              LSLS     r2,r0,#20             ;246
000122  d101              BNE      |L21.296|
000124  f0400001          ORR      r0,r0,#1              ;249
                  |L21.296|
000128  f44f7296          MOV      r2,#0x12c             ;254
00012c  4351              MULS     r1,r2,r1              ;254
00012e  f44f727a          MOV      r2,#0x3e8             ;254
000132  fbb1f1f2          UDIV     r1,r1,r2              ;254
000136  f4404000          ORR      r0,r0,#0x8000         ;252
00013a  e7c9              B        |L21.208|
;;;278    
                          ENDP

                  |L21.316|
                          DCD      0x40005400
                  |L21.320|
                          DCD      0x40005800
                  |L21.324|
                          DCD      0x40005c00
                  |L21.328|
                          DCD      ||.conststring||
                  |L21.332|
                          DCD      0x00061a7f
                  |L21.336|
                          DCD      0x000f4240
                  |L21.340|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=2

                  I2C_NACKPositionConfig PROC
;;;598      */
;;;599    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  b570              PUSH     {r4-r6,lr}
;;;600    {
000002  4604              MOV      r4,r0
;;;601      /* Check the parameters */
;;;602      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4811              LDR      r0,|L22.76|
000006  460d              MOV      r5,r1                 ;600
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L22.34|
00000c  4810              LDR      r0,|L22.80|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L22.34|
000012  4810              LDR      r0,|L22.84|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L22.34|
000018  f240215a          MOV      r1,#0x25a
00001c  480e              LDR      r0,|L22.88|
00001e  f7fffffe          BL       assert_failed
                  |L22.34|
;;;603      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
000022  f5b56f00          CMP      r5,#0x800
000026  d00d              BEQ      |L22.68|
000028  f5a54077          SUB      r0,r5,#0xf700
00002c  38ff              SUBS     r0,r0,#0xff
00002e  d004              BEQ      |L22.58|
000030  f240215b          MOV      r1,#0x25b
000034  4808              LDR      r0,|L22.88|
000036  f7fffffe          BL       assert_failed
                  |L22.58|
;;;604      
;;;605      /* Check the input parameter */
;;;606      if (I2C_NACKPosition == I2C_NACKPosition_Next)
;;;607      {
;;;608        /* Next byte in shift register is the last received byte */
;;;609        I2Cx->CR1 |= I2C_NACKPosition_Next;
;;;610      }
;;;611      else
;;;612      {
;;;613        /* Current byte in shift register is the last received byte */
;;;614        I2Cx->CR1 &= I2C_NACKPosition_Current;
00003a  8820              LDRH     r0,[r4,#0]
00003c  f4206000          BIC      r0,r0,#0x800
                  |L22.64|
000040  8020              STRH     r0,[r4,#0]            ;609
;;;615      }
;;;616    }
000042  bd70              POP      {r4-r6,pc}
                  |L22.68|
000044  8820              LDRH     r0,[r4,#0]            ;609
000046  f4406000          ORR      r0,r0,#0x800          ;609
00004a  e7f9              B        |L22.64|
;;;617    
                          ENDP

                  |L22.76|
                          DCD      0x40005400
                  |L22.80|
                          DCD      0x40005800
                  |L22.84|
                          DCD      0x40005c00
                  |L22.88|
                          DCD      ||.conststring||

                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=2

                  I2C_OwnAddress2Config PROC
;;;433      */
;;;434    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  b570              PUSH     {r4-r6,lr}
;;;435    {
000002  4604              MOV      r4,r0
;;;436      uint16_t tmpreg = 0;
;;;437    
;;;438      /* Check the parameters */
;;;439      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480b              LDR      r0,|L23.52|
000006  460d              MOV      r5,r1                 ;435
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L23.34|
00000c  480a              LDR      r0,|L23.56|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L23.34|
000012  480a              LDR      r0,|L23.60|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L23.34|
000018  f24011b7          MOV      r1,#0x1b7
00001c  4808              LDR      r0,|L23.64|
00001e  f7fffffe          BL       assert_failed
                  |L23.34|
;;;440    
;;;441      /* Get the old register value */
;;;442      tmpreg = I2Cx->OAR2;
000022  89a0              LDRH     r0,[r4,#0xc]
;;;443    
;;;444      /* Reset I2Cx Own address2 bit [7:1] */
;;;445      tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
;;;446    
;;;447      /* Set I2Cx Own address2 */
;;;448      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
000024  f00501fe          AND      r1,r5,#0xfe
000028  f02000fe          BIC      r0,r0,#0xfe           ;445
00002c  4301              ORRS     r1,r1,r0
;;;449    
;;;450      /* Store the new register value */
;;;451      I2Cx->OAR2 = tmpreg;
00002e  81a1              STRH     r1,[r4,#0xc]
;;;452    }
000030  bd70              POP      {r4-r6,pc}
;;;453    
                          ENDP

000032  0000              DCW      0x0000
                  |L23.52|
                          DCD      0x40005400
                  |L23.56|
                          DCD      0x40005800
                  |L23.60|
                          DCD      0x40005c00
                  |L23.64|
                          DCD      ||.conststring||

                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=2

                  I2C_PECPositionConfig PROC
;;;763      */
;;;764    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  b570              PUSH     {r4-r6,lr}
;;;765    {
000002  4604              MOV      r4,r0
;;;766      /* Check the parameters */
;;;767      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4811              LDR      r0,|L24.76|
000006  460d              MOV      r5,r1                 ;765
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L24.34|
00000c  4810              LDR      r0,|L24.80|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L24.34|
000012  4810              LDR      r0,|L24.84|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L24.34|
000018  f24021ff          MOV      r1,#0x2ff
00001c  480e              LDR      r0,|L24.88|
00001e  f7fffffe          BL       assert_failed
                  |L24.34|
;;;768      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
000022  f5b56f00          CMP      r5,#0x800
000026  d00d              BEQ      |L24.68|
000028  f5a54077          SUB      r0,r5,#0xf700
00002c  38ff              SUBS     r0,r0,#0xff
00002e  d004              BEQ      |L24.58|
000030  f44f7140          MOV      r1,#0x300
000034  4808              LDR      r0,|L24.88|
000036  f7fffffe          BL       assert_failed
                  |L24.58|
;;;769      if (I2C_PECPosition == I2C_PECPosition_Next)
;;;770      {
;;;771        /* Next byte in shift register is PEC */
;;;772        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;773      }
;;;774      else
;;;775      {
;;;776        /* Current byte in shift register is PEC */
;;;777        I2Cx->CR1 &= I2C_PECPosition_Current;
00003a  8820              LDRH     r0,[r4,#0]
00003c  f4206000          BIC      r0,r0,#0x800
                  |L24.64|
000040  8020              STRH     r0,[r4,#0]            ;772
;;;778      }
;;;779    }
000042  bd70              POP      {r4-r6,pc}
                  |L24.68|
000044  8820              LDRH     r0,[r4,#0]            ;772
000046  f4406000          ORR      r0,r0,#0x800          ;772
00004a  e7f9              B        |L24.64|
;;;780    
                          ENDP

                  |L24.76|
                          DCD      0x40005400
                  |L24.80|
                          DCD      0x40005800
                  |L24.84|
                          DCD      0x40005c00
                  |L24.88|
                          DCD      ||.conststring||

                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=2

                  I2C_ReadRegister PROC
;;;1004     */
;;;1005   uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b538              PUSH     {r3-r5,lr}
;;;1006   {
000002  4605              MOV      r5,r0
;;;1007     __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
;;;1008   
;;;1009     /* Check the parameters */
;;;1010     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000006  9000              STR      r0,[sp,#0]
000008  4814              LDR      r0,|L25.92|
00000a  460c              MOV      r4,r1                 ;1006
00000c  4285              CMP      r5,r0
00000e  d00a              BEQ      |L25.38|
000010  4813              LDR      r0,|L25.96|
000012  4285              CMP      r5,r0
000014  d007              BEQ      |L25.38|
000016  4813              LDR      r0,|L25.100|
000018  4285              CMP      r5,r0
00001a  d004              BEQ      |L25.38|
00001c  f24031f2          MOV      r1,#0x3f2
000020  4811              LDR      r0,|L25.104|
000022  f7fffffe          BL       assert_failed
                  |L25.38|
;;;1011     assert_param(IS_I2C_REGISTER(I2C_Register));
000026  b1a4              CBZ      r4,|L25.82|
000028  2c04              CMP      r4,#4
00002a  d012              BEQ      |L25.82|
00002c  2c08              CMP      r4,#8
00002e  d010              BEQ      |L25.82|
000030  2c0c              CMP      r4,#0xc
000032  d00e              BEQ      |L25.82|
000034  2c10              CMP      r4,#0x10
000036  d00c              BEQ      |L25.82|
000038  2c14              CMP      r4,#0x14
00003a  d00a              BEQ      |L25.82|
00003c  2c18              CMP      r4,#0x18
00003e  d008              BEQ      |L25.82|
000040  2c1c              CMP      r4,#0x1c
000042  d006              BEQ      |L25.82|
000044  2c20              CMP      r4,#0x20
000046  d004              BEQ      |L25.82|
000048  f24031f3          MOV      r1,#0x3f3
00004c  4806              LDR      r0,|L25.104|
00004e  f7fffffe          BL       assert_failed
                  |L25.82|
;;;1012   
;;;1013     tmp = (uint32_t) I2Cx;
;;;1014     tmp += I2C_Register;
000052  1928              ADDS     r0,r5,r4
;;;1015   
;;;1016     /* Return the selected register value */
;;;1017     return (*(__IO uint16_t *) tmp);
000054  9000              STR      r0,[sp,#0]
000056  8800              LDRH     r0,[r0,#0]
;;;1018   }
000058  bd38              POP      {r3-r5,pc}
;;;1019   
                          ENDP

00005a  0000              DCW      0x0000
                  |L25.92|
                          DCD      0x40005400
                  |L25.96|
                          DCD      0x40005800
                  |L25.100|
                          DCD      0x40005c00
                  |L25.104|
                          DCD      ||.conststring||

                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=2

                  I2C_ReceiveData PROC
;;;701      */
;;;702    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;703    {
000002  4604              MOV      r4,r0
;;;704      /* Check the parameters */
;;;705      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4808              LDR      r0,|L26.40|
000006  4284              CMP      r4,r0
000008  d00a              BEQ      |L26.32|
00000a  4808              LDR      r0,|L26.44|
00000c  4284              CMP      r4,r0
00000e  d007              BEQ      |L26.32|
000010  4807              LDR      r0,|L26.48|
000012  4284              CMP      r4,r0
000014  d004              BEQ      |L26.32|
000016  f24021c1          MOV      r1,#0x2c1
00001a  4806              LDR      r0,|L26.52|
00001c  f7fffffe          BL       assert_failed
                  |L26.32|
;;;706      /* Return the data in the DR register */
;;;707      return (uint8_t)I2Cx->DR;
000020  8a20              LDRH     r0,[r4,#0x10]
000022  b2c0              UXTB     r0,r0
;;;708    }
000024  bd10              POP      {r4,pc}
;;;709    
                          ENDP

000026  0000              DCW      0x0000
                  |L26.40|
                          DCD      0x40005400
                  |L26.44|
                          DCD      0x40005800
                  |L26.48|
                          DCD      0x40005c00
                  |L26.52|
                          DCD      ||.conststring||

                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=2

                  I2C_SMBusAlertConfig PROC
;;;626      */
;;;627    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  b570              PUSH     {r4-r6,lr}
;;;628    {
000002  4604              MOV      r4,r0
;;;629      /* Check the parameters */
;;;630      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4811              LDR      r0,|L27.76|
000006  460d              MOV      r5,r1                 ;628
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L27.34|
00000c  4810              LDR      r0,|L27.80|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L27.34|
000012  4810              LDR      r0,|L27.84|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L27.34|
000018  f2402176          MOV      r1,#0x276
00001c  480e              LDR      r0,|L27.88|
00001e  f7fffffe          BL       assert_failed
                  |L27.34|
;;;631      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
000022  f5b55f00          CMP      r5,#0x2000
000026  d00d              BEQ      |L27.68|
000028  f5a5405f          SUB      r0,r5,#0xdf00
00002c  38ff              SUBS     r0,r0,#0xff
00002e  d004              BEQ      |L27.58|
000030  f2402177          MOV      r1,#0x277
000034  4808              LDR      r0,|L27.88|
000036  f7fffffe          BL       assert_failed
                  |L27.58|
;;;632      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
;;;633      {
;;;634        /* Drive the SMBusAlert pin Low */
;;;635        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;636      }
;;;637      else
;;;638      {
;;;639        /* Drive the SMBusAlert pin High  */
;;;640        I2Cx->CR1 &= I2C_SMBusAlert_High;
00003a  8820              LDRH     r0,[r4,#0]
00003c  f4205000          BIC      r0,r0,#0x2000
                  |L27.64|
000040  8020              STRH     r0,[r4,#0]            ;635
;;;641      }
;;;642    }
000042  bd70              POP      {r4-r6,pc}
                  |L27.68|
000044  8820              LDRH     r0,[r4,#0]            ;635
000046  f4405000          ORR      r0,r0,#0x2000         ;635
00004a  e7f9              B        |L27.64|
;;;643    
                          ENDP

                  |L27.76|
                          DCD      0x40005400
                  |L27.80|
                          DCD      0x40005800
                  |L27.84|
                          DCD      0x40005c00
                  |L27.88|
                          DCD      ||.conststring||

                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=2

                  I2C_Send7bitAddress PROC
;;;383      */
;;;384    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b570              PUSH     {r4-r6,lr}
;;;385    {
000002  4604              MOV      r4,r0
;;;386      /* Check the parameters */
;;;387      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L28.68|
000006  4615              MOV      r5,r2                 ;385
000008  460e              MOV      r6,r1                 ;385
00000a  4284              CMP      r4,r0
00000c  d00a              BEQ      |L28.36|
00000e  480e              LDR      r0,|L28.72|
000010  4284              CMP      r4,r0
000012  d007              BEQ      |L28.36|
000014  480d              LDR      r0,|L28.76|
000016  4284              CMP      r4,r0
000018  d004              BEQ      |L28.36|
00001a  f2401183          MOV      r1,#0x183
00001e  480c              LDR      r0,|L28.80|
000020  f7fffffe          BL       assert_failed
                  |L28.36|
;;;388      assert_param(IS_I2C_DIRECTION(I2C_Direction));
000024  b14d              CBZ      r5,|L28.58|
000026  2d01              CMP      r5,#1
000028  d004              BEQ      |L28.52|
00002a  f44f71c2          MOV      r1,#0x184
00002e  4808              LDR      r0,|L28.80|
000030  f7fffffe          BL       assert_failed
                  |L28.52|
;;;389      /* Test on the direction to set/reset the read/write bit */
;;;390      if (I2C_Direction != I2C_Direction_Transmitter)
;;;391      {
;;;392        /* Set the address bit0 for read */
;;;393        Address |= I2C_OAR1_ADD0;
000034  f0460001          ORR      r0,r6,#1
000038  e001              B        |L28.62|
                  |L28.58|
;;;394      }
;;;395      else
;;;396      {
;;;397        /* Reset the address bit0 for write */
;;;398        Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
00003a  f00600fe          AND      r0,r6,#0xfe
                  |L28.62|
;;;399      }
;;;400      /* Send the address */
;;;401      I2Cx->DR = Address;
00003e  8220              STRH     r0,[r4,#0x10]
;;;402    }
000040  bd70              POP      {r4-r6,pc}
;;;403    
                          ENDP

000042  0000              DCW      0x0000
                  |L28.68|
                          DCD      0x40005400
                  |L28.72|
                          DCD      0x40005800
                  |L28.76|
                          DCD      0x40005c00
                  |L28.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=2

                  I2C_SendData PROC
;;;688      */
;;;689    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;690    {
000002  4604              MOV      r4,r0
;;;691      /* Check the parameters */
;;;692      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  4808              LDR      r0,|L29.40|
000006  460d              MOV      r5,r1                 ;690
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L29.34|
00000c  4807              LDR      r0,|L29.44|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L29.34|
000012  4807              LDR      r0,|L29.48|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L29.34|
000018  f44f712d          MOV      r1,#0x2b4
00001c  4805              LDR      r0,|L29.52|
00001e  f7fffffe          BL       assert_failed
                  |L29.34|
;;;693      /* Write in the DR register the data to be sent */
;;;694      I2Cx->DR = Data;
000022  8225              STRH     r5,[r4,#0x10]
;;;695    }
000024  bd70              POP      {r4-r6,pc}
;;;696    
                          ENDP

000026  0000              DCW      0x0000
                  |L29.40|
                          DCD      0x40005400
                  |L29.44|
                          DCD      0x40005800
                  |L29.48|
                          DCD      0x40005c00
                  |L29.52|
                          DCD      ||.conststring||

                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=2

                  I2C_SoftwareResetCmd PROC
;;;510      */
;;;511    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;512    {
000002  4604              MOV      r4,r0
;;;513      /* Check the parameters */
;;;514      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L30.68|
000006  460d              MOV      r5,r1                 ;512
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L30.34|
00000c  480e              LDR      r0,|L30.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L30.34|
000012  480e              LDR      r0,|L30.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L30.34|
000018  f2402102          MOV      r1,#0x202
00001c  480c              LDR      r0,|L30.80|
00001e  f7fffffe          BL       assert_failed
                  |L30.34|
;;;515      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L30.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L30.50|
000028  f2402103          MOV      r1,#0x203
00002c  4808              LDR      r0,|L30.80|
00002e  f7fffffe          BL       assert_failed
                  |L30.50|
;;;516      if (NewState != DISABLE)
;;;517      {
;;;518        /* Peripheral under reset */
;;;519        I2Cx->CR1 |= I2C_CR1_SWRST;
000032  8820              LDRH     r0,[r4,#0]
000034  f4404000          ORR      r0,r0,#0x8000
000038  e002              B        |L30.64|
                  |L30.58|
;;;520      }
;;;521      else
;;;522      {
;;;523        /* Peripheral not under reset */
;;;524        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
00003a  8820              LDRH     r0,[r4,#0]
00003c  f3c0000e          UBFX     r0,r0,#0,#15
                  |L30.64|
000040  8020              STRH     r0,[r4,#0]            ;519
;;;525      }
;;;526    }
000042  bd70              POP      {r4-r6,pc}
;;;527    
                          ENDP

                  |L30.68|
                          DCD      0x40005400
                  |L30.72|
                          DCD      0x40005800
                  |L30.76|
                          DCD      0x40005c00
                  |L30.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=2

                  I2C_StretchClockCmd PROC
;;;534      */
;;;535    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;536    {
000002  4604              MOV      r4,r0
;;;537      /* Check the parameters */
;;;538      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L31.68|
000006  460d              MOV      r5,r1                 ;536
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L31.34|
00000c  480e              LDR      r0,|L31.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L31.34|
000012  480e              LDR      r0,|L31.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L31.34|
000018  f240211a          MOV      r1,#0x21a
00001c  480c              LDR      r0,|L31.80|
00001e  f7fffffe          BL       assert_failed
                  |L31.34|
;;;539      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b15d              CBZ      r5,|L31.60|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L31.50|
000028  f240211b          MOV      r1,#0x21b
00002c  4808              LDR      r0,|L31.80|
00002e  f7fffffe          BL       assert_failed
                  |L31.50|
;;;540      if (NewState == DISABLE)
;;;541      {
;;;542        /* Enable the selected I2C Clock stretching */
;;;543        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
;;;544      }
;;;545      else
;;;546      {
;;;547        /* Disable the selected I2C Clock stretching */
;;;548        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
000032  8820              LDRH     r0,[r4,#0]
000034  f0200080          BIC      r0,r0,#0x80
                  |L31.56|
000038  8020              STRH     r0,[r4,#0]            ;543
;;;549      }
;;;550    }
00003a  bd70              POP      {r4-r6,pc}
                  |L31.60|
00003c  8820              LDRH     r0,[r4,#0]            ;543
00003e  f0400080          ORR      r0,r0,#0x80           ;543
000042  e7f9              B        |L31.56|
;;;551    
                          ENDP

                  |L31.68|
                          DCD      0x40005400
                  |L31.72|
                          DCD      0x40005800
                  |L31.76|
                          DCD      0x40005c00
                  |L31.80|
                          DCD      ||.conststring||

                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;283      */
;;;284    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;285    {
;;;286    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;287      /* initialize the I2C_ClockSpeed member */
;;;288      I2C_InitStruct->I2C_ClockSpeed = 5000;
;;;289      /* Initialize the I2C_Mode member */
;;;290      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;291      /* Initialize the I2C_DutyCycle member */
;;;292      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b72ff          MOV      r2,#0xbfff
00000e  80c2              STRH     r2,[r0,#6]
;;;293      /* Initialize the I2C_OwnAddress1 member */
;;;294      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  8101              STRH     r1,[r0,#8]
;;;295      /* Initialize the I2C_Ack member */
;;;296      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000012  8141              STRH     r1,[r0,#0xa]
;;;297      /* Initialize the I2C_AcknowledgedAddress member */
;;;298      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000014  f44f4180          MOV      r1,#0x4000
000018  8181              STRH     r1,[r0,#0xc]
;;;299    }
00001a  4770              BX       lr
;;;300    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=2

                  I2C_TransmitPEC PROC
;;;732      */
;;;733    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;734    {
000002  4604              MOV      r4,r0
;;;735      /* Check the parameters */
;;;736      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
000004  480f              LDR      r0,|L33.68|
000006  460d              MOV      r5,r1                 ;734
000008  4284              CMP      r4,r0
00000a  d00a              BEQ      |L33.34|
00000c  480e              LDR      r0,|L33.72|
00000e  4284              CMP      r4,r0
000010  d007              BEQ      |L33.34|
000012  480e              LDR      r0,|L33.76|
000014  4284              CMP      r4,r0
000016  d004              BEQ      |L33.34|
000018  f44f7138          MOV      r1,#0x2e0
00001c  480c              LDR      r0,|L33.80|
00001e  f7fffffe          BL       assert_failed
                  |L33.34|
;;;737      assert_param(IS_FUNCTIONAL_STATE(NewState));
000022  b155              CBZ      r5,|L33.58|
000024  2d01              CMP      r5,#1
000026  d004              BEQ      |L33.50|
000028  f24021e1          MOV      r1,#0x2e1
00002c  4808              LDR      r0,|L33.80|
00002e  f7fffffe          BL       assert_failed
                  |L33.50|
;;;738      if (NewState != DISABLE)
;;;739      {
;;;740        /* Enable the selected I2C PEC transmission */
;;;741        I2Cx->CR1 |= I2C_CR1_PEC;
000032  8820              LDRH     r0,[r4,#0]
000034  f4405080          ORR      r0,r0,#0x1000
000038  e002              B        |L33.64|
                  |L33.58|
;;;742      }
;;;743      else
;;;744      {
;;;745        /* Disable the selected I2C PEC transmission */
;;;746        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
00003a  8820              LDRH     r0,[r4,#0]
00003c  f4205080          BIC      r0,r0,#0x1000
                  |L33.64|
000040  8020              STRH     r0,[r4,#0]            ;741
;;;747      }
;;;748    }
000042  bd70              POP      {r4-r6,pc}
;;;749    
                          ENDP

                  |L33.68|
                          DCD      0x40005400
                  |L33.72|
                          DCD      0x40005800
                  |L33.76|
                          DCD      0x40005c00
                  |L33.80|
                          DCD      ||.conststring||

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_i2c.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f693263
00004a  2e6300  

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_i2c.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_i2c_c_7174d409____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REVSH|
#line 128
|__asm___15_stm32f4xx_i2c_c_7174d409____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
