; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\mem.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mem.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\mem.crf ..\OS\src\mem.c]
                          THUMB

                          AREA ||i.list_mem||, CODE, READONLY, ALIGN=2

                  list_mem PROC
;;;576    
;;;577    void list_mem(void)
000000  b510              PUSH     {r4,lr}
;;;578    {
;;;579        rt_kprintf("total memory: %d\n", mem_size_aligned);
000002  4c07              LDR      r4,|L1.32|
000004  a007              ADR      r0,|L1.36|
000006  6961              LDR      r1,[r4,#0x14]  ; mem_size_aligned
000008  f7fffffe          BL       rt_kprintf
;;;580        rt_kprintf("used memory : %d\n", used_mem);
00000c  a00a              ADR      r0,|L1.56|
00000e  69a1              LDR      r1,[r4,#0x18]  ; used_mem
000010  f7fffffe          BL       rt_kprintf
;;;581        rt_kprintf("maximum allocated memory: %d\n", max_mem);
000014  69e1              LDR      r1,[r4,#0x1c]  ; max_mem
000016  e8bd4010          POP      {r4,lr}
00001a  a00c              ADR      r0,|L1.76|
00001c  f7ffbffe          B.W      rt_kprintf
;;;582    }
;;;583    FINSH_FUNCTION_EXPORT(list_mem, list memory usage information)
                          ENDP

                  |L1.32|
                          DCD      ||.data||
                  |L1.36|
000024  746f7461          DCB      "total memory: %d\n",0
000028  6c206d65
00002c  6d6f7279
000030  3a202564
000034  0a00    
000036  00                DCB      0
000037  00                DCB      0
                  |L1.56|
000038  75736564          DCB      "used memory : %d\n",0
00003c  206d656d
000040  6f727920
000044  3a202564
000048  0a00    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L1.76|
00004c  6d617869          DCB      "maximum allocated memory: %d\n",0
000050  6d756d20
000054  616c6c6f
000058  63617465
00005c  64206d65
000060  6d6f7279
000064  3a202564
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.plug_holes||, CODE, READONLY, ALIGN=2

                  plug_holes PROC
;;;135    
;;;136    static void plug_holes(struct heap_mem *mem)
000000  b5f8              PUSH     {r3-r7,lr}
;;;137    {
;;;138        struct heap_mem *nmem;
;;;139        struct heap_mem *pmem;
;;;140    
;;;141        RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
000002  4d2b              LDR      r5,|L2.176|
000004  4604              MOV      r4,r0                 ;137
000006  2600              MOVS     r6,#0
000008  68a8              LDR      r0,[r5,#8]  ; heap_ptr
00000a  4284              CMP      r4,r0
00000c  d20b              BCS      |L2.38|
00000e  f88d6000          STRB     r6,[sp,#0]
000012  238d              MOVS     r3,#0x8d
000014  4a27              LDR      r2,|L2.180|
000016  a128              ADR      r1,|L2.184|
000018  a02f              ADR      r0,|L2.216|
00001a  f7fffffe          BL       rt_kprintf
                  |L2.30|
00001e  f89d0000          LDRB     r0,[sp,#0]
000022  2800              CMP      r0,#0
000024  d0fb              BEQ      |L2.30|
                  |L2.38|
;;;142        RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
000026  68e8              LDR      r0,[r5,#0xc]  ; heap_end
000028  4284              CMP      r4,r0
00002a  d30b              BCC      |L2.68|
00002c  f88d6000          STRB     r6,[sp,#0]
000030  238e              MOVS     r3,#0x8e
000032  4a20              LDR      r2,|L2.180|
000034  a130              ADR      r1,|L2.248|
000036  a028              ADR      r0,|L2.216|
000038  f7fffffe          BL       rt_kprintf
                  |L2.60|
00003c  f89d0000          LDRB     r0,[sp,#0]
000040  2800              CMP      r0,#0
000042  d0fb              BEQ      |L2.60|
                  |L2.68|
;;;143        RT_ASSERT(mem->used == 0);
000044  8860              LDRH     r0,[r4,#2]
000046  b158              CBZ      r0,|L2.96|
000048  f88d6000          STRB     r6,[sp,#0]
00004c  238f              MOVS     r3,#0x8f
00004e  4a19              LDR      r2,|L2.180|
000050  a134              ADR      r1,|L2.292|
000052  a021              ADR      r0,|L2.216|
000054  f7fffffe          BL       rt_kprintf
                  |L2.88|
000058  f89d0000          LDRB     r0,[sp,#0]
00005c  2800              CMP      r0,#0
00005e  d0fb              BEQ      |L2.88|
                  |L2.96|
;;;144    
;;;145        /* plug hole forward */
;;;146        nmem = (struct heap_mem *)&heap_ptr[mem->next];
000060  6860              LDR      r0,[r4,#4]
000062  68a9              LDR      r1,[r5,#8]  ; heap_ptr
000064  4408              ADD      r0,r0,r1
;;;147        if (mem != nmem &&
000066  4284              CMP      r4,r0
000068  d00f              BEQ      |L2.138|
;;;148            nmem->used == 0 &&
00006a  8842              LDRH     r2,[r0,#2]
00006c  b96a              CBNZ     r2,|L2.138|
;;;149            (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
00006e  68ea              LDR      r2,[r5,#0xc]  ; heap_end
000070  4290              CMP      r0,r2
000072  d00a              BEQ      |L2.138|
;;;150        {
;;;151            /* if mem->next is unused and not end of heap_ptr,
;;;152             * combine mem and mem->next
;;;153             */
;;;154            if (lfree == nmem)
000074  692a              LDR      r2,[r5,#0x10]  ; lfree
000076  4282              CMP      r2,r0
000078  d100              BNE      |L2.124|
;;;155            {
;;;156                lfree = mem;
00007a  612c              STR      r4,[r5,#0x10]  ; lfree
                  |L2.124|
;;;157            }
;;;158            mem->next = nmem->next;
00007c  6842              LDR      r2,[r0,#4]
;;;159            ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
00007e  6062              STR      r2,[r4,#4]
000080  6843              LDR      r3,[r0,#4]
000082  f1010008          ADD      r0,r1,#8
000086  1a62              SUBS     r2,r4,r1
000088  501a              STR      r2,[r3,r0]
                  |L2.138|
;;;160        }
;;;161    
;;;162        /* plug hole backward */
;;;163        pmem = (struct heap_mem *)&heap_ptr[mem->prev];
00008a  68a0              LDR      r0,[r4,#8]
00008c  4408              ADD      r0,r0,r1
;;;164        if (pmem != mem && pmem->used == 0)
00008e  42a0              CMP      r0,r4
000090  d00c              BEQ      |L2.172|
000092  8842              LDRH     r2,[r0,#2]
000094  2a00              CMP      r2,#0
000096  d109              BNE      |L2.172|
;;;165        {
;;;166            /* if mem->prev is unused, combine mem and mem->prev */
;;;167            if (lfree == mem)
000098  692a              LDR      r2,[r5,#0x10]  ; lfree
00009a  42a2              CMP      r2,r4
00009c  d100              BNE      |L2.160|
;;;168            {
;;;169                lfree = pmem;
00009e  6128              STR      r0,[r5,#0x10]  ; lfree
                  |L2.160|
;;;170            }
;;;171            pmem->next = mem->next;
0000a0  6862              LDR      r2,[r4,#4]
;;;172            ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
0000a2  6042              STR      r2,[r0,#4]
0000a4  1a40              SUBS     r0,r0,r1
0000a6  6862              LDR      r2,[r4,#4]
0000a8  3108              ADDS     r1,r1,#8
0000aa  5050              STR      r0,[r2,r1]
                  |L2.172|
;;;173        }
;;;174    }
0000ac  bdf8              POP      {r3-r7,pc}
;;;175    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L2.176|
                          DCD      ||.data||
                  |L2.180|
                          DCD      ||area_number.16||+0x8
                  |L2.184|
0000b8  2872745f          DCB      "(rt_uint8_t *)mem >= heap_ptr",0
0000bc  75696e74
0000c0  385f7420
0000c4  2a296d65
0000c8  6d203e3d
0000cc  20686561
0000d0  705f7074
0000d4  7200    
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L2.216|
0000d8  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000dc  20617373
0000e0  65727420
0000e4  6661696c
0000e8  65642061
0000ec  74202573
0000f0  3a256420
0000f4  0a00    
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L2.248|
0000f8  2872745f          DCB      "(rt_uint8_t *)mem < (rt_uint8_t *)heap_end",0
0000fc  75696e74
000100  385f7420
000104  2a296d65
000108  6d203c20
00010c  2872745f
000110  75696e74
000114  385f7420
000118  2a296865
00011c  61705f65
000120  6e6400  
000123  00                DCB      0
                  |L2.292|
000124  6d656d2d          DCB      "mem->used == 0",0
000128  3e757365
00012c  64203d3d
000130  203000  
000133  00                DCB      0

                          AREA ||i.rt_calloc||, CODE, READONLY, ALIGN=2

                  rt_calloc PROC
;;;480     */
;;;481    void *rt_calloc(rt_size_t count, rt_size_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;482    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;483        void *p;
;;;484    
;;;485        RT_DEBUG_NOT_IN_INTERRUPT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  b188              CBZ      r0,|L3.54|
000012  4910              LDR      r1,|L3.84|
000014  a010              ADR      r0,|L3.88|
000016  f7fffffe          BL       rt_kprintf
00001a  2000              MOVS     r0,#0
00001c  f88d0000          STRB     r0,[sp,#0]
000020  f24013e5          MOV      r3,#0x1e5
000024  4a0b              LDR      r2,|L3.84|
000026  a115              ADR      r1,|L3.124|
000028  a015              ADR      r0,|L3.128|
00002a  f7fffffe          BL       rt_kprintf
                  |L3.46|
00002e  f89d0000          LDRB     r0,[sp,#0]
000032  2800              CMP      r0,#0
000034  d0fb              BEQ      |L3.46|
                  |L3.54|
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       rt_hw_interrupt_enable
;;;486    
;;;487        /* allocate 'count' objects of size 'size' */
;;;488        p = rt_malloc(count * size);
00003c  436c              MULS     r4,r5,r4
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       rt_malloc
000044  0005              MOVS     r5,r0
;;;489    
;;;490        /* zero the memory */
;;;491        if (p)
000046  d003              BEQ      |L3.80|
000048  4622              MOV      r2,r4
;;;492            rt_memset(p, 0, count * size);
00004a  2100              MOVS     r1,#0
00004c  f7fffffe          BL       rt_memset
                  |L3.80|
;;;493    
;;;494        return p;
000050  4628              MOV      r0,r5
;;;495    }
000052  bdf8              POP      {r3-r7,pc}
;;;496    RTM_EXPORT(rt_calloc);
                          ENDP

                  |L3.84|
                          DCD      ||area_number.16||+0x3c
                  |L3.88|
000058  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00005c  74696f6e
000060  5b25735d
000064  20736861
000068  6c6c206e
00006c  6f742075
000070  73656420
000074  696e2049
000078  53520a00
                  |L3.124|
00007c  3000              DCB      "0",0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L3.128|
000080  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000084  20617373
000088  65727420
00008c  6661696c
000090  65642061
000094  74202573
000098  3a256420
00009c  0a00    
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.rt_free||, CODE, READONLY, ALIGN=2

                  rt_free PROC
;;;503     */
;;;504    void rt_free(void *rmem)
000000  b5f8              PUSH     {r3-r7,lr}
;;;505    {
000002  4604              MOV      r4,r0
;;;506        struct heap_mem *mem;
;;;507    
;;;508        RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4606              MOV      r6,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2500              MOVS     r5,#0
000010  b180              CBZ      r0,|L4.52|
000012  493f              LDR      r1,|L4.272|
000014  a03f              ADR      r0,|L4.276|
000016  f7fffffe          BL       rt_kprintf
00001a  f88d5000          STRB     r5,[sp,#0]
00001e  f44f73fe          MOV      r3,#0x1fc
000022  4a3b              LDR      r2,|L4.272|
000024  a144              ADR      r1,|L4.312|
000026  a045              ADR      r0,|L4.316|
000028  f7fffffe          BL       rt_kprintf
                  |L4.44|
00002c  f89d0000          LDRB     r0,[sp,#0]
000030  2800              CMP      r0,#0
000032  d0fb              BEQ      |L4.44|
                  |L4.52|
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       rt_hw_interrupt_enable
;;;509    
;;;510        if (rmem == RT_NULL)
00003a  2c00              CMP      r4,#0
00003c  d067              BEQ      |L4.270|
;;;511            return;
;;;512        RT_ASSERT((((rt_uint32_t)rmem) & (RT_ALIGN_SIZE-1)) == 0);
00003e  0760              LSLS     r0,r4,#29
000040  d00c              BEQ      |L4.92|
000042  f88d5000          STRB     r5,[sp,#0]
000046  f44f7300          MOV      r3,#0x200
00004a  4a31              LDR      r2,|L4.272|
00004c  a143              ADR      r1,|L4.348|
00004e  a03b              ADR      r0,|L4.316|
000050  f7fffffe          BL       rt_kprintf
                  |L4.84|
000054  f89d0000          LDRB     r0,[sp,#0]
000058  2800              CMP      r0,#0
00005a  d0fb              BEQ      |L4.84|
                  |L4.92|
;;;513        RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
00005c  4e4b              LDR      r6,|L4.396|
00005e  68b0              LDR      r0,[r6,#8]  ; heap_ptr
000060  4284              CMP      r4,r0
000062  d302              BCC      |L4.106|
000064  68f0              LDR      r0,[r6,#0xc]  ; heap_end
000066  4284              CMP      r4,r0
000068  d30c              BCC      |L4.132|
                  |L4.106|
00006a  f88d5000          STRB     r5,[sp,#0]
00006e  f2402301          MOV      r3,#0x201
000072  4a27              LDR      r2,|L4.272|
000074  4946              LDR      r1,|L4.400|
000076  a031              ADR      r0,|L4.316|
000078  f7fffffe          BL       rt_kprintf
                  |L4.124|
00007c  f89d0000          LDRB     r0,[sp,#0]
000080  2800              CMP      r0,#0
000082  d0fb              BEQ      |L4.124|
                  |L4.132|
;;;514                  (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);
;;;515    
;;;516        RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
000084  6871              LDR      r1,[r6,#4]  ; rt_free_hook
000086  b109              CBZ      r1,|L4.140|
000088  4620              MOV      r0,r4
00008a  4788              BLX      r1
                  |L4.140|
;;;517    
;;;518        if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
00008c  68b0              LDR      r0,[r6,#8]  ; heap_ptr
00008e  4284              CMP      r4,r0
000090  d33d              BCC      |L4.270|
;;;519            (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
000092  68f0              LDR      r0,[r6,#0xc]  ; heap_end
000094  4284              CMP      r4,r0
000096  d23a              BCS      |L4.270|
;;;520        {
;;;521            RT_DEBUG_LOG(RT_DEBUG_MEM, ("illegal memory\n"));
;;;522    
;;;523            return;
;;;524        }
;;;525    
;;;526        /* Get the corresponding struct heap_mem ... */
;;;527        mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;528    
;;;529        RT_DEBUG_LOG(RT_DEBUG_MEM,
;;;530                     ("release memory 0x%x, size: %d\n",
;;;531                      (rt_uint32_t)rmem,
;;;532                      (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));
;;;533    
;;;534    
;;;535        /* protect the heap from concurrent access */
;;;536        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
000098  f04f31ff          MOV      r1,#0xffffffff
00009c  483d              LDR      r0,|L4.404|
00009e  3c10              SUBS     r4,r4,#0x10
0000a0  f7fffffe          BL       rt_sem_take
;;;537    
;;;538        /* ... which has to be in a used state ... */
;;;539        RT_ASSERT(mem->used);
0000a4  8860              LDRH     r0,[r4,#2]
0000a6  b960              CBNZ     r0,|L4.194|
0000a8  f88d5000          STRB     r5,[sp,#0]
0000ac  f240231b          MOV      r3,#0x21b
0000b0  4a17              LDR      r2,|L4.272|
0000b2  a139              ADR      r1,|L4.408|
0000b4  a021              ADR      r0,|L4.316|
0000b6  f7fffffe          BL       rt_kprintf
                  |L4.186|
0000ba  f89d0000          LDRB     r0,[sp,#0]
0000be  2800              CMP      r0,#0
0000c0  d0fb              BEQ      |L4.186|
                  |L4.194|
;;;540        RT_ASSERT(mem->magic == HEAP_MAGIC);
0000c2  8820              LDRH     r0,[r4,#0]
0000c4  f5b05ff5          CMP      r0,#0x1ea0
0000c8  d00c              BEQ      |L4.228|
0000ca  f88d5000          STRB     r5,[sp,#0]
0000ce  f44f7307          MOV      r3,#0x21c
0000d2  4a0f              LDR      r2,|L4.272|
0000d4  a133              ADR      r1,|L4.420|
0000d6  a019              ADR      r0,|L4.316|
0000d8  f7fffffe          BL       rt_kprintf
                  |L4.220|
0000dc  f89d0000          LDRB     r0,[sp,#0]
0000e0  2800              CMP      r0,#0
0000e2  d0fb              BEQ      |L4.220|
                  |L4.228|
;;;541        /* ... and is now unused. */
;;;542        mem->used  = 0;
0000e4  8065              STRH     r5,[r4,#2]
;;;543        mem->magic = 0;
0000e6  8025              STRH     r5,[r4,#0]
;;;544    
;;;545        if (mem < lfree)
0000e8  6930              LDR      r0,[r6,#0x10]  ; lfree
0000ea  4284              CMP      r4,r0
0000ec  d200              BCS      |L4.240|
;;;546        {
;;;547            /* the newly freed struct is now the lowest */
;;;548            lfree = mem;
0000ee  6134              STR      r4,[r6,#0x10]  ; lfree
                  |L4.240|
;;;549        }
;;;550    
;;;551    #ifdef RT_MEM_STATS
;;;552        used_mem -= (mem->next - ((rt_uint8_t*)mem - heap_ptr));
0000f0  68b1              LDR      r1,[r6,#8]  ; heap_ptr
0000f2  6860              LDR      r0,[r4,#4]
0000f4  1a61              SUBS     r1,r4,r1
0000f6  1a40              SUBS     r0,r0,r1
0000f8  69b1              LDR      r1,[r6,#0x18]  ; used_mem
0000fa  1a08              SUBS     r0,r1,r0
;;;553    #endif
;;;554    
;;;555        /* finally, see if prev or next are free also */
;;;556        plug_holes(mem);
0000fc  61b0              STR      r0,[r6,#0x18]  ; used_mem
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       plug_holes
;;;557        rt_sem_release(&heap_sem);
000104  e8bd40f8          POP      {r3-r7,lr}
000108  4822              LDR      r0,|L4.404|
00010a  f7ffbffe          B.W      rt_sem_release
                  |L4.270|
;;;558    }
00010e  bdf8              POP      {r3-r7,pc}
;;;559    RTM_EXPORT(rt_free);
                          ENDP

                  |L4.272|
                          DCD      ||area_number.16||
                  |L4.276|
000114  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000118  74696f6e
00011c  5b25735d
000120  20736861
000124  6c6c206e
000128  6f742075
00012c  73656420
000130  696e2049
000134  53520a00
                  |L4.312|
000138  3000              DCB      "0",0
00013a  00                DCB      0
00013b  00                DCB      0
                  |L4.316|
00013c  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000140  20617373
000144  65727420
000148  6661696c
00014c  65642061
000150  74202573
000154  3a256420
000158  0a00    
00015a  00                DCB      0
00015b  00                DCB      0
                  |L4.348|
00015c  28282872          DCB      "(((rt_uint32_t)rmem) & (RT_ALIGN_SIZE-1)) == 0",0
000160  745f7569
000164  6e743332
000168  5f742972
00016c  6d656d29
000170  20262028
000174  52545f41
000178  4c49474e
00017c  5f53495a
000180  452d3129
000184  29203d3d
000188  203000  
00018b  00                DCB      0
                  |L4.396|
                          DCD      ||.data||
                  |L4.400|
                          DCD      ||.conststring||+0x94
                  |L4.404|
                          DCD      ||.bss||
                  |L4.408|
000198  6d656d2d          DCB      "mem->used",0
00019c  3e757365
0001a0  6400    
0001a2  00                DCB      0
0001a3  00                DCB      0
                  |L4.420|
0001a4  6d656d2d          DCB      "mem->magic == HEAP_MAGIC",0
0001a8  3e6d6167
0001ac  6963203d
0001b0  3d204845
0001b4  41505f4d
0001b8  41474943
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0

                          AREA ||i.rt_free_sethook||, CODE, READONLY, ALIGN=2

                  rt_free_sethook PROC
;;;97      */
;;;98     void rt_free_sethook(void (*hook)(void *ptr))
000000  4901              LDR      r1,|L5.8|
;;;99     {
;;;100        rt_free_hook = hook;
000002  6048              STR      r0,[r1,#4]  ; rt_free_hook
;;;101    }
000004  4770              BX       lr
;;;102    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.data||

                          AREA ||i.rt_malloc||, CODE, READONLY, ALIGN=2

                  rt_malloc PROC
;;;245     */
;;;246    void *rt_malloc(rt_size_t size)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;247    {
000004  4604              MOV      r4,r0
;;;248        rt_size_t ptr, ptr2;
;;;249        struct heap_mem *mem, *mem2;
;;;250    
;;;251        RT_DEBUG_NOT_IN_INTERRUPT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  2700              MOVS     r7,#0
000012  b178              CBZ      r0,|L6.52|
000014  4965              LDR      r1,|L6.428|
000016  a066              ADR      r0,|L6.432|
000018  f7fffffe          BL       rt_kprintf
00001c  f88d7000          STRB     r7,[sp,#0]
000020  23fb              MOVS     r3,#0xfb
000022  4a62              LDR      r2,|L6.428|
000024  a16b              ADR      r1,|L6.468|
000026  a06c              ADR      r0,|L6.472|
000028  f7fffffe          BL       rt_kprintf
                  |L6.44|
00002c  f89d1000          LDRB     r1,[sp,#0]
000030  2900              CMP      r1,#0
000032  d0fb              BEQ      |L6.44|
                  |L6.52|
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       rt_hw_interrupt_enable
;;;252    
;;;253        if (size == 0)
00003a  b134              CBZ      r4,|L6.74|
;;;254            return RT_NULL;
;;;255    
;;;256        if (size != RT_ALIGN(size, RT_ALIGN_SIZE))
;;;257            RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d, but align to %d\n",
;;;258                                        size, RT_ALIGN(size, RT_ALIGN_SIZE)));
;;;259        else
;;;260            RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));
;;;261    
;;;262        /* alignment size */
;;;263        size = RT_ALIGN(size, RT_ALIGN_SIZE);
;;;264    
;;;265        if (size > mem_size_aligned)
00003c  4e6e              LDR      r6,|L6.504|
00003e  1de4              ADDS     r4,r4,#7              ;253
000040  f0240507          BIC      r5,r4,#7              ;263
000044  6970              LDR      r0,[r6,#0x14]  ; mem_size_aligned
000046  4285              CMP      r5,r0
000048  d902              BLS      |L6.80|
                  |L6.74|
;;;266        {
;;;267            RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));
;;;268    
;;;269            return RT_NULL;
00004a  2000              MOVS     r0,#0
                  |L6.76|
;;;270        }
;;;271    
;;;272        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;273        if (size < MIN_SIZE_ALIGNED)
;;;274            size = MIN_SIZE_ALIGNED;
;;;275    
;;;276        /* take memory semaphore */
;;;277        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;278    
;;;279        for (ptr = (rt_uint8_t *)lfree - heap_ptr;
;;;280             ptr < mem_size_aligned - size;
;;;281             ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
;;;282        {
;;;283            mem = (struct heap_mem *)&heap_ptr[ptr];
;;;284    
;;;285            if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
;;;286            {
;;;287                /* mem is not used and at least perfect fit is possible:
;;;288                 * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;289    
;;;290                if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
;;;291                    (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
;;;292                {
;;;293                    /* (in addition to the above, we test if another struct heap_mem (SIZEOF_STRUCT_MEM) containing
;;;294                     * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;295                     * -> split large block, create empty remainder,
;;;296                     * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;297                     * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;298                     * struct heap_mem would fit in but no data between mem2 and mem2->next
;;;299                     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;300                     *       region that couldn't hold data, but when mem->next gets freed,
;;;301                     *       the 2 regions would be combined, resulting in more free memory
;;;302                     */
;;;303                    ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;304    
;;;305                    /* create mem2 struct */
;;;306                    mem2       = (struct heap_mem *)&heap_ptr[ptr2];
;;;307                    mem2->used = 0;
;;;308                    mem2->next = mem->next;
;;;309                    mem2->prev = ptr;
;;;310    
;;;311                    /* and insert it between mem and mem->next */
;;;312                    mem->next = ptr2;
;;;313                    mem->used = 1;
;;;314    
;;;315                    if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
;;;316                    {
;;;317                        ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
;;;318                    }
;;;319    #ifdef RT_MEM_STATS
;;;320                    used_mem += (size + SIZEOF_STRUCT_MEM);
;;;321                    if (max_mem < used_mem)
;;;322                        max_mem = used_mem;
;;;323    #endif
;;;324                }
;;;325                else
;;;326                {
;;;327                    /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;328                     * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;329                     * take care of this).
;;;330                     * -> near fit or excact fit: do not split, no mem2 creation
;;;331                     * also can't move mem->next directly behind mem, since mem->next
;;;332                     * will always be used at this point!
;;;333                     */
;;;334                    mem->used = 1;
;;;335    #ifdef RT_MEM_STATS
;;;336                    used_mem += mem->next - ((rt_uint8_t*)mem - heap_ptr);
;;;337                    if (max_mem < used_mem)
;;;338                        max_mem = used_mem;
;;;339    #endif
;;;340                }
;;;341                /* set memory block magic */
;;;342                mem->magic = HEAP_MAGIC;
;;;343    
;;;344                if (mem == lfree)
;;;345                {
;;;346                    /* Find next free block after mem and update lowest free pointer */
;;;347                    while (lfree->used && lfree != heap_end)
;;;348                        lfree = (struct heap_mem *)&heap_ptr[lfree->next];
;;;349    
;;;350                    RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
;;;351                }
;;;352    
;;;353                rt_sem_release(&heap_sem);
;;;354                RT_ASSERT((rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint32_t)heap_end);
;;;355                RT_ASSERT((rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
;;;356                RT_ASSERT((((rt_uint32_t)mem) & (RT_ALIGN_SIZE-1)) == 0);
;;;357    
;;;358                RT_DEBUG_LOG(RT_DEBUG_MEM,
;;;359                             ("allocate memory at 0x%x, size: %d\n",
;;;360                              (rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
;;;361                              (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));
;;;362    
;;;363                RT_OBJECT_HOOK_CALL(rt_malloc_hook,
;;;364                                    (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));
;;;365    
;;;366                /* return the memory data except mem struct */
;;;367                return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
;;;368            }
;;;369        }
;;;370    
;;;371        rt_sem_release(&heap_sem);
;;;372    
;;;373        return RT_NULL;
;;;374    }
00004c  e8bd8ff8          POP      {r3-r11,pc}
                  |L6.80|
000050  2d10              CMP      r5,#0x10              ;273
000052  d200              BCS      |L6.86|
000054  2510              MOVS     r5,#0x10              ;274
                  |L6.86|
000056  f04f31ff          MOV      r1,#0xffffffff        ;277
00005a  4868              LDR      r0,|L6.508|
00005c  f7fffffe          BL       rt_sem_take
000060  6930              LDR      r0,[r6,#0x10]         ;279  ; lfree
000062  68b1              LDR      r1,[r6,#8]            ;279  ; heap_ptr
000064  f8d6c014          LDR      r12,[r6,#0x14]        ;280
000068  4681              MOV      r9,r0                 ;279
00006a  1a40              SUBS     r0,r0,r1              ;279
00006c  ebac0205          SUB      r2,r12,r5             ;280
000070  e094              B        |L6.412|
                  |L6.114|
000072  180c              ADDS     r4,r1,r0              ;283
000074  8863              LDRH     r3,[r4,#2]            ;285
000076  2b00              CMP      r3,#0                 ;285
000078  d17d              BNE      |L6.374|
00007a  6863              LDR      r3,[r4,#4]            ;285
00007c  1a1b              SUBS     r3,r3,r0              ;285
00007e  3b10              SUBS     r3,r3,#0x10           ;285
000080  42ab              CMP      r3,r5                 ;285
000082  d378              BCC      |L6.374|
000084  6862              LDR      r2,[r4,#4]            ;290
000086  f1050320          ADD      r3,r5,#0x20           ;290
00008a  1a12              SUBS     r2,r2,r0              ;290
00008c  3a10              SUBS     r2,r2,#0x10           ;313
00008e  f04f0a01          MOV      r10,#1                ;313
000092  429a              CMP      r2,r3                 ;290
000094  d329              BCC      |L6.234|
000096  1943              ADDS     r3,r0,r5              ;303
000098  3310              ADDS     r3,r3,#0x10           ;303
00009a  18ca              ADDS     r2,r1,r3              ;306
00009c  f10c0c10          ADD      r12,r12,#0x10         ;315
0000a0  8057              STRH     r7,[r2,#2]            ;307
0000a2  f8d48004          LDR      r8,[r4,#4]            ;308
0000a6  e9c28001          STRD     r8,r0,[r2,#4]         ;308
0000aa  6063              STR      r3,[r4,#4]            ;313
0000ac  f8a4a002          STRH     r10,[r4,#2]           ;313
0000b0  6850              LDR      r0,[r2,#4]            ;315
0000b2  4560              CMP      r0,r12                ;315
0000b4  d002              BEQ      |L6.188|
0000b6  f1010208          ADD      r2,r1,#8              ;317
0000ba  5083              STR      r3,[r0,r2]            ;317
                  |L6.188|
0000bc  69b0              LDR      r0,[r6,#0x18]         ;320  ; used_mem
0000be  4428              ADD      r0,r0,r5              ;320
0000c0  3010              ADDS     r0,r0,#0x10           ;320
                  |L6.194|
0000c2  61b0              STR      r0,[r6,#0x18]         ;337  ; used_mem
0000c4  69f2              LDR      r2,[r6,#0x1c]         ;337  ; max_mem
0000c6  4282              CMP      r2,r0                 ;337
0000c8  d200              BCS      |L6.204|
0000ca  61f0              STR      r0,[r6,#0x1c]         ;338  ; max_mem
                  |L6.204|
0000cc  f44f50f5          MOV      r0,#0x1ea0            ;342
0000d0  8020              STRH     r0,[r4,#0]            ;342
0000d2  454c              CMP      r4,r9                 ;344
0000d4  d123              BNE      |L6.286|
0000d6  e9d62003          LDRD     r2,r0,[r6,#0xc]       ;344
                  |L6.218|
0000da  8843              LDRH     r3,[r0,#2]            ;347
0000dc  b16b              CBZ      r3,|L6.250|
0000de  4290              CMP      r0,r2                 ;347
0000e0  d00b              BEQ      |L6.250|
0000e2  6840              LDR      r0,[r0,#4]            ;348
0000e4  4408              ADD      r0,r0,r1              ;348
0000e6  6130              STR      r0,[r6,#0x10]         ;348  ; lfree
0000e8  e7f7              B        |L6.218|
                  |L6.234|
0000ea  f8a4a002          STRH     r10,[r4,#2]           ;334
0000ee  6860              LDR      r0,[r4,#4]            ;336
0000f0  1a62              SUBS     r2,r4,r1              ;336
0000f2  1a80              SUBS     r0,r0,r2              ;336
0000f4  69b2              LDR      r2,[r6,#0x18]         ;336  ; used_mem
0000f6  4410              ADD      r0,r0,r2              ;336
0000f8  e7e3              B        |L6.194|
                  |L6.250|
0000fa  4290              CMP      r0,r2                 ;350
0000fc  d00f              BEQ      |L6.286|
0000fe  0418              LSLS     r0,r3,#16             ;350
000100  0c00              LSRS     r0,r0,#16             ;350
000102  d00c              BEQ      |L6.286|
000104  f88d7000          STRB     r7,[sp,#0]            ;350
000108  f44f73af          MOV      r3,#0x15e             ;350
00010c  4a27              LDR      r2,|L6.428|
00010e  a13c              ADR      r1,|L6.512|
000110  a031              ADR      r0,|L6.472|
000112  f7fffffe          BL       rt_kprintf
                  |L6.278|
000116  f89d0000          LDRB     r0,[sp,#0]            ;350
00011a  2800              CMP      r0,#0                 ;350
00011c  d0fb              BEQ      |L6.278|
                  |L6.286|
00011e  4837              LDR      r0,|L6.508|
000120  f7fffffe          BL       rt_sem_release
000124  1960              ADDS     r0,r4,r5              ;354
000126  68f1              LDR      r1,[r6,#0xc]          ;354  ; heap_end
000128  3010              ADDS     r0,r0,#0x10           ;354
00012a  4288              CMP      r0,r1                 ;354
00012c  d90c              BLS      |L6.328|
00012e  f88d7000          STRB     r7,[sp,#0]            ;354
000132  f44f73b1          MOV      r3,#0x162             ;354
000136  4a1d              LDR      r2,|L6.428|
000138  493b              LDR      r1,|L6.552|
00013a  a027              ADR      r0,|L6.472|
00013c  f7fffffe          BL       rt_kprintf
                  |L6.320|
000140  f89d0000          LDRB     r0,[sp,#0]            ;354
000144  2800              CMP      r0,#0                 ;354
000146  d0fb              BEQ      |L6.320|
                  |L6.328|
000148  0760              LSLS     r0,r4,#29             ;355
00014a  d01d              BEQ      |L6.392|
00014c  f88d7000          STRB     r7,[sp,#0]            ;355
000150  f2401363          MOV      r3,#0x163             ;355
000154  4a15              LDR      r2,|L6.428|
000156  4935              LDR      r1,|L6.556|
000158  a01f              ADR      r0,|L6.472|
00015a  f7fffffe          BL       rt_kprintf
                  |L6.350|
00015e  f89d0000          LDRB     r0,[sp,#0]            ;355
000162  2800              CMP      r0,#0                 ;355
000164  d0fb              BEQ      |L6.350|
000166  0760              LSLS     r0,r4,#29             ;356
000168  d00e              BEQ      |L6.392|
00016a  f88d7000          STRB     r7,[sp,#0]            ;356
00016e  f44f73b2          MOV      r3,#0x164             ;356
000172  4a0e              LDR      r2,|L6.428|
000174  e000              B        |L6.376|
                  |L6.374|
000176  e010              B        |L6.410|
                  |L6.376|
000178  a12d              ADR      r1,|L6.560|
00017a  a017              ADR      r0,|L6.472|
00017c  f7fffffe          BL       rt_kprintf
                  |L6.384|
000180  f89d0000          LDRB     r0,[sp,#0]            ;356
000184  2800              CMP      r0,#0                 ;356
000186  d0fb              BEQ      |L6.384|
                  |L6.392|
000188  6832              LDR      r2,[r6,#0]            ;363  ; rt_malloc_hook
00018a  b11a              CBZ      r2,|L6.404|
00018c  4629              MOV      r1,r5                 ;363
00018e  f1040010          ADD      r0,r4,#0x10           ;363
000192  4790              BLX      r2                    ;363
                  |L6.404|
000194  f1040010          ADD      r0,r4,#0x10           ;367
000198  e758              B        |L6.76|
                  |L6.410|
00019a  6860              LDR      r0,[r4,#4]            ;281
                  |L6.412|
00019c  4282              CMP      r2,r0                 ;280
00019e  f63faf68          BHI      |L6.114|
0001a2  4816              LDR      r0,|L6.508|
0001a4  f7fffffe          BL       rt_sem_release
0001a8  e74f              B        |L6.74|
;;;375    RTM_EXPORT(rt_malloc);
                          ENDP

0001aa  0000              DCW      0x0000
                  |L6.428|
                          DCD      ||area_number.16||+0x27
                  |L6.432|
0001b0  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0001b4  74696f6e
0001b8  5b25735d
0001bc  20736861
0001c0  6c6c206e
0001c4  6f742075
0001c8  73656420
0001cc  696e2049
0001d0  53520a00
                  |L6.468|
0001d4  3000              DCB      "0",0
0001d6  00                DCB      0
0001d7  00                DCB      0
                  |L6.472|
0001d8  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0001dc  20617373
0001e0  65727420
0001e4  6661696c
0001e8  65642061
0001ec  74202573
0001f0  3a256420
0001f4  0a00    
0001f6  00                DCB      0
0001f7  00                DCB      0
                  |L6.504|
                          DCD      ||.data||
                  |L6.508|
                          DCD      ||.bss||
                  |L6.512|
000200  28286c66          DCB      "((lfree == heap_end) || (!lfree->used))",0
000204  72656520
000208  3d3d2068
00020c  6561705f
000210  656e6429
000214  207c7c20
000218  28216c66
00021c  7265652d
000220  3e757365
000224  64292900
                  |L6.552|
                          DCD      ||.conststring||
                  |L6.556|
                          DCD      ||.conststring||+0x48
                  |L6.560|
000230  28282872          DCB      "(((rt_uint32_t)mem) & (RT_ALIGN_SIZE-1)) == 0",0
000234  745f7569
000238  6e743332
00023c  5f74296d
000240  656d2920
000244  26202852
000248  545f414c
00024c  49474e5f
000250  53495a45
000254  2d312929
000258  203d3d20
00025c  3000    
00025e  00                DCB      0
00025f  00                DCB      0

                          AREA ||i.rt_malloc_sethook||, CODE, READONLY, ALIGN=2

                  rt_malloc_sethook PROC
;;;86      */
;;;87     void rt_malloc_sethook(void (*hook)(void *ptr, rt_size_t size))
000000  4901              LDR      r1,|L7.8|
;;;88     {
;;;89         rt_malloc_hook = hook;
000002  6008              STR      r0,[r1,#0]  ; rt_malloc_hook
;;;90     }
000004  4770              BX       lr
;;;91     
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||.data||

                          AREA ||i.rt_memory_info||, CODE, READONLY, ALIGN=2

                  rt_memory_info PROC
;;;561    #ifdef RT_MEM_STATS
;;;562    void rt_memory_info(rt_uint32_t *total,
000000  b510              PUSH     {r4,lr}
;;;563                        rt_uint32_t *used,
;;;564                        rt_uint32_t *max_used)
;;;565    {
;;;566        if (total != RT_NULL)
;;;567            *total = mem_size_aligned;
000002  4b06              LDR      r3,|L8.28|
000004  b108              CBZ      r0,|L8.10|
000006  695c              LDR      r4,[r3,#0x14]  ; mem_size_aligned
000008  6004              STR      r4,[r0,#0]
                  |L8.10|
;;;568        if (used  != RT_NULL)
00000a  b109              CBZ      r1,|L8.16|
;;;569            *used = used_mem;
00000c  6998              LDR      r0,[r3,#0x18]  ; used_mem
00000e  6008              STR      r0,[r1,#0]
                  |L8.16|
;;;570        if (max_used != RT_NULL)
000010  2a00              CMP      r2,#0
000012  d001              BEQ      |L8.24|
;;;571            *max_used = max_mem;
000014  69d8              LDR      r0,[r3,#0x1c]  ; max_mem
000016  6010              STR      r0,[r2,#0]
                  |L8.24|
;;;572    }
000018  bd10              POP      {r4,pc}
;;;573    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      ||.data||

                          AREA ||i.rt_realloc||, CODE, READONLY, ALIGN=2

                  rt_realloc PROC
;;;384     */
;;;385    void *rt_realloc(void *rmem, rt_size_t newsize)
000000  b5f8              PUSH     {r3-r7,lr}
;;;386    {
000002  460c              MOV      r4,r1
000004  4606              MOV      r6,r0
;;;387        rt_size_t size;
;;;388        rt_size_t ptr, ptr2;
;;;389        struct heap_mem *mem, *mem2;
;;;390        void *nmem;
;;;391    
;;;392        RT_DEBUG_NOT_IN_INTERRUPT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  2700              MOVS     r7,#0
000012  b180              CBZ      r0,|L9.54|
000014  4939              LDR      r1,|L9.252|
000016  a03a              ADR      r0,|L9.256|
000018  f7fffffe          BL       rt_kprintf
00001c  f88d7000          STRB     r7,[sp,#0]
000020  f44f73c4          MOV      r3,#0x188
000024  4a35              LDR      r2,|L9.252|
000026  a13f              ADR      r1,|L9.292|
000028  a03f              ADR      r0,|L9.296|
00002a  f7fffffe          BL       rt_kprintf
                  |L9.46|
00002e  f89d0000          LDRB     r0,[sp,#0]
000032  2800              CMP      r0,#0
000034  d0fb              BEQ      |L9.46|
                  |L9.54|
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       rt_hw_interrupt_enable
;;;393    
;;;394        /* alignment size */
;;;395        newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
;;;396        if (newsize > mem_size_aligned)
00003c  4d42              LDR      r5,|L9.328|
00003e  1de4              ADDS     r4,r4,#7              ;392
000040  f0240407          BIC      r4,r4,#7              ;395
000044  6968              LDR      r0,[r5,#0x14]  ; mem_size_aligned
000046  4284              CMP      r4,r0
000048  d901              BLS      |L9.78|
;;;397        {
;;;398            RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));
;;;399    
;;;400            return RT_NULL;
00004a  2000              MOVS     r0,#0
;;;401        }
;;;402    
;;;403        /* allocate a new memory block */
;;;404        if (rmem == RT_NULL)
;;;405            return rt_malloc(newsize);
;;;406    
;;;407        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;408    
;;;409        if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
;;;410            (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
;;;411        {
;;;412            /* illegal memory */
;;;413            rt_sem_release(&heap_sem);
;;;414    
;;;415            return rmem;
;;;416        }
;;;417    
;;;418        mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;419    
;;;420        ptr = (rt_uint8_t *)mem - heap_ptr;
;;;421        size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;422        if (size == newsize)
;;;423        {
;;;424            /* the size is the same as */
;;;425            rt_sem_release(&heap_sem);
;;;426    
;;;427            return rmem;
;;;428        }
;;;429    
;;;430        if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
;;;431        {
;;;432            /* split memory block */
;;;433    #ifdef RT_MEM_STATS
;;;434            used_mem -= (size - newsize);
;;;435    #endif
;;;436    
;;;437            ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;438            mem2 = (struct heap_mem *)&heap_ptr[ptr2];
;;;439            mem2->magic= HEAP_MAGIC;
;;;440            mem2->used = 0;
;;;441            mem2->next = mem->next;
;;;442            mem2->prev = ptr;
;;;443            mem->next = ptr2;
;;;444            if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
;;;445            {
;;;446                ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
;;;447            }
;;;448    
;;;449            plug_holes(mem2);
;;;450    
;;;451            rt_sem_release(&heap_sem);
;;;452    
;;;453            return rmem;
;;;454        }
;;;455        rt_sem_release(&heap_sem);
;;;456    
;;;457        /* expand memory */
;;;458        nmem = rt_malloc(newsize);
;;;459        if (nmem != RT_NULL) /* check memory */
;;;460        {
;;;461            rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
;;;462            rt_free(rmem);
;;;463        }
;;;464    
;;;465        return nmem;
;;;466    }
00004c  bdf8              POP      {r3-r7,pc}
                  |L9.78|
00004e  b1de              CBZ      r6,|L9.136|
000050  f04f31ff          MOV      r1,#0xffffffff        ;407
000054  483d              LDR      r0,|L9.332|
000056  f7fffffe          BL       rt_sem_take
00005a  68aa              LDR      r2,[r5,#8]            ;409  ; heap_ptr
00005c  46ae              MOV      lr,r5                 ;409
00005e  4296              CMP      r6,r2                 ;409
000060  d30d              BCC      |L9.126|
000062  f8de000c          LDR      r0,[lr,#0xc]          ;410  ; heap_end
000066  4286              CMP      r6,r0                 ;410
000068  d209              BCS      |L9.126|
00006a  f1a60110          SUB      r1,r6,#0x10           ;418
00006e  eba10c02          SUB      r12,r1,r2             ;420
000072  6848              LDR      r0,[r1,#4]            ;421
000074  eba0050c          SUB      r5,r0,r12             ;421
000078  3d10              SUBS     r5,r5,#0x10           ;421
00007a  42a5              CMP      r5,r4                 ;422
00007c  d109              BNE      |L9.146|
                  |L9.126|
00007e  4833              LDR      r0,|L9.332|
000080  f7fffffe          BL       rt_sem_release
000084  4630              MOV      r0,r6                 ;427
000086  bdf8              POP      {r3-r7,pc}
                  |L9.136|
000088  4620              MOV      r0,r4                 ;405
00008a  e8bd40f8          POP      {r3-r7,lr}            ;405
00008e  f7ffbffe          B.W      rt_malloc
                  |L9.146|
000092  f104001c          ADD      r0,r4,#0x1c           ;430
000096  42a8              CMP      r0,r5                 ;430
000098  d21c              BCS      |L9.212|
00009a  f8de3018          LDR      r3,[lr,#0x18]         ;434  ; used_mem
00009e  1b28              SUBS     r0,r5,r4              ;434
0000a0  1a18              SUBS     r0,r3,r0              ;434
0000a2  eb0c0304          ADD      r3,r12,r4             ;437
0000a6  3310              ADDS     r3,r3,#0x10           ;437
0000a8  f8ce0018          STR      r0,[lr,#0x18]         ;438  ; used_mem
0000ac  18d0              ADDS     r0,r2,r3              ;438
0000ae  f44f54f5          MOV      r4,#0x1ea0            ;439
0000b2  8004              STRH     r4,[r0,#0]            ;439
0000b4  8047              STRH     r7,[r0,#2]            ;440
0000b6  684c              LDR      r4,[r1,#4]            ;441
0000b8  e9c04c01          STRD     r4,r12,[r0,#4]        ;441
0000bc  604b              STR      r3,[r1,#4]            ;444
0000be  f8de4014          LDR      r4,[lr,#0x14]         ;444  ; mem_size_aligned
0000c2  6841              LDR      r1,[r0,#4]            ;444
0000c4  3410              ADDS     r4,r4,#0x10           ;444
0000c6  42a1              CMP      r1,r4                 ;444
0000c8  d001              BEQ      |L9.206|
0000ca  3208              ADDS     r2,r2,#8              ;444
0000cc  508b              STR      r3,[r1,r2]            ;446
                  |L9.206|
0000ce  f7fffffe          BL       plug_holes
0000d2  e7d4              B        |L9.126|
                  |L9.212|
0000d4  481d              LDR      r0,|L9.332|
0000d6  f7fffffe          BL       rt_sem_release
0000da  4620              MOV      r0,r4                 ;458
0000dc  f7fffffe          BL       rt_malloc
0000e0  0007              MOVS     r7,r0                 ;458
0000e2  d009              BEQ      |L9.248|
0000e4  42a5              CMP      r5,r4                 ;461
0000e6  d200              BCS      |L9.234|
0000e8  462c              MOV      r4,r5                 ;461
                  |L9.234|
0000ea  4622              MOV      r2,r4                 ;461
0000ec  4631              MOV      r1,r6                 ;461
0000ee  f7fffffe          BL       rt_memcpy
0000f2  4630              MOV      r0,r6                 ;462
0000f4  f7fffffe          BL       rt_free
                  |L9.248|
0000f8  4638              MOV      r0,r7                 ;465
0000fa  bdf8              POP      {r3-r7,pc}
;;;467    RTM_EXPORT(rt_realloc);
                          ENDP

                  |L9.252|
                          DCD      ||area_number.16||+0x31
                  |L9.256|
000100  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000104  74696f6e
000108  5b25735d
00010c  20736861
000110  6c6c206e
000114  6f742075
000118  73656420
00011c  696e2049
000120  53520a00
                  |L9.292|
000124  3000              DCB      "0",0
000126  00                DCB      0
000127  00                DCB      0
                  |L9.296|
000128  28257329          DCB      "(%s) assert failed at %s:%d \n",0
00012c  20617373
000130  65727420
000134  6661696c
000138  65642061
00013c  74202573
000140  3a256420
000144  0a00    
000146  00                DCB      0
000147  00                DCB      0
                  |L9.328|
                          DCD      ||.data||
                  |L9.332|
                          DCD      ||.bss||

                          AREA ||i.rt_system_heap_init||, CODE, READONLY, ALIGN=2

                  rt_system_heap_init PROC
;;;183     */
;;;184    void rt_system_heap_init(void *begin_addr, void *end_addr)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;185    {
000004  4607              MOV      r7,r0
;;;186        struct heap_mem *mem;
;;;187        rt_uint32_t begin_align = RT_ALIGN((rt_uint32_t)begin_addr, RT_ALIGN_SIZE);
000006  1dc0              ADDS     r0,r0,#7
000008  4688              MOV      r8,r1                 ;185
00000a  f0200407          BIC      r4,r0,#7
;;;188        rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);
00000e  f0210507          BIC      r5,r1,#7
;;;189    
;;;190        RT_DEBUG_NOT_IN_INTERRUPT;
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4681              MOV      r9,r0
000018  f7fffffe          BL       rt_interrupt_get_nest
00001c  2600              MOVS     r6,#0
00001e  b178              CBZ      r0,|L10.64|
000020  491e              LDR      r1,|L10.156|
000022  a01f              ADR      r0,|L10.160|
000024  f7fffffe          BL       rt_kprintf
000028  f88d6000          STRB     r6,[sp,#0]
00002c  23be              MOVS     r3,#0xbe
00002e  4a1b              LDR      r2,|L10.156|
000030  a124              ADR      r1,|L10.196|
000032  a025              ADR      r0,|L10.200|
000034  f7fffffe          BL       rt_kprintf
                  |L10.56|
000038  f89d0000          LDRB     r0,[sp,#0]
00003c  2800              CMP      r0,#0
00003e  d0fb              BEQ      |L10.56|
                  |L10.64|
000040  4648              MOV      r0,r9
000042  f7fffffe          BL       rt_hw_interrupt_enable
;;;191    
;;;192        /* alignment addr */
;;;193        if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
000046  2d20              CMP      r5,#0x20
000048  d920              BLS      |L10.140|
;;;194            ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
00004a  f1a50020          SUB      r0,r5,#0x20
00004e  42a0              CMP      r0,r4
000050  d31c              BCC      |L10.140|
;;;195        {
;;;196            /* calculate the aligned memory size */
;;;197            mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
000052  1b29              SUBS     r1,r5,r4
000054  4d24              LDR      r5,|L10.232|
000056  3920              SUBS     r1,r1,#0x20
;;;198        }
;;;199        else
;;;200        {
;;;201            rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
;;;202                       (rt_uint32_t)begin_addr, (rt_uint32_t)end_addr);
;;;203    
;;;204            return;
;;;205        }
;;;206    
;;;207        /* point to begin address of heap */
;;;208        heap_ptr = (rt_uint8_t *)begin_align;
;;;209    
;;;210        RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
;;;211                                    (rt_uint32_t)heap_ptr, mem_size_aligned));
;;;212    
;;;213        /* initialize the start of the heap */
;;;214        mem        = (struct heap_mem *)heap_ptr;
;;;215        mem->magic = HEAP_MAGIC;
000058  f44f52f5          MOV      r2,#0x1ea0
00005c  60ac              STR      r4,[r5,#8]  ; heap_ptr
00005e  6169              STR      r1,[r5,#0x14]  ; mem_size_aligned
000060  8022              STRH     r2,[r4,#0]
000062  3110              ADDS     r1,r1,#0x10
000064  e9c41601          STRD     r1,r6,[r4,#4]
;;;216        mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
;;;217        mem->prev  = 0;
;;;218        mem->used  = 0;
000068  8066              STRH     r6,[r4,#2]
;;;219    
;;;220        /* initialize the end of the heap */
;;;221        heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
00006a  6860              LDR      r0,[r4,#4]
;;;222        heap_end->magic = HEAP_MAGIC;
;;;223        heap_end->used  = 1;
;;;224        heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
;;;225        heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
;;;226    
;;;227        rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
00006c  2300              MOVS     r3,#0
00006e  4420              ADD      r0,r0,r4              ;221
000070  60e8              STR      r0,[r5,#0xc]          ;222  ; heap_end
000072  8002              STRH     r2,[r0,#0]            ;222
000074  2201              MOVS     r2,#1                 ;223
000076  8042              STRH     r2,[r0,#2]            ;223
000078  6041              STR      r1,[r0,#4]            ;225
00007a  6081              STR      r1,[r0,#8]
00007c  a11b              ADR      r1,|L10.236|
00007e  481d              LDR      r0,|L10.244|
000080  f7fffffe          BL       rt_sem_init
;;;228    
;;;229        /* initialize the lowest-free pointer to the start of the heap */
;;;230        lfree = (struct heap_mem *)heap_ptr;
000084  68a8              LDR      r0,[r5,#8]  ; heap_ptr
000086  6128              STR      r0,[r5,#0x10]  ; lfree
;;;231    }
000088  e8bd83f8          POP      {r3-r9,pc}
                  |L10.140|
00008c  4642              MOV      r2,r8                 ;201
00008e  4639              MOV      r1,r7                 ;201
000090  e8bd43f8          POP      {r3-r9,lr}            ;201
000094  a018              ADR      r0,|L10.248|
000096  f7ffbffe          B.W      rt_kprintf
;;;232    
                          ENDP

00009a  0000              DCW      0x0000
                  |L10.156|
                          DCD      ||area_number.16||+0x13
                  |L10.160|
0000a0  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0000a4  74696f6e
0000a8  5b25735d
0000ac  20736861
0000b0  6c6c206e
0000b4  6f742075
0000b8  73656420
0000bc  696e2049
0000c0  53520a00
                  |L10.196|
0000c4  3000              DCB      "0",0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L10.200|
0000c8  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000cc  20617373
0000d0  65727420
0000d4  6661696c
0000d8  65642061
0000dc  74202573
0000e0  3a256420
0000e4  0a00    
0000e6  00                DCB      0
0000e7  00                DCB      0
                  |L10.232|
                          DCD      ||.data||
                  |L10.236|
0000ec  68656170          DCB      "heap",0
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L10.244|
                          DCD      ||.bss||
                  |L10.248|
0000f8  6d656d20          DCB      "mem init, error begin address 0x%x, and end address 0x%"
0000fc  696e6974
000100  2c206572
000104  726f7220
000108  62656769
00010c  6e206164
000110  64726573
000114  73203078
000118  25782c20
00011c  616e6420
000120  656e6420
000124  61646472
000128  65737320
00012c  307825  
00012f  780a00            DCB      "x\n",0
000132  00                DCB      0
000133  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  heap_sem
                          %        32

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __fsym_list_mem_name
000000  6c697374          DCB      0x6c,0x69,0x73,0x74
000004  5f6d656d          DCB      0x5f,0x6d,0x65,0x6d
000008  00                DCB      0x00

                          AREA ||area_number.15||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.15||, ||.constdata||
                  __fsym_list_mem_desc
000000  6c697374          DCB      0x6c,0x69,0x73,0x74
000004  206d656d          DCB      0x20,0x6d,0x65,0x6d
000008  6f727920          DCB      0x6f,0x72,0x79,0x20
00000c  75736167          DCB      0x75,0x73,0x61,0x67
000010  6520696e          DCB      0x65,0x20,0x69,0x6e
000014  666f726d          DCB      0x66,0x6f,0x72,0x6d
000018  6174696f          DCB      0x61,0x74,0x69,0x6f
00001c  6e00              DCB      0x6e,0x00

                          AREA ||area_number.16||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.16||, ||.constdata||
                  __FUNCTION__
000000  72745f66          DCB      0x72,0x74,0x5f,0x66
000004  72656500          DCB      0x72,0x65,0x65,0x00
                  |symbol_number.42|
000008  706c7567          DCB      0x70,0x6c,0x75,0x67
00000c  5f686f6c          DCB      0x5f,0x68,0x6f,0x6c
000010  657300            DCB      0x65,0x73,0x00
                  |symbol_number.43|
000013  72                DCB      0x72
000014  745f7379          DCB      0x74,0x5f,0x73,0x79
000018  7374656d          DCB      0x73,0x74,0x65,0x6d
00001c  5f686561          DCB      0x5f,0x68,0x65,0x61
000020  705f696e          DCB      0x70,0x5f,0x69,0x6e
000024  697400            DCB      0x69,0x74,0x00
                  |symbol_number.44|
000027  72                DCB      0x72
000028  745f6d61          DCB      0x74,0x5f,0x6d,0x61
00002c  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000030  00                DCB      0x00
                  |symbol_number.45|
000031  72745f            DCB      0x72,0x74,0x5f
000034  7265616c          DCB      0x72,0x65,0x61,0x6c
000038  6c6f6300          DCB      0x6c,0x6f,0x63,0x00
                  |symbol_number.46|
00003c  72745f63          DCB      0x72,0x74,0x5f,0x63
000040  616c6c6f          DCB      0x61,0x6c,0x6c,0x6f
000044  6300              DCB      0x63,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2872745f          DCB      "(rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint"
000004  75696e74
000008  33325f74
00000c  296d656d
000010  202b2053
000014  495a454f
000018  465f5354
00001c  52554354
000020  5f4d454d
000024  202b2073
000028  697a6520
00002c  3c3d2028
000030  72745f75
000034  696e74  
000037  33325f74          DCB      "32_t)heap_end",0
00003b  29686561
00003f  705f656e
000043  6400    
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0
000048  2872745f          DCB      "(rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % "
00004c  75696e74
000050  33325f74
000054  29282872
000058  745f7569
00005c  6e74385f
000060  74202a29
000064  6d656d20
000068  2b205349
00006c  5a454f46
000070  5f535452
000074  5543545f
000078  4d454d29
00007c  202520  
00007f  52545f41          DCB      "RT_ALIGN_SIZE == 0",0
000083  4c49474e
000087  5f53495a
00008b  45203d3d
00008f  203000  
000092  00                DCB      0
000093  00                DCB      0
000094  2872745f          DCB      "(rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr && (rt_uin"
000098  75696e74
00009c  385f7420
0000a0  2a29726d
0000a4  656d203e
0000a8  3d202872
0000ac  745f7569
0000b0  6e74385f
0000b4  74202a29
0000b8  68656170
0000bc  5f707472
0000c0  20262620
0000c4  2872745f
0000c8  75696e  
0000cb  74385f74          DCB      "t8_t *)rmem < (rt_uint8_t *)heap_end",0
0000cf  202a2972
0000d3  6d656d20
0000d7  3c202872
0000db  745f7569
0000df  6e74385f
0000e3  74202a29
0000e7  68656170
0000eb  5f656e64
0000ef  00      

                          AREA ||.data||, DATA, ALIGN=2

                  rt_malloc_hook
                          DCD      0x00000000
                  rt_free_hook
                          DCD      0x00000000
                  heap_ptr
                          DCD      0x00000000
                  heap_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
                  mem_size_aligned
                          DCD      0x00000000
                  used_mem
                          DCD      0x00000000
                  max_mem
                          DCD      0x00000000

                          AREA FSymTab, DATA, READONLY, ALIGN=2

                  __fsym_list_mem
                          DCD      __fsym_list_mem_name
                          DCD      __fsym_list_mem_desc
                          DCD      list_mem
