; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_dac.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_dac.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_dac.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c]
                          THUMB

                          AREA ||i.DAC_ClearFlag||, CODE, READONLY, ALIGN=2

                  DAC_ClearFlag PROC
;;;611      */
;;;612    void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;613    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d006              BEQ      |L1.22|
;;;614      /* Check the parameters */
;;;615      assert_param(IS_DAC_CHANNEL(DAC_Channel));
000008  2c10              CMP      r4,#0x10
00000a  d004              BEQ      |L1.22|
00000c  f2402167          MOV      r1,#0x267
000010  4807              LDR      r0,|L1.48|
000012  f7fffffe          BL       assert_failed
                  |L1.22|
;;;616      assert_param(IS_DAC_FLAG(DAC_FLAG));
000016  f5b55f00          CMP      r5,#0x2000
00001a  d004              BEQ      |L1.38|
00001c  f44f711a          MOV      r1,#0x268
000020  4803              LDR      r0,|L1.48|
000022  f7fffffe          BL       assert_failed
                  |L1.38|
;;;617    
;;;618      /* Clear the selected DAC flags */
;;;619      DAC->SR = (DAC_FLAG << DAC_Channel);
000026  4803              LDR      r0,|L1.52|
000028  40a5              LSLS     r5,r5,r4
00002a  6005              STR      r5,[r0,#0]
;;;620    }
00002c  bd70              POP      {r4-r6,pc}
;;;621    
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      ||.conststring||
                  |L1.52|
                          DCD      0x40007434

                          AREA ||i.DAC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DAC_ClearITPendingBit PROC
;;;674      */
;;;675    void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;676    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d006              BEQ      |L2.22|
;;;677      /* Check the parameters */
;;;678      assert_param(IS_DAC_CHANNEL(DAC_Channel));
000008  2c10              CMP      r4,#0x10
00000a  d004              BEQ      |L2.22|
00000c  f24021a6          MOV      r1,#0x2a6
000010  4807              LDR      r0,|L2.48|
000012  f7fffffe          BL       assert_failed
                  |L2.22|
;;;679      assert_param(IS_DAC_IT(DAC_IT)); 
000016  f5b55f00          CMP      r5,#0x2000
00001a  d004              BEQ      |L2.38|
00001c  f24021a7          MOV      r1,#0x2a7
000020  4803              LDR      r0,|L2.48|
000022  f7fffffe          BL       assert_failed
                  |L2.38|
;;;680    
;;;681      /* Clear the selected DAC interrupt pending bits */
;;;682      DAC->SR = (DAC_IT << DAC_Channel);
000026  4803              LDR      r0,|L2.52|
000028  40a5              LSLS     r5,r5,r4
00002a  6005              STR      r5,[r0,#0]
;;;683    }
00002c  bd70              POP      {r4-r6,pc}
;;;684    
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      ||.conststring||
                  |L2.52|
                          DCD      0x40007434

                          AREA ||i.DAC_Cmd||, CODE, READONLY, ALIGN=2

                  DAC_Cmd PROC
;;;252      */
;;;253    void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;254    {
000004  460e              MOV      r6,r1
000006  0005              MOVS     r5,r0
000008  d006              BEQ      |L3.24|
;;;255      /* Check the parameters */
;;;256      assert_param(IS_DAC_CHANNEL(DAC_Channel));
00000a  2d10              CMP      r5,#0x10
00000c  d004              BEQ      |L3.24|
00000e  f44f7180          MOV      r1,#0x100
000012  480b              LDR      r0,|L3.64|
000014  f7fffffe          BL       assert_failed
                  |L3.24|
000018  2401              MOVS     r4,#1                 ;254
;;;257      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;258    
;;;259      if (NewState != DISABLE)
;;;260      {
;;;261        /* Enable the selected DAC channel */
;;;262        DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
00001a  4f0a              LDR      r7,|L3.68|
00001c  40ac              LSLS     r4,r4,r5
00001e  b14e              CBZ      r6,|L3.52|
000020  2e01              CMP      r6,#1                 ;257
000022  d004              BEQ      |L3.46|
000024  f2401101          MOV      r1,#0x101             ;257
000028  4805              LDR      r0,|L3.64|
00002a  f7fffffe          BL       assert_failed
                  |L3.46|
00002e  6838              LDR      r0,[r7,#0]
000030  4320              ORRS     r0,r0,r4
000032  e001              B        |L3.56|
                  |L3.52|
;;;263      }
;;;264      else
;;;265      {
;;;266        /* Disable the selected DAC channel */
;;;267        DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
000034  6838              LDR      r0,[r7,#0]
000036  43a0              BICS     r0,r0,r4
                  |L3.56|
000038  6038              STR      r0,[r7,#0]            ;262
;;;268      }
;;;269    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;270    
                          ENDP

00003e  0000              DCW      0x0000
                  |L3.64|
                          DCD      ||.conststring||
                  |L3.68|
                          DCD      0x40007400

                          AREA ||i.DAC_DMACmd||, CODE, READONLY, ALIGN=2

                  DAC_DMACmd PROC
;;;496      */
;;;497    void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;498    {
000004  460e              MOV      r6,r1
000006  0005              MOVS     r5,r0
000008  d006              BEQ      |L4.24|
;;;499      /* Check the parameters */
;;;500      assert_param(IS_DAC_CHANNEL(DAC_Channel));
00000a  2d10              CMP      r5,#0x10
00000c  d004              BEQ      |L4.24|
00000e  f44f71fa          MOV      r1,#0x1f4
000012  480b              LDR      r0,|L4.64|
000014  f7fffffe          BL       assert_failed
                  |L4.24|
;;;501      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;502    
;;;503      if (NewState != DISABLE)
;;;504      {
;;;505        /* Enable the selected DAC channel DMA request */
;;;506        DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
000018  4f0a              LDR      r7,|L4.68|
00001a  14bc              ASRS     r4,r7,#18
00001c  40ac              LSLS     r4,r4,r5
00001e  b14e              CBZ      r6,|L4.52|
000020  2e01              CMP      r6,#1                 ;501
000022  d004              BEQ      |L4.46|
000024  f24011f5          MOV      r1,#0x1f5             ;501
000028  4805              LDR      r0,|L4.64|
00002a  f7fffffe          BL       assert_failed
                  |L4.46|
00002e  6838              LDR      r0,[r7,#0]
000030  4320              ORRS     r0,r0,r4
000032  e001              B        |L4.56|
                  |L4.52|
;;;507      }
;;;508      else
;;;509      {
;;;510        /* Disable the selected DAC channel DMA request */
;;;511        DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
000034  6838              LDR      r0,[r7,#0]
000036  43a0              BICS     r0,r0,r4
                  |L4.56|
000038  6038              STR      r0,[r7,#0]            ;506
;;;512      }
;;;513    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;514    /**
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      ||.conststring||
                  |L4.68|
                          DCD      0x40007400

                          AREA ||i.DAC_DeInit||, CODE, READONLY, ALIGN=1

                  DAC_DeInit PROC
;;;173      */
;;;174    void DAC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;175    {
;;;176      /* Enable DAC reset state */
;;;177      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
000002  2101              MOVS     r1,#1
000004  074c              LSLS     r4,r1,#29
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;178      /* Release DAC from reset state */
;;;179      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;180    }
;;;181    
                          ENDP


                          AREA ||i.DAC_DualSoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_DualSoftwareTriggerCmd PROC
;;;304      */
;;;305    void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;306    {
;;;307      /* Check the parameters */
;;;308      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;309    
;;;310      if (NewState != DISABLE)
;;;311      {
;;;312        /* Enable software trigger for both DAC channels */
;;;313        DAC->SWTRIGR |= DUAL_SWTRIG_SET;
000002  4c09              LDR      r4,|L6.40|
000004  b150              CBZ      r0,|L6.28|
000006  2801              CMP      r0,#1                 ;308
000008  d004              BEQ      |L6.20|
00000a  f44f719a          MOV      r1,#0x134             ;308
00000e  4807              LDR      r0,|L6.44|
000010  f7fffffe          BL       assert_failed
                  |L6.20|
000014  6820              LDR      r0,[r4,#0]
000016  f0400003          ORR      r0,r0,#3
00001a  e002              B        |L6.34|
                  |L6.28|
;;;314      }
;;;315      else
;;;316      {
;;;317        /* Disable software trigger for both DAC channels */
;;;318        DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
00001c  6820              LDR      r0,[r4,#0]
00001e  f0200003          BIC      r0,r0,#3
                  |L6.34|
000022  6020              STR      r0,[r4,#0]            ;313
;;;319      }
;;;320    }
000024  bd10              POP      {r4,pc}
;;;321    
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      0x40007404
                  |L6.44|
                          DCD      ||.conststring||

                          AREA ||i.DAC_GetDataOutputValue||, CODE, READONLY, ALIGN=2

                  DAC_GetDataOutputValue PROC
;;;451      */
;;;452    uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
000000  b538              PUSH     {r3-r5,lr}
;;;453    {
000002  0004              MOVS     r4,r0
;;;454      __IO uint32_t tmp = 0;
000004  f04f0000          MOV      r0,#0
000008  9000              STR      r0,[sp,#0]            ;453
00000a  d006              BEQ      |L7.26|
;;;455      
;;;456      /* Check the parameters */
;;;457      assert_param(IS_DAC_CHANNEL(DAC_Channel));
00000c  2c10              CMP      r4,#0x10
00000e  d004              BEQ      |L7.26|
000010  f24011c9          MOV      r1,#0x1c9
000014  4805              LDR      r0,|L7.44|
000016  f7fffffe          BL       assert_failed
                  |L7.26|
;;;458      
;;;459      tmp = (uint32_t) DAC_BASE ;
00001a  4805              LDR      r0,|L7.48|
;;;460      tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
00001c  eb000094          ADD      r0,r0,r4,LSR #2
000020  302c              ADDS     r0,r0,#0x2c
;;;461      
;;;462      /* Returns the DAC channel data output register value */
;;;463      return (uint16_t) (*(__IO uint32_t*) tmp);
000022  9000              STR      r0,[sp,#0]
000024  6800              LDR      r0,[r0,#0]
000026  b280              UXTH     r0,r0
;;;464    }
000028  bd38              POP      {r3-r5,pc}
;;;465    /**
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      ||.conststring||
                  |L7.48|
                          DCD      0x40007400

                          AREA ||i.DAC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DAC_GetFlagStatus PROC
;;;576      */
;;;577    FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;578    {
000002  460e              MOV      r6,r1
000004  0004              MOVS     r4,r0
;;;579      FlagStatus bitstatus = RESET;
000006  f04f0500          MOV      r5,#0
00000a  d006              BEQ      |L8.26|
;;;580      /* Check the parameters */
;;;581      assert_param(IS_DAC_CHANNEL(DAC_Channel));
00000c  2c10              CMP      r4,#0x10
00000e  d004              BEQ      |L8.26|
000010  f2402145          MOV      r1,#0x245
000014  4809              LDR      r0,|L8.60|
000016  f7fffffe          BL       assert_failed
                  |L8.26|
;;;582      assert_param(IS_DAC_FLAG(DAC_FLAG));
00001a  f5b65f00          CMP      r6,#0x2000
00001e  d004              BEQ      |L8.42|
000020  f2402146          MOV      r1,#0x246
000024  4805              LDR      r0,|L8.60|
000026  f7fffffe          BL       assert_failed
                  |L8.42|
;;;583    
;;;584      /* Check the status of the specified DAC flag */
;;;585      if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
00002a  4805              LDR      r0,|L8.64|
00002c  6800              LDR      r0,[r0,#0]
00002e  40a6              LSLS     r6,r6,r4
000030  4230              TST      r0,r6
000032  d000              BEQ      |L8.54|
;;;586      {
;;;587        /* DAC_FLAG is set */
;;;588        bitstatus = SET;
000034  2501              MOVS     r5,#1
                  |L8.54|
;;;589      }
;;;590      else
;;;591      {
;;;592        /* DAC_FLAG is reset */
;;;593        bitstatus = RESET;
;;;594      }
;;;595      /* Return the DAC_FLAG status */
;;;596      return  bitstatus;
000036  4628              MOV      r0,r5
;;;597    }
000038  bd70              POP      {r4-r6,pc}
;;;598    
                          ENDP

00003a  0000              DCW      0x0000
                  |L8.60|
                          DCD      ||.conststring||
                  |L8.64|
                          DCD      0x40007434

                          AREA ||i.DAC_GetITStatus||, CODE, READONLY, ALIGN=2

                  DAC_GetITStatus PROC
;;;634      */
;;;635    ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;636    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
;;;637      ITStatus bitstatus = RESET;
000006  f04f0600          MOV      r6,#0
00000a  d006              BEQ      |L9.26|
;;;638      uint32_t enablestatus = 0;
;;;639      
;;;640      /* Check the parameters */
;;;641      assert_param(IS_DAC_CHANNEL(DAC_Channel));
00000c  2c10              CMP      r4,#0x10
00000e  d004              BEQ      |L9.26|
000010  f2402181          MOV      r1,#0x281
000014  480b              LDR      r0,|L9.68|
000016  f7fffffe          BL       assert_failed
                  |L9.26|
;;;642      assert_param(IS_DAC_IT(DAC_IT));
00001a  f5b55f00          CMP      r5,#0x2000
00001e  d004              BEQ      |L9.42|
000020  f2402182          MOV      r1,#0x282
000024  4807              LDR      r0,|L9.68|
000026  f7fffffe          BL       assert_failed
                  |L9.42|
;;;643    
;;;644      /* Get the DAC_IT enable bit status */
;;;645      enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
00002a  4807              LDR      r0,|L9.72|
00002c  6800              LDR      r0,[r0,#0]
00002e  40a5              LSLS     r5,r5,r4
;;;646      
;;;647      /* Check the status of the specified DAC interrupt */
;;;648      if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
000030  4905              LDR      r1,|L9.72|
000032  4028              ANDS     r0,r0,r5              ;645
000034  3134              ADDS     r1,r1,#0x34
000036  6809              LDR      r1,[r1,#0]
000038  4229              TST      r1,r5
00003a  d001              BEQ      |L9.64|
00003c  b100              CBZ      r0,|L9.64|
;;;649      {
;;;650        /* DAC_IT is set */
;;;651        bitstatus = SET;
00003e  2601              MOVS     r6,#1
                  |L9.64|
;;;652      }
;;;653      else
;;;654      {
;;;655        /* DAC_IT is reset */
;;;656        bitstatus = RESET;
;;;657      }
;;;658      /* Return the DAC_IT status */
;;;659      return  bitstatus;
000040  4630              MOV      r0,r6
;;;660    }
000042  bd70              POP      {r4-r6,pc}
;;;661    
                          ENDP

                  |L9.68|
                          DCD      ||.conststring||
                  |L9.72|
                          DCD      0x40007400

                          AREA ||i.DAC_ITConfig||, CODE, READONLY, ALIGN=2

                  DAC_ITConfig PROC
;;;544      */ 
;;;545    void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
000000  b570              PUSH     {r4-r6,lr}
;;;546    {
000002  4615              MOV      r5,r2
000004  460c              MOV      r4,r1
000006  0006              MOVS     r6,r0
000008  d006              BEQ      |L10.24|
;;;547      /* Check the parameters */
;;;548      assert_param(IS_DAC_CHANNEL(DAC_Channel));
00000a  2e10              CMP      r6,#0x10
00000c  d004              BEQ      |L10.24|
00000e  f44f7109          MOV      r1,#0x224
000012  480e              LDR      r0,|L10.76|
000014  f7fffffe          BL       assert_failed
                  |L10.24|
;;;549      assert_param(IS_FUNCTIONAL_STATE(NewState));
000018  b135              CBZ      r5,|L10.40|
00001a  2d01              CMP      r5,#1
00001c  d004              BEQ      |L10.40|
00001e  f2402125          MOV      r1,#0x225
000022  480a              LDR      r0,|L10.76|
000024  f7fffffe          BL       assert_failed
                  |L10.40|
;;;550      assert_param(IS_DAC_IT(DAC_IT)); 
000028  f5b45f00          CMP      r4,#0x2000
00002c  d004              BEQ      |L10.56|
00002e  f2402126          MOV      r1,#0x226
000032  4806              LDR      r0,|L10.76|
000034  f7fffffe          BL       assert_failed
                  |L10.56|
;;;551    
;;;552      if (NewState != DISABLE)
;;;553      {
;;;554        /* Enable the selected DAC interrupts */
;;;555        DAC->CR |=  (DAC_IT << DAC_Channel);
000038  4905              LDR      r1,|L10.80|
00003a  40b4              LSLS     r4,r4,r6
;;;556      }
;;;557      else
;;;558      {
;;;559        /* Disable the selected DAC interrupts */
;;;560        DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
00003c  6808              LDR      r0,[r1,#0]
00003e  b10d              CBZ      r5,|L10.68|
000040  4320              ORRS     r0,r0,r4              ;555
000042  e000              B        |L10.70|
                  |L10.68|
000044  43a0              BICS     r0,r0,r4
                  |L10.70|
000046  6008              STR      r0,[r1,#0]            ;555
;;;561      }
;;;562    }
000048  bd70              POP      {r4-r6,pc}
;;;563    
                          ENDP

00004a  0000              DCW      0x0000
                  |L10.76|
                          DCD      ||.conststring||
                  |L10.80|
                          DCD      0x40007400

                          AREA ||i.DAC_Init||, CODE, READONLY, ALIGN=2

                  DAC_Init PROC
;;;192      */
;;;193    void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  680a              LDR      r2,[r1,#0]
000004  460c              MOV      r4,r1
000006  4605              MOV      r5,r0
000008  b19a              CBZ      r2,|L11.50|
;;;195      uint32_t tmpreg1 = 0, tmpreg2 = 0;
;;;196    
;;;197      /* Check the DAC parameters */
;;;198      assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
00000a  2a04              CMP      r2,#4
00000c  d011              BEQ      |L11.50|
00000e  2a0c              CMP      r2,#0xc
000010  d00f              BEQ      |L11.50|
000012  2a14              CMP      r2,#0x14
000014  d00d              BEQ      |L11.50|
000016  2a1c              CMP      r2,#0x1c
000018  d00b              BEQ      |L11.50|
00001a  2a24              CMP      r2,#0x24
00001c  d009              BEQ      |L11.50|
00001e  2a2c              CMP      r2,#0x2c
000020  d007              BEQ      |L11.50|
000022  2a34              CMP      r2,#0x34
000024  d005              BEQ      |L11.50|
000026  2a3c              CMP      r2,#0x3c
000028  d003              BEQ      |L11.50|
00002a  21c6              MOVS     r1,#0xc6
00002c  4826              LDR      r0,|L11.200|
00002e  f7fffffe          BL       assert_failed
                  |L11.50|
;;;199      assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
000032  6860              LDR      r0,[r4,#4]
000034  b138              CBZ      r0,|L11.70|
000036  2840              CMP      r0,#0x40
000038  d005              BEQ      |L11.70|
00003a  2880              CMP      r0,#0x80
00003c  d003              BEQ      |L11.70|
00003e  21c7              MOVS     r1,#0xc7
000040  4821              LDR      r0,|L11.200|
000042  f7fffffe          BL       assert_failed
                  |L11.70|
;;;200      assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
000046  68a2              LDR      r2,[r4,#8]
000048  b322              CBZ      r2,|L11.148|
00004a  f5b27f80          CMP      r2,#0x100
00004e  d021              BEQ      |L11.148|
000050  f5b27f00          CMP      r2,#0x200
000054  d01e              BEQ      |L11.148|
000056  f5b27f40          CMP      r2,#0x300
00005a  d01b              BEQ      |L11.148|
00005c  f5b26f80          CMP      r2,#0x400
000060  d018              BEQ      |L11.148|
000062  f5b26fa0          CMP      r2,#0x500
000066  d015              BEQ      |L11.148|
000068  f5b26fc0          CMP      r2,#0x600
00006c  d012              BEQ      |L11.148|
00006e  f5b26fe0          CMP      r2,#0x700
000072  d00f              BEQ      |L11.148|
000074  f5b26f00          CMP      r2,#0x800
000078  d00c              BEQ      |L11.148|
00007a  f5b26f10          CMP      r2,#0x900
00007e  d009              BEQ      |L11.148|
000080  f5b26f20          CMP      r2,#0xa00
000084  d006              BEQ      |L11.148|
000086  f5b26f30          CMP      r2,#0xb00
00008a  d003              BEQ      |L11.148|
00008c  21c8              MOVS     r1,#0xc8
00008e  480e              LDR      r0,|L11.200|
000090  f7fffffe          BL       assert_failed
                  |L11.148|
;;;201      assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
000094  68e0              LDR      r0,[r4,#0xc]
000096  b128              CBZ      r0,|L11.164|
000098  2802              CMP      r0,#2
00009a  d003              BEQ      |L11.164|
00009c  21c9              MOVS     r1,#0xc9
00009e  480a              LDR      r0,|L11.200|
0000a0  f7fffffe          BL       assert_failed
                  |L11.164|
;;;202    
;;;203    /*---------------------------- DAC CR Configuration --------------------------*/
;;;204      /* Get the DAC CR value */
;;;205      tmpreg1 = DAC->CR;
0000a4  4a09              LDR      r2,|L11.204|
0000a6  6811              LDR      r1,[r2,#0]
;;;206      /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
;;;207      tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
0000a8  f64070fe          MOV      r0,#0xffe
0000ac  40a8              LSLS     r0,r0,r5
0000ae  4381              BICS     r1,r1,r0
0000b0  e9d40300          LDRD     r0,r3,[r4,#0]
;;;208      /* Configure for the selected DAC channel: buffer output, trigger, 
;;;209         wave generation, mask/amplitude for wave generation */
;;;210      /* Set TSELx and TENx bits according to DAC_Trigger value */
;;;211      /* Set WAVEx bits according to DAC_WaveGeneration value */
;;;212      /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
;;;213      /* Set BOFFx bit according to DAC_OutputBuffer value */   
;;;214      tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
0000b4  4318              ORRS     r0,r0,r3
0000b6  e9d43402          LDRD     r3,r4,[r4,#8]
0000ba  4323              ORRS     r3,r3,r4
0000bc  4318              ORRS     r0,r0,r3
;;;215                 DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
;;;216                 DAC_InitStruct->DAC_OutputBuffer);
;;;217      /* Calculate CR register value depending on DAC_Channel */
;;;218      tmpreg1 |= tmpreg2 << DAC_Channel;
0000be  40a8              LSLS     r0,r0,r5
0000c0  4308              ORRS     r0,r0,r1
;;;219      /* Write to DAC CR */
;;;220      DAC->CR = tmpreg1;
0000c2  6010              STR      r0,[r2,#0]
;;;221    }
0000c4  bd70              POP      {r4-r6,pc}
;;;222    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L11.200|
                          DCD      ||.conststring||
                  |L11.204|
                          DCD      0x40007400

                          AREA ||i.DAC_SetChannel1Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel1Data PROC
;;;364      */
;;;365    void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
000000  b538              PUSH     {r3-r5,lr}
;;;366    {  
000002  0004              MOVS     r4,r0
;;;367      __IO uint32_t tmp = 0;
000004  f04f0000          MOV      r0,#0
000008  460d              MOV      r5,r1                 ;366
00000a  9000              STR      r0,[sp,#0]            ;366
00000c  d008              BEQ      |L12.32|
;;;368      
;;;369      /* Check the parameters */
;;;370      assert_param(IS_DAC_ALIGN(DAC_Align));
00000e  2c04              CMP      r4,#4
000010  d006              BEQ      |L12.32|
000012  2c08              CMP      r4,#8
000014  d004              BEQ      |L12.32|
000016  f44f71b9          MOV      r1,#0x172
00001a  4809              LDR      r0,|L12.64|
00001c  f7fffffe          BL       assert_failed
                  |L12.32|
;;;371      assert_param(IS_DAC_DATA(Data));
000020  f64f70f0          MOV      r0,#0xfff0
000024  4285              CMP      r5,r0
000026  d904              BLS      |L12.50|
000028  f2401173          MOV      r1,#0x173
00002c  4804              LDR      r0,|L12.64|
00002e  f7fffffe          BL       assert_failed
                  |L12.50|
;;;372      
;;;373      tmp = (uint32_t)DAC_BASE; 
000032  4804              LDR      r0,|L12.68|
;;;374      tmp += DHR12R1_OFFSET + DAC_Align;
000034  4420              ADD      r0,r0,r4
000036  3008              ADDS     r0,r0,#8
;;;375    
;;;376      /* Set the DAC channel1 selected data holding register */
;;;377      *(__IO uint32_t *) tmp = Data;
000038  9000              STR      r0,[sp,#0]
00003a  6005              STR      r5,[r0,#0]
;;;378    }
00003c  bd38              POP      {r3-r5,pc}
;;;379    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      ||.conststring||
                  |L12.68|
                          DCD      0x40007400

                          AREA ||i.DAC_SetChannel2Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel2Data PROC
;;;389      */
;;;390    void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
000000  b538              PUSH     {r3-r5,lr}
;;;391    {
000002  0004              MOVS     r4,r0
;;;392      __IO uint32_t tmp = 0;
000004  f04f0000          MOV      r0,#0
000008  460d              MOV      r5,r1                 ;391
00000a  9000              STR      r0,[sp,#0]            ;391
00000c  d008              BEQ      |L13.32|
;;;393    
;;;394      /* Check the parameters */
;;;395      assert_param(IS_DAC_ALIGN(DAC_Align));
00000e  2c04              CMP      r4,#4
000010  d006              BEQ      |L13.32|
000012  2c08              CMP      r4,#8
000014  d004              BEQ      |L13.32|
000016  f240118b          MOV      r1,#0x18b
00001a  4809              LDR      r0,|L13.64|
00001c  f7fffffe          BL       assert_failed
                  |L13.32|
;;;396      assert_param(IS_DAC_DATA(Data));
000020  f64f70f0          MOV      r0,#0xfff0
000024  4285              CMP      r5,r0
000026  d904              BLS      |L13.50|
000028  f44f71c6          MOV      r1,#0x18c
00002c  4804              LDR      r0,|L13.64|
00002e  f7fffffe          BL       assert_failed
                  |L13.50|
;;;397      
;;;398      tmp = (uint32_t)DAC_BASE;
000032  4804              LDR      r0,|L13.68|
;;;399      tmp += DHR12R2_OFFSET + DAC_Align;
000034  4420              ADD      r0,r0,r4
000036  3014              ADDS     r0,r0,#0x14
;;;400    
;;;401      /* Set the DAC channel2 selected data holding register */
;;;402      *(__IO uint32_t *)tmp = Data;
000038  9000              STR      r0,[sp,#0]
00003a  6005              STR      r5,[r0,#0]
;;;403    }
00003c  bd38              POP      {r3-r5,pc}
;;;404    
                          ENDP

00003e  0000              DCW      0x0000
                  |L13.64|
                          DCD      ||.conststring||
                  |L13.68|
                          DCD      0x40007400

                          AREA ||i.DAC_SetDualChannelData||, CODE, READONLY, ALIGN=2

                  DAC_SetDualChannelData PROC
;;;417      */
;;;418    void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;419    {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  0004              MOVS     r4,r0
00000a  d008              BEQ      |L14.30|
;;;420      uint32_t data = 0, tmp = 0;
;;;421      
;;;422      /* Check the parameters */
;;;423      assert_param(IS_DAC_ALIGN(DAC_Align));
00000c  2c04              CMP      r4,#4
00000e  d006              BEQ      |L14.30|
000010  2c08              CMP      r4,#8
000012  d004              BEQ      |L14.30|
000014  f24011a7          MOV      r1,#0x1a7
000018  480f              LDR      r0,|L14.88|
00001a  f7fffffe          BL       assert_failed
                  |L14.30|
;;;424      assert_param(IS_DAC_DATA(Data1));
00001e  f64f77f0          MOV      r7,#0xfff0
000022  42bd              CMP      r5,r7
000024  d904              BLS      |L14.48|
000026  f44f71d4          MOV      r1,#0x1a8
00002a  480b              LDR      r0,|L14.88|
00002c  f7fffffe          BL       assert_failed
                  |L14.48|
;;;425      assert_param(IS_DAC_DATA(Data2));
000030  42be              CMP      r6,r7
000032  d904              BLS      |L14.62|
000034  f24011a9          MOV      r1,#0x1a9
000038  4807              LDR      r0,|L14.88|
00003a  f7fffffe          BL       assert_failed
                  |L14.62|
;;;426      
;;;427      /* Calculate and set dual DAC data holding register value */
;;;428      if (DAC_Align == DAC_Align_8b_R)
00003e  2c08              CMP      r4,#8
000040  d006              BEQ      |L14.80|
;;;429      {
;;;430        data = ((uint32_t)Data2 << 8) | Data1; 
;;;431      }
;;;432      else
;;;433      {
;;;434        data = ((uint32_t)Data2 << 16) | Data1;
000042  ea454006          ORR      r0,r5,r6,LSL #16
                  |L14.70|
;;;435      }
;;;436      
;;;437      tmp = (uint32_t)DAC_BASE;
000046  4905              LDR      r1,|L14.92|
;;;438      tmp += DHR12RD_OFFSET + DAC_Align;
000048  4421              ADD      r1,r1,r4
;;;439    
;;;440      /* Set the dual DAC selected data holding register */
;;;441      *(__IO uint32_t *)tmp = data;
00004a  6208              STR      r0,[r1,#0x20]
;;;442    }
00004c  e8bd81f0          POP      {r4-r8,pc}
                  |L14.80|
000050  ea452006          ORR      r0,r5,r6,LSL #8       ;430
000054  e7f7              B        |L14.70|
;;;443    
                          ENDP

000056  0000              DCW      0x0000
                  |L14.88|
                          DCD      ||.conststring||
                  |L14.92|
                          DCD      0x40007400

                          AREA ||i.DAC_SoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_SoftwareTriggerCmd PROC
;;;280      */
;;;281    void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;282    {
000004  460e              MOV      r6,r1
000006  0005              MOVS     r5,r0
000008  d006              BEQ      |L15.24|
;;;283      /* Check the parameters */
;;;284      assert_param(IS_DAC_CHANNEL(DAC_Channel));
00000a  2d10              CMP      r5,#0x10
00000c  d004              BEQ      |L15.24|
00000e  f44f718e          MOV      r1,#0x11c
000012  480b              LDR      r0,|L15.64|
000014  f7fffffe          BL       assert_failed
                  |L15.24|
000018  2401              MOVS     r4,#1                 ;282
;;;285      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;286    
;;;287      if (NewState != DISABLE)
;;;288      {
;;;289        /* Enable software trigger for the selected DAC channel */
;;;290        DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
00001a  4f0a              LDR      r7,|L15.68|
00001c  0928              LSRS     r0,r5,#4
00001e  4084              LSLS     r4,r4,r0
000020  b14e              CBZ      r6,|L15.54|
000022  2e01              CMP      r6,#1                 ;285
000024  d004              BEQ      |L15.48|
000026  f240111d          MOV      r1,#0x11d             ;285
00002a  4805              LDR      r0,|L15.64|
00002c  f7fffffe          BL       assert_failed
                  |L15.48|
000030  6838              LDR      r0,[r7,#0]
000032  4320              ORRS     r0,r0,r4
000034  e001              B        |L15.58|
                  |L15.54|
;;;291      }
;;;292      else
;;;293      {
;;;294        /* Disable software trigger for the selected DAC channel */
;;;295        DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
000036  6838              LDR      r0,[r7,#0]
000038  43a0              BICS     r0,r0,r4
                  |L15.58|
00003a  6038              STR      r0,[r7,#0]            ;290
;;;296      }
;;;297    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;298    
                          ENDP

                  |L15.64|
                          DCD      ||.conststring||
                  |L15.68|
                          DCD      0x40007404

                          AREA ||i.DAC_StructInit||, CODE, READONLY, ALIGN=1

                  DAC_StructInit PROC
;;;228      */
;;;229    void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
000000  2100              MOVS     r1,#0
;;;230    {
;;;231    /*--------------- Reset DAC init structure parameters values -----------------*/
;;;232      /* Initialize the DAC_Trigger member */
;;;233      DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
;;;234      /* Initialize the DAC_WaveGeneration member */
;;;235      DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
000002  6001              STR      r1,[r0,#0]
;;;236      /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
;;;237      DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
000004  6041              STR      r1,[r0,#4]
;;;238      /* Initialize the DAC_OutputBuffer member */
;;;239      DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;240    }
00000a  4770              BX       lr
;;;241    
                          ENDP


                          AREA ||i.DAC_WaveGenerationCmd||, CODE, READONLY, ALIGN=2

                  DAC_WaveGenerationCmd PROC
;;;335      */
;;;336    void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;337    {
000004  4616              MOV      r6,r2
000006  460c              MOV      r4,r1
000008  0005              MOVS     r5,r0
00000a  d006              BEQ      |L17.26|
;;;338      /* Check the parameters */
;;;339      assert_param(IS_DAC_CHANNEL(DAC_Channel));
00000c  2d10              CMP      r5,#0x10
00000e  d004              BEQ      |L17.26|
000010  f2401153          MOV      r1,#0x153
000014  480e              LDR      r0,|L17.80|
000016  f7fffffe          BL       assert_failed
                  |L17.26|
;;;340      assert_param(IS_DAC_WAVE(DAC_Wave)); 
00001a  2c40              CMP      r4,#0x40
00001c  d006              BEQ      |L17.44|
00001e  2c80              CMP      r4,#0x80
000020  d004              BEQ      |L17.44|
000022  f44f71aa          MOV      r1,#0x154
000026  480a              LDR      r0,|L17.80|
000028  f7fffffe          BL       assert_failed
                  |L17.44|
;;;341      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;342    
;;;343      if (NewState != DISABLE)
;;;344      {
;;;345        /* Enable the selected wave generation for the selected DAC channel */
;;;346        DAC->CR |= DAC_Wave << DAC_Channel;
00002c  4f09              LDR      r7,|L17.84|
00002e  40ac              LSLS     r4,r4,r5
000030  b14e              CBZ      r6,|L17.70|
000032  2e01              CMP      r6,#1                 ;341
000034  d004              BEQ      |L17.64|
000036  f2401155          MOV      r1,#0x155             ;341
00003a  4805              LDR      r0,|L17.80|
00003c  f7fffffe          BL       assert_failed
                  |L17.64|
000040  6838              LDR      r0,[r7,#0]
000042  4320              ORRS     r0,r0,r4
000044  e001              B        |L17.74|
                  |L17.70|
;;;347      }
;;;348      else
;;;349      {
;;;350        /* Disable the selected wave generation for the selected DAC channel */
;;;351        DAC->CR &= ~(DAC_Wave << DAC_Channel);
000046  6838              LDR      r0,[r7,#0]
000048  43a0              BICS     r0,r0,r4
                  |L17.74|
00004a  6038              STR      r0,[r7,#0]            ;346
;;;352      }
;;;353    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;354    
                          ENDP

                  |L17.80|
                          DCD      ||.conststring||
                  |L17.84|
                          DCD      0x40007400

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_dac.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f646163
00004a  2e6300  

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_dac.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_dac_c_4da4a0a9____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_dac_c_4da4a0a9____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_dac_c_4da4a0a9____REVSH|
#line 128
|__asm___15_stm32f4xx_dac_c_4da4a0a9____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
