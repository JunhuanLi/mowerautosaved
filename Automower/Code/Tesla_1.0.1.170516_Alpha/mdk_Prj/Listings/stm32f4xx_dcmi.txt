; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_dcmi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_dcmi.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\stm32f4xx_dcmi.crf ..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dcmi.c]
                          THUMB

                          AREA ||i.DCMI_CROPCmd||, CODE, READONLY, ALIGN=2

                  DCMI_CROPCmd PROC
;;;218      */
;;;219    void DCMI_CROPCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;220    {
;;;221      /* Check the parameters */
;;;222      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;223        
;;;224      if (NewState != DISABLE)
;;;225      {
;;;226        /* Enable the DCMI Crop feature */
;;;227        DCMI->CR |= (uint32_t)DCMI_CR_CROP;
000002  4c08              LDR      r4,|L1.36|
000004  b148              CBZ      r0,|L1.26|
000006  2801              CMP      r0,#1                 ;222
000008  d003              BEQ      |L1.18|
00000a  21de              MOVS     r1,#0xde              ;222
00000c  4806              LDR      r0,|L1.40|
00000e  f7fffffe          BL       assert_failed
                  |L1.18|
000012  6820              LDR      r0,[r4,#0]
000014  f0400004          ORR      r0,r0,#4
000018  e002              B        |L1.32|
                  |L1.26|
;;;228      }
;;;229      else
;;;230      {
;;;231        /* Disable the DCMI Crop feature */
;;;232        DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
00001a  6820              LDR      r0,[r4,#0]
00001c  f0200004          BIC      r0,r0,#4
                  |L1.32|
000020  6020              STR      r0,[r4,#0]            ;227
;;;233      }
;;;234    }
000022  bd10              POP      {r4,pc}
;;;235    
                          ENDP

                  |L1.36|
                          DCD      0x50050000
                  |L1.40|
                          DCD      ||.conststring||

                          AREA ||i.DCMI_CROPConfig||, CODE, READONLY, ALIGN=2

                  DCMI_CROPConfig PROC
;;;200      */
;;;201    void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
000000  6801              LDR      r1,[r0,#0]
;;;202    {  
;;;203      /* Sets the CROP window coordinates */
;;;204      DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
000002  ea4f4231          ROR      r2,r1,#16
000006  4903              LDR      r1,|L2.20|
000008  620a              STR      r2,[r1,#0x20]
;;;205                      ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));
;;;206    
;;;207      /* Sets the CROP window size */
;;;208      DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
00000a  6840              LDR      r0,[r0,#4]
00000c  ea4f4030          ROR      r0,r0,#16
000010  6248              STR      r0,[r1,#0x24]
;;;209                      ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalLineCount << 16));
;;;210    }
000012  4770              BX       lr
;;;211    
                          ENDP

                  |L2.20|
                          DCD      0x50050000

                          AREA ||i.DCMI_CaptureCmd||, CODE, READONLY, ALIGN=2

                  DCMI_CaptureCmd PROC
;;;317      */
;;;318    void DCMI_CaptureCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;319    {
;;;320      /* Check the parameters */
;;;321      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;322        
;;;323      if (NewState != DISABLE)
;;;324      {
;;;325        /* Enable the DCMI Capture */
;;;326        DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
000002  4c09              LDR      r4,|L3.40|
000004  b150              CBZ      r0,|L3.28|
000006  2801              CMP      r0,#1                 ;321
000008  d004              BEQ      |L3.20|
00000a  f2401141          MOV      r1,#0x141             ;321
00000e  4807              LDR      r0,|L3.44|
000010  f7fffffe          BL       assert_failed
                  |L3.20|
000014  6820              LDR      r0,[r4,#0]
000016  f0400001          ORR      r0,r0,#1
00001a  e002              B        |L3.34|
                  |L3.28|
;;;327      }
;;;328      else
;;;329      {
;;;330        /* Disable the DCMI Capture */
;;;331        DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
00001c  6820              LDR      r0,[r4,#0]
00001e  f0200001          BIC      r0,r0,#1
                  |L3.34|
000022  6020              STR      r0,[r4,#0]            ;326
;;;332      }
;;;333    }
000024  bd10              POP      {r4,pc}
;;;334    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x50050000
                  |L3.44|
                          DCD      ||.conststring||

                          AREA ||i.DCMI_ClearFlag||, CODE, READONLY, ALIGN=2

                  DCMI_ClearFlag PROC
;;;456      */
;;;457    void DCMI_ClearFlag(uint16_t DCMI_FLAG)
000000  b510              PUSH     {r4,lr}
;;;458    {
000002  4604              MOV      r4,r0
;;;459      /* Check the parameters */
;;;460      assert_param(IS_DCMI_CLEAR_FLAG(DCMI_FLAG));
000004  0940              LSRS     r0,r0,#5
000006  d100              BNE      |L4.10|
000008  b924              CBNZ     r4,|L4.20|
                  |L4.10|
00000a  f44f71e6          MOV      r1,#0x1cc
00000e  4803              LDR      r0,|L4.28|
000010  f7fffffe          BL       assert_failed
                  |L4.20|
;;;461      
;;;462      /* Clear the flag by writing in the ICR register 1 in the corresponding 
;;;463      Flag position*/
;;;464      
;;;465      DCMI->ICR = DCMI_FLAG;
000014  4802              LDR      r0,|L4.32|
000016  6144              STR      r4,[r0,#0x14]
;;;466    }
000018  bd10              POP      {r4,pc}
;;;467    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      ||.conststring||
                  |L4.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DCMI_ClearITPendingBit PROC
;;;510      */
;;;511    void DCMI_ClearITPendingBit(uint16_t DCMI_IT)
000000  4901              LDR      r1,|L5.8|
;;;512    {
;;;513      /* Clear the interrupt pending Bit by writing in the ICR register 1 in the 
;;;514      corresponding pending Bit position*/
;;;515      
;;;516      DCMI->ICR = DCMI_IT;
000002  6148              STR      r0,[r1,#0x14]
;;;517    }
000004  4770              BX       lr
;;;518    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_Cmd||, CODE, READONLY, ALIGN=2

                  DCMI_Cmd PROC
;;;294      */
;;;295    void DCMI_Cmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;296    {
;;;297      /* Check the parameters */
;;;298      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;299      
;;;300      if (NewState != DISABLE)
;;;301      {
;;;302        /* Enable the DCMI by setting ENABLE bit */
;;;303        DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
000002  4c09              LDR      r4,|L6.40|
000004  b150              CBZ      r0,|L6.28|
000006  2801              CMP      r0,#1                 ;298
000008  d004              BEQ      |L6.20|
00000a  f44f7195          MOV      r1,#0x12a             ;298
00000e  4807              LDR      r0,|L6.44|
000010  f7fffffe          BL       assert_failed
                  |L6.20|
000014  6820              LDR      r0,[r4,#0]
000016  f4404080          ORR      r0,r0,#0x4000
00001a  e002              B        |L6.34|
                  |L6.28|
;;;304      }
;;;305      else
;;;306      {
;;;307        /* Disable the DCMI by clearing ENABLE bit */
;;;308        DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
00001c  6820              LDR      r0,[r4,#0]
00001e  f4204080          BIC      r0,r0,#0x4000
                  |L6.34|
000022  6020              STR      r0,[r4,#0]            ;303
;;;309      }
;;;310    }
000024  bd10              POP      {r4,pc}
;;;311    
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      0x50050000
                  |L6.44|
                          DCD      ||.conststring||

                          AREA ||i.DCMI_DeInit||, CODE, READONLY, ALIGN=2

                  DCMI_DeInit PROC
;;;121      */
;;;122    void DCMI_DeInit(void)
000000  4805              LDR      r0,|L7.24|
;;;123    {
;;;124      DCMI->CR = 0x0;
000002  2100              MOVS     r1,#0
000004  6001              STR      r1,[r0,#0]
;;;125      DCMI->IER = 0x0;
000006  60c1              STR      r1,[r0,#0xc]
;;;126      DCMI->ICR = 0x1F;
000008  221f              MOVS     r2,#0x1f
00000a  6142              STR      r2,[r0,#0x14]
;;;127      DCMI->ESCR = 0x0;
00000c  6181              STR      r1,[r0,#0x18]
;;;128      DCMI->ESUR = 0x0;
00000e  61c1              STR      r1,[r0,#0x1c]
;;;129      DCMI->CWSTRTR = 0x0;
000010  6201              STR      r1,[r0,#0x20]
;;;130      DCMI->CWSIZER = 0x0;
000012  6241              STR      r1,[r0,#0x24]
;;;131    }
000014  4770              BX       lr
;;;132    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DCMI_GetFlagStatus PROC
;;;409      */
;;;410    FlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;411    {
000002  4604              MOV      r4,r0
;;;412      FlagStatus bitstatus = RESET;
000004  2500              MOVS     r5,#0
;;;413      uint32_t dcmireg, tempreg = 0;
;;;414    
;;;415      /* Check the parameters */
;;;416      assert_param(IS_DCMI_GET_FLAG(DCMI_FLAG));
000006  f2420001          MOV      r0,#0x2001
00000a  4284              CMP      r4,r0
00000c  d022              BEQ      |L8.84|
00000e  f5a45000          SUB      r0,r4,#0x2000
000012  3802              SUBS     r0,#2
000014  d01e              BEQ      |L8.84|
000016  1e80              SUBS     r0,r0,#2
000018  d01c              BEQ      |L8.84|
00001a  2c01              CMP      r4,#1
00001c  d01a              BEQ      |L8.84|
00001e  2c02              CMP      r4,#2
000020  d018              BEQ      |L8.84|
000022  2c04              CMP      r4,#4
000024  d016              BEQ      |L8.84|
000026  2c08              CMP      r4,#8
000028  d014              BEQ      |L8.84|
00002a  2c10              CMP      r4,#0x10
00002c  d012              BEQ      |L8.84|
00002e  f2410001          MOV      r0,#0x1001
000032  4284              CMP      r4,r0
000034  d00e              BEQ      |L8.84|
000036  f5a45080          SUB      r0,r4,#0x1000
00003a  3802              SUBS     r0,#2
00003c  d00a              BEQ      |L8.84|
00003e  1e80              SUBS     r0,r0,#2
000040  d008              BEQ      |L8.84|
000042  1f00              SUBS     r0,r0,#4
000044  d006              BEQ      |L8.84|
000046  3808              SUBS     r0,r0,#8
000048  d004              BEQ      |L8.84|
00004a  f44f71d0          MOV      r1,#0x1a0
00004e  4809              LDR      r0,|L8.116|
000050  f7fffffe          BL       assert_failed
                  |L8.84|
;;;417      
;;;418      /* Get the DCMI register index */
;;;419      dcmireg = (((uint16_t)DCMI_FLAG) >> 12);
000054  0b20              LSRS     r0,r4,#12
;;;420      
;;;421      if (dcmireg == 0x01) /* The FLAG is in RISR register */
;;;422      {
;;;423        tempreg= DCMI->RISR;
000056  4908              LDR      r1,|L8.120|
000058  2801              CMP      r0,#1                 ;421
00005a  d007              BEQ      |L8.108|
;;;424      }
;;;425      else if (dcmireg == 0x02) /* The FLAG is in SR register */
00005c  2802              CMP      r0,#2
00005e  d007              BEQ      |L8.112|
;;;426      {
;;;427        tempreg = DCMI->SR;
;;;428      }
;;;429      else /* The FLAG is in MISR register */
;;;430      {
;;;431        tempreg = DCMI->MISR;
000060  6908              LDR      r0,[r1,#0x10]
                  |L8.98|
;;;432      }
;;;433      
;;;434      if ((tempreg & DCMI_FLAG) != (uint16_t)RESET )
000062  4220              TST      r0,r4
000064  d000              BEQ      |L8.104|
;;;435      {
;;;436        bitstatus = SET;
000066  2501              MOVS     r5,#1
                  |L8.104|
;;;437      }
;;;438      else
;;;439      {
;;;440        bitstatus = RESET;
;;;441      }
;;;442      /* Return the DCMI_FLAG status */
;;;443      return  bitstatus;
000068  4628              MOV      r0,r5
;;;444    }
00006a  bd70              POP      {r4-r6,pc}
                  |L8.108|
00006c  6888              LDR      r0,[r1,#8]            ;423
00006e  e7f8              B        |L8.98|
                  |L8.112|
000070  6848              LDR      r0,[r1,#4]            ;427
000072  e7f6              B        |L8.98|
;;;445    
                          ENDP

                  |L8.116|
                          DCD      ||.conststring||
                  |L8.120|
                          DCD      0x50050000

                          AREA ||i.DCMI_GetITStatus||, CODE, READONLY, ALIGN=2

                  DCMI_GetITStatus PROC
;;;478      */
;;;479    ITStatus DCMI_GetITStatus(uint16_t DCMI_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;480    {
;;;481      ITStatus bitstatus = RESET;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;480
;;;482      uint32_t itstatus = 0;
;;;483      
;;;484      /* Check the parameters */
;;;485      assert_param(IS_DCMI_GET_IT(DCMI_IT));
000006  2801              CMP      r0,#1
000008  d00c              BEQ      |L9.36|
00000a  2c02              CMP      r4,#2
00000c  d00a              BEQ      |L9.36|
00000e  2c04              CMP      r4,#4
000010  d008              BEQ      |L9.36|
000012  2c08              CMP      r4,#8
000014  d006              BEQ      |L9.36|
000016  2c10              CMP      r4,#0x10
000018  d004              BEQ      |L9.36|
00001a  f24011e5          MOV      r1,#0x1e5
00001e  4805              LDR      r0,|L9.52|
000020  f7fffffe          BL       assert_failed
                  |L9.36|
;;;486      
;;;487      itstatus = DCMI->MISR & DCMI_IT; /* Only masked interrupts are checked */
000024  4804              LDR      r0,|L9.56|
000026  6900              LDR      r0,[r0,#0x10]
000028  4220              TST      r0,r4
;;;488      
;;;489      if ((itstatus != (uint16_t)RESET))
00002a  d000              BEQ      |L9.46|
;;;490      {
;;;491        bitstatus = SET;
00002c  2501              MOVS     r5,#1
                  |L9.46|
;;;492      }
;;;493      else
;;;494      {
;;;495        bitstatus = RESET;
;;;496      }
;;;497      return bitstatus;
00002e  4628              MOV      r0,r5
;;;498    }
000030  bd70              POP      {r4-r6,pc}
;;;499    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      ||.conststring||
                  |L9.56|
                          DCD      0x50050000

                          AREA ||i.DCMI_ITConfig||, CODE, READONLY, ALIGN=2

                  DCMI_ITConfig PROC
;;;372      */
;;;373    void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;374    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;375      /* Check the parameters */
;;;376      assert_param(IS_DCMI_CONFIG_IT(DCMI_IT));
000006  0940              LSRS     r0,r0,#5
000008  d100              BNE      |L10.12|
00000a  b924              CBNZ     r4,|L10.22|
                  |L10.12|
00000c  f44f71bc          MOV      r1,#0x178
000010  480a              LDR      r0,|L10.60|
000012  f7fffffe          BL       assert_failed
                  |L10.22|
;;;377      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;378      
;;;379      if (NewState != DISABLE)
;;;380      {
;;;381        /* Enable the Interrupt sources */
;;;382        DCMI->IER |= DCMI_IT;
000016  4e0a              LDR      r6,|L10.64|
000018  b14d              CBZ      r5,|L10.46|
00001a  2d01              CMP      r5,#1                 ;377
00001c  d004              BEQ      |L10.40|
00001e  f2401179          MOV      r1,#0x179             ;377
000022  4806              LDR      r0,|L10.60|
000024  f7fffffe          BL       assert_failed
                  |L10.40|
000028  68f0              LDR      r0,[r6,#0xc]
00002a  4320              ORRS     r0,r0,r4
00002c  e003              B        |L10.54|
                  |L10.46|
;;;383      }
;;;384      else
;;;385      {
;;;386        /* Disable the Interrupt sources */
;;;387        DCMI->IER &= (uint16_t)(~DCMI_IT);
00002e  68f0              LDR      r0,[r6,#0xc]
000030  43e1              MVNS     r1,r4
000032  b289              UXTH     r1,r1
000034  4008              ANDS     r0,r0,r1
                  |L10.54|
000036  60f0              STR      r0,[r6,#0xc]          ;382
;;;388      }  
;;;389    }
000038  bd70              POP      {r4-r6,pc}
;;;390    
                          ENDP

00003a  0000              DCW      0x0000
                  |L10.60|
                          DCD      ||.conststring||
                  |L10.64|
                          DCD      0x50050000

                          AREA ||i.DCMI_Init||, CODE, READONLY, ALIGN=2

                  DCMI_Init PROC
;;;138      */
;;;139    void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;140    {
000002  4604              MOV      r4,r0
;;;141      uint32_t temp = 0x0;
;;;142      
;;;143      /* Check the parameters */
;;;144      assert_param(IS_DCMI_CAPTURE_MODE(DCMI_InitStruct->DCMI_CaptureMode));
000004  8800              LDRH     r0,[r0,#0]
000006  b128              CBZ      r0,|L11.20|
000008  2802              CMP      r0,#2
00000a  d003              BEQ      |L11.20|
00000c  2190              MOVS     r1,#0x90
00000e  482c              LDR      r0,|L11.192|
000010  f7fffffe          BL       assert_failed
                  |L11.20|
;;;145      assert_param(IS_DCMI_SYNCHRO(DCMI_InitStruct->DCMI_SynchroMode));
000014  8860              LDRH     r0,[r4,#2]
000016  b128              CBZ      r0,|L11.36|
000018  2810              CMP      r0,#0x10
00001a  d003              BEQ      |L11.36|
00001c  2191              MOVS     r1,#0x91
00001e  4828              LDR      r0,|L11.192|
000020  f7fffffe          BL       assert_failed
                  |L11.36|
;;;146      assert_param(IS_DCMI_PCKPOLARITY(DCMI_InitStruct->DCMI_PCKPolarity));
000024  88a0              LDRH     r0,[r4,#4]
000026  b128              CBZ      r0,|L11.52|
000028  2820              CMP      r0,#0x20
00002a  d003              BEQ      |L11.52|
00002c  2192              MOVS     r1,#0x92
00002e  4824              LDR      r0,|L11.192|
000030  f7fffffe          BL       assert_failed
                  |L11.52|
;;;147      assert_param(IS_DCMI_VSPOLARITY(DCMI_InitStruct->DCMI_VSPolarity));
000034  88e0              LDRH     r0,[r4,#6]
000036  b128              CBZ      r0,|L11.68|
000038  2880              CMP      r0,#0x80
00003a  d003              BEQ      |L11.68|
00003c  2193              MOVS     r1,#0x93
00003e  4820              LDR      r0,|L11.192|
000040  f7fffffe          BL       assert_failed
                  |L11.68|
;;;148      assert_param(IS_DCMI_HSPOLARITY(DCMI_InitStruct->DCMI_HSPolarity));
000044  8920              LDRH     r0,[r4,#8]
000046  b128              CBZ      r0,|L11.84|
000048  2840              CMP      r0,#0x40
00004a  d003              BEQ      |L11.84|
00004c  2194              MOVS     r1,#0x94
00004e  481c              LDR      r0,|L11.192|
000050  f7fffffe          BL       assert_failed
                  |L11.84|
;;;149      assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
000054  8960              LDRH     r0,[r4,#0xa]
000056  b148              CBZ      r0,|L11.108|
000058  f5b07f80          CMP      r0,#0x100
00005c  d006              BEQ      |L11.108|
00005e  f5b07f00          CMP      r0,#0x200
000062  d003              BEQ      |L11.108|
000064  2195              MOVS     r1,#0x95
000066  4816              LDR      r0,|L11.192|
000068  f7fffffe          BL       assert_failed
                  |L11.108|
;;;150      assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));
00006c  89a0              LDRH     r0,[r4,#0xc]
00006e  b160              CBZ      r0,|L11.138|
000070  f5b06f80          CMP      r0,#0x400
000074  d009              BEQ      |L11.138|
000076  f5b06f00          CMP      r0,#0x800
00007a  d006              BEQ      |L11.138|
00007c  f5b06f40          CMP      r0,#0xc00
000080  d003              BEQ      |L11.138|
000082  2196              MOVS     r1,#0x96
000084  480e              LDR      r0,|L11.192|
000086  f7fffffe          BL       assert_failed
                  |L11.138|
;;;151    
;;;152      /* The DCMI configuration registers should be programmed correctly before 
;;;153      enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
;;;154      DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
00008a  480e              LDR      r0,|L11.196|
00008c  6801              LDR      r1,[r0,#0]
00008e  f2440201          MOV      r2,#0x4001
000092  4391              BICS     r1,r1,r2
000094  6001              STR      r1,[r0,#0]
;;;155       
;;;156      /* Reset the old DCMI configuration */
;;;157      temp = DCMI->CR;
000096  6801              LDR      r1,[r0,#0]
;;;158      
;;;159      temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
000098  f64072f2          MOV      r2,#0xff2
00009c  4391              BICS     r1,r1,r2
;;;160                          DCMI_CR_HSPOL  | DCMI_CR_VSPOL | DCMI_CR_FCRC_0 | 
;;;161                          DCMI_CR_FCRC_1 | DCMI_CR_EDM_0 | DCMI_CR_EDM_1); 
;;;162                      
;;;163      /* Sets the new configuration of the DCMI peripheral */
;;;164      temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
00009e  8822              LDRH     r2,[r4,#0]
0000a0  8863              LDRH     r3,[r4,#2]
0000a2  88e5              LDRH     r5,[r4,#6]
0000a4  431a              ORRS     r2,r2,r3
0000a6  88a3              LDRH     r3,[r4,#4]
0000a8  432b              ORRS     r3,r3,r5
0000aa  431a              ORRS     r2,r2,r3
0000ac  8923              LDRH     r3,[r4,#8]
0000ae  431a              ORRS     r2,r2,r3
0000b0  8963              LDRH     r3,[r4,#0xa]
0000b2  431a              ORRS     r2,r2,r3
0000b4  89a3              LDRH     r3,[r4,#0xc]
0000b6  431a              ORRS     r2,r2,r3
0000b8  430a              ORRS     r2,r2,r1
;;;165                         DCMI_InitStruct->DCMI_SynchroMode |
;;;166                         DCMI_InitStruct->DCMI_PCKPolarity |
;;;167                         DCMI_InitStruct->DCMI_VSPolarity |
;;;168                         DCMI_InitStruct->DCMI_HSPolarity |
;;;169                         DCMI_InitStruct->DCMI_CaptureRate |
;;;170                         DCMI_InitStruct->DCMI_ExtendedDataMode);
;;;171    
;;;172      DCMI->CR = temp;                              
0000ba  6002              STR      r2,[r0,#0]
;;;173    }
0000bc  bd70              POP      {r4-r6,pc}
;;;174    
                          ENDP

0000be  0000              DCW      0x0000
                  |L11.192|
                          DCD      ||.conststring||
                  |L11.196|
                          DCD      0x50050000

                          AREA ||i.DCMI_JPEGCmd||, CODE, READONLY, ALIGN=2

                  DCMI_JPEGCmd PROC
;;;256      */
;;;257    void DCMI_JPEGCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;258    {
;;;259      /* Check the parameters */
;;;260      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;261     
;;;262      if (NewState != DISABLE)
;;;263      {
;;;264        /* Enable the DCMI JPEG format */
;;;265        DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
000002  4c09              LDR      r4,|L12.40|
000004  b150              CBZ      r0,|L12.28|
000006  2801              CMP      r0,#1                 ;260
000008  d004              BEQ      |L12.20|
00000a  f44f7182          MOV      r1,#0x104             ;260
00000e  4807              LDR      r0,|L12.44|
000010  f7fffffe          BL       assert_failed
                  |L12.20|
000014  6820              LDR      r0,[r4,#0]
000016  f0400008          ORR      r0,r0,#8
00001a  e002              B        |L12.34|
                  |L12.28|
;;;266      }
;;;267      else
;;;268      {
;;;269        /* Disable the DCMI JPEG format */
;;;270        DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
00001c  6820              LDR      r0,[r4,#0]
00001e  f0200008          BIC      r0,r0,#8
                  |L12.34|
000022  6020              STR      r0,[r4,#0]            ;265
;;;271      }
;;;272    }
000024  bd10              POP      {r4,pc}
;;;273    /**
                          ENDP

000026  0000              DCW      0x0000
                  |L12.40|
                          DCD      0x50050000
                  |L12.44|
                          DCD      ||.conststring||

                          AREA ||i.DCMI_ReadData||, CODE, READONLY, ALIGN=2

                  DCMI_ReadData PROC
;;;339      */
;;;340    uint32_t DCMI_ReadData(void)
000000  4801              LDR      r0,|L13.8|
;;;341    {
;;;342      return DCMI->DR;
000002  6a80              LDR      r0,[r0,#0x28]
;;;343    }
000004  4770              BX       lr
;;;344    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_SetEmbeddedSynchroCodes||, CODE, READONLY, ALIGN=2

                  DCMI_SetEmbeddedSynchroCodes PROC
;;;241      */
;;;242    void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
000000  78c1              LDRB     r1,[r0,#3]
;;;243    {
;;;244      DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
000002  6800              LDR      r0,[r0,#0]
000004  f361601f          BFI      r0,r1,#24,#8
000008  4901              LDR      r1,|L14.16|
00000a  6188              STR      r0,[r1,#0x18]
;;;245                              ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
;;;246                              ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
;;;247                              ((uint32_t)DCMI_CodesInitStruct->DCMI_FrameEndCode << 24));
;;;248    }
00000c  4770              BX       lr
;;;249    
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x50050000

                          AREA ||i.DCMI_StructInit||, CODE, READONLY, ALIGN=1

                  DCMI_StructInit PROC
;;;180      */
;;;181    void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct)
000000  2100              MOVS     r1,#0
;;;182    {
;;;183      /* Set the default configuration */
;;;184      DCMI_InitStruct->DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
000002  8001              STRH     r1,[r0,#0]
;;;185      DCMI_InitStruct->DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
000004  8041              STRH     r1,[r0,#2]
;;;186      DCMI_InitStruct->DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
000006  8081              STRH     r1,[r0,#4]
;;;187      DCMI_InitStruct->DCMI_VSPolarity = DCMI_VSPolarity_Low;
000008  80c1              STRH     r1,[r0,#6]
;;;188      DCMI_InitStruct->DCMI_HSPolarity = DCMI_HSPolarity_Low;
00000a  8101              STRH     r1,[r0,#8]
;;;189      DCMI_InitStruct->DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
00000c  8141              STRH     r1,[r0,#0xa]
;;;190      DCMI_InitStruct->DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
00000e  8181              STRH     r1,[r0,#0xc]
;;;191    }
000010  4770              BX       lr
;;;192    
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c4f          DCB      "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_"
000004  535c6273
000008  705c7374
00000c  6d333266
000010  3430785c
000014  4c696272
000018  61726965
00001c  735c5354
000020  4d333246
000024  3478785f
000028  53746450
00002c  65726970
000030  685f    
000032  44726976          DCB      "Driver\\src\\stm32f4xx_dcmi.c",0
000036  65725c73
00003a  72635c73
00003e  746d3332
000042  66347878
000046  5f64636d
00004a  692e6300

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_dcmi.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_dcmi_c_3610e7fb____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_dcmi_c_3610e7fb____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_dcmi_c_3610e7fb____REVSH|
#line 128
|__asm___16_stm32f4xx_dcmi_c_3610e7fb____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
