; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\serial.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\serial.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\OS -I..\OS\components\finsh -I..\OS\include -I..\OS\libcpu\arm\common -I..\OS\libcpu\arm\cortex-m4 -I..\OS\bsp\stm32f40x\Libraries\CMSIS\Include -I..\OS\bsp\stm32f40x\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\OS\bsp\stm32f40x\Libraries\CMSIS\ST\STM32F4xx\Include -I..\OS\bsp\stm32f40x\applications -I..\OS\bsp\stm32f40x\drivers -I..\OS\bsp\stm32f40x -I..\ext\inc -I..\tb_Application -I..\tb_Algorithm -I..\tb_Driver -IE:\Robotic_Platform\mdk_Prj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.8.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F429xx -DUSE_STDPERIPH_DRIVER -DSTM32F429xx --omf_browse=.\objects\serial.crf ..\OS\bsp\stm32f40x\drivers\serial.c]
                          THUMB

                          AREA ||i.rt_hw_serial_dma_tx_isr||, CODE, READONLY, ALIGN=2

                  rt_hw_serial_dma_tx_isr PROC
;;;372     */
;;;373    void rt_hw_serial_dma_tx_isr(rt_device_t device)
000000  b5f8              PUSH     {r3-r7,lr}
;;;374    {
000002  4606              MOV      r6,r0
;;;375    	rt_uint32_t level;
;;;376    	struct stm32_serial_data_node* data_node;
;;;377    	struct stm32_serial_device* uart = (struct stm32_serial_device*) device->user_data;
;;;378    
;;;379    	/* DMA mode receive */
;;;380    	RT_ASSERT(device->flag & RT_DEVICE_FLAG_DMA_TX);
000004  6bc4              LDR      r4,[r0,#0x3c]
000006  8ac0              LDRH     r0,[r0,#0x16]
000008  f04f0700          MOV      r7,#0
00000c  0500              LSLS     r0,r0,#20
00000e  d40c              BMI      |L1.42|
000010  f88d7000          STRB     r7,[sp,#0]
000014  f44f73be          MOV      r3,#0x17c
000018  4a1d              LDR      r2,|L1.144|
00001a  a11e              ADR      r1,|L1.148|
00001c  a027              ADR      r0,|L1.188|
00001e  f7fffffe          BL       rt_kprintf
                  |L1.34|
000022  f89d0000          LDRB     r0,[sp,#0]
000026  2800              CMP      r0,#0
000028  d0fb              BEQ      |L1.34|
                  |L1.42|
;;;381    
;;;382    	/* get the first data node */
;;;383    	data_node = uart->dma_tx->list_head;
00002a  68a0              LDR      r0,[r4,#8]
;;;384    	RT_ASSERT(data_node != RT_NULL);
00002c  6845              LDR      r5,[r0,#4]
00002e  b965              CBNZ     r5,|L1.74|
000030  f88d7000          STRB     r7,[sp,#0]
000034  f44f73c0          MOV      r3,#0x180
000038  4a15              LDR      r2,|L1.144|
00003a  a128              ADR      r1,|L1.220|
00003c  a01f              ADR      r0,|L1.188|
00003e  f7fffffe          BL       rt_kprintf
                  |L1.66|
000042  f89d0000          LDRB     r0,[sp,#0]
000046  2800              CMP      r0,#0
000048  d0fb              BEQ      |L1.66|
                  |L1.74|
;;;385    
;;;386    	/* invoke call to notify tx complete */
;;;387    	if (device->tx_complete != RT_NULL)
00004a  6a32              LDR      r2,[r6,#0x20]
00004c  b112              CBZ      r2,|L1.84|
;;;388    		device->tx_complete(device, data_node->data_ptr);
00004e  4630              MOV      r0,r6
000050  6829              LDR      r1,[r5,#0]
000052  4790              BLX      r2
                  |L1.84|
;;;389    
;;;390    	/* disable interrupt */
;;;391    	level = rt_hw_interrupt_disable();
000054  f7fffffe          BL       rt_hw_interrupt_disable
;;;392    
;;;393    	/* remove list head */
;;;394    	uart->dma_tx->list_head = data_node->next;
000058  68a2              LDR      r2,[r4,#8]
00005a  4601              MOV      r1,r0                 ;391
00005c  68a8              LDR      r0,[r5,#8]
;;;395    	if (uart->dma_tx->list_head == RT_NULL) /* data link empty */
00005e  6050              STR      r0,[r2,#4]
000060  68a2              LDR      r2,[r4,#8]
000062  b900              CBNZ     r0,|L1.102|
;;;396    		uart->dma_tx->list_tail = RT_NULL;
000064  6097              STR      r7,[r2,#8]
                  |L1.102|
;;;397    
;;;398    	/* enable interrupt */
;;;399    	rt_hw_interrupt_enable(level);
000066  4608              MOV      r0,r1
000068  f7fffffe          BL       rt_hw_interrupt_enable
;;;400    
;;;401    	/* release data node memory */
;;;402    	rt_mp_free(data_node);
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       rt_mp_free
;;;403    
;;;404    	if (uart->dma_tx->list_head != RT_NULL)
000072  68a0              LDR      r0,[r4,#8]
000074  6841              LDR      r1,[r0,#4]
000076  b129              CBZ      r1,|L1.132|
000078  c906              LDM      r1,{r1,r2}
;;;405    	{
;;;406    		/* transmit next data node */
;;;407    		rt_serial_enable_dma(uart->dma_tx->dma_channel,
00007a  6800              LDR      r0,[r0,#0]
00007c  e8bd40f8          POP      {r3-r7,lr}
000080  f7ffbffe          B.W      rt_serial_enable_dma
                  |L1.132|
;;;408    			(rt_uint32_t)uart->dma_tx->list_head->data_ptr,
;;;409    			uart->dma_tx->list_head->data_size);
;;;410    	}
;;;411    	else
;;;412    	{
;;;413    		/* no data to be transmitted, disable DMA */
;;;414    		DMA_Cmd(uart->dma_tx->dma_channel, DISABLE);
000084  6800              LDR      r0,[r0,#0]
000086  e8bd40f8          POP      {r3-r7,lr}
00008a  2100              MOVS     r1,#0
00008c  f7ffbffe          B.W      DMA_Cmd
;;;415    	}
;;;416    }
;;;417    
                          ENDP

                  |L1.144|
                          DCD      ||.constdata||+0x6d
                  |L1.148|
000094  64657669          DCB      "device->flag & RT_DEVICE_FLAG_DMA_TX",0
000098  63652d3e
00009c  666c6167
0000a0  20262052
0000a4  545f4445
0000a8  56494345
0000ac  5f464c41
0000b0  475f444d
0000b4  415f5458
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L1.188|
0000bc  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000c0  20617373
0000c4  65727420
0000c8  6661696c
0000cc  65642061
0000d0  74202573
0000d4  3a256420
0000d8  0a00    
0000da  00                DCB      0
0000db  00                DCB      0
                  |L1.220|
0000dc  64617461          DCB      "data_node != RT_NULL",0
0000e0  5f6e6f64
0000e4  6520213d
0000e8  2052545f
0000ec  4e554c4c
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||i.rt_hw_serial_isr||, CODE, READONLY, ALIGN=2

                  rt_hw_serial_isr PROC
;;;310    /* ISR for serial interrupt */
;;;311    void rt_hw_serial_isr(rt_device_t device)
000000  b5f8              PUSH     {r3-r7,lr}
;;;312    {
;;;313    	struct stm32_serial_device* uart = (struct stm32_serial_device*) device->user_data;
;;;314    
;;;315    	if(USART_GetITStatus(uart->uart_device, USART_IT_RXNE) != RESET)
000002  6bc4              LDR      r4,[r0,#0x3c]
000004  4606              MOV      r6,r0                 ;312
000006  f2405725          MOV      r7,#0x525
00000a  4639              MOV      r1,r7
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       USART_GetITStatus
000012  2800              CMP      r0,#0
000014  d046              BEQ      |L2.164|
;;;316    	{
;;;317    		/* interrupt mode receive */
;;;318    		RT_ASSERT(device->flag & RT_DEVICE_FLAG_INT_RX);
000016  8af0              LDRH     r0,[r6,#0x16]
000018  f04f0500          MOV      r5,#0
00001c  05c0              LSLS     r0,r0,#23
00001e  d42b              BMI      |L2.120|
000020  f88d5000          STRB     r5,[sp,#0]
000024  f44f739f          MOV      r3,#0x13e
000028  4a26              LDR      r2,|L2.196|
00002a  a127              ADR      r1,|L2.200|
00002c  a030              ADR      r0,|L2.240|
00002e  f7fffffe          BL       rt_kprintf
                  |L2.50|
000032  f89d0000          LDRB     r0,[sp,#0]
000036  2800              CMP      r0,#0
000038  d0fb              BEQ      |L2.50|
00003a  e01d              B        |L2.120|
                  |L2.60|
;;;319    
;;;320    		/* save on rx buffer */
;;;321    		while (uart->uart_device->SR & USART_FLAG_RXNE)
;;;322    		{
;;;323    			rt_base_t level;
;;;324    
;;;325    			/* disable interrupt */
;;;326    			level = rt_hw_interrupt_disable();
00003c  f7fffffe          BL       rt_hw_interrupt_disable
000040  4602              MOV      r2,r0
;;;327    
;;;328    			/* save character */
;;;329    			uart->int_rx->rx_buffer[uart->int_rx->save_index] = uart->uart_device->DR & 0xff;
000042  6820              LDR      r0,[r4,#0]
000044  8881              LDRH     r1,[r0,#4]
000046  6860              LDR      r0,[r4,#4]
000048  6c43              LDR      r3,[r0,#0x44]
00004a  54c1              STRB     r1,[r0,r3]
;;;330    			uart->int_rx->save_index ++;
00004c  6860              LDR      r0,[r4,#4]
00004e  6c41              LDR      r1,[r0,#0x44]
000050  1c49              ADDS     r1,r1,#1
;;;331    			if (uart->int_rx->save_index >= UART_RX_BUFFER_SIZE)
000052  6441              STR      r1,[r0,#0x44]
000054  6860              LDR      r0,[r4,#4]
000056  2940              CMP      r1,#0x40
000058  d300              BCC      |L2.92|
;;;332    				uart->int_rx->save_index = 0;
00005a  6445              STR      r5,[r0,#0x44]
                  |L2.92|
;;;333    
;;;334    			/* if the next position is read index, discard this 'read char' */
;;;335    			if (uart->int_rx->save_index == uart->int_rx->read_index)
00005c  6860              LDR      r0,[r4,#4]
00005e  e9d01310          LDRD     r1,r3,[r0,#0x40]
000062  428b              CMP      r3,r1
000064  d105              BNE      |L2.114|
000066  1c49              ADDS     r1,r1,#1
;;;336    			{
;;;337    				uart->int_rx->read_index ++;
;;;338    				if (uart->int_rx->read_index >= UART_RX_BUFFER_SIZE)
000068  6401              STR      r1,[r0,#0x40]
00006a  6860              LDR      r0,[r4,#4]
00006c  2940              CMP      r1,#0x40
00006e  d300              BCC      |L2.114|
;;;339    					uart->int_rx->read_index = 0;
000070  6405              STR      r5,[r0,#0x40]
                  |L2.114|
;;;340    			}
;;;341    
;;;342    			/* enable interrupt */
;;;343    			rt_hw_interrupt_enable(level);
000072  4610              MOV      r0,r2
000074  f7fffffe          BL       rt_hw_interrupt_enable
                  |L2.120|
000078  6820              LDR      r0,[r4,#0]            ;321
00007a  8800              LDRH     r0,[r0,#0]            ;321
00007c  0680              LSLS     r0,r0,#26             ;321
00007e  d4dd              BMI      |L2.60|
;;;344    		}
;;;345    
;;;346    		/* clear interrupt */
;;;347    		USART_ClearITPendingBit(uart->uart_device, USART_IT_RXNE);
000080  4639              MOV      r1,r7
000082  6820              LDR      r0,[r4,#0]
000084  f7fffffe          BL       USART_ClearITPendingBit
;;;348    
;;;349    		/* invoke callback */
;;;350    		if (device->rx_indicate != RT_NULL)
000088  69f2              LDR      r2,[r6,#0x1c]
00008a  b15a              CBZ      r2,|L2.164|
;;;351    		{
;;;352    			rt_size_t rx_length;
;;;353    
;;;354    			/* get rx length */
;;;355    			rx_length = uart->int_rx->read_index > uart->int_rx->save_index ?
00008c  6861              LDR      r1,[r4,#4]
00008e  e9d10110          LDRD     r0,r1,[r1,#0x40]
000092  4288              CMP      r0,r1
000094  d903              BLS      |L2.158|
;;;356    				UART_RX_BUFFER_SIZE - uart->int_rx->read_index + uart->int_rx->save_index :
000096  f1c00040          RSB      r0,r0,#0x40
00009a  4401              ADD      r1,r1,r0
00009c  e000              B        |L2.160|
                  |L2.158|
;;;357    				uart->int_rx->save_index - uart->int_rx->read_index;
00009e  1a09              SUBS     r1,r1,r0
                  |L2.160|
;;;358    
;;;359    			device->rx_indicate(device, rx_length);
0000a0  4630              MOV      r0,r6
0000a2  4790              BLX      r2
                  |L2.164|
;;;360    		}
;;;361    	}
;;;362    
;;;363    	if (USART_GetITStatus(uart->uart_device, USART_IT_TC) != RESET)
0000a4  f2406526          MOV      r5,#0x626
0000a8  4629              MOV      r1,r5
0000aa  6820              LDR      r0,[r4,#0]
0000ac  f7fffffe          BL       USART_GetITStatus
0000b0  2800              CMP      r0,#0
0000b2  d005              BEQ      |L2.192|
;;;364    	{
;;;365    		/* clear interrupt */
;;;366    		USART_ClearITPendingBit(uart->uart_device, USART_IT_TC);
0000b4  4629              MOV      r1,r5
0000b6  6820              LDR      r0,[r4,#0]
0000b8  e8bd40f8          POP      {r3-r7,lr}
0000bc  f7ffbffe          B.W      USART_ClearITPendingBit
                  |L2.192|
;;;367    	}
;;;368    }
0000c0  bdf8              POP      {r3-r7,pc}
;;;369    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L2.196|
                          DCD      ||.constdata||+0x5c
                  |L2.200|
0000c8  64657669          DCB      "device->flag & RT_DEVICE_FLAG_INT_RX",0
0000cc  63652d3e
0000d0  666c6167
0000d4  20262052
0000d8  545f4445
0000dc  56494345
0000e0  5f464c41
0000e4  475f494e
0000e8  545f5258
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L2.240|
0000f0  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000f4  20617373
0000f8  65727420
0000fc  6661696c
000100  65642061
000104  74202573
000108  3a256420
00010c  0a00    
00010e  00                DCB      0
00010f  00                DCB      0

                          AREA ||i.rt_hw_serial_register||, CODE, READONLY, ALIGN=2

                  rt_hw_serial_register PROC
;;;284     */
;;;285    rt_err_t rt_hw_serial_register(rt_device_t device, const char* name, rt_uint32_t flag, struct stm32_serial_device *serial)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;286    {
000004  461f              MOV      r7,r3
000006  4616              MOV      r6,r2
000008  4688              MOV      r8,r1
00000a  0004              MOVS     r4,r0
00000c  f04f0500          MOV      r5,#0
000010  d10c              BNE      |L3.44|
;;;287    	RT_ASSERT(device != RT_NULL);
000012  f88d5000          STRB     r5,[sp,#0]
000016  f240131f          MOV      r3,#0x11f
00001a  4a19              LDR      r2,|L3.128|
00001c  a119              ADR      r1,|L3.132|
00001e  a01e              ADR      r0,|L3.152|
000020  f7fffffe          BL       rt_kprintf
                  |L3.36|
000024  f89d0000          LDRB     r0,[sp,#0]
000028  2800              CMP      r0,#0
00002a  d0fb              BEQ      |L3.36|
                  |L3.44|
;;;288    
;;;289    	if ((flag & RT_DEVICE_FLAG_DMA_RX) ||
00002c  f4166fc0          TST      r6,#0x600
000030  d00c              BEQ      |L3.76|
;;;290    		(flag & RT_DEVICE_FLAG_INT_TX))
;;;291    	{
;;;292    		RT_ASSERT(0);
000032  f88d5000          STRB     r5,[sp,#0]
000036  f44f7392          MOV      r3,#0x124
00003a  4a11              LDR      r2,|L3.128|
00003c  a11e              ADR      r1,|L3.184|
00003e  a016              ADR      r0,|L3.152|
000040  f7fffffe          BL       rt_kprintf
                  |L3.68|
000044  f89d0000          LDRB     r0,[sp,#0]
000048  2800              CMP      r0,#0
00004a  d0fb              BEQ      |L3.68|
                  |L3.76|
;;;293    	}
;;;294    
;;;295    	device->type 		= RT_Device_Class_Char;
00004c  7525              STRB     r5,[r4,#0x14]
;;;296    	device->rx_indicate = RT_NULL;
;;;297    	device->tx_complete = RT_NULL;
;;;298    	device->init 		= rt_serial_init;
00004e  481b              LDR      r0,|L3.188|
000050  61e5              STR      r5,[r4,#0x1c]
000052  e9c45008          STRD     r5,r0,[r4,#0x20]
;;;299    	device->open		= rt_serial_open;
000056  481a              LDR      r0,|L3.192|
;;;300    	device->close		= rt_serial_close;
000058  62a0              STR      r0,[r4,#0x28]
00005a  481a              LDR      r0,|L3.196|
;;;301    	device->read 		= rt_serial_read;
00005c  62e0              STR      r0,[r4,#0x2c]
00005e  481a              LDR      r0,|L3.200|
;;;302    	device->write 		= rt_serial_write;
000060  6320              STR      r0,[r4,#0x30]
000062  481a              LDR      r0,|L3.204|
;;;303    	device->control 	= rt_serial_control;
000064  6360              STR      r0,[r4,#0x34]
000066  481a              LDR      r0,|L3.208|
000068  e9c4070e          STRD     r0,r7,[r4,#0x38]
;;;304    	device->user_data	= serial;
;;;305    
;;;306    	/* register a character device */
;;;307    	return rt_device_register(device, name, RT_DEVICE_FLAG_RDWR | flag);
00006c  b2b0              UXTH     r0,r6
00006e  f0400203          ORR      r2,r0,#3
000072  4641              MOV      r1,r8
000074  4620              MOV      r0,r4
000076  e8bd43f8          POP      {r3-r9,lr}
00007a  f7ffbffe          B.W      rt_device_register
;;;308    }
;;;309    
                          ENDP

00007e  0000              DCW      0x0000
                  |L3.128|
                          DCD      ||.constdata||+0x46
                  |L3.132|
000084  64657669          DCB      "device != RT_NULL",0
000088  63652021
00008c  3d205254
000090  5f4e554c
000094  4c00    
000096  00                DCB      0
000097  00                DCB      0
                  |L3.152|
000098  28257329          DCB      "(%s) assert failed at %s:%d \n",0
00009c  20617373
0000a0  65727420
0000a4  6661696c
0000a8  65642061
0000ac  74202573
0000b0  3a256420
0000b4  0a00    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L3.184|
0000b8  3000              DCB      "0",0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L3.188|
                          DCD      rt_serial_init
                  |L3.192|
                          DCD      rt_serial_open
                  |L3.196|
                          DCD      rt_serial_close
                  |L3.200|
                          DCD      rt_serial_read
                  |L3.204|
                          DCD      rt_serial_write
                  |L3.208|
                          DCD      rt_serial_control

                          AREA ||i.rt_serial_close||, CODE, READONLY, ALIGN=1

                  rt_serial_close PROC
;;;70     
;;;71     static rt_err_t rt_serial_close(rt_device_t dev)
000000  2000              MOVS     r0,#0
;;;72     {
;;;73     	return RT_EOK;
;;;74     }
000002  4770              BX       lr
;;;75     
                          ENDP


                          AREA ||i.rt_serial_control||, CODE, READONLY, ALIGN=2

                  rt_serial_control PROC
;;;255    
;;;256    static rt_err_t rt_serial_control (rt_device_t dev, rt_uint8_t cmd, void *args)
000000  b538              PUSH     {r3-r5,lr}
;;;257    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d10c              BNE      |L5.34|
;;;258    	struct stm32_serial_device* uart;
;;;259    
;;;260    	RT_ASSERT(dev != RT_NULL);
000008  f88d0000          STRB     r0,[sp,#0]
00000c  f44f7382          MOV      r3,#0x104
000010  4a0f              LDR      r2,|L5.80|
000012  a110              ADR      r1,|L5.84|
000014  a013              ADR      r0,|L5.100|
000016  f7fffffe          BL       rt_kprintf
                  |L5.26|
00001a  f89d0000          LDRB     r0,[sp,#0]
00001e  2800              CMP      r0,#0
000020  d0fb              BEQ      |L5.26|
                  |L5.34|
;;;261    
;;;262    	uart = (struct stm32_serial_device*)dev->user_data;
;;;263    	switch (cmd)
000022  6be0              LDR      r0,[r4,#0x3c]
000024  2d01              CMP      r5,#1
000026  d008              BEQ      |L5.58|
000028  2d02              CMP      r5,#2
00002a  d10e              BNE      |L5.74|
;;;264    	{
;;;265    	case RT_DEVICE_CTRL_SUSPEND:
;;;266    		/* suspend device */
;;;267    		dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
00002c  8ae1              LDRH     r1,[r4,#0x16]
00002e  f0410120          ORR      r1,r1,#0x20
000032  82e1              STRH     r1,[r4,#0x16]
;;;268    		USART_Cmd(uart->uart_device, DISABLE);
000034  6800              LDR      r0,[r0,#0]
000036  2100              MOVS     r1,#0
;;;269    		break;
000038  e005              B        |L5.70|
                  |L5.58|
;;;270    
;;;271    	case RT_DEVICE_CTRL_RESUME:
;;;272    		/* resume device */
;;;273    		dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
00003a  8ae1              LDRH     r1,[r4,#0x16]
00003c  f0210120          BIC      r1,r1,#0x20
000040  82e1              STRH     r1,[r4,#0x16]
;;;274    		USART_Cmd(uart->uart_device, ENABLE);
000042  6800              LDR      r0,[r0,#0]
000044  2101              MOVS     r1,#1
                  |L5.70|
000046  f7fffffe          BL       USART_Cmd
                  |L5.74|
;;;275    		break;
;;;276    	}
;;;277    
;;;278    	return RT_EOK;
00004a  2000              MOVS     r0,#0
;;;279    }
00004c  bd38              POP      {r3-r5,pc}
;;;280    
                          ENDP

00004e  0000              DCW      0x0000
                  |L5.80|
                          DCD      ||.constdata||+0x34
                  |L5.84|
000054  64657620          DCB      "dev != RT_NULL",0
000058  213d2052
00005c  545f4e55
000060  4c4c00  
000063  00                DCB      0
                  |L5.100|
000064  28257329          DCB      "(%s) assert failed at %s:%d \n",0
000068  20617373
00006c  65727420
000070  6661696c
000074  65642061
000078  74202573
00007c  3a256420
000080  0a00    
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.rt_serial_enable_dma||, CODE, READONLY, ALIGN=2

                  rt_serial_enable_dma PROC
;;;138    
;;;139    static void rt_serial_enable_dma(DMA_Stream_TypeDef* dma_channel,
000000  b5f8              PUSH     {r3-r7,lr}
;;;140    	rt_uint32_t address, rt_uint32_t size)
;;;141    {
000002  4616              MOV      r6,r2
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d10b              BNE      |L6.34|
;;;142    	RT_ASSERT(dma_channel != RT_NULL);
00000a  f88d0000          STRB     r0,[sp,#0]
00000e  238e              MOVS     r3,#0x8e
000010  4a0a              LDR      r2,|L6.60|
000012  a10b              ADR      r1,|L6.64|
000014  a010              ADR      r0,|L6.88|
000016  f7fffffe          BL       rt_kprintf
                  |L6.26|
00001a  f89d3000          LDRB     r3,[sp,#0]
00001e  2b00              CMP      r3,#0
000020  d0fb              BEQ      |L6.26|
                  |L6.34|
;;;143    
;;;144    	/* disable DMA */
;;;145    	DMA_Cmd(dma_channel, DISABLE);
000022  2100              MOVS     r1,#0
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       DMA_Cmd
;;;146    
;;;147    	/* set buffer address */
;;;148    	dma_channel->M0AR = address;
00002a  60e5              STR      r5,[r4,#0xc]
;;;149    	/* set size */
;;;150    	dma_channel->NDTR = size;
00002c  6066              STR      r6,[r4,#4]
;;;151    
;;;152    	/* enable DMA */
;;;153    	DMA_Cmd(dma_channel, ENABLE);
00002e  4620              MOV      r0,r4
000030  e8bd40f8          POP      {r3-r7,lr}
000034  2101              MOVS     r1,#1
000036  f7ffbffe          B.W      DMA_Cmd
;;;154    }
;;;155    
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      ||.constdata||+0xf
                  |L6.64|
000040  646d615f          DCB      "dma_channel != RT_NULL",0
000044  6368616e
000048  6e656c20
00004c  213d2052
000050  545f4e55
000054  4c4c00  
000057  00                DCB      0
                  |L6.88|
000058  28257329          DCB      "(%s) assert failed at %s:%d \n",0
00005c  20617373
000060  65727420
000064  6661696c
000068  65642061
00006c  74202573
000070  3a256420
000074  0a00    
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.rt_serial_init||, CODE, READONLY, ALIGN=2

                  rt_serial_init PROC
;;;30     /* RT-Thread Device Interface */
;;;31     static rt_err_t rt_serial_init (rt_device_t dev)
000000  b5f8              PUSH     {r3-r7,lr}
;;;32     {
000002  4605              MOV      r5,r0
;;;33     	struct stm32_serial_device* uart = (struct stm32_serial_device*) dev->user_data;
;;;34     
;;;35     	if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
000004  6bc4              LDR      r4,[r0,#0x3c]
000006  8ac0              LDRH     r0,[r0,#0x16]
000008  06c1              LSLS     r1,r0,#27
00000a  d434              BMI      |L7.118|
;;;36     	{
;;;37     		if (dev->flag & RT_DEVICE_FLAG_INT_RX)
00000c  05c0              LSLS     r0,r0,#23
00000e  f04f0600          MOV      r6,#0
000012  d508              BPL      |L7.38|
;;;38     		{
;;;39     			rt_memset(uart->int_rx->rx_buffer, 0,
000014  2240              MOVS     r2,#0x40
000016  2100              MOVS     r1,#0
000018  6860              LDR      r0,[r4,#4]
00001a  f7fffffe          BL       rt_memset
;;;40     				sizeof(uart->int_rx->rx_buffer));
;;;41     			uart->int_rx->read_index = 0;
00001e  6860              LDR      r0,[r4,#4]
;;;42     			uart->int_rx->save_index = 0;
000020  6406              STR      r6,[r0,#0x40]
000022  6860              LDR      r0,[r4,#4]
000024  6446              STR      r6,[r0,#0x44]
                  |L7.38|
;;;43     		}
;;;44     
;;;45     		if (dev->flag & RT_DEVICE_FLAG_DMA_TX)
000026  8ae8              LDRH     r0,[r5,#0x16]
000028  0500              LSLS     r0,r0,#20
00002a  d51c              BPL      |L7.102|
;;;46     		{
;;;47     			RT_ASSERT(uart->dma_tx->dma_channel != RT_NULL);
00002c  68a0              LDR      r0,[r4,#8]
00002e  6800              LDR      r0,[r0,#0]
000030  b958              CBNZ     r0,|L7.74|
000032  f88d6000          STRB     r6,[sp,#0]
000036  232f              MOVS     r3,#0x2f
000038  4a10              LDR      r2,|L7.124|
00003a  a111              ADR      r1,|L7.128|
00003c  a01a              ADR      r0,|L7.168|
00003e  f7fffffe          BL       rt_kprintf
                  |L7.66|
000042  f89d0000          LDRB     r0,[sp,#0]
000046  2800              CMP      r0,#0
000048  d0fb              BEQ      |L7.66|
                  |L7.74|
;;;48     			uart->dma_tx->list_head = uart->dma_tx->list_tail = RT_NULL;
00004a  68a0              LDR      r0,[r4,#8]
;;;49     
;;;50     			/* init data node memory pool */
;;;51     			  rt_mp_init(&(uart->dma_tx->data_node_mp), "dn",
00004c  2350              MOVS     r3,#0x50
00004e  a11e              ADR      r1,|L7.200|
000050  6086              STR      r6,[r0,#8]            ;48
000052  68a0              LDR      r0,[r4,#8]            ;48
000054  6046              STR      r6,[r0,#4]
000056  2010              MOVS     r0,#0x10
000058  9000              STR      r0,[sp,#0]
00005a  68a0              LDR      r0,[r4,#8]
00005c  f1000244          ADD      r2,r0,#0x44
000060  300c              ADDS     r0,r0,#0xc
000062  f7fffffe          BL       rt_mp_init
                  |L7.102|
;;;52     				uart->dma_tx->data_node_mem_pool,
;;;53     				sizeof(uart->dma_tx->data_node_mem_pool),
;;;54     				sizeof(struct stm32_serial_data_node));
;;;55     		}
;;;56     
;;;57     		/* Enable USART */
;;;58     		USART_Cmd(uart->uart_device, ENABLE);
000066  2101              MOVS     r1,#1
000068  6820              LDR      r0,[r4,#0]
00006a  f7fffffe          BL       USART_Cmd
;;;59     
;;;60     		dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
00006e  8ae8              LDRH     r0,[r5,#0x16]
000070  f0400010          ORR      r0,r0,#0x10
000074  82e8              STRH     r0,[r5,#0x16]
                  |L7.118|
;;;61     	}
;;;62     
;;;63     	return RT_EOK;
000076  2000              MOVS     r0,#0
;;;64     }
000078  bdf8              POP      {r3-r7,pc}
;;;65     
                          ENDP

00007a  0000              DCW      0x0000
                  |L7.124|
                          DCD      ||.constdata||
                  |L7.128|
000080  75617274          DCB      "uart->dma_tx->dma_channel != RT_NULL",0
000084  2d3e646d
000088  615f7478
00008c  2d3e646d
000090  615f6368
000094  616e6e65
000098  6c20213d
00009c  2052545f
0000a0  4e554c4c
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L7.168|
0000a8  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000ac  20617373
0000b0  65727420
0000b4  6661696c
0000b8  65642061
0000bc  74202573
0000c0  3a256420
0000c4  0a00    
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L7.200|
0000c8  646e00            DCB      "dn",0
0000cb  00                DCB      0

                          AREA ||i.rt_serial_open||, CODE, READONLY, ALIGN=1

                  rt_serial_open PROC
;;;65     
;;;66     static rt_err_t rt_serial_open(rt_device_t dev, rt_uint16_t oflag)
000000  2000              MOVS     r0,#0
;;;67     {
;;;68     	return RT_EOK;
;;;69     }
000002  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_serial_read||, CODE, READONLY, ALIGN=1

                  rt_serial_read PROC
;;;75     
;;;76     static rt_size_t rt_serial_read (rt_device_t dev, rt_off_t pos, void* buffer, rt_size_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;77     {
;;;78     	rt_uint8_t* ptr;
;;;79     	rt_err_t err_code;
;;;80     	struct stm32_serial_device* uart;
;;;81     
;;;82     	ptr = buffer;
;;;83     	err_code = RT_EOK;
;;;84     	uart = (struct stm32_serial_device*)dev->user_data;
;;;85     
;;;86     	if (dev->flag & RT_DEVICE_FLAG_INT_RX)
000004  6bc5              LDR      r5,[r0,#0x3c]
000006  8ac0              LDRH     r0,[r0,#0x16]
000008  461e              MOV      r6,r3                 ;77
00000a  4617              MOV      r7,r2                 ;77
00000c  4614              MOV      r4,r2                 ;82
00000e  f04f0800          MOV      r8,#0                 ;83
000012  05c0              LSLS     r0,r0,#23
000014  d524              BPL      |L9.96|
000016  46c1              MOV      r9,r8                 ;77
                  |L9.24|
;;;87     	{
;;;88     		/* interrupt mode Rx */
;;;89     		while (size)
000018  b32e              CBZ      r6,|L9.102|
;;;90     		{
;;;91     			rt_base_t level;
;;;92     
;;;93     			/* disable interrupt */
;;;94     			level = rt_hw_interrupt_disable();
00001a  f7fffffe          BL       rt_hw_interrupt_disable
;;;95     
;;;96     			if (uart->int_rx->read_index != uart->int_rx->save_index)
00001e  6869              LDR      r1,[r5,#4]
000020  e9d12310          LDRD     r2,r3,[r1,#0x40]
000024  429a              CMP      r2,r3
000026  d00f              BEQ      |L9.72|
;;;97     			{
;;;98     				/* read a character */
;;;99     				*ptr++ = uart->int_rx->rx_buffer[uart->int_rx->read_index];
000028  5c89              LDRB     r1,[r1,r2]
00002a  f8041b01          STRB     r1,[r4],#1
;;;100    				size--;
;;;101    
;;;102    				/* move to next position */
;;;103    				uart->int_rx->read_index ++;
00002e  686a              LDR      r2,[r5,#4]
;;;104    				if (uart->int_rx->read_index >= UART_RX_BUFFER_SIZE)
000030  1e76              SUBS     r6,r6,#1
000032  6c11              LDR      r1,[r2,#0x40]         ;103
000034  1c49              ADDS     r1,r1,#1              ;103
000036  6411              STR      r1,[r2,#0x40]
000038  686a              LDR      r2,[r5,#4]
00003a  2940              CMP      r1,#0x40
00003c  d301              BCC      |L9.66|
;;;105    					uart->int_rx->read_index = 0;
00003e  f8c29040          STR      r9,[r2,#0x40]
                  |L9.66|
;;;106    			}
;;;107    			else
;;;108    			{
;;;109    				/* set error code */
;;;110    				err_code = -RT_EEMPTY;
;;;111    
;;;112    				/* enable interrupt */
;;;113    				rt_hw_interrupt_enable(level);
;;;114    				break;
;;;115    			}
;;;116    
;;;117    			/* enable interrupt */
;;;118    			rt_hw_interrupt_enable(level);
000042  f7fffffe          BL       rt_hw_interrupt_enable
;;;119    		}
000046  e7e7              B        |L9.24|
                  |L9.72|
000048  f06f0803          MVN      r8,#3                 ;110
00004c  f7fffffe          BL       rt_hw_interrupt_enable
000050  e009              B        |L9.102|
                  |L9.82|
;;;120    	}
;;;121    	else
;;;122    	{
;;;123    		/* polling mode */
;;;124    		while ((rt_uint32_t)ptr - (rt_uint32_t)buffer < size)
;;;125    		{
;;;126    			while (uart->uart_device->SR & USART_FLAG_RXNE)
;;;127    			{
;;;128    				*ptr = uart->uart_device->DR & 0xff;
000052  8880              LDRH     r0,[r0,#4]
000054  f8040b01          STRB     r0,[r4],#1
                  |L9.88|
000058  6828              LDR      r0,[r5,#0]            ;126
00005a  8801              LDRH     r1,[r0,#0]            ;126
00005c  0689              LSLS     r1,r1,#26             ;126
00005e  d4f8              BMI      |L9.82|
                  |L9.96|
000060  1be0              SUBS     r0,r4,r7              ;124
000062  42b0              CMP      r0,r6                 ;124
000064  d3f8              BCC      |L9.88|
                  |L9.102|
;;;129    				ptr ++;
;;;130    			}
;;;131    		}
;;;132    	}
;;;133    
;;;134    	/* set error code */
;;;135    	rt_set_errno(err_code);
000066  4640              MOV      r0,r8
000068  f7fffffe          BL       rt_set_errno
;;;136    	return (rt_uint32_t)ptr - (rt_uint32_t)buffer;
00006c  1be0              SUBS     r0,r4,r7
;;;137    }
00006e  e8bd87f0          POP      {r4-r10,pc}
;;;138    
                          ENDP


                          AREA ||i.rt_serial_write||, CODE, READONLY, ALIGN=2

                  rt_serial_write PROC
;;;155    
;;;156    static rt_size_t rt_serial_write (rt_device_t dev, rt_off_t pos, const void* buffer, rt_size_t size)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;157    {
;;;158    	rt_uint8_t* ptr;
;;;159    	rt_err_t err_code;
;;;160    	struct stm32_serial_device* uart;
;;;161    
;;;162    	err_code = RT_EOK;
;;;163    	ptr = (rt_uint8_t*)buffer;
;;;164    	uart = (struct stm32_serial_device*)dev->user_data;
;;;165    
;;;166    	if (dev->flag & RT_DEVICE_FLAG_INT_TX)
000004  6bc5              LDR      r5,[r0,#0x3c]
000006  8ac0              LDRH     r0,[r0,#0x16]
000008  f04f0900          MOV      r9,#0                 ;162
00000c  461e              MOV      r6,r3                 ;157
00000e  4690              MOV      r8,r2                 ;157
000010  4614              MOV      r4,r2                 ;163
000012  0541              LSLS     r1,r0,#21
000014  46ca              MOV      r10,r9
000016  d50c              BPL      |L10.50|
;;;167    	{
;;;168    		/* interrupt mode Tx, does not support */
;;;169    		RT_ASSERT(0);
000018  f88da000          STRB     r10,[sp,#0]
00001c  23a9              MOVS     r3,#0xa9
00001e  4a2d              LDR      r2,|L10.212|
000020  a12d              ADR      r1,|L10.216|
000022  a02e              ADR      r0,|L10.220|
000024  f7fffffe          BL       rt_kprintf
                  |L10.40|
000028  f89d0000          LDRB     r0,[sp,#0]
00002c  2800              CMP      r0,#0
00002e  d0fb              BEQ      |L10.40|
000030  e048              B        |L10.196|
                  |L10.50|
;;;170    	}
;;;171    	else if (dev->flag & RT_DEVICE_FLAG_DMA_TX)
000032  0501              LSLS     r1,r0,#20
000034  d527              BPL      |L10.134|
;;;172    	{
;;;173    		/* DMA mode Tx */
;;;174    
;;;175    		/* allocate a data node */
;;;176    		struct stm32_serial_data_node* data_node = (struct stm32_serial_data_node*)
000036  68a8              LDR      r0,[r5,#8]
000038  f04f31ff          MOV      r1,#0xffffffff
00003c  300c              ADDS     r0,r0,#0xc
00003e  f7fffffe          BL       rt_mp_alloc
000042  0007              MOVS     r7,r0
;;;177    			rt_mp_alloc (&(uart->dma_tx->data_node_mp), RT_WAITING_FOREVER);
;;;178    		if (data_node == RT_NULL)
000044  d011              BEQ      |L10.106|
000046  e8870450          STM      r7,{r4,r6,r10}
;;;179    		{
;;;180    			/* set error code */
;;;181    			err_code = -RT_ENOMEM;
;;;182    		}
;;;183    		else
;;;184    		{
;;;185    			rt_uint32_t level;
;;;186    
;;;187    			/* fill data node */
;;;188    			data_node->data_ptr 	= ptr;
;;;189    			data_node->data_size 	= size;
;;;190    
;;;191    			/* insert to data link */
;;;192    			data_node->next = RT_NULL;
;;;193    
;;;194    			/* disable interrupt */
;;;195    			level = rt_hw_interrupt_disable();
00004a  f7fffffe          BL       rt_hw_interrupt_disable
00004e  4606              MOV      r6,r0
;;;196    
;;;197    			data_node->prev = uart->dma_tx->list_tail;
000050  68a8              LDR      r0,[r5,#8]
000052  6880              LDR      r0,[r0,#8]
;;;198    			if (uart->dma_tx->list_tail != RT_NULL)
000054  60f8              STR      r0,[r7,#0xc]
000056  68a8              LDR      r0,[r5,#8]
000058  6880              LDR      r0,[r0,#8]
00005a  b100              CBZ      r0,|L10.94|
;;;199    				uart->dma_tx->list_tail->next = data_node;
00005c  6087              STR      r7,[r0,#8]
                  |L10.94|
;;;200    			uart->dma_tx->list_tail = data_node;
00005e  68a8              LDR      r0,[r5,#8]
;;;201    
;;;202    			if (uart->dma_tx->list_head == RT_NULL)
000060  6087              STR      r7,[r0,#8]
000062  68a8              LDR      r0,[r5,#8]
000064  6841              LDR      r1,[r0,#4]
000066  b119              CBZ      r1,|L10.112|
000068  e009              B        |L10.126|
                  |L10.106|
00006a  f06f0904          MVN      r9,#4                 ;181
00006e  e029              B        |L10.196|
                  |L10.112|
;;;203    			{
;;;204    				/* start DMA to transmit data */
;;;205    				uart->dma_tx->list_head = data_node;
;;;206    
;;;207    				/* Enable DMA Channel */
;;;208    				rt_serial_enable_dma(uart->dma_tx->dma_channel,
000070  6047              STR      r7,[r0,#4]
000072  68a8              LDR      r0,[r5,#8]
000074  e9d71200          LDRD     r1,r2,[r7,#0]
000078  6800              LDR      r0,[r0,#0]
00007a  f7fffffe          BL       rt_serial_enable_dma
                  |L10.126|
;;;209    					(rt_uint32_t)uart->dma_tx->list_head->data_ptr,
;;;210    					uart->dma_tx->list_head->data_size);
;;;211    			}
;;;212    
;;;213    			/* enable interrupt */
;;;214    			rt_hw_interrupt_enable(level);
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       rt_hw_interrupt_enable
;;;215    		}
000084  e01e              B        |L10.196|
                  |L10.134|
;;;216    	}
;;;217    	else
;;;218    	{
;;;219    		/* polling mode */
;;;220    		if (dev->flag & RT_DEVICE_FLAG_STREAM)
000086  0640              LSLS     r0,r0,#25
000088  d51a              BPL      |L10.192|
;;;221    		{
;;;222    			/* stream mode */
;;;223    			while (size)
;;;224    			{
;;;225    				if (*ptr == '\n')
;;;226    				{
;;;227    					while (!(uart->uart_device->SR & USART_FLAG_TXE));
;;;228    					uart->uart_device->DR = '\r';
00008a  220d              MOVS     r2,#0xd
                  |L10.140|
00008c  b1d6              CBZ      r6,|L10.196|
00008e  7820              LDRB     r0,[r4,#0]            ;225
000090  280a              CMP      r0,#0xa               ;225
000092  d104              BNE      |L10.158|
000094  6828              LDR      r0,[r5,#0]            ;227
                  |L10.150|
000096  8801              LDRH     r1,[r0,#0]            ;227
000098  0609              LSLS     r1,r1,#24             ;227
00009a  d5fc              BPL      |L10.150|
00009c  8082              STRH     r2,[r0,#4]
                  |L10.158|
00009e  6828              LDR      r0,[r5,#0]            ;227
                  |L10.160|
;;;229    				}
;;;230    
;;;231    				while (!(uart->uart_device->SR & USART_FLAG_TXE));
0000a0  8801              LDRH     r1,[r0,#0]
0000a2  0609              LSLS     r1,r1,#24
0000a4  d5fc              BPL      |L10.160|
;;;232    				uart->uart_device->DR = (*ptr & 0x1FF);
0000a6  f8141b01          LDRB     r1,[r4],#1
0000aa  8081              STRH     r1,[r0,#4]
0000ac  1e76              SUBS     r6,r6,#1
;;;233    
;;;234    				++ptr; --size;
0000ae  e7ed              B        |L10.140|
                  |L10.176|
0000b0  6828              LDR      r0,[r5,#0]            ;227
                  |L10.178|
;;;235    			}
;;;236    		}
;;;237    		else
;;;238    		{
;;;239    			/* write data directly */
;;;240    			while (size)
;;;241    			{
;;;242    				while (!(uart->uart_device->SR & USART_FLAG_TXE));
0000b2  8801              LDRH     r1,[r0,#0]
0000b4  0609              LSLS     r1,r1,#24
0000b6  d5fc              BPL      |L10.178|
;;;243    				uart->uart_device->DR = (*ptr & 0x1FF);
0000b8  f8141b01          LDRB     r1,[r4],#1
0000bc  8081              STRH     r1,[r0,#4]
0000be  1e76              SUBS     r6,r6,#1
                  |L10.192|
0000c0  2e00              CMP      r6,#0                 ;240
0000c2  d1f5              BNE      |L10.176|
                  |L10.196|
;;;244    
;;;245    				++ptr; --size;
;;;246    			}
;;;247    		}
;;;248    	}
;;;249    
;;;250    	/* set error code */
;;;251    	rt_set_errno(err_code);
0000c4  4648              MOV      r0,r9
0000c6  f7fffffe          BL       rt_set_errno
;;;252    
;;;253    	return (rt_uint32_t)ptr - (rt_uint32_t)buffer;
0000ca  eba40008          SUB      r0,r4,r8
;;;254    }
0000ce  e8bd8ff8          POP      {r3-r11,pc}
;;;255    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L10.212|
                          DCD      ||.constdata||+0x24
                  |L10.216|
0000d8  3000              DCB      "0",0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L10.220|
0000dc  28257329          DCB      "(%s) assert failed at %s:%d \n",0
0000e0  20617373
0000e4  65727420
0000e8  6661696c
0000ec  65642061
0000f0  74202573
0000f4  3a256420
0000f8  0a00    
0000fa  00                DCB      0
0000fb  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f73          DCB      0x72,0x74,0x5f,0x73
000004  65726961          DCB      0x65,0x72,0x69,0x61
000008  6c5f696e          DCB      0x6c,0x5f,0x69,0x6e
00000c  697400            DCB      0x69,0x74,0x00
                  |symbol_number.32|
00000f  72                DCB      0x72
000010  745f7365          DCB      0x74,0x5f,0x73,0x65
000014  7269616c          DCB      0x72,0x69,0x61,0x6c
000018  5f656e61          DCB      0x5f,0x65,0x6e,0x61
00001c  626c655f          DCB      0x62,0x6c,0x65,0x5f
000020  646d6100          DCB      0x64,0x6d,0x61,0x00
                  |symbol_number.33|
000024  72745f73          DCB      0x72,0x74,0x5f,0x73
000028  65726961          DCB      0x65,0x72,0x69,0x61
00002c  6c5f7772          DCB      0x6c,0x5f,0x77,0x72
000030  69746500          DCB      0x69,0x74,0x65,0x00
                  |symbol_number.34|
000034  72745f73          DCB      0x72,0x74,0x5f,0x73
000038  65726961          DCB      0x65,0x72,0x69,0x61
00003c  6c5f636f          DCB      0x6c,0x5f,0x63,0x6f
000040  6e74726f          DCB      0x6e,0x74,0x72,0x6f
000044  6c00              DCB      0x6c,0x00
                  |symbol_number.35|
000046  7274              DCB      0x72,0x74
000048  5f68775f          DCB      0x5f,0x68,0x77,0x5f
00004c  73657269          DCB      0x73,0x65,0x72,0x69
000050  616c5f72          DCB      0x61,0x6c,0x5f,0x72
000054  65676973          DCB      0x65,0x67,0x69,0x73
000058  74657200          DCB      0x74,0x65,0x72,0x00
                  |symbol_number.36|
00005c  72745f68          DCB      0x72,0x74,0x5f,0x68
000060  775f7365          DCB      0x77,0x5f,0x73,0x65
000064  7269616c          DCB      0x72,0x69,0x61,0x6c
000068  5f697372          DCB      0x5f,0x69,0x73,0x72
00006c  00                DCB      0x00
                  |symbol_number.37|
00006d  72745f            DCB      0x72,0x74,0x5f
000070  68775f73          DCB      0x68,0x77,0x5f,0x73
000074  65726961          DCB      0x65,0x72,0x69,0x61
000078  6c5f646d          DCB      0x6c,0x5f,0x64,0x6d
00007c  615f7478          DCB      0x61,0x5f,0x74,0x78
000080  5f697372          DCB      0x5f,0x69,0x73,0x72
000084  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\OS\\bsp\\stm32f40x\\drivers\\serial.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_serial_c_5e45469f____REV16|
#line 114 "..\\OS\\bsp\\stm32f40x\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_serial_c_5e45469f____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___8_serial_c_5e45469f____REVSH|
#line 128
|__asm___8_serial_c_5e45469f____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
